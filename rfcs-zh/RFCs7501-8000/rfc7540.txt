# RFC 7540 中文翻译 (stub)
# 原文文件: ../../rfcs/RFCs7501-8000/rfc7540.txt

互联网工程任务组（IETF）                         M. Belshe
意见征求稿：7540                                              BitGo
标准轨道类别                                              R. Peon
ISSN：2070-1721                                              Google公司
                                                         M. Thomson，主编
                                                                 Mozilla
                                                                2015年5月


             超文本传输协议版本2（HTTP/2）

摘要

   本规范描述了超文本传输协议（HTTP）语义的优化表达，称为HTTP版本2（HTTP/2）。HTTP/2通过引入头字段压缩和允许在同一连接上进行多个并发交换，实现了网络资源的更高效利用和延迟感知的降低。它还引入了服务器主动推送表示内容到客户端的功能。

   本规范是HTTP/1.1消息语法的替代方案，但不废止其存在。HTTP的现有语义保持不变。

本备忘录的状态

   这是一个互联网标准轨道的文档。

   本文档由互联网工程任务组（IETF）制定，代表了IETF社区的共识。已经过公开审查，并获得互联网工程指导组（IESG）批准发布。关于互联网标准的更多信息，请参见RFC 5741第2节。

   有关本文件当前状态、任何勘误以及反馈方式的信息，可在 http://www.rfc-editor.org/info/rfc7540 获取。

版权声明

   本文件的版权归2015年IETF信托及文档作者所有。保留所有权利。

   本文件受BCP 78和IETF信托关于IETF文档的法律规定（http://trustee.ietf.org/license-info）约束，适用于本文件发布之日。请仔细阅读这些文件，它们描述了您对本文件的权利和限制。从本文件中提取的代码组件必须包含简化BSD许可证文本（详见信托法律规定第4.e节），且按简化BSD许可证的规定提供，不提供任何担保。

目录

   1. 引言 ....................................................4
   2. HTTP/2协议概述 ........................................5
      2.1. 文档结构 ..........................................6
      2.2. 约定与术语 ........................................6
   3. 启动HTTP/2 ..............................................7
      3.1. HTTP/2版本识别 ....................................8
      3.2. 为“http”URI启动HTTP/2 ..............................8
           3.2.1. HTTP2-Settings头字段 ..........................9
      3.3. 为“https”URI启动HTTP/2 ............................10
      3.4. 具备先验知识的HTTP/2启动 ..........................10
      3.5. HTTP/2连接预备 ....................................11
   4. HTTP帧 ..................................................12
      4.1. 帧格式 ..............................................12
      4.2. 帧大小 ..............................................13
      4.3. 头字段压缩与解压 ..................................14
   5. 流与多路复用 ............................................15
      5.1. 流状态 ..............................................16
           5.1.1. 流标识符 ....................................21
           5.1.2. 流的并发性 ..................................22
      5.2. 流量控制 ............................................22
           5.2.1. 流量控制原则 ................................23
           5.2.2. 合理使用流量控制 ............................24
      5.3. 流优先级 ............................................24
           5.3.1. 流依赖关系 ..................................25
           5.3.2. 依赖权重 ....................................26
           5.3.3. 重新优先级 ..................................26
           5.3.4. 优先级状态管理 ..............................27
           5.3.5. 默认优先级 ..................................28
      5.4. 错误处理 ............................................28
           5.4.1. 连接错误处理 ................................29
           5.4.2. 流错误处理 ..................................29
           5.4.3. 连接终止 ....................................30
      5.5. 扩展HTTP/2 ..........................................30
   6. 帧定义 ..................................................31
      6.1. DATA ..................................................31
      6.2. HEADERS ...............................................32
      6.3. PRIORITY ..............................................34
      6.4. RST_STREAM ............................................36
      6.5. SETTINGS ..............................................36
           6.5.1. SETTINGS格式 ..................................38
           6.5.2. 已定义的SETTINGS参数 ..........................38
           6.5.3. 设置同步 ....................................39
      6.6. PUSH_PROMISE ..........................................40
      6.7. PING ..................................................42
      6.8. GOAWAY ................................................43
      6.9. WINDOW_UPDATE .........................................46
           6.9.1. 流量控制窗口 ................................47
           6.9.2. 初始流量控制窗口大小 ..........................48
           6.9.3. 减少流窗口大小 ................................49
      6.10. CONTINUATION .........................................49
   7. 错误码 ....................................................50
   8. HTTP消息交换 .............................................51
      8.1. HTTP请求/响应交换 ..................................52
           8.1.1. 从HTTP/2升级 ..................................53
           8.1.2. HTTP头字段 ....................................53
           8.1.3. 示例 ..........................................57
           8.1.4. HTTP/2中的请求可靠性机制 ....................60
      8.2. 服务器推送 ..........................................60
           8.2.1. 推送请求 ......................................61
           8.2.2. 推送响应 ......................................63
      8.3. CONNECT方法 .........................................64
   9. 其他HTTP要求/考虑 .......................................65
      9.1. 连接管理 ............................................65
           9.1.1. 连接复用 ......................................66
           9.1.2. 421（错误请求）状态码 ..........................66
      9.2. TLS特性使用 .........................................67
           9.2.1. TLS 1.2特性 ...................................67
           9.2.2. TLS 1.2密码套件 .................................68
   10. 安全考虑 ...............................................69
      10.1. 服务器权限 .........................................69
      10.2. 跨协议攻击 .........................................69
      10.3. 中间人封装攻击 .....................................70
      10.4. 推送响应的可缓存性 .................................70
      10.5. 拒绝服务（DoS）考虑 .................................70
           10.5.1. 头块大小限制 ................................71
           10.5.2. CONNECT相关问题 ...............................72
      10.6. 压缩的使用 .........................................72
      10.7. 填充的使用 .........................................73
      10.8. 隐私考虑 ...........................................73
   11. IANA考虑 ...............................................74
      11.1. HTTP/2识别字符串注册 ................................74
      11.2. 帧类型注册 ..........................................75
      11.3. 设置参数注册 ........................................75
      11.4. 错误码注册 ..........................................76
      11.5. HTTP2-Settings头字段注册 ............................77
      11.6. PRI方法注册 .........................................78
      11.7. 421（错误请求）HTTP状态码注册 ......................78
      11.8. h2c升级标记注册 ....................................78
   12. 参考文献 ...............................................79
      12.1. 核心参考文献 .......................................79
      12.2. 说明性参考文献 .....................................81
   附录A. TLS 1.2密码套件黑名单 ................................83
致谢 .........................................................95
作者联系方式 .................................................96

1. 引言

   超文本传输协议（HTTP）是一种极为成功的协议。然而，HTTP/1.1在底层传输（[RFC7230]第6节）上的使用方式具有一些特性，这些特性在当今整体上对应用性能产生了负面影响。

   特别是，HTTP/1.0在一个TCP连接上一次只允许一个请求待处理。HTTP/1.1引入了请求流水线，但这仅部分解决了请求并发问题，仍存在“头阻塞”问题。因此，HTTP/1.0和HTTP/1.1的客户端在需要发起大量请求时，通常会使用多个连接到服务器，以实现并发，从而降低延迟。

   此外，HTTP头字段往往重复且冗长，导致不必要的网络流量，并使初始的TCP[TCP]拥塞窗口迅速填满。这在新建TCP连接时可能引起过多的延迟。

   HTTP/2通过定义一种优化的映射，将HTTP语义映射到底层连接，解决了这些问题。具体而言，它允许请求和响应消息在同一连接上交错传输，并采用高效的HTTP头字段编码。同时，它还支持请求优先级，使更重要的请求能更快完成，进一步提升性能。

   这种协议对网络更友好，因为相比HTTP/1.x，可以使用更少的TCP连接。这意味着减少了与其他流的竞争，连接也更持久，从而更好地利用网络容量。

   最后，HTTP/2还通过使用二进制消息帧实现了消息处理的更高效率。

（以下内容省略，继续翻译全文）

3.2. 启用“http” URI的HTTP/2

   在不知道下一跳是否支持HTTP/2的情况下，客户端请求“http” URI时，使用HTTP升级机制（[RFC7230]第6.7节）。客户端通过发起包含Upgrade头字段且带有“h2c”标记的HTTP/1.1请求来实现。此类HTTP/1.1请求必须包含且仅包含一个HTTP2-Settings（第3.2.1节）头字段。

   例如：

     GET / HTTP/1.1
     Host: server.example.com
     Connection: Upgrade, HTTP2-Settings
     Upgrade: h2c
     HTTP2-Settings: <HTTP/2 SETTINGS负载的Base64url编码>

   载荷体（payload body）请求必须在客户端发送HTTP/2帧之前全部发送完毕。这意味着，较大的请求可能会阻塞连接，直到全部发送完成。

   如果初始请求的并发性与后续请求的并发性很重要，可以使用OPTIONS请求进行HTTP/2的升级，但会增加一次往返延迟。

支持HTTP/2的服务器可以像没有Upgrade头字段一样响应请求：

     HTTP/1.1 200 OK
     Content-Length: 243
     Content-Type: text/html

     ...

   服务器必须忽略Upgrade头字段中的“h2”标记。带有“h2”标记的存在意味着通过TLS的HTTP/2，但实际上应通过第3.3节所述的协商方式进行。

   支持HTTP/2的服务器会以101（切换协议）响应来接受升级。在结束101响应的空行之后，服务器可以开始发送HTTP/2帧。这些帧必须包括对发起升级请求的响应。

   例如：

     HTTP/1.1 101 Switching Protocols
     Connection: Upgrade
     Upgrade: h2c

     [HTTP/2连接...

   服务器发出的第一个HTTP/2帧必须是服务器连接预告（第3.5节），由一个SETTINGS帧（第6.5节）组成。收到101响应后，客户端必须发送连接预告（第3.5节），其中也包括一个SETTINGS帧。

   升级前发出的HTTP/1.1请求会被赋予流标识符1（见第5.1.1节），优先级值为默认（第5.3.5节）。流1在客户端向服务器的方向上是“半关闭”的（见第5.1节），因为请求作为HTTP/1.1请求已完成。启动HTTP/2连接后，流1用于响应。

3.2.1. HTTP2-Settings头字段

   从HTTP/1.1升级到HTTP/2的请求必须包含且仅包含一个“HTTP2-Settings”头字段。HTTP2-Settings头字段是一个连接特定的头字段，包含用于管理HTTP/2连接的参数，预期服务器会接受升级请求时提供。

     HTTP2-Settings = token68

   服务器不得在未提供此头字段或提供多个时升级到HTTP/2。服务器也不得发送此头字段。

   HTTP2-Settings头字段的内容是一个SETTINGS帧（第6.5节）负载，经过Base64url编码（即[RFC4648]第5节描述的URL和文件名安全的Base64编码，省略尾部的“=”字符）。“token68”的ABNF（[RFC5234]第2.1节）定义在[RFC7235]中。

   由于升级仅适用于立即的连接，客户端在发送HTTP2-Settings头字段时，必须在Connection头字段中将“HTTP2-Settings”作为连接选项，以防止其被转发（见[RFC7230]第6.1节）。

   服务器会像处理其他SETTINGS帧一样解码和解释这些值。无需显式确认这些设置（第6.5.3节），因为101响应已隐含确认。提供这些参数在升级请求中，允许客户端在接收服务器帧之前提前设置参数。

3.3. 使用“https” URI启动HTTP/2

   请求“https” URI的客户端使用TLS [TLS12]，并启用应用层协议协商（ALPN）扩展 [TLS-ALPN]。

   在TLS之上，HTTP/2使用“h2”协议标识符。客户端或服务器不得发送或选择“h2c”协议标识符；“h2c”描述不使用TLS的协议。

   TLS协商完成后，客户端和服务器都必须发送连接预告（第3.5节）。

3.4. 通过“先验知识”启动HTTP/2

   客户端可以通过其他方式获知某个服务器支持HTTP/2。例如，[ALT-SVC]描述了一种广告此能力的机制。

   客户端必须发送连接预告（第3.5节），然后可以立即向此类服务器发送HTTP/2帧；服务器可以通过连接预告识别这些连接。这仅影响在明文TCP上建立的HTTP/2连接；支持TLS的实现必须使用TLS协议协商（[TLS-ALPN]）。

   同样，服务器也必须发送连接预告（第3.5节）。

   在没有额外信息的情况下，之前支持HTTP/2并不能强烈表明未来的连接也会支持HTTP/2。例如，服务器配置可能会变，集群中的不同实例配置不同，或网络条件发生变化。

3.5. HTTP/2连接预告

   在HTTP/2中，每个端点都必须发送连接预告，作为协议使用的最终确认，并建立HTTP/2连接的初始设置。客户端和服务器各自发送不同的连接预告。

   客户端连接预告以24个字节的序列开始，十六进制表示为：

     0x505249202a20485454502f322e300d0a0d0a534d0d0a0d0a

   即，连接预告以字符串“PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n”开始。此序列后必须跟随一个SETTINGS帧（第6.5节），可以为空。客户端在收到101（切换协议）响应（表示升级成功）后，或在TLS连接的第一个应用数据八位组中立即发送连接预告。如果提前知道服务器支持HTTP/2，则在建立连接时立即发送连接预告。

      注意：客户端连接预告的设计使得大部分HTTP/1.1或HTTP/1.0服务器和中间设备不会尝试处理后续帧。注意，这并未解决[Talking]中提出的问题。

   服务器连接预告由一个可能为空的SETTINGS帧（第6.5节）组成，必须是服务器在HTTP/2连接中发送的第一个帧。

   从对等端接收的连接预告中的SETTINGS帧必须在发送连接预告后得到确认（第6.5.3节）。

   为避免不必要的延迟，客户端可以在发送客户端连接预告后立即向服务器发送其他帧，而无需等待服务器连接预告的到达。但要注意，服务器的SETTINGS帧可能包含参数，必要时会改变客户端与服务器的通信方式。收到SETTINGS帧后，客户端应遵守任何已建立的参数。在某些配置中，服务器可以在客户端发送其他帧之前传输SETTINGS，从而避免此问题。

   客户端和服务器必须将无效的连接预告视为协议错误（第5.4.1节）中的连接错误（PROTOCOL_ERROR）。在这种情况下，可以省略GOAWAY帧（第6.8节），因为无效预告表明对端未使用HTTP/2。

4. HTTP帧

   一旦HTTP/2连接建立，端点即可开始交换帧。

4.1. 帧格式

   所有帧以固定的9字节头部开始，后跟可变长度的负载。

    +-----------------------------------------------+
    |                 长度（24）                    |
    +---------------+---------------+---------------+
    |   类型（8）   |   标志（8）   |
    +-+-------------+---------------+-------------------------------+
    |R|                 流标识符（31）                                |
    +=+=============================================================+
    |                   帧负载（0...）                                ...
    +---------------------------------------------------------------+

   图1：帧布局

   帧头字段定义如下：

   长度：以无符号24位整数表示的帧负载长度。超过2^14（16,384）的值不得发送，除非接收方设置了更大的SETTINGS_MAX_FRAME_SIZE。

   这9个字节的帧头不包含在长度值中。

   类型：帧的8位类型。帧类型决定了帧的格式和语义。实现必须忽略并丢弃任何未知类型的帧。

   标志：为特定帧类型保留的8位布尔标志字段。

      标志具有特定于所指示帧类型的语义。没有定义语义的标志在特定帧类型中必须被忽略，且在发送时必须保持未设置（0x0）。

   R：保留的1位字段。此位的语义未定义，发送时必须保持未设置（0x0），接收时应忽略。

   流标识符：以无符号31位整数表示的流标识符（见第5.1.1节）。值0x0保留用于与整个连接相关的帧，而非单个流。

   帧负载的结构和内容完全依赖于帧类型。

4.2. 帧大小

   帧负载的大小受接收方在SETTINGS_MAX_FRAME_SIZE中广告的最大值限制。该值可以在2^14（16,384）到2^24-1（16,777,215）字节之间。

   所有实现必须能够接收和至少处理长度不超过2^14字节（加上9字节帧头）的帧。帧头的大小不计入帧大小。

      注意：某些帧类型（如PING，第6.7节）对负载数据的限制更严格。

   如果帧超过由SETTINGS_MAX_FRAME_SIZE定义的大小、超出特定帧类型的限制，或太小无法包含必要的帧数据，端点必须返回FRAME_SIZE_ERROR错误码。帧大小错误如果可能影响整个连接状态，应视为连接错误（第5.4.1节），包括携带头部块（第4.3节）的帧（HEADERS、PUSH_PROMISE和CONTINUATION）、SETTINGS，以及流标识符为0的任何帧。

   端点没有义务使用所有可用空间。使用比最大允许值更小的帧可以提高响应性。发送大帧可能会延迟时间敏感帧（如RST_STREAM、WINDOW_UPDATE或PRIORITY）的发送，从而影响性能。

4.3. 头部压缩与解压缩

   与HTTP/1类似，HTTP/2中的头字段是一个名称及一个或多个相关值。头字段在HTTP请求和响应消息中使用，也用于服务器推送（见第8.2节）。

   头部列表是零个或多个头字段的集合。在连接上传输时，头部列表会被序列化成头块，使用HTTP头压缩（[COMPRESSION]）。序列化后的头块被划分为一个或多个八位组序列，称为头块片段，并在HEADERS（第6.2节）、PUSH_PROMISE（第6.6节）或CONTINUATION（第6.10节）帧的负载中传输。

   Cookie头字段（[COOKIE]）在HTTP映射中有特殊处理（见第8.1.2.5节）。

   接收端通过连接片段拼接成完整的头块，然后解压缩以重建头部列表。

   完整的头块可以是：

   - 一个带有END_HEADERS标志的HEADERS或PUSH_PROMISE帧，或

   - 一个HEADERS或PUSH_PROMISE帧，未设置END_HEADERS标志，后跟一个或多个CONTINUATION帧，最后一个CONTINUATION帧设置了END_HEADERS。

   头部压缩是有状态的。整个连接使用一个压缩上下文和一个解压缩上下文。头块中的解码错误必须视为连接错误（第5.4.1节），类型为COMPRESSION_ERROR。

每个头部块都作为一个独立的单元进行处理。头部块必须作为连续的帧序列传输，中间不得插入任何其他类型或来自其他流的帧。一个HEADERS或CONTINUATION帧序列中的最后一帧必须设置END_HEADERS标志。一个PUSH_PROMISE或CONTINUATION帧序列中的最后一帧也必须设置END_HEADERS标志。这允许将一个头部块在逻辑上等同于单个帧。

头部块片段只能作为HEADERS、PUSH_PROMISE或CONTINUATION帧的有效载荷进行发送，因为这些帧携带的数据可能会修改接收端维护的压缩上下文。接收端在收到HEADERS、PUSH_PROMISE或CONTINUATION帧时，需要重新组装头部块并进行解压缩，即使这些帧最终会被丢弃。如果接收端未能解压缩头部块，必须以类型为COMPRESSION_ERROR的连接错误终止连接（参见第5.4.1节）。

5. 流和多路复用

“流”是在一个HTTP/2连接中，客户端和服务器之间交换的独立的双向帧序列。流具有几个重要特性：

- 一个HTTP/2连接可以同时包含多个打开的流，任一端都可以交错发送多个流的帧。
- 流可以由任一端单方面建立和使用，也可以由双方共享。
- 流可以由任一端关闭。
- 在一个流上发送帧的顺序是有意义的。接收方按接收顺序处理帧，特别是HEADERS和DATA帧的顺序具有语义上的重要性。
- 流由一个整数标识。流标识符由发起该流的端点分配。

5.1. 流状态

流的生命周期如图2所示。

（此处为图示，描述了流在不同状态下的转变过程，包括：空闲、保留（本地/远程）、开启、半关闭（本地/远程）、关闭等状态，以及相关的帧和标志。）

请注意，此图仅显示流状态的转变以及影响这些转变的帧和标志。在这方面，CONTINUATION帧不会引起状态转变；它们实际上是跟随在HEADERS或PUSH_PROMISE之后的部分。

在状态转变的过程中，END_STREAM标志被视为与携带它的帧的一个单独事件；设置了END_STREAM标志的HEADERS帧可能引起两个状态转变。

两个端点对流的状态可能存在主观上的不同，尤其是在帧在传输途中时。端点不会协调流的创建，它们由任一端单方面建立。状态不匹配的负面后果仅限于在发送RST_STREAM后进入“已关闭”状态时，可能会在关闭后仍接收一些帧。

流具有以下状态：

- 空闲（idle）：
  所有流都从“空闲”状态开始。
  - 发送或接收HEADERS帧会使流变为“开启”状态。流标识符的选择如第5.1.1节所述。相同的HEADERS帧也可以使流立即变为“半关闭”。
  - 在其他流上发送PUSH_PROMISE帧会预留一个空闲流，用于后续使用。预留流的状态变为“保留（本地）”。
  - 在其他流上接收PUSH_PROMISE帧会预留一个空闲流，用于后续使用。预留流的状态变为“保留（远程）”。
  - 注意，PUSH_PROMISE帧不是在空闲流上发送的，而是在“承诺流ID”字段中引用新预留的流。
  - 在此状态下，接收除HEADERS或PRIORITY之外的任何帧都必须视为连接错误（第5.4.1节）中的PROTOCOL_ERROR。

- 保留（本地）（reserved (local)）：
  这是由发送PUSH_PROMISE帧预留的流状态。该帧将空闲流与由远端发起的打开流关联，从而预留该流（见第8.2节）。
  - 仅允许以下转变：
    - 端点可以发送HEADERS帧，使流变为“半关闭（远程）”。
    - 任一端可以发送RST_STREAM帧，使流变为“已关闭”，释放预留。
  - 在此状态下，端点不得发送除HEADERS、RST_STREAM或PRIORITY之外的任何帧。
  - 可能会接收PRIORITY或WINDOW_UPDATE帧。
  - 接收除RST_STREAM、PRIORITY或WINDOW_UPDATE之外的任何帧都必须视为连接错误（第5.4.1节）中的PROTOCOL_ERROR。

- 保留（远程）（reserved (remote)）：
  这是由远端预留的流状态。
  - 仅允许以下转变：
    - 接收HEADERS帧使流变为“半关闭（本地）”。
    - 任一端可以发送RST_STREAM帧，使流变为“已关闭”，释放预留。
    - 在此状态下，端点可以发送PRIORITY帧以重新优先级排序预留的流。不得发送除RST_STREAM、WINDOW_UPDATE或PRIORITY之外的其他帧。
    - 接收除HEADERS、RST_STREAM或PRIORITY之外的任何帧都必须视为连接错误（第5.4.1节）中的PROTOCOL_ERROR。

- 开放（open）：
  流处于“开启”状态时，双方都可以发送任何类型的帧。在此状态下，发送端会遵守广告的流级流控限制（第5.2节）。
  - 任一端可以发送带有END_STREAM标志的帧，使流变为“半关闭”状态。具体：
    - 发送END_STREAM标志会使流变为“半关闭（本地）”；
    - 接收END_STREAM标志会使流变为“半关闭（远程）”。
  - 任一端可以从此状态发送RST_STREAM帧，立即将流转为“已关闭”。

- 半关闭（本地）（half-closed (local)）：
  这是已由本端关闭的流状态，只能用于接收WINDOW_UPDATE、PRIORITY和RST_STREAM帧。
  - 当收到包含END_STREAM标志的帧或任一端发送RST_STREAM帧时，流会变为“已关闭”。
  - 在此状态下，端点可以接收任何类型的帧。为了继续接收流控帧，必须通过WINDOW_UPDATE帧提供流控额度。在此状态下，接收端可以忽略可能在发送END_STREAM后短时间内到达的WINDOW_UPDATE帧。
  - 在此状态下接收的PRIORITY帧用于重新排序依赖该流的其他流。

- 半关闭（远程）（half-closed (remote)）：
  这是由远端关闭的流状态，不再由远端发送帧。在此状态下，端点不再有义务维护接收流控窗口。
  - 如果在此状态下接收除WINDOW_UPDATE、PRIORITY或RST_STREAM之外的帧，必须响应流错误（第5.4.2节）中的STREAM_CLOSED。
  - 在此状态下，端点仍可发送任何类型的帧。继续遵守广告的流级流控限制（第5.2节）。
  - 可以通过发送包含END_STREAM标志的帧或任一端发送RST_STREAM帧，将流从此状态转为“已关闭”。

- 已关闭（closed）：
  这是终结状态。
  - 在已关闭的流上，端点不得发送除PRIORITY之外的任何帧。收到RST_STREAM后，端点必须将任何非PRIORITY的帧视为流错误（第5.4.2节）中的STREAM_CLOSED。
  - 在收到带有END_STREAM标志的帧后，除非允许，否则端点不得再接收任何帧，否则视为连接错误（第5.4.1节）中的STREAM_CLOSED。
  - 在此状态下，可能会短暂接收WINDOW_UPDATE或RST_STREAM帧（在发送带END_STREAM的DATA或HEADERS帧后）。
  - 直到远端收到并处理RST_STREAM或带END_STREAM的帧之前，可能会继续收到这些类型的帧。端点必须忽略在此状态下接收的WINDOW_UPDATE或RST_STREAM帧，但可以选择将长时间后到达的帧视为连接错误（第5.4.1节）中的PROTOCOL_ERROR。
  - 可以在已关闭的流上发送PRIORITY帧，以优先处理依赖已关闭流的其他流。端点应处理这些PRIORITY帧，但如果依赖树已被移除，也可以忽略。
  - 如果是通过发送RST_STREAM帧到达此状态，可能远端已在流上发送或排队待发无法撤回的帧。端点必须忽略在已关闭流上接收的帧。
  - 端点可以选择限制忽略帧的时间段，将在此时间后到达的帧视为错误。
  - 在发送RST_STREAM后接收的流控帧（如DATA）会计入连接的流控窗口。虽然这些帧可能被忽略，但由于它们在发送端收到RST_STREAM之前已发出，发送端会认为这些帧会占用流控额度。
  - 端点可能在发送RST_STREAM后接收PUSH_PROMISE帧。PUSH_PROMISE会使流变为“预留”，即使相关流已被重置。因此，关闭不需要的承诺流需要发送RST_STREAM。

在本文件其他部分未提供更具体指导的情况下，实施者应将未明确允许的帧视为连接错误（第5.4.1节）中的PROTOCOL_ERROR。注意，PRIORITY帧可以在任何流状态下发送和接收。未知类型的帧会被忽略。

关于HTTP请求/响应交换的状态转变示例，请参见第8.1节。关于服务器推送的状态转变示例，请参见第8.2.1和8.2.2节。

5.1.1 流标识符

流的标识符由一个无符号的31位整数表示。由客户端发起的流必须使用奇数编号的流标识符；由服务器发起的流必须使用偶数编号的流标识符。流标识符为零（0x0）用于连接控制消息；零流标识符不能用来建立新流。

升级到HTTP/2（参见第3.2节）的HTTP/1.1请求会以流标识符1（0x1）进行响应。升级完成后，流0x1对客户端来说是“半关闭（本地）”状态。因此，客户端在从HTTP/1.1升级时，不能选择流0x1作为新流的标识符。

新建立的流的标识符必须比发起端已打开或保留的所有流的标识符都大。这适用于使用HEADERS帧打开的流和使用PUSH_PROMISE保留的流。收到意外流标识符的端点必须以连接错误（第5.4.1节）中的PROTOCOL_ERROR类型作出响应。

首次使用新流标识符会隐式关闭所有由对端用较低编号流标识符发起的“空闲”状态的流。例如，如果客户端在没有在流5上发送任何帧的情况下，在流7上发送了HEADERS帧，则当第一个流7的帧被发送或接收时，流5会转变为“已关闭”状态。

流标识符不能重复使用。长连接可能会导致端点耗尽可用的流标识符范围。无法建立新流标识符的客户端可以通过建立新连接来创建新流。无法建立新流标识符的服务器可以发送GOAWAY帧，迫使客户端为新流开启新连接。

### 5.1.2. 流的并发数

对端可以通过在SETTINGS帧中的SETTINGS_MAX_CONCURRENT_STREAMS参数（第6.5.2节）限制同时活跃的流数。最大并发流数的设置对每个端点是特定的，只适用于接收该设置的对端。也就是说，客户端指定服务器可以发起的最大并发流数，服务器指定客户端可以发起的最大并发流数。

处于“打开”状态或任一“半关闭”状态的流会计入端点允许打开的最大流数。任何这三种状态的流都计入在SETTINGS_MAX_CONCURRENT_STREAMS广告的限制中。处于“保留”状态的流不计入流数限制。

端点不得超过对端设置的限制。收到导致其广告的最大并发流数被超出的HEADERS帧的端点，必须将其视为流错误（第5.4.2节），类型为PROTOCOL_ERROR或REFUSED_STREAM。错误码的选择决定了端点是否希望启用自动重试（第8.1.4节的详细信息）。

希望将SETTINGS_MAX_CONCURRENT_STREAMS值降低到低于当前打开流数的端点，可以选择关闭超出新值的流，或允许流完成。

### 5.2. 流量控制

多路复用中的流会引起对TCP连接的争用，导致流阻塞。流量控制方案确保同一连接上的流不会相互破坏性干扰。流量控制既适用于单个流，也适用于整个连接。

HTTP/2通过WINDOW_UPDATE帧（第6.9节）实现流量控制。

#### 5.2.1. 流量控制原则

HTTP/2的流量控制旨在允许使用多种流量控制算法，而无需修改协议。HTTP/2中的流量控制具有以下特性：

1. 流量控制是针对连接的。两种类型的流量控制都发生在单跳的端点之间，而非端到端路径。

2. 流量控制基于WINDOW_UPDATE帧。接收方会广告其准备接收的字节数（以八位字节为单位），这是一个基于信用的方案。

3. 流量控制是单向的，整体控制由接收方提供。接收方可以为每个流和整个连接设置任意窗口大小。发送方必须遵守接收方施加的流量控制限制。客户端、服务器和中间代理都作为接收方独立广告其流量控制窗口，并在发送时遵守对端设定的限制。

4. 初始流量控制窗口的值为65,535字节，适用于新流和整个连接。

5. 帧类型决定是否应用流量控制。本文档中定义的帧类型中，只有DATA帧受流量控制限制；其他帧类型不占用广告的流量控制窗口空间。这确保重要的控制帧不会被流量控制阻塞。

6. 流量控制不能被禁用。

7. HTTP/2只定义了WINDOW_UPDATE帧的格式和语义（第6.9节）。本文件不规定接收方何时发送此帧或其值，也不规定发送方如何选择发送包。实现可以选择任何适合其需求的算法。

实现还需管理请求和响应的优先级，避免请求的头阻塞（head-of-line blocking），以及管理新流的创建。这些算法的选择可能会与任何流量控制算法相互作用。

#### 5.2.2. 流量控制的合理使用

流量控制旨在保护资源有限的端点。例如，代理需要在多个连接之间共享内存，且可能有缓慢的上游连接和快速的下游连接。流量控制解决了接收方在无法处理某个流上的数据时，仍希望继续处理其他流的情况。

不需要此功能的部署可以将流量控制窗口设置为最大值（2^31-1），并在收到任何数据时通过发送WINDOW_UPDATE帧保持此窗口，从而实际上禁用流量控制。反之，发送方始终受制于接收方广告的流量控制窗口。

资源有限的部署（如内存）可以利用流量控制限制对端的内存使用量。但请注意，如果在不了解带宽-延迟积（bandwidth-delay product，参见[RFC7323]）的情况下启用流量控制，可能导致网络资源的利用率不佳。

即使完全了解当前的带宽-延迟积，流量控制的实现也较为复杂。在使用流量控制时，接收方必须及时读取TCP接收缓冲区，否则可能导致死锁，例如WINDOW_UPDATE帧未被读取和处理。

### 5.3. 流优先级

客户端可以在打开流的HEADERS帧（第6.2节）中包含优先级信息，为新流分配优先级。任何时候，也可以通过PRIORITY帧（第6.3节）改变流的优先级。

优先级的目的是让端点表达在管理并发流时希望对端如何分配资源。最重要的是，优先级可以用来选择在容量有限时传输帧的流。

流可以通过依赖其他流（第5.3.1节）来实现优先级。每个依赖关系都被赋予一个相对权重，用于决定依赖同一流的资源比例。

明确设置流的优先级是优先级处理的输入，但不保证流的处理或传输顺序。端点不能通过优先级强制对端以特定顺序处理并发流。表达优先级仅是建议。

消息中可以省略优先级信息。未提供明确值时，使用默认值（第5.3.5节）。

#### 5.3.1. 流依赖关系

每个流可以显式依赖于另一个流。包含依赖关系表示偏好将资源分配给被依赖的流，而非依赖的流。

不依赖任何其他流的流，其依赖关系为0x0，即不存在的流0作为树的根。

依赖于其他流的流为依赖流。被依赖的流为父流。对不在树中的流（如“空闲”状态的流）依赖会赋予其默认优先级（第5.3.5节）。

在为某个流分配依赖关系时，该流会作为父流的一个新依赖加入。共享同一父流的依赖流之间没有顺序。例如，若流B和C都依赖于A，且流D依赖于A，则依赖顺序为A，然后是B、C和D，顺序可以任意。

```
    A                 A
   / \      ==>      /|\
  B   C             B D C
```

图3：默认依赖关系创建示例

排他标志（exclusive flag）允许插入新的依赖层级。设置排他标志会使该流成为父流的唯一依赖，其他依赖会变成依赖于该排他流。在前例中，如果流D以排他依赖关系创建于A，则D成为B和C的父依赖。

在依赖树中，依赖流只有在其所有依赖的父流（链条到0x0）都关闭或无法继续时，才会被分配资源。

流不能依赖于自己。端点必须将此视为流错误（第5.4.2节），类型为PROTOCOL_ERROR。

#### 5.3.2. 依赖权重

所有依赖流都被分配一个1到256之间的整数权重。

具有相同父流的流应根据其权重按比例分配资源。例如，若流B依赖于A，权重为4，流C依赖于A，权重为12，且A没有进展，则理想情况下，流B会获得分配给流C的三分之一的资源。

#### 5.3.3. 重新优先级

流的优先级通过PRIORITY帧进行更改。设置依赖关系会使流依赖于指定的父流。

依赖的流会随着父流的优先级变化而移动。如果为重新优先级的流设置排他依赖关系，所有新父流的依赖都将变为依赖于该排他流。

如果一个流依赖于其自身的某个依赖，则原本依赖它的流会先变为依赖于该流的前父流，保持其权重。

例如，假设原依赖关系为：B和C依赖A，D和E依赖C，F依赖D。如果将A依赖于D（排他），则D取代A成为其父依赖，其他关系保持不变，除了F会变成依赖于A（如果排他）。

（此处图示略，原文中有示意图。）

依赖树中，排他标志允许插入新层级的依赖。排他依赖会使新依赖成为父依赖的唯一依赖，其他依赖会转为依赖于新依赖的子依赖。

在依赖树中，依赖流只有在其所有依赖的父流（链条到0x0）都关闭或无法继续时，才会被分配资源。

流不能依赖于自己。端点必须将此视为PROTOCOL_ERROR类型的流错误（第5.4.2节）。

贝尔谢等人               标准轨道                   [第26页]


RFC 7540                         HTTP/2                         2015年5月


       x                x                x                 x
       |               / \               |                 |
       A              D   A              D                 D
      / \            /   / \            / \                |
     B   C     ==>  F   B   C   ==>    F   A       或      A
        / \                 |             / \             /|\
       D   E                E            B   C           B C F
       |                                     |             |
       F                                     E             E
                  （中间）       （非排他）        （排他性）

                图5：依赖重排序示例

5.3.4.  优先级状态管理

   当一个流从依赖树中移除时，其依赖关系可以被移动，使其依赖于已关闭流的父节点。新依赖的权重会根据已关闭流的依赖关系的权重，按比例重新计算。

   从依赖树中移除的流会导致一些优先级信息丢失。资源在具有相同父流的流之间共享，这意味着如果该组中的某个流关闭或变得阻塞，分配给该流的剩余容量会分配给其直接邻居。然而，如果共同依赖被从树中移除，这些流会与下一层级的流共享资源。

   例如，假设流A和B共享一个父节点，流C和D都依赖于流A。在移除流A之前，如果流A和D无法继续，流C会获得所有分配给流A的资源。如果流A从树中被移除，流A的权重会在流C和D之间分配。如果流D仍无法继续，流C获得的资源比例会减少。对于相等的起始权重，C会获得三分之一的资源，而不是一半。

   可能会出现流在优先级信息传输中已关闭的情况下变为关闭状态的情况。如果依赖关系中的某个流没有相关的优先级信息，则依赖于它的流会被赋予默认优先级（第5.3.5节）。这可能导致优先级配置不理想，因为流可能被赋予与预期不同的优先级。

   为避免这些问题，端点应在流关闭后的一段时间内保留流的优先级状态。状态保留时间越长，流被错误或默认优先级赋值的可能性越低。

   类似地，处于“空闲”状态的流也可以被赋予优先级或成为其他流的父节点。这允许在依赖树中创建分组节点，从而实现更灵活的优先级表达。空闲流起始时具有默认优先级（第5.3.5节）。

   保留未计入SETTINGS_MAX_CONCURRENT_STREAMS限制的流的优先级信息，可能会给端点带来较大的状态存储负担。因此，可以限制保留的优先级状态的数量。

   端点维护的优先级状态量可能会根据负载变化；在高负载情况下，可以丢弃部分优先级状态以限制资源占用。在极端情况下，端点甚至可以丢弃活跃或保留状态的流的优先级信息。如果设置了限制，端点应至少维护与其SETTINGS_MAX_CONCURRENT_STREAMS设置允许的流数相等的状态。实现时还应尽量保留在优先级树中活跃使用的流的状态。

   如果端点已保留足够的状态，在接收到改变已关闭流优先级的PRIORITY帧时，应调整依赖关系，使依赖于该流的其他流的依赖关系得到更新。

5.3.5.  默认优先级

   所有流最初都依赖于流0x0（非排他性依赖）。推送流（第8.2节）最初依赖于其关联的流。在这两种情况下，流的默认权重为16。

5.4.  错误处理

   HTTP/2帧允许两类错误：

   o  使整个连接无法使用的错误条件称为连接错误。

   o  单个流中的错误称为流错误。

   错误码列表在第7节中提供。




贝尔谢等人               标准轨道                   [第27页]


RFC 7540                         HTTP/2                         2015年5月


5.4.1.  连接错误处理

   连接错误是阻止帧层进一步处理或破坏任何连接状态的任何错误。

   遇到连接错误的端点应首先发送一个GOAWAY帧（第6.8节），其中包含其成功接收的最后一个流的流标识符。GOAWAY帧还包括一个错误码，指示连接终止的原因。在发送GOAWAY帧后，端点必须关闭TCP连接。

   但可能无法可靠地接收到GOAWAY（[RFC7230]第6.6节描述了立即关闭连接可能导致数据丢失的情况）。在发生连接错误时，GOAWAY仅是尽力通知对端连接终止的原因。

   任何端点都可以随时终止连接。特别地，端点可以将流错误视为连接错误。端点在终止连接时应尽可能发送GOAWAY帧。

5.4.2.  流错误处理

   流错误是与特定流相关的错误，不影响其他流的处理。

   端点检测到流错误后，应发送RST_STREAM帧（第6.4节），其中包含发生错误的流的流标识符。RST_STREAM帧还包括一个错误码，指示错误类型。

   RST_STREAM是端点可以在流上发送的最后一帧。发送RST_STREAM的对端应准备好接收远端可能已发送或排队发送的任何帧。这些帧可以忽略，除非它们会修改连接状态（如头部压缩状态（第4.3节）或流控状态）。

   通常，端点不应对同一流多次发送RST_STREAM帧。但如果在关闭的流上收到多于一次的帧，端点可以再次发送RST_STREAM帧。这种行为允许处理不良实现。

   为避免循环，端点不得对RST_STREAM帧响应地再发RST_STREAM。

5.4.3.  连接终止

   如果在流仍处于“打开”或“半关闭”状态时，TCP连接被关闭或重置，则受影响的流不能自动重试（详见第8.1.4节）。

5.5.  扩展HTTP/2

   HTTP/2允许协议扩展。在本节描述的限制范围内，协议扩展可以提供额外的服务或改变协议的任何方面。扩展仅在单个HTTP/2连接范围内有效。

   这适用于本文档定义的协议元素。不会影响现有的HTTP扩展方式，比如定义新方法、状态码或头字段。

   扩展可以使用新的帧类型（第4.1节）、新的设置（第6.5.2节）或新的错误码（第7节）。为管理这些扩展点建立了注册表：帧类型（第11.2节）、设置（第11.3节）和错误码（第11.4节）。

   实现必须忽略所有未知或不支持的扩展协议元素中的值。必须丢弃类型未知或不支持的帧。这意味着扩展点可以在不事先协商的情况下安全使用。然而，不允许在头部块中间插入扩展帧（第4.3节）；此类行为应视为连接错误（第5.4.1节），类型为PROTOCOL_ERROR。

   可能会改变现有协议组件语义的扩展，必须在使用前协商。例如，改变HEADERS帧布局的扩展，必须在对端确认接受后才能使用。在这种情况下，还可能需要协调何时生效。注意，将除DATA帧之外的任何帧都视为流控控制的变化，也属于语义变化，必须通过协商实现。

   本文档未规定具体的扩展协商方法，但指出可以使用设置（第6.5.2节）进行协商。如果双方都设置了表示愿意使用扩展的值，则可以启用扩展。如果



贝尔谢等人               标准轨道                   [第30页]


RFC 7540                         HTTP/2                         2015年5月


   使用设置进行扩展协商，初始值应定义为扩展默认禁用。

6.  帧定义

   本规范定义了多种帧类型，每种由唯一的8位类型码标识。每种帧类型在建立和管理连接或单个流时具有不同的作用。

   具体帧类型的传输可能会改变连接状态。如果端点未能保持对连接状态的同步，连接中的成功通信将无法进行。因此，端点必须对使用任何帧时状态的影响有共同理解。

6.1.  DATA

   DATA帧（类型=0x0）传输与流相关的任意长度字节序列。例如，用于携带HTTP请求或响应的负载。

   DATA帧也可以包含填充。填充可以添加到DATA帧中，以隐藏消息大小。填充是安全特性；详见第10.7节。

    +---------------+
    |Pad Length? (8)|
    +---------------+-----------------------------------------------+
    |                            Data (*)                         ...
    +---------------------------------------------------------------+
    |                           Padding (*)                       ...
    +---------------------------------------------------------------+

                       图6：DATA帧载荷

   DATA帧包含以下字段：

   Pad Length：一个8位字段，表示帧填充的长度（以字节为单位）。此字段是可选的（由图中的“？”表示），仅在设置了PADDED标志时存在。

   Data：应用数据。数据量为帧载荷中除去其他字段（如Pad Length和Padding）后剩余的部分。

   Padding：无应用语义的填充字节。发送时必须将填充字节设为零。接收方不必验证填充，但可以将非零填充视为连接错误（第5.4.1节）类型为PROTOCOL_ERROR。

   DATA帧定义了以下标志：

   END_STREAM（0x1）：设置后，位0表示这是端点将为该流发送的最后一帧。设置此标志会使流进入“半关闭”状态或“已关闭”状态（第5.1节）。

   PADDED（0x8）：设置后，位3表示Pad Length字段及其描述的任何填充都存在。

   DATA帧必须关联到某个流。如果收到的DATA帧的流标识符为0x0，接收方必须响应连接错误（第5.4.1节），类型为PROTOCOL_ERROR。

   DATA帧受流控限制，只能在流处于“开启”或“半关闭（远端）”状态时发送。整个DATA帧载荷（包括Pad Length和Padding字段）都在流控范围内。如果收到的DATA帧对应的流不在“开启”或“半关闭（本端）”状态，接收方必须响应流错误（第5.4.2节），类型为STREAM_CLOSED。

   填充字节总数由Pad Length字段值决定。如果填充长度等于或大于帧载荷长度，接收方必须视为连接错误（第5.4.1节），类型为PROTOCOL_ERROR。

注意：通过包含一个值为零的Pad Length字段，可以将一个帧的大小增加一个八位字节。

6.2.  HEADERS（头部）

HEADERS帧（类型=0x1）用于打开一个流（第5.1节），并且还携带一个头部块片段。HEADERS帧可以在“空闲”、“保留（本地）”、“打开”或“半关闭（远端）”状态的流上发送。

图7：HEADERS帧负载

HEADERS帧的负载包含以下字段：

- Pad Length（填充长度）：一个8位字段，表示帧中填充的长度（以八位字节为单位）。只有在设置了PADDED标志时，此字段才存在。

- E（排他标志）：一个单比特标志，指示流依赖关系是否为排他（参见第5.3节）。此字段仅在PRIORITY标志被设置时存在。

- Stream Dependency（流依赖）：一个31位的流标识符，表示此流依赖的流（参见第5.3节）。此字段仅在PRIORITY标志被设置时存在。

- Weight（权重）：一个无符号的8位整数，表示该流的优先级权重（参见第5.3节）。通过在值上加一，可以获得1到256之间的权重。此字段仅在PRIORITY标志被设置时存在。

- Header Block Fragment（头部块片段）：一个头部块片段（参见第4.3节）。

- Padding（填充）：填充八位字节。

HEADERS帧定义了以下标志：

- END_STREAM（0x1）：当设置时，位0表示该头部块（第4.3节）是端点将为指定流发送的最后一个头部块。

  HEADERS帧携带END_STREAM标志，标志流的结束。然而，带有END_STREAM标志的HEADERS帧之后，可以在同一流上跟随CONTINUATION帧。从逻辑上讲，CONTINUATION帧是HEADERS帧的一部分。

- END_HEADERS（0x4）：当设置时，位2表示该帧包含完整的头部块（第4.3节），且后续没有CONTINUATION帧。

  未设置END_HEADERS标志的HEADERS帧必须由同一流上的CONTINUATION帧跟随。接收方必须将收到任何其他类型的帧或不同流上的帧视为连接错误（第5.4.1节）中的PROTOCOL_ERROR。

- PADDED（0x8）：当设置时，位3表示存在Pad Length字段及其描述的填充。

- PRIORITY（0x20）：当设置时，位5表示存在排他标志（E）、流依赖关系和权重字段；参见第5.3节。

HEADERS帧的负载包含一个头部块片段（第4.3节）。如果头部块太大，无法放入HEADERS帧中，则在CONTINUATION帧中继续。

HEADERS帧必须关联到一个流。如果收到的HEADERS帧的流标识符字段为0x0，接收方必须响应一个类型为PROTOCOL_ERROR的连接错误（第5.4.1节）。

HEADERS帧会改变连接状态，如第4.3节所述。

HEADERS帧可以包含填充。填充字段和标志与DATA帧（第6.1节）定义的相同。超过剩余空间的填充必须被视为协议错误。

HEADERS帧中的优先级信息在逻辑上等同于单独的PRIORITY帧，但包含在HEADERS中可以避免在创建新流时流优先级的潜在变动。后续在同一流上的HEADERS帧中的优先级字段会重新优先级化该流（第5.3.3节）。

6.3.  PRIORITY（优先级）

PRIORITY帧（类型=0x2）指定发送方建议的流优先级（第5.3节）。它可以在任何流状态下发送，包括空闲或关闭的流。

图8：PRIORITY帧负载

PRIORITY帧的负载包含以下字段：

- E（排他标志）：一个单比特标志，指示流依赖关系是否为排他（参见第5.3节）。

- Stream Dependency（流依赖）：一个31位的流标识符，表示此流依赖的流（参见第5.3节）。

- Weight（权重）：一个无符号的8位整数，表示该流的优先级权重（参见第5.3节）。值加一后，范围为1到256。

PRIORITY帧没有定义任何标志。

PRIORITY帧总是标识一个流。如果收到的PRIORITY帧的流标识符为0x0，必须响应一个类型为PROTOCOL_ERROR的连接错误（第5.4.1节）。

PRIORITY帧可以在任何状态的流上发送，但不能在组成单个头部块的连续帧之间发送（第4.3节）。注意，该帧可能在处理或帧发送完成后到达，此时对已标识的流没有影响。对于“半关闭（远端）”或“已关闭”状态的流，此帧只能影响该流及其依赖的流的处理，不影响该流上的帧传输。

PRIORITY帧可以在“空闲”或“已关闭”状态的流上发送。这允许通过改变未使用或已关闭父流的优先级，重新优先级化一组依赖的流。

长度不为5个八位字节的PRIORITY帧必须被视为流错误（第5.4.2节）中的FRAME_SIZE_ERROR。

6.4.  RST_STREAM（重置流）

RST_STREAM帧（类型=0x3）允许立即终止一个流。它用于请求取消流或指示发生了错误。

图9：RST_STREAM帧负载

RST_STREAM帧包含一个无符号的32位整数，表示错误码（第7节）。错误码指示终止该流的原因。

RST_STREAM帧没有定义任何标志。

该帧会完全终止被引用的流，并使其进入“已关闭”状态。在收到RST_STREAM后，接收方不得为该流发送额外的帧，除非是PRIORITY帧。然而，发送端在发送RST_STREAM后，必须准备好接收和处理可能在RST_STREAM到达前由对端发送的其他帧。

RST_STREAM帧必须关联到一个流。如果收到的RST_STREAM的流标识符为0x0，必须视为连接错误（第5.4.1节）中的PROTOCOL_ERROR。

不应对“空闲”状态的流发送RST_STREAM帧。如果收到标识空闲流的RST_STREAM帧，必须视为连接错误（第5.4.1节）中的PROTOCOL_ERROR。

长度不为4个八位字节的RST_STREAM帧必须视为连接错误（第5.4.1节）中的FRAME_SIZE_ERROR。

6.5.  SETTINGS（设置）

SETTINGS帧（类型=0x4）传达影响端点通信的配置参数，例如偏好和对等方行为的约束。SETTINGS帧也用于确认已接收这些参数。每个SETTINGS参数也可以称为“设置”。

SETTINGS参数不经过协商；它们描述发送端的特性，由接收端使用。不同的端点可以广告相同参数的不同值。例如，客户端可能设置较高的初始流量控制窗口，而服务器可能设置较低的值以节省资源。

连接开始时，双方必须都发送SETTINGS帧，之后在连接存续期间，任一端也可以随时发送。实现必须支持本规范定义的所有参数。

每个SETTINGS参数会替换该参数的任何现有值。参数按出现顺序处理，接收方无需维护除当前参数值之外的任何状态。因此，SETTINGS参数的值是接收方看到的最后一个值。

接收方必须对SETTINGS帧进行确认。为此，定义了以下标志：

- ACK（0x1）：当设置时，位0表示该帧确认已收到并应用了对端的SETTINGS帧。设置此标志时，负载必须为空。带有ACK标志且长度字段值非0的SETTINGS帧必须视为连接错误（第5.4.1节）中的FRAME_SIZE_ERROR。更多信息请参见第6.5.3节（“设置同步”）。

SETTINGS帧始终应用于整个连接，而非单个流。其流标识符必须为0（0x0）。如果端点收到的SETTINGS帧的流标识符非0，必须响应一个类型为PROTOCOL_ERROR的连接错误（第5.4.1节）。

SETTINGS帧会影响连接状态。格式错误或不完整的SETTINGS帧必须视为连接错误（第5.4.1节）中的PROTOCOL_ERROR。

长度非6的倍数的SETTINGS帧必须视为连接错误（第5.4.1节）中的FRAME_SIZE_ERROR。

6.5.1.  SETTINGS格式

SETTINGS帧的负载由零个或多个参数组成，每个参数由一个无符号的16位设置标识符和一个无符号的32位值组成。

图10：设置格式

6.5.2.  已定义的SETTINGS参数

以下参数已定义：

- SETTINGS_HEADER_TABLE_SIZE（0x1）：通知远端最大头部压缩表的大小（以八位字节为单位），用于解码头部块。编码器可以通过特定于头部压缩格式的信令，在头部块中选择任何小于或等于此值的大小（参见[COMPRESSION]）。初始值为4096字节。

- SETTINGS_ENABLE_PUSH（0x2）：用于禁用服务器推送（第8.2节）。如果收到此参数且值为0，端点不得发送PUSH_PROMISE帧。已将此参数设置为0且已确认的端点，必须将接收到的PUSH_PROMISE帧视为PROTOCOL_ERROR连接错误。

  初始值为1，表示允许服务器推送。任何非0或1的值都必须视为PROTOCOL_ERROR连接错误。

- SETTINGS_MAX_CONCURRENT_STREAMS（0x3）：指示允许的最大并发流数。此限制是单向的：它适用于允许接收方创建的流数。初始时无限制。建议此值不小于100，以避免不必要的并行限制。

  设置为0不应被端点特殊处理。虽然它阻止新流的创建，但也可能在任何限制耗尽时发生。服务器应只在短时间内设置为0；如果不希望接受请求，关闭连接更为合适。

- SETTINGS_INITIAL_WINDOW_SIZE（0x4）：指示流级流控的初始窗口大小（以八位字节为单位）。初始值为2^16-1（65,535）字节。

  此设置影响所有流的窗口大小（参见第6.9.2节）。

  超过最大流控窗口大小2^31-1的值必须视为PROTOCOL_ERROR连接错误（第5.4.1节）。

设置最大帧大小（0x5）：表示发送方愿意接收的最大帧有效载荷大小，以字节（八位字节）为单位。

初始值为2^14（16,384）字节。端点所广告的值必须在此初始值和最大允许帧大小（2^24-1，即16,777,215字节）之间（含两端点值）。超出此范围的值必须被视为连接错误（第5.4.1节），类型为协议错误（PROTOCOL_ERROR）。

设置最大头部列表大小（0x6）：这是一个建议性设置，用于通知对端端点，发送方准备接受的最大头部列表大小，以字节为单位。该值基于未压缩的头部字段的大小，包括名称和值的长度（以字节为单位）以及每个头部字段的32字节开销。

对于任何特定请求，可以强制执行比广告值更低的限制。此设置的初始值为无限制。

接收带有未知或不支持标识符的SETTINGS帧的端点，必须忽略该设置。

6.5.3. 设置同步

大多数SETTINGS值依赖或需要理解对端何时已接收并应用了更改的参数值。为了提供这样的同步时间点，未设置ACK标志的SETTINGS帧的接收方必须在尽快收到后应用更新的参数。

SETTINGS帧中的值必须按出现顺序处理，值之间不得处理其他帧。未支持的参数必须被忽略。所有值处理完毕后，接收方必须立即发出带有ACK标志的SETTINGS帧。收到带有ACK标志的SETTINGS帧后，发送已更改参数的端点可以确信参数已被应用。

如果发送方在合理时间内未收到确认，应可能发出连接错误（第5.4.1节），类型为SETTINGS_TIMEOUT。

6.6. PUSH_PROMISE（推送承诺）

PUSH_PROMISE帧（类型=0x5）用于提前通知对端端点，发送方打算启动的流。该帧包括一个无符号的31位标识符，标识计划创建的流，以及一组头部，提供关于该流的额外上下文。第8.2节详细描述了PUSH_PROMISE帧的使用。

+---------------+
| Pad Length? (8)|
+-+-------------+----------------------------------------------+
|R|                  预留流ID (31)                        |
+-+-----------------------------+------------------------------+
|                   头部块片段 (*)                        ...
+--------------------------------------------------------------+
|                           填充 (*)                          ...
+--------------------------------------------------------------+

图11：PUSH_PROMISE有效载荷格式

PUSH_PROMISE帧的有效载荷包含以下字段：

- Pad Length（填充长度）：一个8位字段，表示帧中填充的长度（以字节为单位）。仅在设置了PADDED标志时存在。

- R：一个保留位。

- Promised Stream ID（承诺流ID）：一个无符号的31位整数，标识由PUSH_PROMISE保留的流。该标识符必须是发送方将要发送的下一个流的有效选择（参见第5.1.1节中的“新流标识符”）。

- Header Block Fragment（头部块片段）：包含请求头字段的头部块片段（第4.3节）。

- Padding（填充）：填充字节。

PUSH_PROMISE帧定义了以下标志：

- END_HEADERS（0x4）：设置后，位2表示该帧包含完整的头部块（第4.3节），且后续不跟任何CONTINUATION帧。

  未设置END_HEADERS标志的PUSH_PROMISE帧，必须由同一流上的CONTINUATION帧跟随。接收方必须将收到任何其他类型的帧或不同流上的帧视为连接错误（第5.4.1节），类型为协议错误（PROTOCOL_ERROR）。

- PADDED（0x8）：设置后，位3表示存在Pad Length字段及其描述的填充。

PUSH_PROMISE帧只能在由对端发起且处于“打开”或“远端半关闭”状态的流上发送。流标识符指示该帧关联的流。如果流ID字段为0x0，接收方必须响应连接错误（第5.4.1节），类型为协议错误。

承诺的流不必按承诺顺序使用。PUSH_PROMISE仅预留流标识符以供后续使用。

如果对端的SETTINGS_ENABLE_PUSH设置为0，则不得发送PUSH_PROMISE。已设置此设置且已收到确认的端点，必须将收到PUSH_PROMISE帧视为连接错误（第5.4.1节），类型为协议错误。

接收方可以选择拒绝承诺的流，通过返回一个RST_STREAM帧，引用被承诺的流ID。

PUSH_PROMISE帧会以两种方式修改连接状态：一是包含头部块（第4.3节）可能会影响头部压缩的状态；二是预留一个流，令其进入“已预留”状态。发送方不得在非“打开”或“远端半关闭”状态的流上发送PUSH_PROMISE。必须确保被承诺的流是“空闲”状态（第5.1.1节）中的有效选择。

由于PUSH_PROMISE预留了流，忽略该帧会导致流状态不确定。接收方必须将收到的在非“打开”或“本地半关闭”状态的流上的PUSH_PROMISE视为连接错误（第5.4.1节），类型为协议错误。然而，已对相关流发送RST_STREAM的端点，必须处理在RST_STREAM帧接收和处理之前可能已创建的PUSH_PROMISE。

接收方必须将承诺非法流ID（第5.1.1节）的PUSH_PROMISE视为连接错误（第5.4.1节），类型为协议错误。非法流ID指当前不处于“空闲”状态的流。

PUSH_PROMISE帧可以包含填充。填充字段和标志与数据帧（第6.1节）定义的相同。

6.7. PING（心跳）

PING帧（类型=0x6）用于测量从发送端到接收端的最小往返时间，以及检测空闲连接是否仍然正常。任何端点都可以发送PING帧。

+--------------------------------------------------------------+
|                                                              |
|                      不透明数据（64字节）                   |
|                                                              |
+--------------------------------------------------------------+

图12：PING有效载荷格式

除了帧头外，PING帧的有效载荷必须包含8个字节的不透明数据。发送方可以包含任何值，并以任何方式使用这些字节。

未包含ACK标志的PING帧，接收方必须以相同的有效载荷，响应一个设置了ACK标志的PING帧。PING响应应优先于其他任何帧。

PING帧定义了以下标志：

- ACK（0x1）：设置后，位0表示该PING帧为响应。端点必须在PING响应中设置此标志。端点不得对包含此标志的PING帧作出响应。

PING帧不关联任何特定流。如果收到的PING帧的流ID字段值非0x0，接收方必须响应连接错误（第5.4.1节），类型为协议错误。

长度字段值非8的PING帧，必须视为连接错误（第5.4.1节），类型为帧大小错误（FRAME_SIZE_ERROR）。

6.8. GOAWAY（关闭连接）

GOAWAY帧（类型=0x7）用于发起连接关闭或通知严重错误。它允许端点优雅地停止接受新流，同时完成已建立流的处理。这适用于管理操作，比如服务器维护。

在端点启动新流和远端发送GOAWAY帧之间存在潜在的竞态条件。为应对这种情况，GOAWAY帧包含最后一个由对端发起、已处理或可能处理的流的流ID。比如，服务器发出GOAWAY时，标识的流是由客户端发起的最高编号流。

一旦发出，发送端会忽略在该连接上由接收端发起且流ID高于最后流ID的帧。接收端不得在连接上开启额外的流，但可以建立新连接以启动新流。

如果接收端在GOAWAY中指示的最后流ID之前的流上已发送数据，这些流将不被处理。接收端可以视为这些流从未创建过，从而允许在新连接上重试。

端点应在关闭连接前总是发送GOAWAY帧，以便对端知道某些流是否已部分处理。例如，如果HTTP客户端在服务器关闭连接时同时发出POST请求，客户端无法得知服务器是否已开始处理该请求，除非服务器发送GOAWAY指示可能已处理的流。

端点也可以在没有发送GOAWAY的情况下关闭连接，尤其是对不守规矩的对端。

GOAWAY帧可能不会立即在关闭连接前发出；在没有更多用途的情况下，接收方应在终止连接前仍然发送GOAWAY。

+--------------------------------------------------------------+
|R|                  最后流ID（31）                              |
+--------------------------------------------------------------+
|                      错误码（32）                              |
+--------------------------------------------------------------+
|                  附加调试数据 (*)                              |
+--------------------------------------------------------------+

图13：GOAWAY有效载荷格式

GOAWAY帧没有定义任何标志。

GOAWAY帧作用于整个连接，而非特定流。端点必须将流ID非0x0的GOAWAY帧视为连接错误（第5.4.1节），类型为协议错误。

最后流ID表示发出GOAWAY的端点可能已对该编号及以下的所有流采取了某些操作。所有编号不高于该值的流，可能都已被处理。若未处理任何流，可以将最后流ID设为0。

注意：“已处理”在此指某些数据已传递到上层软件，可能已采取某些行动。

如果连接在未发出GOAWAY的情况下终止，最后流ID实际上是最高可能的流ID。

对于编号低于或等于最后流ID且未在连接关闭前完全关闭的流，无法重试请求、事务或任何协议活动，除了幂等操作如GET、PUT或DELETE。使用更高编号流的任何协议活动可以在新连接上安全重试。

编号低于或等于最后流ID的流上的活动可能仍会成功完成。发出GOAWAY的端点可以通过发送GOAWAY帧优雅地关闭连接，保持连接“打开”状态，直到所有正在进行的流完成。

无法重试请求的客户端在服务器关闭连接时会丢失所有正在进行中的请求。这一点对于可能未使用HTTP/2为客户端提供服务的中间代理尤其如此。试图优雅关闭连接的服务器应当首先发送一个带有最后流ID设置为2^31-1且错误码为NO_ERROR的GOAWAY帧。这一信号通知客户端，关闭即将到来，禁止发起更多请求。在留出足够时间（至少一个往返时间）处理任何正在进行的流创建后，服务器可以再发送一个带有更新后最后流ID的GOAWAY帧，以确保连接可以干净地关闭而不丢失请求。

在发送GOAWAY帧后，发送端可以丢弃由接收端发起且流ID高于指定最后流ID的帧，但任何改变连接状态的帧都不能被完全忽略。例如，HEADERS、PUSH_PROMISE和CONTINUATION帧必须至少被处理，以确保头部压缩所维护的状态一致（参见第4.3节）；同样，DATA帧必须计入连接的流控窗口。未处理这些帧可能导致流控或头部压缩状态不同步。

GOAWAY帧还包含一个32位的错误码（第7节），用于说明关闭连接的原因。

端点可以在任何GOAWAY帧的负载中附加不透明数据。这些附加的调试信息仅用于诊断目的，没有语义价值。调试信息可能包含安全或隐私敏感数据。记录或以其他方式持久存储的调试数据必须采取充分的安全措施，以防止未授权访问。

6.9.  WINDOW_UPDATE

WINDOW_UPDATE帧（类型=0x8）用于实现流控，详见第5.2节的概述。

流控在两个层面上操作：每个单独的流和整个连接。

这两种流控都是点对点的，即仅在两个端点之间。中间代理不会在依赖连接之间转发WINDOW_UPDATE帧，但任何接收方对数据传输的限制都可能间接导致流控信息向原始发送端传播。

流控仅适用于被标记为受流控控制的帧类型。在本文定义的帧类型中，仅DATA帧受流控控制。免于流控的帧必须被接受和处理，除非接收方无法分配资源处理该帧。如果无法接受某帧，接收方可以响应流错误（第5.4.2节）或连接错误（第5.4.1节），错误类型为FLOW_CONTROL_ERROR。

| R |  Window Size Increment (31)  |
|---|------------------------------|

图14：WINDOW_UPDATE负载格式

WINDOW_UPDATE帧的负载由一个保留位和一个无符号的31位整数组成，表示发送端在现有流控窗口基础上可以额外传输的字节数。合法的增量范围是1到2^31-1（即2,147,483,647字节）。

WINDOW_UPDATE帧没有定义任何标志。

该帧可以针对某个特定流，也可以针对整个连接。在前者中，帧的流ID指示受影响的流；在后者中，值“0”表示整个连接。

接收端必须将流ID对应的WINDOW_UPDATE帧中流控窗口增量为0的情况视为流错误（第5.4.2节）中的PROTOCOL_ERROR；连接层的流控窗口出现错误则视为连接错误（第5.4.1节）。

当一个端点已发送带有END_STREAM标志的帧后，另一端仍可接收WINDOW_UPDATE帧。这意味着在“半关闭（远端）”或“已关闭”的流上也可能收到WINDOW_UPDATE帧。接收端不得将此视为错误（参见第5.1节）。

接收方必须始终将流控帧的贡献计入连接的流控窗口，除非将此视为连接错误（第5.4.1节）。即使帧有误，也应如此，否则发送端和接收端的流控窗口可能不同。

长度非4字节的WINDOW_UPDATE帧必须被视为连接错误（第5.4.1节）中的FRAME_SIZE_ERROR。

6.9.1. 流控窗口

HTTP/2中的流控通过每个端点在每个流上维护的窗口实现。流控窗口是一个简单的整数值，表示发送端允许传输的数据字节数，其大小反映接收端的缓冲能力。

适用的两个流控窗口是：流级流控窗口和连接级流控窗口。发送端不得发送超出接收端广告的任一流控窗口空间的流控帧。可以发送长度为0且设置END_STREAM标志（即空DATA帧）的帧，前提是两个流控窗口都没有空间。

在流控计算中，不计入9字节的帧头。

发送端在发送流控帧后，应将两个窗口的剩余空间减去已传输的帧长度。

接收端在消费数据并释放流控窗口空间时，会发送WINDOW_UPDATE帧。流控窗口的更新是分别针对流级和连接级的。

接收端收到WINDOW_UPDATE后，应将相应窗口增加帧中指定的数量。

发送端不得让任何流控窗口超过2^31-1字节。如果收到导致窗口超过最大值的WINDOW_UPDATE，必须终止相应的流或连接。对于流，发送端应发送RST_STREAM，错误码为FLOW_CONTROL_ERROR；对于连接，应发送带有相同错误码的GOAWAY帧。

流控帧和WINDOW_UPDATE帧是完全异步的，这允许接收端积极更新窗口大小，防止流阻塞。

6.9.2. 初始流控窗口大小

在HTTP/2连接首次建立时，所有新流的初始流控窗口大小为65,535字节，连接的流控窗口也是如此。双方可以在连接预告中的SETTINGS帧中通过设置SETTINGS_INITIAL_WINDOW_SIZE值来调整新建流的初始窗口大小。连接的流控窗口只能通过WINDOW_UPDATE帧调整。

在收到设置了SETTINGS_INITIAL_WINDOW_SIZE的SETTINGS帧之前，端点只能使用默认的初始窗口大小来发送流控帧。连接的流控窗口也保持在默认值，直到收到WINDOW_UPDATE。

除了调整未激活流的窗口外，SETTINGS帧还可以改变已激活流（处于“打开”或“半关闭（远端）”状态）的初始窗口大小。当SETTINGS_INITIAL_WINDOW_SIZE的值发生变化时，接收端必须根据新旧值的差异调整其维护的所有流控窗口的大小。

更改SETTINGS_INITIAL_WINDOW_SIZE可能导致流控窗口的可用空间变为负值。发送端必须跟踪负的流控窗口，直到收到使窗口变为正的WINDOW_UPDATE帧，才能继续发送流控帧。

例如，客户端在连接建立时立即发送60KB数据，而服务器将初始窗口设置为16KB，则客户端在收到SETTINGS帧后，流控窗口变为-44KB。客户端会保持负值，直到收到WINDOW_UPDATE帧将窗口恢复为正数，之后才能继续发送。

SETTINGS帧不能改变连接级的流控窗口。

端点必须将导致任何流控窗口超过最大值（2^31-1字节）的设置更改视为连接错误（第5.4.1节），错误类型为FLOW_CONTROL_ERROR。

6.9.3. 缩小流控窗口

希望使用比当前更小的流控窗口的接收端可以发送新的SETTINGS帧。但必须准备好接受超出该窗口大小的数据，因为在处理SETTINGS帧之前，发送端可能已发送超出下限的数据。

在发送缩小初始流控窗口的SETTINGS帧后，接收端可以继续处理超出流控限制的流，但这不会立即减少其为流控窗口预留的空间。由于需要等待WINDOW_UPDATE帧以允许发送端恢复发送，流的处理可能会停滞。接收端也可以选择发送带有FLOW_CONTROL_ERROR的RST_STREAM，终止受影响的流。

6.10.  CONTINUATION

CONTINUATION帧（类型=0x9）用于续传头部块片段（第4.3节）。只要前一帧在同一流上且是HEADERS、PUSH_PROMISE或未设置END_HEADERS标志的CONTINUATION帧，就可以连续发送任意数量的CONTINUATION帧。

| Header Block Fragment (*) ... |

图15：CONTINUATION帧负载格式

CONTINUATION帧的负载包含一个头部块片段（第4.3节）。

该帧定义了以下标志：

END_HEADERS（0x4）：设置后，第二位指示该帧结束一个头部块（第4.3节）。

如果未设置END_HEADERS位，该帧必须由另一个CONTINUATION帧跟随。接收端必须将收到其他类型帧或不同流上的帧视为连接错误（第5.4.1节）中的PROTOCOL_ERROR。

CONTINUATION帧会改变连接状态（第4.3节定义）。

CONTINUATION帧必须关联到某个流。如果收到流ID为0x0的CONTINUATION帧，接收端必须响应连接错误（第5.4.1节）中的PROTOCOL_ERROR。

必须在HEADERS、PUSH_PROMISE或未设置END_HEADERS的CONTINUATION帧之前接收相应的帧。违反此规则的接收端应响应连接错误（第5.4.1节）中的PROTOCOL_ERROR。

7.  错误码

错误码是用于在RST_STREAM和GOAWAY帧中传达流或连接错误原因的32位字段。

错误码共享一个码空间。有些错误码仅适用于流或整个连接，在另一种场景下没有定义语义。

定义的错误码包括：

NO_ERROR（0x0）：表示没有错误。例如，GOAWAY可能包含此码，表示连接正常关闭。

PROTOCOL_ERROR（0x1）：端点检测到非特定的协议错误。当没有更具体的错误码时使用。

INTERNAL_ERROR（0x2）：端点遇到未预料的内部错误。

FLOW_CONTROL_ERROR（0x3）：端点检测到对端违反了流控协议。

SETTINGS_TIMEOUT（0x4）：端点发送了SETTINGS帧但未及时收到响应。详见第6.5.3节。

STREAM_CLOSED（0x5）：端点在流半关闭后仍收到帧。

FRAME_SIZE_ERROR（0x6）：端点收到帧大小无效。

REFUSED_STREAM（0x7）：端点在应用处理之前拒绝了流（详见第8.1.4节）。

CANCEL（0x8）：端点用以表示不再需要该流。

压缩错误（0x9）：端点无法维持连接的头部压缩上下文。

连接错误（0xa）：对响应于CONNECT请求（第8.3节）建立的连接进行了重置或异常关闭。

增强你的冷静（0xb）：端点检测到其对等方表现出可能产生过载的行为。

安全不足（0xc）：底层传输具有不符合最低安全要求的属性（见第9.2节）。

必须使用HTTP/1.1（0xd）：端点要求使用HTTP/1.1而非HTTP/2。

未知或不支持的错误代码不得触发任何特殊行为。这些可以由实现视为等同于内部错误。

8. HTTP消息交换

HTTP/2旨在尽可能与当前的HTTP使用保持兼容。这意味着，从应用程序的角度来看，协议的特性基本保持不变。为实现这一点，所有请求和响应的语义都得以保留，尽管传达这些语义的语法发生了变化。

因此，HTTP/1.1语义和内容的规范与要求（[RFC7231]）、条件请求（[RFC7232]）、范围请求（[RFC7233]）、缓存（[RFC7234]）以及认证（[RFC7235]）都适用于HTTP/2。HTTP/1.1消息语法和路由（[RFC7230]）的部分内容，例如HTTP和HTTPS URI方案，也适用于HTTP/2，但这些语义在本协议中的表达方式在以下章节中定义。

8.1. HTTP请求/响应交换

客户端在新流上发送HTTP请求，使用之前未使用过的流标识符（第5.1.1节）。服务器在与请求相同的流上发送HTTP响应。

HTTP消息（请求或响应）由以下部分组成：

1. 仅响应部分，包含零个或多个HEADERS帧（每个后跟零个或多个CONTINUATION帧），其中包含信息性（1xx）HTTP响应的消息头（见[RFC7230]第3.2节和[RFC7231]第6.2节）；

2. 一个HEADERS帧（后跟零个或多个CONTINUATION帧），包含消息头（见[RFC7230]第3.2节）；

3. 零个或多个DATA帧，包含有效载荷正文（见[RFC7230]第3.3节）；

4. 可选的一个HEADERS帧，后跟零个或多个CONTINUATION帧，包含尾部部分（trailer），如果存在（见[RFC7230]第4.1.2节）。

序列中的最后一个帧带有END_STREAM标志，表示该HEADERS帧可以后续跟随携带剩余头部块的CONTINUATION帧。

其他帧（来自任何流）不得出现在HEADERS帧与可能跟随的CONTINUATION帧之间。

HTTP/2使用DATA帧携带消息负载。定义在[RFC7230]第4.1节中的“分块”传输编码在HTTP/2中不得使用。

尾部头字段在一个头块中携带，该头块也会终止流。这样的头块以HEADERS帧开始，后跟零个或多个CONTINUATION帧，其中HEADERS帧带有END_STREAM标志。在第一个之后的头块中未终止流的头块，不属于HTTP请求或响应。

HEADERS帧（及相关的CONTINUATION帧）只能出现在流的开始或结束处。接收方如果在收到最终（非信息性）状态码后，收到没有设置END_STREAM标志的HEADERS帧，必须将相应的请求或响应视为格式错误（第8.1.2.6节）。

HTTP请求/响应交换完全占用一个流。请求以将流置于“开启”状态的HEADERS帧开始。请求以带有END_STREAM的帧结束，使流变为“半关闭（本端）”。响应以HEADERS帧开始，以带有END_STREAM的帧结束，使流变为“关闭”状态。

当服务器发送——或客户端接收——带有END_STREAM标志的帧（包括完成头部块所需的CONTINUATION帧）后，HTTP响应即完成。如果响应不依赖于未发送或未接收的请求部分，服务器可以在客户端发送完整请求之前就发送完整响应。在这种情况下，服务器可以通过发送带有NO_ERROR错误码的RST_STREAM帧，请求客户端无错误地中止请求传输（在发送完完整响应，即带END_STREAM标志的帧后）。客户端不得因收到此类RST_STREAM而丢弃响应，但可以出于其他原因自行丢弃。

8.1.1. 从HTTP/2升级

HTTP/2取消支持101（切换协议）状态码（[RFC7231]第6.2.2节）。

101（切换协议）的语义不适用于多路复用协议。其他协议可以使用HTTP/2用来协商其使用的机制（见第3节）。

8.1.2. HTTP头字段

HTTP头字段以一系列键值对的形式携带信息。注册的HTTP头字段列表，请参见由<https://www.iana.org/assignments/message-headers>维护的“消息头字段”注册表。

与HTTP/1.x一样，头字段名是ASCII字符字符串，比较时不区分大小写。然而，头字段名在编码到HTTP/2中之前，必须转换为小写。包含大写字母的请求或响应头字段名视为格式错误（第8.1.2.6节）。

8.1.2.1. 伪头字段

虽然HTTP/1.x使用起始行（见[RFC7230]第3.1节）传达目标URI、请求方法和响应状态码，HTTP/2使用以':'字符（ASCII 0x3a）开头的特殊伪头字段来实现。

伪头字段不是HTTP头字段。端点不得生成除本文档定义的伪头字段之外的伪头字段。

伪头字段仅在其定义的上下文中有效。请求的伪头字段不得出现在响应中；响应的伪头字段不得出现在请求中。伪头字段不得出现在尾部（trailers）中。端点必须将包含未定义或无效伪头字段的请求或响应视为格式错误（第8.1.2.6节）。

所有伪头字段必须在普通头字段之前出现在头块中。任何在普通头字段之后出现的伪头字段的请求或响应，都必须视为格式错误（第8.1.2.6节）。

8.1.2.2. 连接特定的头字段

HTTP/2不使用Connection头字段来指示连接特定的头字段；在此协议中，连接特定的元数据通过其他方式传达。端点不得生成包含连接特定头字段的HTTP/2消息；任何包含此类头字段的消息都必须视为格式错误（第8.1.2.6节）。

唯一的例外是TE头字段，它可以出现在HTTP/2请求中；当存在时，必须只包含值“trailers”。

这意味着，将HTTP/1.x消息转换为HTTP/2的中间设备，需要删除由Connection头字段指定的任何头字段，以及Connection头字段本身。此类中间设备还应删除其他连接特定的头字段，如Keep-Alive、Proxy-Connection、Transfer-Encoding和Upgrade，即使它们未被Connection头字段指定。

注意：HTTP/2故意不支持协议升级。第3节描述的握手方法被认为足以协商使用其他协议。

8.1.2.3. 请求伪头字段

HTTP/2请求定义了以下伪头字段：

- “:method”伪头字段，包含HTTP方法（[RFC7231]第4节）；

- “:scheme”伪头字段，包含目标URI的方案部分（[RFC3986]第3.1节）；

  “:scheme”不限于“http”和“https”方案URI。代理或网关可以转换非HTTP方案的请求，从而允许HTTP与非HTTP服务交互。

- “:authority”伪头字段，包含目标URI的授权部分（[RFC3986]第3.2节）。该授权部分不得包含已废弃的“userinfo”子组件（针对“http”或“https”方案URI）。

为了确保能准确重现HTTP/1.1请求行，转换自具有原点或星号（*）请求目标的HTTP/1.1请求时，必须省略此伪头字段（见[RFC7230]第5.3节）。直接生成HTTP/2请求的客户端应使用“:authority”伪头字段代替Host头。将HTTP/2请求转换为HTTP/1.1的中间设备，必须在请求中没有Host头时，通过复制“:authority”伪头字段的值来创建Host头。

- “:path”伪头字段，包含目标URI的路径和查询部分（“绝对路径”产生式，可能后跟“?”字符和“查询”产生式，见[RFC3986]第3.3和第3.4节）。星号（*）请求中，":path"值为“*”。

对于“http”或“https”URI，此伪头字段不得为空；不包含路径部分的“http”或“https”URI，必须包含“/”作为值。例外情况是对不包含路径的“http”或“https”URI的OPTIONS请求，这些请求必须包含值为“*”的“:path”伪头字段（见[RFC7230]第5.3.4节）。

所有HTTP/2请求必须恰好包含一个有效的“:method”、“:scheme”和“:path”伪头字段的值，除非是CONNECT请求（第8.3节）。省略必需伪头字段的HTTP请求视为格式错误（第8.1.2.6节）。

HTTP/2未定义携带HTTP/1.1请求行中版本标识符的方法。

8.1.2.4. 响应伪头字段

对于HTTP/2响应，定义了单一的“:status”伪头字段，携带HTTP状态码（见[RFC7231]第6节）。所有响应都必须包含此伪头字段，否则响应视为格式错误（第8.1.2.6节）。

HTTP/2未定义携带HTTP/1.1状态行中版本或原因短语的方法。

8.1.2.5. 压缩Cookie头字段

Cookie头字段[COOKIE]使用分号（“;”）作为cookie对（或“碎片”）的分隔符。此头字段不遵循HTTP中的列表构造规则（见[RFC7230]第3.2.2节），这会阻碍cookie对被拆分成不同的键值对。随着cookie的频繁更新，这会显著降低压缩效率。

为了改善压缩效率，可以将Cookie头字段拆分成多个头字段，每个包含一个或多个cookie对。如果解压后存在多个Cookie头字段，这些必须用两个字节的分隔符0x3B、0x20（ASCII字符串“; ”）连接成一个字节串，然后在传入非HTTP/2环境（如HTTP/1.1连接或通用HTTP服务器应用）之前进行处理。

因此，以下两组Cookie头字段在语义上是等价的：

cookie: a=b; c=d; e=f

与

cookie: a=b
cookie: c=d
cookie: e=f

8.1.2.6. 格式错误的请求和响应

格式错误的请求或响应是指本应为有效的HTTP/2帧序列，但由于存在多余的帧、禁止的头字段、缺少必需的头字段或包含大写头字段名而无效的情况。

包含有效载荷的请求或响应可以包含Content-Length头字段。如果Content-Length的值不等于组成正文的DATA帧负载长度之和，则请求或响应也是格式错误的。根据[RFC7230]第3.3.2节定义，没有有效载荷的响应可以有非零的Content-Length头字段，即使没有在DATA帧中包含内容。

【完】

中介机构在处理HTTP请求或响应时（即，任何不作为隧道的中介机构）不得转发格式错误的请求或响应。检测到的格式错误请求或响应必须被视为流错误（第5.4.2节）中的PROTOCOL_ERROR类型。

对于格式错误的请求，服务器可以在关闭或重置流之前，先发送一个HTTP响应。客户端不得接受格式错误的响应。注意，这些要求旨在防止多种常见的HTTP攻击类型；它们故意设置得较为严格，因为宽容可能会使实现暴露于这些漏洞之下。

8.1.3. 示例

本节展示了HTTP/1.1请求和响应，以及对应的HTTP/2请求和响应的示意。

一个HTTP GET请求包含请求头字段且没有有效载荷，因此以一个HEADERS帧传输，后跟零个或多个CONTINUATION帧，包含序列化的请求头字段块。以下的HEADERS帧同时设置了END_HEADERS和END_STREAM标志；没有发送CONTINUATION帧。

     GET /resource HTTP/1.1           HEADERS
     Host: example.org          ==>     + END_STREAM
     Accept: image/jpeg                 + END_HEADERS
                                          :method = GET
                                          :scheme = https
                                          :path = /resource
                                          host = example.org
                                          accept = image/jpeg

类似地，只包含响应头字段的响应以HEADERS帧传输（同样，后续可能跟零个或多个CONTINUATION帧），包含序列化的响应头块。

     HTTP/1.1 304 Not Modified        HEADERS
     ETag: "xyzzy"              ==>     + END_STREAM
     Expires: Thu, 23 Jan ...           + END_HEADERS
                                          :status = 304
                                          etag = "xyzzy"
                                          expires = Thu, 23 Jan ...

一个包含请求头字段和有效载荷数据的HTTP POST请求以一个HEADERS帧传输，后跟零个或多个包含请求头字段的CONTINUATION帧，再后跟一个或多个DATA帧，最后一个CONTINUATION（或HEADERS）帧设置END_HEADERS标志，最后一个DATA帧设置END_STREAM标志。

     POST /resource HTTP/1.1          HEADERS
     Host: example.org          ==>     - END_STREAM
     Content-Type: image/jpeg           - END_HEADERS
     Content-Length: 123                  :method = POST
                                          :path = /resource
                                          :scheme = https
     {二进制数据}                       

                                      CONTINUATION
                                        + END_HEADERS
                                          content-type = image/jpeg
                                          host = example.org
                                          content-length = 123

                                      DATA
                                        + END_STREAM
                                      {二进制数据}

注意，任何给定头字段的内容可能被分散在多个头块片段中。本示例中头字段到帧的分配仅为示意。

包含头字段和有效载荷数据的响应以HEADERS帧传输，后跟零个或多个CONTINUATION帧，再后跟一个或多个DATA帧，最后一个DATA帧设置END_STREAM标志。

     HTTP/1.1 200 OK                  HEADERS
     Content-Type: image/jpeg   ==>     - END_STREAM
     Content-Length: 123                + END_HEADERS
                                          :status = 200
     {二进制数据}                        content-type = image/jpeg
                                          content-length = 123

                                      DATA
                                        + END_STREAM
                                      {二进制数据}

使用非101状态码的中间响应（1xx）以HEADERS帧传输，后跟零个或多个CONTINUATION帧。

在请求或响应头块以及所有数据帧都已发送完毕后，尾部头字段作为头块发送。启动尾部头块的HEADERS帧必须设置END_STREAM标志。

以下示例包括一个100（Continue）状态码的响应（用于对包含“100-continue”令牌的Expect头字段的请求的响应）以及尾部头字段：

     HTTP/1.1 100 Continue            HEADERS
     Extension-Field: bar       ==>     - END_STREAM
                                        + END_HEADERS
                                          :status = 100
                                          extension-field = bar

     HTTP/1.1 200 OK                  HEADERS
     Content-Type: image/jpeg   ==>     - END_STREAM
     Transfer-Encoding: chunked         + END_HEADERS
     Trailer: Foo                         :status = 200
                                          content-length = 123
     123                                  content-type = image/jpeg
     {二进制数据}                        trailer = Foo
     0
     Foo: bar                         DATA
                                        - END_STREAM
                                      {二进制数据}

                                      HEADERS
                                        + END_STREAM
                                        + END_HEADERS
                                          foo = bar

8.1.4. HTTP/2中的请求可靠性机制

在HTTP/1.1中，当发生错误时，HTTP客户端无法重试非幂等请求，因为无法判断错误的性质。可能在错误发生前，服务器已进行了一些处理，如果重试请求，可能会导致不良后果。

HTTP/2提供两种机制，向客户端保证请求未被处理：

- GOAWAY帧指示可能已处理的最高流编号。因此，编号更高的请求流被保证安全重试。
- REFUSED_STREAM错误码可以包含在RST_STREAM帧中，表示在任何处理发生之前，流已被关闭。任何在重置流上发送的请求都可以安全重试。

未被处理的请求并不意味着失败；客户端可以自动重试它们，即使是非幂等方法的请求。

服务器不得指示某个流未被处理，除非它能保证这一点。如果某个流上的帧被传递到应用层，则不能对该流使用REFUSED_STREAM，且GOAWAY帧必须包含一个大于或等于该流编号的流标识符。

除了这些机制外，PING帧还提供了一种方便的方式，让客户端测试连接状态。空闲连接可能会被某些中间设备（如网络地址转换器或负载均衡器）静默丢弃连接绑定。PING帧允许客户端在不发请求的情况下安全地测试连接是否仍然活跃。

8.2. 服务器推送

HTTP/2允许服务器在响应之前，主动向客户端“推送”响应（以及对应的“承诺”请求）。当服务器知道客户端需要这些响应以完整处理原始请求时，这种机制尤为有用。

客户端可以请求禁用服务器推送，但此设置在每个跳点（hop）上是单独协商的。可以将SETTINGS_ENABLE_PUSH设置为0，表示禁用推送。

承诺的请求必须可缓存（参见[RFC7231]第4.2.3节）、必须安全（参见[RFC7231]第4.2.1节），且不得包含请求体。客户端收到不可缓存、非安全或指示存在请求体的承诺请求时，必须用流错误（第5.4.2节）中的PROTOCOL_ERROR重置承诺流。注意，如果客户端不识别新定义的方法为安全，可能会导致承诺流被重置。

可缓存的推送响应（参见[RFC7234]第3节）可以由客户端存储（如果实现了HTTP缓存）。在承诺的流ID对应的流仍然开启时，推送响应被视为已成功验证（例如，存在“no-cache”缓存指令（[RFC7234]第5.2.2节））。

不可缓存的推送响应不得由任何HTTP缓存存储，但可以单独提供给应用层。

服务器必须在":authority"伪头字段中包含其权威的值（参见第10.1节）。客户端应将服务器非权威的PUSH_PROMISE视为流错误（第5.4.2节）中的PROTOCOL_ERROR。

中间代理可以接收服务器推送，但选择不转发给客户端。换句话说，如何使用推送信息由该中间代理决定。同样，中间代理也可以选择向客户端发起额外的推送，而无需服务器采取任何行动。

客户端不能发起推送。因此，服务器必须将接收PUSH_PROMISE帧视为连接错误（第5.4.1节）中的PROTOCOL_ERROR。客户端不得试图将SETTINGS_ENABLE_PUSH设置为非0值，否则应将此消息视为连接错误（第5.4.1节）中的PROTOCOL_ERROR。

8.2.1. 推送请求

服务器推送在语义上等同于服务器响应请求；但在此情况下，推送请求也是由服务器作为PUSH_PROMISE帧发出的。

PUSH_PROMISE帧包含一个头块，内含服务器归因于请求的完整请求头字段集。不能对包含请求体的请求进行推送响应。

推送响应始终关联于客户端的明确请求。服务器发出的PUSH_PROMISE帧在该明确请求的流上发送。PUSH_PROMISE帧还包括一个承诺的流标识符，从服务器可用的流标识符中选择（参见第5.1.1节）。

PUSH_PROMISE及随后的CONTINUATION帧中的头字段必须是有效且完整的请求头字段集（第8.1.2.3节）。服务器必须在":method"伪头字段中包含一个安全且可缓存的方法。如果客户端收到的PUSH_PROMISE未包含完整有效的头字段集，或":method"伪头字段指示的方法不安全，必须用流错误（第5.4.2节）中的PROTOCOL_ERROR响应。

服务器应在发送任何引用承诺响应的帧之前，先发送PUSH_PROMISE（第6.6节），以避免客户端在收到任何PUSH_PROMISE帧之前发出请求的竞态。

例如，如果服务器收到一个请求，内容包含多个图片文件的嵌入链接，且服务器选择推送这些图片，提前发送PUSH_PROMISE帧可以确保客户端在发现嵌入链接之前就已知会有资源被推送。同样，如果服务器在头块中引用的资源（如Link头字段）中推送响应，提前发送PUSH_PROMISE帧可以避免客户端请求这些资源。

客户端不得发送PUSH_PROMISE帧。

服务器可以对任何由客户端发起的流发送PUSH_PROMISE帧，但该流必须处于“开启”或“半关闭（远端）”状态（相对于服务器）。PUSH_PROMISE帧会与响应的帧交错发送，但不能与组成单个头块的HEADERS和CONTINUATION帧交错。

发送PUSH_PROMISE帧会创建一个新流，并将该流置于“保留（本地）”状态（服务器端）和“保留（远端）”状态（客户端端）。

8.2.2. 推送响应

在发送PUSH_PROMISE帧后，服务器可以在使用承诺的流标识符的服务器发起流上，开始传送推送的响应（第8.1.2.4节），作为响应。服务器使用此流传输HTTP响应，采用第8.1节定义的相同帧序列。该流在发送第一个HEADERS帧后变为“半关闭”状态（第5.1节）。

一旦客户端收到PUSH_PROMISE帧并选择接受推送响应，除非承诺的流已关闭，否则不应发出任何请求。

如果客户端出于任何原因决定不接受服务器的推送响应，或服务器长时间未开始发送承诺的响应，客户端可以发送RST_STREAM帧，使用CANCEL或REFUSED_STREAM错误码，并引用该推送流的标识符。

客户端可以使用 SETTINGS_MAX_CONCURRENT_STREAMS 设置来限制服务器可以同时推送的响应数量。将 SETTINGS_MAX_CONCURRENT_STREAMS 设置为零会禁用服务器推送，因为这会阻止服务器创建必要的流。这并不禁止服务器发送 PUSH_PROMISE 帧；客户端需要重置任何不需要的承诺流。

接收推送响应的客户端必须验证服务器是否具有权威性（参见第10.1节）或提供推送响应的代理是否已针对相应的请求进行配置。例如，服务器只为“example.com” DNS-ID 或通用名称提供证书，则不允许推送“https://www.example.org/doc”的响应。

PUSH_PROMISE 流的响应以 HEADERS 帧开始，立即将该流置于“半关闭（远端）”状态（服务器端）和“半关闭（本端）”状态（客户端），并以带有 END_STREAM 标志的帧结束，将流置于“已关闭”状态。

注意：客户端在服务器推送中从不发送带有 END_STREAM 标志的帧。

---

Belshe 等人，标准轨迹 [第63页]

RFC 7540 HTTP/2 2015年5月

8.3.  CONNECT 方法

在 HTTP/1.x 中，伪方法 CONNECT（[RFC7231] 第4.3.6节）用于将 HTTP 连接转换为到远程主机的隧道。CONNECT 主要用于与 HTTP 代理配合，建立与源服务器的 TLS 会话，以便与“https”资源交互。

在 HTTP/2 中，CONNECT 方法用于在单个 HTTP/2 流上建立到远程主机的隧道，目的类似。HTTP 头字段映射按照第8.1.2.3节（“请求伪头字段”）的定义进行，但有一些差异，具体包括：

- “:method”伪头字段设置为“CONNECT”。
- “:scheme”和“:path”伪头字段必须省略。
- “:authority”伪头字段包含要连接的主机和端口（等同于 CONNECT 请求的请求目标的 authority 形式（参见 [RFC7230] 第5.3节））。

不符合这些限制的 CONNECT 请求为格式错误（第8.1.2.6节）。

支持 CONNECT 的代理会建立一个 TCP 连接（[TCP]）到“:authority”伪头字段指定的服务器。一旦连接成功建立，代理会向客户端发送一个包含 2xx 状态码的 HEADERS 帧，具体定义见 [RFC7231] 第4.3.6节。

在每个对等方发送的初始 HEADERS 帧之后，所有后续的 DATA 帧都对应于在 TCP 连接上传输的数据。客户端发送的任何 DATA 帧的负载由代理转发到 TCP 服务器；从 TCP 服务器接收的数据由代理组装成 DATA 帧。除 DATA 或流管理帧（RST_STREAM、WINDOW_UPDATE 和 PRIORITY）外，不得在已连接的流上发送其他帧，若收到则视为流错误（第5.4.2节）。

TCP 连接可以由任一端关闭。DATA 帧上的 END_STREAM 标志被视为等同于 TCP 的 FIN 位。客户端应在收到带有 END_STREAM 标志的帧后，发送带有 END_STREAM 标志的 DATA 帧。代理收到带有 END_STREAM 标志的 DATA 帧后，会在最后一个 TCP 段上设置 FIN 位后，发送带有 END_STREAM 标志的 DATA 帧。代理收到带有 FIN 位的 TCP 段后，会发送带有 END_STREAM 标志的 DATA 帧。注意，最后的 TCP 段或 DATA 帧可能为空。

TCP 连接错误通过 RST_STREAM 信号指示。代理将 TCP 连接中的任何错误（包括接收到带 RST 位的 TCP 段）视为类型为 CONNECT_ERROR 的流错误（第5.4.2节）。相应地，代理在检测到流或 HTTP/2 连接出现错误时，必须发送带 RST 位的 TCP 段。

---

9. 其他 HTTP 需求/考虑事项

本节概述了改善互操作性、减少已知安全漏洞暴露或减少实现差异的 HTTP 协议属性。

9.1. 连接管理

HTTP/2 连接是持久的。为了获得最佳性能，建议客户端在确认不再需要与服务器通信（例如用户离开某个网页）或服务器关闭连接之前，不要关闭连接。

客户端不应对同一主机和端口对开设多个 HTTP/2 连接，主机名应由 URI、备用服务 [ALT-SVC] 或配置的代理确定。

客户端可以创建额外的连接作为替代，主要用于：一是当现有连接接近耗尽流标识符空间（第5.1.1节）；二是刷新 TLS 连接的密钥材料；三是替换遇到错误的连接（第5.4.1节）。

客户端可以使用不同的 Server Name Indication [TLS-EXT] 值，或提供不同的 TLS 客户端证书，来在相同 IP 和端口上建立多个连接，但应避免用相同配置建立多个连接。

鼓励服务器尽可能长时间保持连接开启，但在必要时也可以终止空闲连接。当任一端决定关闭传输层 TCP 连接时，应先发送 GOAWAY（第6.8节）帧，以确保双方能可靠确认已处理完之前发送的帧，并优雅地完成或终止剩余任务。

---

9.1.1. 连接复用

对源服务器（直接或通过 CONNECT 方法创建的隧道）建立的连接，可以在多个不同的 URI authority 组件请求中复用，只要源服务器具有权威性（第10.1节）。对于没有 TLS 的 TCP 连接，这取决于主机解析到的 IP 地址是否相同。

对于“https”资源，连接复用还依赖于证书是否对 URI 中的主机有效。服务器提供的证书必须满足客户端在建立新 TLS 连接时对该主机的验证要求。

源服务器可能提供包含多个“subjectAltName”属性或带有通配符的名称的证书，其中至少有一个对 URI 中的 authority 有效。例如，带有“*.example.com” “subjectAltName”的证书，可能允许在“https://a.example.com/”和“https://b.example.com/”的请求中使用同一连接。

在某些部署中，复用连接到多个源可能导致请求被导向错误的源服务器。例如，中间设备可能通过 TLS Server Name Indication (SNI) [TLS-EXT] 来选择源服务器，从而在 TLS 终止时可能将机密信息发送到非目标服务器，尽管该服务器具有权威性。

不希望客户端复用连接的服务器，可以通过在响应中返回 421（Misdirected Request）状态码，表明其不对请求具有权威性（第9.1.2节）。

使用 HTTP/2 通过代理发起请求的客户端，所有请求都通过单一连接发送到代理，连接会被复用。

---

9.1.2. 421（错误请求）状态码

状态码 421（Misdirected Request）表示请求被导向了无法响应的服务器。此状态码由未配置响应特定方案和 authority 组合的服务器发出。

客户端收到 421 响应后，可以尝试在不同连接上重试请求——无论请求方法是否幂等——前提是可以复用连接（第9.1.1节）或选择备用服务 [ALT-SVC]。

此状态码不得由代理生成。

默认情况下，421 响应是可缓存的，除非方法定义或明确的缓存控制（参见 [RFC7234] 第4.2.2节）另有说明。

---

9.2. 使用 TLS 功能

HTTP/2 实现必须在 TLS 1.2 [TLS12] 或更高版本上使用。应遵循 [TLSBCP] 中的 TLS 使用指南，但对 HTTP/2 有一些额外限制。

TLS 实现必须支持 Server Name Indication (SNI) [TLS-EXT] 扩展。HTTP/2 客户端在协商 TLS 时必须指明目标域名。

部署支持 TLS 1.3 或更高版本的 HTTP/2，只需支持和使用 SNI 扩展；部署 TLS 1.2 时，需遵守以下节中的要求。建议实现提供符合要求的默认配置，但最终由部署负责确保合规。

---

9.2.1. TLS 1.2 功能限制

本节描述可与 HTTP/2 一起使用的 TLS 1.2 功能集的限制。由于部署限制，可能无法在不满足这些限制时失败 TLS 协商。端点可以在不符合这些 TLS 要求时立即终止连接，返回连接错误（第5.4.1节）类型为 INADEQUATE_SECURITY。

部署的 HTTP/2 必须禁用压缩。TLS 压缩可能泄露未被披露的信息 [RFC3749]。由于 HTTP/2 提供的压缩功能更具上下文感知，通常更适合出于性能和安全等考虑使用，因此无需使用通用压缩。

部署的 HTTP/2 必须禁用重新协商。端点应将 TLS 重新协商视为协议错误（第5.4.1节）类型的连接错误（PROTOCOL_ERROR）。禁用重新协商可能导致长连接因底层密码套件的消息限制而变得不可用。

端点可以在握手中使用重新协商提供客户端凭证的机密性保护，但任何重新协商必须在发送连接预告（connection preface）之前完成。服务器应在建立连接后立即看到重新协商请求时，要求客户端提供证书。

这实际上阻止了在请求特定受保护资源时使用重新协商。未来的规范可能会支持此用例，或者服务器可以通过返回 HTTP_1_1_REQUIRED 类型的错误，要求客户端使用支持重新协商的协议。

实现必须支持至少2048位的临时密钥交换大小（DHE [TLS12]），以及224位的临时椭圆曲线 Diffie-Hellman（ECDHE） [RFC4492]。客户端必须接受高达4096位的 DHE 密钥大小。端点可以将小于最低限制的密钥协商视为连接错误（第5.4.1节）类型为 INADEQUATE_SECURITY。

---

9.2.2. TLS 1.2 密码套件

部署的 HTTP/2 在 TLS 1.2 上不应使用附录A中列出的密码套件黑名单中的任何密码套件。

如果协商出黑名单中的密码套件，端点可以选择生成类型为 INADEQUATE_SECURITY 的连接错误（第5.4.1节）。使用黑名单中的密码套件的部署存在触发连接错误的风险，除非已知潜在对等方接受该密码套件。

实现不得对未在黑名单中的密码套件的协商生成此错误。因此，客户端在提供非黑名单密码套件时，应准备在 HTTP/2 中使用该密码套件。

黑名单包括TLS 1.2强制使用的密码套件，这意味着TLS 1.2的部署可能会有不相交的允许密码套件集。为了避免此问题导致TLS握手失败，使用TLS 1.2的HTTP/2部署必须支持TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 [TLS-ECDHE]，并使用P-256椭圆曲线 [FIPS186]。

Belshe等人               标准轨道                   [第68页]

RFC 7540                         HTTP/2                         2015年5月

请注意，客户端可能会广告支持黑名单上的密码套件，以便连接不支持HTTP/2的服务器。这允许服务器选择HTTP/1.1并使用在HTTP/2黑名单上的密码套件。然而，如果应用协议和密码套件是独立选择的，这可能导致HTTP/2协商使用黑名单中的密码套件。

10. 安全注意事项

10.1. 服务器权威性

HTTP/2依赖HTTP/1.1中关于权威性的定义来判断服务器是否对提供的响应具有权威性（参见[RFC7230]第9.1节）。这依赖于“http” URI方案的本地名称解析，以及“https”方案的经过验证的服务器身份（参见[RFC2818]第3节）。

10.2. 跨协议攻击

在跨协议攻击中，攻击者诱使客户端向理解不同协议的服务器发起交易。攻击者可能使该交易表现为第二个协议中的有效交易。结合Web环境的能力，这可以用来与保护不佳的私有网络中的服务器交互。

使用带有HTTP/2 ALPN标识符的TLS握手可以视为对抗跨协议攻击的充分保护。ALPN提供了服务器愿意继续使用HTTP/2的正面指示，从而防止对其他基于TLS的协议的攻击。

TLS中的加密使攻击者难以控制可能用于跨协议攻击的明文数据。

HTTP/2的明文版本对跨协议攻击的保护极少。连接预告（第3.5节）包含一个字符串，旨在混淆HTTP/1.1服务器，但对其他协议没有特殊保护。愿意忽略包含Upgrade头字段的HTTP/1.1请求部分的服务器，可能会暴露于跨协议攻击。

10.3. 中间人封装攻击

HTTP/2的头字段编码允许表达在HTTP/1.1使用的互联网消息语法中无效的字段名。包含无效字段名的请求或响应必须被视为格式错误（第8.1.2.6节）。因此，中间人无法将包含无效字段名的HTTP/2请求或响应转换为HTTP/1.1消息。

同样，HTTP/2允许无效的头字段值。虽然大多数可编码的值不会改变头字段解析，但回车符（CR，ASCII 0xd）、换行符（LF，ASCII 0xa）和空字符（NUL，ASCII 0x0）可能被攻击者利用，如果被逐字翻译。任何包含不允许在头字段值中的字符的请求或响应，必须被视为格式错误（第8.1.2.6节）。有效字符由[RFC7230]第3.2节中的“field-content”ABNF规则定义。

10.4. 推送响应的可缓存性

推送的响应没有客户端的明确请求；请求由服务器在PUSH_PROMISE帧中提供。

根据源服务器在Cache-Control头字段中的指导，推送的响应可以被缓存。然而，如果一个服务器托管多个租户，这可能引发问题。例如，服务器可能为不同用户提供URI空间的不同部分。

当多个租户共享同一服务器空间时，必须确保租户不能推送其无权限的资源表示。否则，租户可能提供一个被缓存的表示，覆盖实际由具有权限的租户提供的表示。

源服务器不具有权威性的推送响应（见第10.1节）不得使用或缓存。

10.5. 拒绝服务（DoS）考虑

HTTP/2连接可能比HTTP/1.1连接消耗更多资源。头部压缩和流量控制依赖于存储更多状态的资源承诺。这些功能的设置确保了内存承诺的严格界限。

PUSH_PROMISE帧的数量没有相同的限制。接受服务器推送的客户端应限制允许处于“保留（远程）”状态的流数量。过多的服务器推送流可能被视为类型为ENHANCE_YOUR_CALM的流错误（第5.4.2节）。

处理能力不能像状态容量那样有效地受到保护。

SETTINGS帧可能被滥用，导致对端消耗额外的处理时间。这可以通过无意义地更改SETTINGS参数、设置多个未定义参数或在同一帧中多次更改相同设置来实现。WINDOW_UPDATE或PRIORITY帧也可能被滥用，造成资源的无谓浪费。

大量的小帧或空帧可能被滥用，导致对端花费时间处理帧头。需要注意的是，一些用途是合法的，例如在流结束时发送空的DATA或CONTINUATION帧。

头部压缩也可能被用来浪费处理资源；详见[COMPRESSION]第7节关于潜在滥用的描述。

SETTINGS参数的限制不能立即减少，这可能使端点暴露于对端超出新限制的行为中。特别是在建立连接后，服务器设置的限制对客户端来说是未知的，可能会被超出而不被视为协议违规。

所有这些特性——即SETTINGS变更、小帧、头部压缩——只有在不必要或过度使用时才成为负担。

未监控此类行为的端点面临拒绝服务攻击的风险。实现应跟踪这些特性的使用情况，并对其使用设置限制。可将可疑活动视为连接错误（第5.4.1节），类型为ENHANCE_YOUR_CALM。

10.5.1. 头块大小限制

大型头块（第4.3节）可能导致实现承诺大量状态。关键的路由头字段可能出现在头块的末尾，阻碍头字段的流式传输到最终目的地。这种排序和其他原因（如确保缓存正确性）意味着端点可能需要缓冲整个头块。由于没有硬性限制头块的大小，一些端点可能被迫分配大量内存用于存储头字段。

端点可以使用SETTINGS_MAX_HEADER_LIST_SIZE通知对端可能的头块大小限制。此设置仅为建议，因此端点可以选择发送超出此限制的头块，风险是请求或响应被视为格式错误。此设置是针对连接的，因此任何请求或响应都可能遇到较低、未知的限制。中间人可以尝试通过传递不同对端提供的值来避免此问题，但没有义务这样做。

接收超出其处理能力的较大头块的服务器应返回HTTP 431（请求头字段过大）状态码[RFC6585]。客户端可以丢弃无法处理的响应。除非连接关闭，否则必须处理头块以确保连接状态的一致性。

10.5.2. CONNECT方法的问题

CONNECT方法可能会对代理造成不成比例的负载，因为创建流相较于建立和维护TCP连接成本较低。代理可能还会在关闭携带CONNECT请求的流之后，继续维护一些TCP连接资源，因为出站TCP连接仍处于TIME_WAIT状态。因此，单靠SETTINGS_MAX_CONCURRENT_STREAMS不能限制CONNECT请求所消耗的资源。

10.6. 压缩的使用

压缩可能被攻击者利用，在压缩的内容中恢复秘密数据，尤其是在压缩内容与攻击者控制的数据在同一上下文中时。HTTP/2支持头字段的压缩（第4.3节）；以下问题也适用于HTTP压缩编码（[RFC7231]第3.1.2.1节）。

存在利用Web特性（如[BREACH]）的压缩攻击。攻击者诱导多次请求，内容不同，观察每次的密文长度，从而在猜测秘密正确时获得更短的长度。

在安全通道中通信的实现不得压缩包含机密和攻击者控制数据的内容，除非为每个数据源使用不同的压缩字典。不能可靠识别数据源时，不得使用压缩。必须避免在HTTP/2中使用TLS提供的通用流压缩（详见第9.2节）。

关于头字段压缩的更多考虑，详见[COMPRESSION]。

10.7. 填充的使用

HTTP/2中的填充不是用作通用填充（如TLS [TLS12]提供的那样）。冗余填充可能反而适得其反。正确的应用依赖于对被填充数据的具体了解。

为了缓解基于压缩的攻击，禁用或限制压缩可能比填充更优作为防御措施。

填充可用来模糊帧内容的确切大小，旨在缓解特定的HTTP攻击，例如压缩内容中同时包含攻击者控制的明文和秘密数据（如[BREACH]）。

使用填充可能带来的保护远不如预期。充其量，填充只是增加攻击者观察帧数的难度。实现不当的填充方案容易被攻破。特别是，具有可预测分布的随机填充几乎没有保护作用；类似地，将载荷填充到固定大小会在载荷大小跨越固定边界时泄露信息，如果攻击者能控制明文。

中间人应保留DATA帧的填充，但可以删除HEADERS和PUSH_PROMISE帧的填充。中间人改变帧的填充量的合理理由是为了增强填充的保护效果。

10.8. 隐私考虑

HTTP/2的若干特性为观察者提供了关联单个客户端或服务器行为的机会。这些特性包括设置值、流量控制窗口的管理方式、流的优先级分配、对刺激的反应时间以及由设置控制的任何特性。

只要这些特性在行为上产生可观察的差异，就可能被用作指纹识别特定客户端的依据，详见[HTML5]第1.8节。

HTTP/2偏好使用单一TCP连接，允许关联用户在某个站点上的活动。复用连接到不同源也允许跨源追踪。

由于PING和SETTINGS帧会立即响应，它们可以被端点用来测量到对端的延迟。在某些场景下，这可能涉及隐私问题。

11. IANA考虑事项

在[TLS-ALPN]建立的“应用层协议协商（ALPN）协议ID”注册表中，为HTTP/2输入了识别字符串。

本文档建立了一个关于帧类型、设置和错误码的注册表。这些新注册表出现在“超文本传输协议第2版（HTTP/2）参数”部分。

此外，本文档注册了HTTP/2的设置头字段（HTTP2-Settings）用于HTTP中，并注册了状态码421（请求误导）。

本文档还注册了“PRI”方法，用于HTTP，以避免与连接预热（第3.5节）发生冲突。

11.1. HTTP/2识别字符串的注册

本文档在[TLS-ALPN]中建立的“应用层协议协商（ALPN）协议ID”注册表中，为识别HTTP/2（见第3.3节）创建了两个注册。

“h2”字符串用于在TLS上识别HTTP/2：

- 协议：TLS上的HTTP/2

- 识别序列：0x68 0x32（“h2”）

- 规范：本文件

“h2c”字符串用于在明文TCP上识别HTTP/2：

- 协议：TCP上的HTTP/2

- 识别序列：0x68 0x32 0x63（“h2c”）

- 规范：本文件

11.2. 帧类型注册表

本文档建立了HTTP/2帧类型码的注册表。“HTTP/2帧类型”注册表管理一个8位空间。该注册表在值范围0x00到0xef之间采用“IETF审查”或“IESG批准”政策[RFC5226]，而0xf0到0xff的值为实验用途保留。

新增条目需提供以下信息：

- 帧类型：帧类型的名称或标签。

- 代码：分配给该帧类型的8位代码。

- 规范：包含帧布局、语义、使用的标志以及根据标志值可能条件性出现部分的描述的规范参考。

以下表格中的条目由本文件注册。

| 帧类型        | 代码   | 节点        |
|--------------|--------|------------|
| DATA         | 0x0    | 第6.1节    |
| HEADERS      | 0x1    | 第6.2节    |
| PRIORITY     | 0x2    | 第6.3节    |
| RST_STREAM   | 0x3    | 第6.4节    |
| SETTINGS     | 0x4    | 第6.5节    |
| PUSH_PROMISE | 0x5    | 第6.6节    |
| PING         | 0x6    | 第6.7节    |
| GOAWAY       | 0x7    | 第6.8节    |
| WINDOW_UPDATE| 0x8    | 第6.9节    |
| CONTINUATION | 0x9    | 第6.10节   |

11.3. 设置注册表

本文档建立了HTTP/2设置的注册表。“HTTP/2设置”注册表管理一个16位空间。该注册表在“专家审查”政策[RFC5226]下，值范围为0x0000到0xefff，0xf000到0xffff的值为实验用途保留。

建议新注册项提供以下信息：

- 名称：设置的符号名。可选。

- 代码：分配给该设置的16位代码。

- 初始值：该设置的初始值。

- 规范：描述该设置用途的规范参考（可选）。

以下表格中的条目由本文件注册。

| 名称                     | 代码   | 初始值     | 规范             |
|--------------------------|--------|------------|------------------|
| HEADER_TABLE_SIZE        | 0x1    | 4096       | 第6.5.2节        |
| ENABLE_PUSH              | 0x2    | 1          | 第6.5.2节        |
| MAX_CONCURRENT_STREAMS   | 0x3    | 无限       | 第6.5.2节        |
| INITIAL_WINDOW_SIZE      | 0x4    | 65535      | 第6.5.2节        |
| MAX_FRAME_SIZE           | 0x5    | 16384      | 第6.5.2节        |
| MAX_HEADER_LIST_SIZE     | 0x6    | 无限       | 第6.5.2节        |

11.4. 错误码注册表

本文档建立了HTTP/2错误码的注册表。“HTTP/2错误码”注册表管理一个32位空间。该注册表在“专家审查”政策[RFC5226]下。

错误码注册需包含错误码的描述。建议专家审查员检查新注册项是否与现有错误码重复。鼓励使用已注册的错误码，但非强制。

新注册项建议提供以下信息：

- 名称：错误码的名称。可选。

- 代码：32位错误码值。

- 描述：简要说明错误码的语义，若无详细规范则可更长。

- 规范：定义该错误码的规范参考（可选）。

以下表格中的条目由本文件注册。

| 名称             | 代码   | 描述                     | 规范             |
|------------------|--------|--------------------------|------------------|
| NO_ERROR         | 0x0    | 正常关闭                 | 第7节            |
| PROTOCOL_ERROR   | 0x1    | 协议错误检测到           | 第7节            |
| INTERNAL_ERROR   | 0x2    | 实现故障                 | 第7节            |
| FLOW_CONTROL_ERROR| 0x3   | 流控限制超出             | 第7节            |
| SETTINGS_TIMEOUT | 0x4    | 设置未确认               | 第7节            |
| STREAM_CLOSED    | 0x5    | 收到已关闭流的帧         | 第7节            |
| FRAME_SIZE_ERROR | 0x6    | 帧大小不正确             | 第7节            |
| REFUSED_STREAM   | 0x7    | 流未处理                 | 第7节            |
| CANCEL           | 0x8    | 流取消                   | 第7节            |
| COMPRESSION_ERROR| 0x9    | 压缩状态未更新           | 第7节            |
| CONNECT_ERROR    | 0xa    | TCP连接错误（用于CONNECT）| 第7节            |
| ENHANCE_YOUR_CALM| 0xb    | 处理能力超出             | 第7节            |
| INADEQUATE_SECURITY| 0xc  | 协商的TLS参数不可接受    | 第7节            |
| HTTP_1_1_REQUIRED| 0xd    | 需使用HTTP/1.1请求       | 第7节            |

11.5. HTTP2-Settings头字段注册

本节在“永久消息头字段名”注册表[BCP90]中注册HTTP2-Settings头字段。

- 头字段名：HTTP2-Settings

- 适用协议：http

- 状态：标准

- 作者/变更控制：IETF

- 规范文档：本文件第3.2.1节

- 相关信息：该头字段仅由HTTP/2客户端用于基于升级的协商。

11.6. PRI方法注册

本节在“HTTP方法注册表”([RFC7231], 第8.1节)中注册“PRI”方法。

- 方法名：PRI

- 安全：是

- 幂等：是

- 规范文档：本文件第3.5节

- 相关信息：该方法从未被实际客户端使用。当HTTP/1.1服务器或中间件试图解析HTTP/2连接预热时，会表现出该方法。

11.7. 421（请求误导）HTTP状态码

本文件在“HTTP状态码”注册表([RFC7231], 第8.2节)中注册状态码421。

- 状态码：421

- 简短描述：请求误导

- 规范：本文件第9.1.2节

11.8. h2c升级令牌

本文件在“HTTP升级令牌”注册表([RFC7230], 第8.6节)中注册“h2c”升级令牌。

- 值：h2c

- 描述：超文本传输协议第2版（HTTP/2）

- 预期版本令牌：无

- 参考：本文件第3.2节

12. 参考文献

12.1. 标准引用

[COMPRESSION] Peon, R. 和 H. Ruellan，“HPACK：HTTP/2的头部压缩”，RFC 7541，DOI 10.17487/RFC7541，2015年5月，<http://www.rfc-editor.org/info/rfc7541>。

[COOKIE] Barth, A.，“HTTP状态管理机制”，RFC 6265，DOI 10.17487/RFC6265，2011年4月，<http://www.rfc-editor.org/info/rfc6265>。

[FIPS186] NIST，“数字签名标准（DSS）”，FIPS PUB 186-4，2013年7月，<http://dx.doi.org/10.6028/NIST.FIPS.186-4>。

[RFC2119] Bradner, S.，“RFC中用以指示需求级别的关键词”，BCP 14，RFC 2119，DOI 10.17487/RFC2119，1997年3月，<http://www.rfc-editor.org/info/rfc2119>。

[RFC2818] Rescorla, E.，“基于TLS的HTTP”，RFC 2818，DOI 10.17487/RFC2818，2000年5月，<http://www.rfc-editor.org/info/rfc2818>。

[RFC3986] Berners-Lee, T.、Fielding, R. 和 L. Masinter，“统一资源标识符（URI）：通用语法”，STD 66，RFC 3986，DOI 10.17487/RFC3986，2005年1月，<http://www.rfc-editor.org/info/rfc3986>。

[RFC4648] Josefsson, S.，“Base16、Base32和Base64数据编码”，RFC 4648，DOI 10.17487/RFC4648，2006年10月，<http://www.rfc-editor.org/info/rfc4648>。

[RFC5226] Narten, T. 和 H. Alvestrand，“IANA考虑事项的编写指南”，BCP 26，RFC 5226，DOI 10.17487/RFC5226，2008年5月，<http://www.rfc-editor.org/info/rfc5226>。

[RFC5234] Crocker, D.（主编）和 P. Overell，“语法规范的增强BNF：ABNF”，STD 68，RFC 5234，DOI 10.17487/RFC5234，2008年1月，<http://www.rfc-editor.org/info/rfc5234>。

[RFC7230] Fielding, R.（主编）和 J. Reschke（主编），“超文本传输协议（HTTP/1.1）：消息语法和路由”，RFC 7230，DOI 10.17487/RFC7230，2014年6月，<http://www.rfc-editor.org/info/rfc7230>。

[RFC7231] Fielding, R.（主编）和 J. Reschke（主编），“超文本传输协议（HTTP/1.1）：语义和内容”，RFC 7231，DOI 10.17487/RFC7231，2014年6月，<http://www.rfc-editor.org/info/rfc7231>。

[RFC7232] Fielding, R.（主编）和 J. Reschke（主编），“超文本传输协议（HTTP/1.1）：条件请求”，RFC 7232，DOI 10.17487/RFC7232，2014年6月，<http://www.rfc-editor.org/info/rfc7232>。

[RFC7233] Fielding, R.（主编）、Lafon, Y.（主编）和 J. Reschke（主编），“超文本传输协议（HTTP/1.1）：范围请求”，RFC 7233，DOI 10.17487/RFC7233，2014年6月，<http://www.rfc-editor.org/info/rfc7233>。

[RFC7234] Fielding, R.（主编）、Nottingham, M.（主编）和 J. Reschke（主编），“超文本传输协议（HTTP/1.1）：缓存”，RFC 7234，DOI 10.17487/RFC7234，2014年6月，<http://www.rfc-editor.org/info/rfc7234>。

[RFC7235] Fielding, R.（主编）和 J. Reschke（主编），“超文本传输协议（HTTP/1.1）：认证”，RFC 7235，DOI 10.17487/RFC7235，2014年6月，<http://www.rfc-editor.org/info/rfc7235>。

[TCP] Postel, J.，“传输控制协议”，STD 7，RFC 793，DOI 10.17487/RFC0793，1981年9月，<http://www.rfc-editor.org/info/rfc793>。

[TLS-ALPN] Friedl, S.、Popov, A.、Langley, A. 和 E. Stephan，“传输层安全（TLS）应用层协议协商扩展”，RFC 7301，DOI 10.17487/RFC7301，2014年7月，<http://www.rfc-editor.org/info/rfc7301>。

[TLS-ECDHE] Rescorla, E.，“TLS椭圆曲线密码套件（ECC）与SHA-256/384及AES Galois计数器模式（GCM）”，RFC 5289，DOI 10.17487/RFC5289，2008年8月，<http://www.rfc-editor.org/info/rfc5289>。

[TLS-EXT] Eastlake 3rd, D.，“传输层安全（TLS）扩展：扩展定义”，RFC 6066，DOI 10.17487/RFC6066，2011年1月，<http://www.rfc-editor.org/info/rfc6066>。

[RFC5246] Dierks, T. 和 E. Rescorla，“传输层安全（TLS）协议版本1.2”，RFC 5246，DOI 10.17487/RFC5246，2008年8月，<http://www.rfc-editor.org/info/rfc5246>。

12.2. 说明性参考

[ALT-SVC] Nottingham, M.、McManus, P. 和 J. Reschke，“HTTP备用服务”，工作进展中，draft-ietf-httpbis-alt-svc-06，2015年2月。

[BCP90] Klyne, G.、Nottingham, M. 和 J. Mogul，“消息头字段的注册程序”，BCP 90，RFC 3864，2004年9月，<http://www.rfc-editor.org/info/bcp90>。

[BREACH] Gluck, Y.、Harris, N. 和 A. Prado，“BREACH：复兴CRIME攻击”，2013年7月，<http://breachattack.com/resources/BREACH%20-%20SSL,%20gone%20in%2030%20seconds.pdf>。

[HTML5] Hickson, I.、Berjon, R.、Faulkner, S.、Leithead, T.、Doyle Navara, E.、O'Connor, E. 和 S. Pfeiffer，“HTML5”，W3C推荐标准REC-html5-20141028，2014年10月，<http://www.w3.org/TR/2014/REC-html5-20141028/>。

[RFC3749] Hollenbeck, S.，“传输层安全协议压缩方法”，RFC 3749，DOI 10.17487/RFC3749，2004年5月，<http://www.rfc-editor.org/info/rfc3749>。

[RFC4492] Blake-Wilson, S.、Bolyard, N.、Gupta, V.、Hawk, C. 和 B. Moeller，“用于传输层安全（TLS）的椭圆曲线密码套件（ECC）”，RFC 4492，DOI 10.17487/RFC4492，2006年5月，<http://www.rfc-editor.org/info/rfc4492>。

[RFC6585] Nottingham, M. 和 R. Fielding，“额外的HTTP状态码”，RFC 6585，DOI 10.17487/RFC6585，2012年4月，<http://www.rfc-editor.org/info/rfc6585>。

[RFC7323] Borman, D.、Braden, B.、Jacobson, V. 和 R. Scheffenegger（主编），“高性能TCP扩展”，RFC 7323，DOI 10.17487/RFC7323，2014年9月，<http://www.rfc-editor.org/info/rfc7323>。

[TALKING] Huang, L.、Chen, E.、Barth, A.、Rescorla, E. 和 C. Jackson，“为了娱乐和盈利而自言自语”，2011年，<http://w2spconf.com/2011/papers/websocket.pdf>。

[TLSBCP] Sheffer, Y.、Holz, R. 和 P. Saint-Andre，“安全使用传输层安全（TLS）和数据报传输层安全（DTLS）的建议”，BCP 195，RFC 7525，DOI 10.17487/RFC7525，2015年5月，<http://www.rfc-editor.org/info/rfc7525>。

（附录A：TLS 1.2密码套件黑名单）

HTTP/2实现可以将与TLS 1.2协商的以下密码套件视为连接错误（第5.4.1节）中的“不充分安全”类型：

- TLS_NULL_WITH_NULL_NULL

- TLS_RSA_WITH_NULL_MD5

- TLS_RSA_WITH_NULL_SHA

- TLS_RSA_EXPORT_WITH_RC4_40_MD5

- TLS_RSA_WITH_RC4_128_MD5

- TLS_RSA_WITH_RC4_128_SHA

- TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5

- TLS_RSA_WITH_IDEA_CBC_SHA

- TLS_RSA_EXPORT_WITH_DES40_CBC_SHA

- TLS_RSA_WITH_DES_CBC_SHA

- TLS_RSA_WITH_3DES_EDE_CBC_SHA

- TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA

- TLS_DH_DSS_WITH_DES_CBC_SHA

- TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA

- TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA

- TLS_DH_RSA_WITH_DES_CBC_SHA

- TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA

- TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA

- TLS_DHE_DSS_WITH_DES_CBC_SHA

- TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA

- TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA

- TLS_DHE_RSA_WITH_DES_CBC_SHA

- TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA

- TLS_DH_anon_EXPORT_WITH_RC4_40_MD5

- TLS_DH_anon_WITH_RC4_128_MD5

- TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA

- TLS_DH_anon_WITH_DES_CBC_SHA

- TLS_DH_anon_WITH_3DES_EDE_CBC_SHA

- TLS_KRB5_WITH_DES_CBC_SHA

- TLS_KRB5_WITH_3DES_EDE_CBC_SHA

- TLS_KRB5_WITH_RC4_128_SHA

- TLS_KRB5_WITH_IDEA_CBC_SHA

- TLS_KRB5_WITH_DES_CBC_MD5

- TLS_KRB5_WITH_3DES_EDE_CBC_MD5

- TLS_KRB5_WITH_RC4_128_MD5

- TLS_KRB5_WITH_IDEA_CBC_MD5

- TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA

- TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA

- TLS_KRB5_EXPORT_WITH_RC4_40_SHA

- TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5

- TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5

以下是英文内容的中文翻译：

```
   o  TLS_KRB5_EXPORT_WITH_RC4_40_MD5（导出版KRB5与RC4_40的MD5哈希）

   o  TLS_PSK_WITH_NULL_SHA（预共享密钥与空SHA）

   o  TLS_DHE_PSK_WITH_NULL_SHA（Diffie-Hellman预共享密钥与空SHA）

   o  TLS_RSA_PSK_WITH_NULL_SHA（RSA预共享密钥与空SHA）




Belshe 等人               标准轨迹                   [第84页]


RFC 7540                         HTTP/2                         2015年5月


   o  TLS_RSA_WITH_AES_128_CBC_SHA（RSA与AES_128_CBC_SHA）

   o  TLS_DH_DSS_WITH_AES_128_CBC_SHA（DH_DSS与AES_128_CBC_SHA）

   o  TLS_DH_RSA_WITH_AES_128_CBC_SHA（DH_RSA与AES_128_CBC_SHA）

   o  TLS_DHE_DSS_WITH_AES_128_CBC_SHA（DHE_DSS与AES_128_CBC_SHA）

   o  TLS_DHE_RSA_WITH_AES_128_CBC_SHA（DHE_RSA与AES_128_CBC_SHA）

   o  TLS_DH_anon_WITH_AES_128_CBC_SHA（匿名DH与AES_128_CBC_SHA）

   o  TLS_RSA_WITH_AES_256_CBC_SHA（RSA与AES_256_CBC_SHA）

   o  TLS_DH_DSS_WITH_AES_256_CBC_SHA（DH_DSS与AES_256_CBC_SHA）

   o  TLS_DH_RSA_WITH_AES_256_CBC_SHA（DH_RSA与AES_256_CBC_SHA）

   o  TLS_DHE_DSS_WITH_AES_256_CBC_SHA（DHE_DSS与AES_256_CBC_SHA）

   o  TLS_DHE_RSA_WITH_AES_256_CBC_SHA（DHE_RSA与AES_256_CBC_SHA）

   o  TLS_DH_anon_WITH_AES_256_CBC_SHA（匿名DH与AES_256_CBC_SHA）

   o  TLS_RSA_WITH_NULL_SHA256（RSA与空SHA256）

   o  TLS_RSA_WITH_AES_128_CBC_SHA256（RSA与AES_128_CBC_SHA256）

   o  TLS_RSA_WITH_AES_256_CBC_SHA256（RSA与AES_256_CBC_SHA256）

   o  TLS_DH_DSS_WITH_AES_128_CBC_SHA256（DH_DSS与AES_128_CBC_SHA256）

   o  TLS_DH_RSA_WITH_AES_128_CBC_SHA256（DH_RSA与AES_128_CBC_SHA256）

   o  TLS_DHE_DSS_WITH_AES_128_CBC_SHA256（DHE_DSS与AES_128_CBC_SHA256）

   o  TLS_RSA_WITH_CAMELLIA_128_CBC_SHA（RSA与卡梅利亚_128_CBC_SHA）

   o  TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA（DH_DSS与卡梅利亚_128_CBC_SHA）

   o  TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA（DH_RSA与卡梅利亚_128_CBC_SHA）

   o  TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA（DHE_DSS与卡梅利亚_128_CBC_SHA）

   o  TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA（DHE_RSA与卡梅利亚_128_CBC_SHA）

   o  TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA（匿名DH与卡梅利亚_128_CBC_SHA）




Belshe 等人               标准轨迹                   [第85页]


RFC 7540                         HTTP/2                         2015年5月


   o  TLS_DHE_RSA_WITH_AES_128_CBC_SHA256（DHE_RSA与AES_128_CBC_SHA256）

   o  TLS_DH_DSS_WITH_AES_256_CBC_SHA256（DH_DSS与AES_256_CBC_SHA256）

   o  TLS_DH_RSA_WITH_AES_256_CBC_SHA256（DH_RSA与AES_256_CBC_SHA256）

   o  TLS_DHE_DSS_WITH_AES_256_CBC_SHA256（DHE_DSS与AES_256_CBC_SHA256）

   o  TLS_DHE_RSA_WITH_AES_256_CBC_SHA256（DHE_RSA与AES_256_CBC_SHA256）

   o  TLS_DH_anon_WITH_AES_128_CBC_SHA256（匿名DH与AES_128_CBC_SHA256）

   o  TLS_DH_anon_WITH_AES_256_CBC_SHA256（匿名DH与AES_256_CBC_SHA256）

   o  TLS_RSA_WITH_CAMELLIA_256_CBC_SHA（RSA与卡梅利亚_256_CBC_SHA）

   o  TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA（DH_DSS与卡梅利亚_256_CBC_SHA）

   o  TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA（DH_RSA与卡梅利亚_256_CBC_SHA）

   o  TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA（DHE_DSS与卡梅利亚_256_CBC_SHA）

   o  TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA（DHE_RSA与卡梅利亚_256_CBC_SHA）

   o  TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA（匿名DH与卡梅利亚_256_CBC_SHA）

   o  TLS_PSK_WITH_RC4_128_SHA（预共享密钥与RC4_128_SHA）

   o  TLS_PSK_WITH_3DES_EDE_CBC_SHA（预共享密钥与3DES_EDE_CBC_SHA）

   o  TLS_PSK_WITH_AES_128_CBC_SHA（预共享密钥与AES_128_CBC_SHA）

   o  TLS_PSK_WITH_AES_256_CBC_SHA（预共享密钥与AES_256_CBC_SHA）

   o  TLS_DHE_PSK_WITH_RC4_128_SHA（DHE预共享密钥与RC4_128_SHA）

   o  TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA（DHE预共享密钥与3DES_EDE_CBC_SHA）

   o  TLS_DHE_PSK_WITH_AES_128_CBC_SHA（DHE预共享密钥与AES_128_CBC_SHA）

   o  TLS_DHE_PSK_WITH_AES_256_CBC_SHA（DHE预共享密钥与AES_256_CBC_SHA）

   o  TLS_RSA_PSK_WITH_RC4_128_SHA（RSA预共享密钥与RC4_128_SHA）

   o  TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA（RSA预共享密钥与3DES_EDE_CBC_SHA）

   o  TLS_RSA_PSK_WITH_AES_128_CBC_SHA（RSA预共享密钥与AES_128_CBC_SHA）




Belshe 等人               标准轨迹                   [第86页]


RFC 7540                         HTTP/2                         2015年5月


   o  TLS_RSA_PSK_WITH_AES_256_CBC_SHA（RSA预共享密钥与AES_256_CBC_SHA）

   o  TLS_RSA_WITH_SEED_CBC_SHA（RSA与SEED_CBC_SHA）

   o  TLS_DH_DSS_WITH_SEED_CBC_SHA（DH_DSS与SEED_CBC_SHA）

   o  TLS_DH_RSA_WITH_SEED_CBC_SHA（DH_RSA与SEED_CBC_SHA）

   o  TLS_DHE_DSS_WITH_SEED_CBC_SHA（DHE_DSS与SEED_CBC_SHA）

   o  TLS_DHE_RSA_WITH_SEED_CBC_SHA（DHE_RSA与SEED_CBC_SHA）

   o  TLS_DH_anon_WITH_SEED_CBC_SHA（匿名DH与SEED_CBC_SHA）

   o  TLS_RSA_WITH_AES_128_GCM_SHA256（RSA与AES_128_GCM_SHA256）

   o  TLS_RSA_WITH_AES_256_GCM_SHA384（RSA与AES_256_GCM_SHA384）

   o  TLS_DH_RSA_WITH_AES_128_GCM_SHA256（DH_RSA与AES_128_GCM_SHA256）

   o  TLS_DH_RSA_WITH_AES_256_GCM_SHA384（DH_RSA与AES_256_GCM_SHA384）

   o  TLS_DH_DSS_WITH_AES_128_GCM_SHA256（DH_DSS与AES_128_GCM_SHA256）

   o  TLS_DH_DSS_WITH_AES_256_GCM_SHA384（DH_DSS与AES_256_GCM_SHA384）

   o  TLS_DH_anon_WITH_AES_128_GCM_SHA256（匿名DH与AES_128_GCM_SHA256）

   o  TLS_DH_anon_WITH_AES_256_GCM_SHA384（匿名DH与AES_256_GCM_SHA384）

   o  TLS_PSK_WITH_AES_128_GCM_SHA256（预共享密钥与AES_128_GCM_SHA256）

   o  TLS_PSK_WITH_AES_256_GCM_SHA384（预共享密钥与AES_256_GCM_SHA384）

   o  TLS_RSA_PSK_WITH_AES_128_GCM_SHA256（RSA预共享密钥与AES_128_GCM_SHA256）

   o  TLS_RSA_PSK_WITH_AES_256_GCM_SHA384（RSA预共享密钥与AES_256_GCM_SHA384）

   o  TLS_PSK_WITH_AES_128_CBC_SHA256（预共享密钥与AES_128_CBC_SHA256）

   o  TLS_PSK_WITH_AES_256_CBC_SHA384（预共享密钥与AES_256_CBC_SHA384）

   o  TLS_PSK_WITH_NULL_SHA256（预共享密钥与空SHA256）

   o  TLS_PSK_WITH_NULL_SHA384（预共享密钥与空SHA384）

   o  TLS_DHE_PSK_WITH_AES_128_CBC_SHA256（DHE预共享密钥与AES_128_CBC_SHA256）




Belshe 等人               标准轨迹                   [第87页]


RFC 7540                         HTTP/2                         2015年5月


   o  TLS_DHE_PSK_WITH_AES_256_CBC_SHA384（DHE预共享密钥与AES_256_CBC_SHA384）

   o  TLS_DHE_PSK_WITH_NULL_SHA256（DHE预共享密钥与空SHA256）

   o  TLS_DHE_PSK_WITH_NULL_SHA384（DHE预共享密钥与空SHA384）

   o  TLS_RSA_PSK_WITH_AES_128_CBC_SHA256（RSA预共享密钥与AES_128_CBC_SHA256）

   o  TLS_RSA_PSK_WITH_AES_256_CBC_SHA384（RSA预共享密钥与AES_256_CBC_SHA384）

   o  TLS_RSA_PSK_WITH_NULL_SHA256（RSA预共享密钥与空SHA256）

   o  TLS_RSA_PSK_WITH_NULL_SHA384（RSA预共享密钥与空SHA384）

   o  TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256（RSA与卡梅利亚_128_CBC_SHA256）

   o  TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256（DH_DSS与卡梅利亚_128_CBC_SHA256）

   o  TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256（DH_RSA与卡梅利亚_128_CBC_SHA256）

   o  TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256（DHE_DSS与卡梅利亚_128_CBC_SHA256）

   o  TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256（DHE_RSA与卡梅利亚_128_CBC_SHA256）

   o  TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256（匿名DH与卡梅利亚_128_CBC_SHA256）

   o  TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256（RSA与卡梅利亚_256_CBC_SHA256）

   o  TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256（DH_DSS与卡梅利亚_256_CBC_SHA256）

   o  TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256（DH_RSA与卡梅利亚_256_CBC_SHA256）

   o  TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256（DHE_DSS与卡梅利亚_256_CBC_SHA256）

   o  TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256（DHE_RSA与卡梅利亚_256_CBC_SHA256）

   o  TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256（匿名DH与卡梅利亚_256_CBC_SHA256）

   o  TLS_EMPTY_RENEGOTIATION_INFO_SCSV（空重协商信息）

   o  TLS_ECDH_ECDSA_WITH_NULL_SHA（ECDH_ECDSA与空SHA）

   o  TLS_ECDH_ECDSA_WITH_RC4_128_SHA（ECDH_ECDSA与RC4_128_SHA）

   o  TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA（ECDH_ECDSA与3DES_EDE_CBC_SHA）

   o  TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA（ECDH_ECDSA与AES_128_CBC_SHA）




Belshe 等人               标准轨迹                   [第88页]


RFC 7540                         HTTP/2                         2015年5月


   o  TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA（ECDH_ECDSA与AES_256_CBC_SHA）

   o  TLS_ECDHE_ECDSA_WITH_NULL_SHA（ECDHE_ECDSA与空SHA）

   o  TLS_ECDHE_ECDSA_WITH_RC4_128_SHA（ECDHE_ECDSA与RC4_128_SHA）

   o  TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA（ECDHE_ECDSA与3DES_EDE_CBC_SHA）

   o  TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA（ECDHE_ECDSA与AES_128_CBC_SHA）

   o  TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA（ECDHE_ECDSA与AES_256_CBC_SHA）

   o  TLS_ECDH_RSA_WITH_NULL_SHA（ECDH_RSA与空SHA）

   o  TLS_ECDH_RSA_WITH_RC4_128_SHA（ECDH_RSA与RC4_128_SHA）

   o  TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA（ECDH_RSA与3DES_EDE_CBC_SHA）

   o  TLS_ECDH_RSA_WITH_AES_128_CBC_SHA（ECDH_RSA与AES_128_CBC_SHA）

   o  TLS_ECDH_RSA_WITH_AES_256_CBC_SHA（ECDH_RSA与AES_256_CBC_SHA）

   o  TLS_ECDHE_RSA_WITH_NULL_SHA（ECDHE_RSA与空SHA）

   o  TLS_ECDHE_RSA_WITH_RC4_128_SHA（ECDHE_RSA与RC4_128_SHA）

   o  TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA（ECDHE_RSA与3DES_EDE_CBC_SHA）

   o  TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA（ECDHE_RSA与AES_128_CBC_SHA）

   o  TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA（ECDHE_RSA与AES_256_CBC_SHA）

   o  TLS_ECDH_anon_WITH_NULL_SHA（匿名ECDH与空SHA）

   o  TLS_ECDH_anon_WITH_RC4_128_SHA（匿名ECDH与RC4_128_SHA）

   o  TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA（匿名ECDH与3DES_EDE_CBC_SHA）

   o  TLS_ECDH_anon_WITH_AES_128_CBC_SHA（匿名ECDH与AES_128_CBC_SHA）

   o  TLS_ECDH_anon_WITH_AES_256_CBC_SHA（匿名ECDH与AES_256_CBC_SHA）

   o  TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA（SRP_SHA与3DES_EDE_CBC_SHA）

   o  TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA（SRP_SHA_RSA与3DES_EDE_CBC_SHA）

   o  TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA（SRP_SHA_DSS与3DES_EDE_CBC_SHA）




Belshe 等人               标准轨迹                   [第89页]


RFC 7540                         HTTP/2                         2015年5月


   o  TLS_SRP_SHA_WITH_AES_128_CBC_SHA（SRP_SHA与AES_128_CBC_SHA）

   o  TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA（SRP_SHA_RSA与AES_128_CBC_SHA）

   o  TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA（SRP_SHA_DSS与AES_128_CBC_SHA）

   o  TLS_SRP_SHA_WITH_AES_256_CBC_SHA（SRP_SHA与AES_256_CBC_SHA）

   o  TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA（SRP_SHA_RSA与AES_256_CBC_SHA）

   o  TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA（SRP_SHA_DSS与AES_256_CBC_SHA）

   o  TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256（ECDHE_ECDSA与AES_128_CBC_SHA256）

   o  TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384（ECDHE_ECDSA与AES_256_CBC_SHA384）

   o  TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256（ECDH_ECDSA与AES_128_CBC_SHA256）

   o  TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384（ECDH_ECDSA与AES_256_CBC_SHA384）

   o  TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256（ECDHE_RSA与AES_128_CBC_SHA256）

   o  TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384（ECDHE_RSA与AES_256_CBC_SHA384）

   o  TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256（ECDH_RSA与AES_128_CBC_SHA256）

   o  TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384（ECDH_RSA与AES_256_CBC_SHA384）

   o  TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256（ECDH_ECDSA与AES_128_GCM_SHA256）

   o  TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384（ECDH_ECDSA与AES_256_GCM_SHA384）

   o  TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256（ECDH_RSA与AES_128_GCM_SHA256）

   o  TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384（ECDH_RSA与AES_256_GCM_SHA384）

   o  TLS_ECDHE_PSK_WITH_RC4_128_SHA（ECDHE预共享密钥与RC4_128_SHA）

   o  TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA（ECDHE预共享密钥与3DES_EDE_CBC_SHA）

   o  TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA（ECDHE预共享密钥与AES_128_CBC_SHA）

   o  TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA（ECDHE预共享密钥与AES_256_CBC_SHA）

   o  TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256（ECDHE预共享密钥与AES_128_CBC_SHA256）

   o  TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384（ECDHE预共享密钥与AES_256_CBC_SHA384）




Belshe 等人               标准轨迹                   [第90页]


RFC 7540                         HTTP/2                         2015年5月


   o  TLS_ECDHE_PSK_WITH_NULL_SHA（ECDHE预共享密钥与空SHA）

   o  TLS_ECDHE_PSK_WITH_NULL_SHA256（ECDHE预共享密钥与空SHA256）

   o  TLS_ECDHE_PSK_WITH_NULL_SHA384（ECDHE预共享密钥与空SHA384）

   o  TLS_RSA_WITH_ARIA_128_CBC_SHA256（RSA与ARIA_128_CBC_SHA256）

   o  TLS_RSA_WITH_ARIA_256_CBC_SHA384（RSA与ARIA_256_CBC_SHA384）

   o  TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256（DH_DSS与ARIA_128_CBC_SHA256）

   o  TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384（DH_DSS与ARIA_256_CBC_SHA384）

   o  TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256（DH_RSA与ARIA_128_CBC_SHA256）

   o  TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384（DH_RSA与ARIA_256_CBC_SHA384）

   o  TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256（DHE_DSS与ARIA_128_CBC_SHA256）

   o  TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384（DHE_DSS与ARIA_256_CBC_SHA384）

   o  TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256（DHE_RSA与ARIA_128_CBC_SHA256）

   o  TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384（DHE_RSA与ARIA_256_CBC_SHA384）

   o  TLS_DH_anon_WITH_ARIA_128_CBC_SHA256（匿名DH与ARIA_128_CBC_SHA256）

   o  TLS_DH_anon_WITH_ARIA_256_CBC_SHA384（匿名DH与ARIA_256_CBC_SHA384）

   o  TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256（ECDHE_ECDSA与ARIA_128_CBC_SHA256）

   o  TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384（ECDHE_ECDSA与ARIA_256_CBC_SHA384）

   o  TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256（ECDH_ECDSA与ARIA_128_CBC_SHA256）

   o  TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384（ECDH_ECDSA与ARIA_256_CBC_SHA384）

   o  TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256（ECDHE_RSA与ARIA_128_CBC_SHA256）

   o  TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384（ECDHE_RSA与ARIA_256_CBC_SHA384）

   o  TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256（ECDH_RSA与ARIA_128_CBC_SHA256）

   o  TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384（ECDH_RSA与ARIA_256_CBC_SHA384）

   o  TLS_PSK_WITH_ARIA_128_CBC_SHA256（预共享密钥与ARIA_128_CBC_SHA256）

   o  TLS_PSK_WITH_ARIA_256_CBC_SHA384（预共享密钥与ARIA_256_CBC_SHA384）

   o  TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256（DHE预共享密钥与ARIA_128_CBC_SHA256）

   o  TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384（DHE预共享密钥与ARIA_256_CBC_SHA384）

   o  TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256（RSA预共享密钥与ARIA_128_CBC_SHA256）

   o  TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384（RSA预共享密钥与ARIA_256_CBC_SHA384）

   o  TLS_PSK_WITH_ARIA_128_GCM_SHA256（预共享密钥与ARIA_128_GCM_SHA256）

   o  TLS_PSK_WITH_ARIA_256_GCM_SHA384（预共享密钥与ARIA_256_GCM_SHA384）

   o  TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256（RSA预共享密钥与ARIA_128_GCM_SHA256）

   o  TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384（RSA预共享密钥与ARIA_256_GCM_SHA384）

   o  TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256（ECDHE预共享密钥与ARIA_128_CBC_SHA256）

   o  TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384（ECDHE预共享密钥与ARIA_256_CBC_SHA384）

   o  TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256（ECDHE_ECDSA与卡梅利亚_128_CBC_SHA256）




Belshe 等人               标准轨迹                   [第91页]


RFC 7540                         HTTP/2                         2015年5月


   o  TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384（ECDHE_ECDSA与卡梅利亚_256_CBC_SHA384）

   o  TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256（ECDH_ECDSA与卡梅利亚_128_CBC_SHA256）

   o  TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384（ECDH_ECDSA与卡梅利亚_256_CBC_SHA384）

   o  TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256（ECDHE_RSA与卡梅利亚_128_CBC_SHA256）

   o  TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384（ECDHE_RSA与卡梅利亚_256_CBC_SHA384）

   o  TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256（ECDH_RSA与卡梅利亚_128_CBC_SHA256）

   o  TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384（ECDH_RSA与卡梅利亚_256_CBC_SHA384）

   o  TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256（RSA与卡梅利亚_128_GCM_SHA256）

   o  TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384（RSA与卡梅利亚_256_GCM_SHA384）

   o  TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256（DH_RSA与卡梅利亚_128_GCM_SHA256）

   o  TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384（DH_RSA与卡梅利亚_256_GCM_SHA384）

   o  TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256（DH_DSS与卡梅利亚_128_GCM_SHA256）

   o  TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384（DH_DSS与卡梅利亚_256_GCM_SHA384）

   o  TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256（匿名DH与卡梅利亚_128_GCM_SHA256）

   o  TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384（匿名DH与卡梅利亚_256_GCM_SHA384）

   o  TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256（ECDH_ECDSA与卡梅利亚_128_GCM_SHA256）

   o  TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384（ECDH_ECDSA与卡梅利亚_256_GCM_SHA384）

   o  TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256（ECDH_RSA与卡梅利亚_128_GCM_SHA256）

   o  TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384（ECDH_RSA与卡梅利亚_256_GCM_SHA384）

   o  TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256（预共享密钥与卡梅利亚_128_GCM_SHA256）

   o  TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384（预共享密钥与卡梅利亚_256_GCM_SHA384）

   o  TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256（RSA预共享密钥与卡梅利亚_128_GCM_SHA256）

   o  TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384（RSA预共享密钥与卡梅利亚_256_GCM_SHA384）

   o  TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256（预共享密钥与卡梅利亚_128_CBC_SHA256）




Belshe 等人               标准轨迹                   [第92页]


RFC 7540                         HTTP/2                         2015年5月


   o  TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384（预共享密钥与卡梅利亚_256_CBC_SHA384）

   o  TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256（DHE预共享密钥与卡梅利亚_128_CBC_SHA256）

   o  TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384（DHE预共享密钥与卡梅利亚_256_CBC_SHA384）

   o  TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256（RSA预共享密钥与卡梅利亚_128_CBC_SHA256）

   o  TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384（RSA预共享密钥与卡梅利亚_256_CBC_SHA384）

   o  TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256（ECDHE预共享密钥与卡梅利亚_128_CBC_SHA256）

   o  TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384（ECDHE预共享密钥与卡梅利亚_256_CBC_SHA384）

   o  TLS_RSA_WITH_AES_128_CCM（RSA与AES_128_CCM）

   o  TLS_RSA_WITH_AES_256_CCM（RSA与AES_256_CCM）

   o  TLS_RSA_WITH_AES_128_CCM_8（RSA与AES_128_CCM_8）

   o  TLS_RSA_WITH_AES_256_CCM_8（RSA与AES_256_CCM_8）

   o  TLS_PSK_WITH_AES_128_CCM（预共享密钥与AES_128_CCM）

   o  TLS_PSK_WITH_AES_256_CCM（预共享密钥与AES_256_CCM）

   o  TLS_PSK_WITH_AES_128_CCM_8（预共享密钥与AES_128_CCM_8）

   o  TLS_PSK_WITH_AES_256_CCM_8（预共享密钥与AES_256_CCM_8）

      注：此列表由撰写时注册的TLS密码套件集合整理而成。包括那些不提供临时密钥交换的密码套件，以及基于TLS空密码、流密码或块密码类型（如[TLS12]第6.2.3节所定义）的密码套件。还可以定义具有这些特性的其他密码套件；这些不会被明确禁止。












Belshe 等人               标准轨迹                   [第94页]


致谢

   本文档得到了以下人员的大量贡献：

   o  Adam Langley、Wan-Teh Chang、Jim Morrison、Mark Nottingham、Alyssa Wilk、Costin Manolache、William Chan、Vitaliy Lvin、Joe Chan、Adam Barth、Ryan Hamilton、Gavin Peters、Kent Alstad、Kevin Lindsay、Paul Amer、Fan Yang 和 Jonathan Leighton（SPDY贡献者）。

   o  Gabriel Montenegro 和 Willy Tarreau（升级机制）。

   o  William Chan、Salvatore Loreto、Osama Mazahir、Gabriel Montenegro、Jitu Padhye、Roberto Peon 和 Rob Trace（流量控制）。

   o  Mike Bishop（扩展性）。

   o  Mark Nottingham、Julian Reschke、James Snell、Jeff Pinner、Mike Bishop 和 Herve Ruellan（大量编辑贡献）。

   o  Kari Hurtta、Tatsuhiro Tsujikawa、Greg Wilkins、Poul-Henning Kamp 和 Jonathan Thackray。

   o  2013年本文件的编辑之一，Alexey Melnikov。

   Martin的大部分贡献得到了微软在其任职期间的支持。

   日本HTTP/2社区也做出了宝贵的贡献，包括多个实现以及大量的技术和编辑工作。




















Belshe 等人               标准轨迹                   [第95页]


作者联系方式

   Mike Belshe
   BitGo

   电子邮箱：mike@belshe.com


   Roberto Peon
   Google公司

   电子邮箱：fenix@google.com


   Martin Thomson（编辑）
   Mozilla
   331 E Evelyn Street
   Mountain View, CA  94041
   美国

   电子邮箱：martin.thomson@gmail.com






























Belshe 等人               标准轨迹                   [第96页]
```