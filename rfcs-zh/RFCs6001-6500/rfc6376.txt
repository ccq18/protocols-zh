# RFC 6376 中文翻译 (stub)
# 原文文件: ../../rfcs/RFCs6001-6500/rfc6376.txt

互联网工程任务组（IETF）                     D. Crocker，主编
征求意见稿：6376                        布兰登堡互联网工作组
废止：4871、5672                                    T. Hansen，主编
类别：标准轨道                                    美国电话电话公司实验室
ISSN：2070-1721                                       M. Kucherawy，主编
                                                          Cloudmark
                                                    2011年9月

              域名密钥识别邮件（DKIM）签名

摘要

   域名密钥识别邮件（DKIM）允许拥有签名域的个人、角色或组织
   通过将域名与邮件关联，声称对该邮件承担一定责任。这可以是
   作者的组织、操作中继或其代理人之一。DKIM将签名者的身份问题
   与邮件的假定作者区分开来。责任的声明通过加密签名进行验证，
   并通过直接查询签名者的域名以获取相应的公钥来确认。邮件从
   作者到收件人的传输过程通常经过中继，这些中继通常不会对邮件
   内容进行实质性更改，从而保持了DKIM签名的有效性。

   本备忘录废止RFC 4871和RFC 5672。

本备忘录的状态

   这是一个互联网标准轨道的文档。

   本文档由互联网工程任务组（IETF）制定，代表IETF社区的共识。
   它经过公开审查，并已获得互联网工程指导组（IESG）批准发布。
   关于互联网标准的更多信息，请参见RFC 5741的第2节。

   有关本文件当前状态、任何勘误以及如何提供反馈的信息，
   可在 http://www.rfc-editor.org/info/rfc6376 获取。

版权声明

   版权所有（c）2011年IETF信托及被列为作者的个人。保留所有权利。

   本文件受BCP 78和IETF信托关于IETF文件的法律规定（
   http://trustee.ietf.org/license-info）约束，适用于本文件发布之日。
   请仔细阅读这些文件，因为它们描述了您对本文件的权利和限制。
   从本文件中提取的代码组件必须包括简化BSD许可证文本，
   如信托法律规定第4.e节所述，并且在没有担保的情况下提供，
   如简化BSD许可证所述。

   本文件可能包含在2008年11月10日之前发布或公开的IETF文件或
   IETF贡献的内容。这些内容的版权控制人可能未授予IETF信托
   允许在IETF标准流程之外修改此类内容的权利。在未获得
   控制这些内容的个人或实体的充分许可的情况下，本文件不得
   在IETF标准流程之外进行修改，也不得在IETF标准流程之外
   创建其衍生作品，除非是为了将其格式化为RFC或翻译成非英语
   语言。

目录

   1.  引言 . . . . . . . . . . . . . . . . . . . . . . . . .  4
     1.1.  DKIM架构文档  . . . . . . . . . . . . . . . . .  5
     1.2.  签名身份 . . . . . . . . . . . . . . . . . . . .  5
     1.3.  可扩展性  . . . . . . . . . . . . . . . . . . .  5
     1.4.  简单密钥管理  . . . . . . . . . . . . . . . . .  6
     1.5.  数据完整性 . . . . . . . . . . . . . . . . .  6
   2.  术语和定义  . . . . . . . . . . . . . . . . . . .  6
     2.1.  签名者  . . . . . . . . . . . . . . . . . . .  6
     2.2.  验证者  . . . . . . . . . . . . . . . . . .  7
     2.3.  身份  . . . . . . . . . . . . . . . . . .  7
     2.4.  标识符  . . . . . . . . . . . . . . . .  7
     2.5.  签名域标识符（SDID）  . . . . . . . . .  7
     2.6.  代理或用户标识符（AUID）  . . . . . .  7
     2.7.  身份评估者  . . . . . . . . . . . . . .  7
     2.8.  空白字符  . . . . . . . . . . . . . .  8
     2.9.  导入的ABNF标记  . . . . . . . . .  8
     2.10.  常用ABNF标记  . . . . . . . .  9
     2.11.  DKIM-Quoted-Printable  . . . . . .  9
   3.  协议元素  . . . . . . . . . . . . . . . . . 10
     3.1.  选择器  . . . . . . . . . . . . . . . 10
     3.2.  标签=值列表  . . . . . . . . . . 12
     3.3.  签名与验证算法  . . . . . . . . 13
     3.4.  规范化  . . . . . . . . . . . . . 14
     3.5.  DKIM签名头字段  . . . . . . . . 18

（以下内容省略）

3.6. 密钥管理与表示 .............................................. 26  
3.7. 计算消息哈希 .............................................. 29  
3.8. 输入要求 .................................................. 32  
3.9. 输出要求 .................................................. 32  
3.10. 父域签名 .................................................. 33  
3.11. SDID 与 AUID 之间的关系 .................................. 33  
4. 多重签名的语义 .............................................. 34  
4.1. 示例场景 .................................................. 34  
4.2. 解释 ...................................................... 35  
5. 签名者操作 .................................................. 36  
5.1. 确定是否应对邮件签名及由谁签名 ............................ 36  
5.2. 选择私钥及对应的选择器信息 ................................. 37  
5.3. 规范化消息以防止传输转换 .................................. 37  
5.4. 确定要签名的头字段 ........................................ 38  
5.5. 计算消息哈希与签名 ........................................ 43  
5.6. 插入 DKIM-Signature 头字段 .................................. 43  
6. 验证者操作 .................................................. 43  
6.1. 从消息中提取签名 .......................................... 44  
6.2. 通知验证结果 .............................................. 49  
6.3. 解释结果/应用本地策略 ...................................... 50  
7. IANA 考虑事项 .............................................. 51  
7.1. 邮件认证方法注册表 ........................................ 51  
7.2. DKIM-Signature 标签规范 .................................... 51  
7.3. DKIM-Signature 查询方法注册表 ............................... 52  
7.4. DKIM-Signature 规范化注册表 ................................ 52  
7.5. _domainkey DNS TXT 资源记录标签规范 .......................... 53  
7.6. DKIM 密钥类型注册表 ........................................ 53  
7.7. DKIM 哈希算法注册表 ........................................ 54  
7.8. DKIM 服务类型注册表 ........................................ 54  
7.9. DKIM 选择器标志注册表 ...................................... 55  
7.10. DKIM-Signature 头字段 ....................................... 55  
8. 安全注意事项 ................................................ 55  
8.1. ASCII 艺术攻击 ............................................ 55  
8.2. 误用正文长度限制（"l=" 标签） ............................ 55  
8.3. 私钥被盗用 ................................................ 56  
8.4. 密钥服务器拒绝服务攻击 .................................... 56  
8.5. 针对 DNS 的攻击 ........................................... 57  
8.6. 重放/垃圾邮件攻击 .......................................... 57  
8.7. 撤销密钥的限制 ............................................ 58  
8.8. 故意格式错误的密钥记录 .................................... 58  
8.9. 故意格式错误的 DKIM-Signature 头字段 ....................... 58  
8.10. 信息泄露 ................................................. 58  
8.11. 远程时间攻击 ............................................. 59  
8.12. 头字段重排序 ............................................. 59  
8.13. RSA 攻击 .................................................. 59  
8.14. 父域不当签名 ............................................. 59  
8.15. 涉及额外头字段的攻击 ..................................... 60  
9. 参考文献 .................................................... 61  
9.1. 标准性参考 ............................................... 61  
9.2. 资料性参考 ............................................... 62  
附录 A. 使用示例（资料性） .................................... 64  
A.1. 用户撰写邮件 ............................................. 64  
A.2. 邮件签名 ................................................. 65  
A.3. 邮件签名验证 ............................................. 66  
附录 B. 使用示例（资料性） .................................... 67  
B.1. 替代提交场景 ............................................. 67  
B.2. 替代投递场景 ............................................. 69  
附录 C. 创建公钥（资料性） .................................... 71  
C.1. 与 DomainKeys 密钥记录的兼容性 ............................ 72  
C.2. 与 RFC 4871 的兼容性 ..................................... 73  
附录 D. MUA 相关考虑（资料性） ................................ 73  
附录 E. 自 RFC 4871 以来的变更 ................................ 73  
附录 F. 致谢 .................................................... 75  

1. 引言

域名密钥识别邮件（DKIM）允许个人、角色或组织通过将其被授权使用的域名 [RFC1034] 与消息 [RFC5322] 相关联，从而声称对消息承担一定责任。责任声明通过加密签名验证，并通过查询签名者域名直接获取相应的公钥。消息从作者到收件人经过的中继通常不会对内容做实质性更改，从而保持 DKIM 签名的有效性。一个消息可以包含多个签名，来自相同或不同的组织。

DKIM 所采用的方法不同于之前的消息签名方案（如安全/多用途互联网邮件扩展（S/MIME） [RFC5751]，OpenPGP [RFC4880]），其特点包括：

- 签名作为消息头字段书写，避免签名相关内容出现在消息正文中导致人类用户或现有邮件客户端（MUA）混淆；
- 不依赖由知名、受信任的证书机构颁发的公私钥对；
- 不依赖任何新互联网协议或服务进行公钥分发或吊销；
- 签名验证失败不会强制拒绝消息；
- 不试图将加密作为机制的一部分；
- 不以消息存档为设计目标。

DKIM：

- 与现有邮件基础设施兼容，尽可能透明；
- 需要的基础设施最少；
- 可以独立于客户端实现，以缩短部署时间；
- 支持逐步部署；
- 允许将签名委托给第三方。

1.1. DKIM 架构文档

建议读者熟悉 [RFC4686]、[RFC5585] 和 [RFC5863]，它们分别提供了 DKIM 的背景、服务概述以及部署和操作指南。

1.2. 签名身份

DKIM 将签名者的身份与消息的假定作者区分开。具体而言，签名中包含签名者的身份信息。验证者可以利用签名信息决定如何处理消息。签名身份作为签名头字段的一部分包含在内。

【注：签名身份由 DKIM 签名指定，但不必与任何特定头字段中的地址完全匹配，因收件系统（包括 MUA）对解释方式较宽泛。】

1.3. 可扩展性

DKIM 旨在支持极端的可扩展性需求，以应对邮件识别问题的复杂性。邮件域数以百万计，单个域下的地址数量更为庞大。

DKIM 试图保持当前邮件基础设施的积极特性，例如任何人都可以与任何人通信，无需引入新关系。

1.4. 简单的密钥管理

与传统的分层公钥系统不同，DKIM 不依赖证书授权机构。验证者直接从声称签名者的域的存储库请求公钥，而非第三方。

DNS 被提议作为存放公钥的初始机制。因此，DKIM 目前依赖 DNS 管理和 DNS 系统的安全性。未来，DKIM 设计为可扩展到其他密钥获取服务。

1.5. 数据完整性

DKIM 签名将“d=” 名称与消息部分（或全部）计算的哈希值关联（见第3.7节），以防止签名被用于不同的消息。验证签名意味着自签名以来，哈希内容未被篡改，但不保证消息的端到端完整性。

DKIM旨在在互联网邮件服务中运行，如[RFC5598]所定义。基本的电子邮件术语取自该规范。

语法描述采用增强BNF（ABNF）[RFC5234]。

本文档中的关键词“必须”、“不得”、“需要”、“应当”、“不得”、“建议”、“不建议”、“推荐”、“不推荐”、“可以”和“可选”应按照[RFC2119]中的描述进行解释。只有当这些词全部用大写字母表示时，才具有规范性意义。

2.1. 签名者

代表某个域签署消息的邮件系统元素称为签名者。这些可能是邮件用户代理（MUA）、邮件提交代理（MSA）、邮件传输代理（MTA）或其他代理，如邮件列表扩散器。一般而言，任何签名者都将在某种程度上参与消息的注入到消息系统中。关键点在于，消息必须在离开签名者的管理域之前完成签名。

2.2. 验证者

验证签名的邮件系统元素称为验证者。这些可能是MTA、邮件投递代理（MDA）或MUA。在大多数情况下，验证者预计会接近消息的终端用户（读者）或某些消费代理，如邮件列表扩散器。

2.3. 身份

指个人、角色或组织。在DKIM的上下文中，示例包括作者、作者所在组织、处理路径上的ISP、独立的信任评估服务以及邮件列表运营者。

2.4. 标识符

指一个指向某个身份的标签。

2.5. 签名域标识符（SDID）

一个单一的域名，是DKIM的强制载荷输出，指示签名者对消息承担某种责任的身份。详见第3.5节。

2.6. 代理或用户标识符（AUID）

指一个单一的标识符，代表代表签名域标识符（SDID）承担责任的代理或用户。AUID由域名和可选的<local-part>组成。域名与用于SDID的域名相同或是其子域。在DKIM处理过程中，AUID的域名部分仅具有基本的域名语义；任何可能的所有者特定语义超出DKIM的范围。详见第3.5节。

注意，AUID的可接受值可能受到公钥记录中标志的限制（参见第3.6.1节）。

2.7. 身份评估者

邮件系统中负责使用DKIM载荷（即签名者的SDID）的元素。身份评估者专门负责评估所交付的标识符。其他DKIM（以及非DKIM）值也可以由身份评估者使用（如果可用），以提供更通用的消息评估过滤引擎。然而，这些额外活动超出了本规范的范围。

2.8. 空白字符

空白字符有三种形式：

- WSP：表示简单空白，即空格或制表符（详见[RFC5234]）。

- LWSP：线性空白，由WSP加上CRLF定义（详见[RFC5234]）。

- FWS：折叠空白。允许由CRLF分隔的多行通过在其后至少有一个空白字符的方式连接。

这些的ABNF定义（WSP和LWSP仅供参考）如下：

WSP = 空格 / 制表符  
LWSP = *(WSP / CRLF WSP)  
FWS = [*WSP CRLF] 1*WSP

FWS的定义与[RFC5322]中的相同，但不包括obs-FWS。

2.9. 导入的ABNF标记

以下标记从其他RFC导入，相关RFC应视为权威。

从[RFC5321]导入：

- "local-part"（实现警告：允许引号字符串）

- "sub-domain"

从[RFC5322]导入：

- "field-name"（头字段名）

- "dot-atom-text"（电子邮件地址的本地部分）

从[RFC2045]导入：

- "qp-section"（单行Quoted-Printable编码文本）

- "hex-octet"（Quoted-Printable编码的八位字节）

【注意：】请注意，[RFC2045]中的ABNF不遵循[RFC5234]的规则，必须相应解释，特别是在大小写折叠方面。

其他未在此定义的标记从[RFC5234]导入，包括SP、HTAB、WSP、ALPHA、DIGIT、CRLF等。

2.10. 常用ABNF标记

本文档中其他部分使用的ABNF标记包括：

hyphenated-word =  ALPHA [ *(ALPHA / DIGIT / "-") (ALPHA / DIGIT) ]  
ALPHADIGITPS =  (ALPHA / DIGIT / "+" / "/")  
base64string =  ALPHADIGITPS *([FWS] ALPHADIGITPS) [ [FWS] "=" [ [FWS] "=" ] ]  
hdr-name =  field-name  
qp-hdr-value =  dkim-quoted-printable（带“|”编码）

2.11. DKIM引号可打印编码（Quoted-Printable）

DKIM的Quoted-Printable编码语法类似于[RFC2045]第6.7节描述的：任何字符都可以用“=”后跟两个十六进制数字（不允许小写字母）表示，代表该字符的十六进制值。所有控制字符（值<%x20）、8位字符（值>%x7F）、DEL（%x7F）、空格（%x20）和分号（“;”，%x3B）都必须编码。注意，所有空白字符，包括空格、回车（CR）和换行（LF），都必须编码。编码后，可以在任意位置添加FWS以避免行过长；此类空白不属于值，解码前必须去除。不建议使用未列为“邮件安全”的字符（详见[RFC2049]）。

ABNF定义如下：

dkim-quoted-printable =  *(FWS / hex-octet / dkim-safe-char)  
dkim-safe-char =  %x21-3A / %x3C / %x3E-7E

【注意：】DKIM-Quoted-Printable与[RFC2045]定义的Quoted-Printable在几个方面不同：

1. 输入文本中的空白字符（包括CR和LF）必须编码。[RFC2045]不要求如此，也不允许编码CR或LF字符作为CRLF行断。

2. 编码文本中的空白字符被忽略。这允许使用DKIM-Quoted-Printable编码的标签根据需要换行。特别是，[RFC2045]要求输入中的换行表示为物理换行，而这里不要求。

3. 不支持“软换行”语法（行末“=”后跟空白字符）。

4. DKIM-Quoted-Printable不要求编码行长度不超过76字符（但根据使用场景可能有其他要求）。

3. 协议元素

协议元素是协议的概念部分，不特定于签名者或验证者。签名者和验证者的协议描述在后续章节（第5节“签名者操作”和第6节“验证者操作”）中介绍。注意：阅读本节时应结合这些章节。

3.1. 选择器

为了支持每个签名域多个并发的公钥，使用“选择器”划分密钥空间。例如，选择器可以表示办公室位置（如“sanfrancisco”、“coolumbeach”、“reykjavik”）、签名日期（如“january2005”、“february2005”）或某个用户。

选择器支持一些重要用例，例如：

- 允许域将特定地址的签名能力委托给合作伙伴（如广告提供商或外包服务）一段时间。

- 允许频繁出差的用户在本地发送邮件，无需连接特定的MSA。

- 提供转发功能的“亲和”域（如校友会），但不运营出站邮件提交代理。

选择器中的点（“.”）用作组件分隔符，定义DNS标签边界，类似于域名中的用法。例如，"march2005.reykjavik"。在DNS实现中，这可以用来委托部分选择器空间。

ABNF定义：

selector =   sub-domain *( "." sub-domain )

每个域的公钥数量和对应的选择器由域所有者决定。许多域所有者可能只用一个选择器，而分布式管理的组织可以选择在不同区域或不同邮件服务器管理不同的选择器和密钥对。

除了管理便利外，选择器还能实现密钥的例行更换。例如，从“january2005”切换到“february2005”时，只需确保两个公钥同时在公钥仓库中公布，便于过渡期内的邮件验证。过渡期开始时，出站邮件服务器用“february2005”私钥签名，结束时，删除“january2005”公钥。

【注意：】密钥也可以被吊销，详见下文。吊销与删除选择器记录的区别微妙。过渡期后，签名域可能会删除密钥记录，但也可以选择吊销密钥（保持记录）以延长使用期。吊销和删除没有定义明确的语义差异。

一些域可能希望将选择器值设为众所周知，而其他域则会注意不要让外部方通过选择器名采集数据。例如，若发放每个用户的密钥，域所有者需决定是否将选择器直接关联到注册用户的名称，或用随机值（如公钥指纹）代替。

【操作提示：】重复使用带新密钥的选择器（如更换用户名称对应的密钥）会导致难以区分未验证（因为密钥失效）和伪造的消息。因此，不建议签名者重复使用选择器，应为新密钥分配新选择器。

3.2. 标签=值列表

DKIM在多处使用“标签=值”语法，包括消息和域签名记录。

值是由一系列字符串组成，可以是纯文本、"base64"编码（[RFC2045]第6.8节）、"qp-section"（第6.7节）或"dkim-quoted-printable"（第2.11节定义）。标签名决定每个值的编码方式。标签值中不得出现未编码的分号（“;”），因为分号用于分隔标签。

【操作提示：】虽然下面定义的“纯文本”仅包含7位字符，但未来标准可能支持UTF-8编码（[RFC3629]），因此建议实现不要排除UTF-8字符。

ABNF规则如下：

tag-list  =  tag-spec *( ";" tag-spec ) [ ";" ]  
tag-spec  =  [FWS] tag-name [FWS] "=" [FWS] tag-value [FWS]  
tag-name  =  ALPHA *ALNUMPUNC  
tag-value =  [ tval *( 1*(WSP / FWS) tval ) ]  ; 禁止在开始和结束处有WSP和FWS  
tval      =  1*VALCHAR  
VALCHAR   =  %x21-3A / %x3C-7E  ; 感叹号到波浪线，除分号  
ALNUMPUNC =  ALPHA / DIGIT / "_"  

注意，标签周围允许空白字符（WSP），特别是在“=”之后和“;”之前的空白不属于值，但值内部的空白字符具有意义。

RFC 6376  数字签名（DKIM签名）  2011年9月

标签（Tags）必须区分大小写进行解释。除非特定标签的描述中明确说明不区分大小写，否则值必须按大小写敏感的方式处理。

具有重复名称的标签（Tags）在单一标签列表（tag-list）中不得出现；如果某个标签名出现多次，则整个标签列表无效。

值中的空白字符（Whitespace）必须保留，除非特定标签的描述中明确排除。

表示默认值的“标签=值”对（Tag=value）可以包含，以增强可读性。

未识别的标签（Tags）必须被忽略。

空值（空字符串）的标签与省略的标签不同。省略的标签视为具有默认值；而空值标签明确表示空字符串作为其值。

3.3.  签名与验证算法

DKIM支持多种数字签名算法。目前该规范定义了两种算法：rsa-sha1 和 rsa-sha256。签名者（Signers）必须实现这两种算法，并应优先使用 rsa-sha256 进行签名。验证者（Verifiers）必须实现这两种算法。

【提示说明】：虽然强烈建议使用 rsa-sha256，但某些发件人可能会在安全强度与性能、复杂性或其他需求之间权衡时选择使用 rsa-sha1。一般而言，应尽可能使用 rsa-sha256。

3.3.1.  rsa-sha1 签名算法

rsa-sha1 签名算法通过对消息进行哈希（使用 SHA-1 [FIPS-180-3-2008]，详见第3.7节）得到哈希值，然后由签名者（Signer）用 RSA 算法（定义在公钥密码学标准（PKCS）#1第1.5版 [RFC3447]）作为加密算法（crypt-alg）和签名者的私钥对哈希值进行签名。签名前，哈希值不得被截断或转换为除原生二进制形式之外的任何形式。签名算法应使用公指数为65537。

3.3.2.  rsa-sha256 签名算法

rsa-sha256 签名算法通过对消息进行哈希（使用 SHA-256 [FIPS-180-3-2008]，详见第3.7节）得到哈希值，然后由签名者用 RSA 算法（定义在 PKCS#1 v1.5 [RFC3447]）作为加密算法和签名者的私钥对哈希值进行签名。签名前，哈希值不得被截断或转换为除原生二进制形式之外的任何形式。签名算法应使用公指数为65537。

3.3.3.  密钥长度

选择合适的密钥长度是在成本、性能和风险之间的权衡。由于较短的 RSA 密钥更容易受到离线攻击，签名者（Signers）必须使用至少1024位的 RSA 密钥（适用于长期使用的密钥）。验证者（Verifiers）必须能够验证范围从512位到2048位的签名，且可能支持更长的密钥。验证策略可以将签名密钥的长度作为判断签名是否可接受的一个指标。

影响密钥长度选择的因素包括：

- 实际限制：较大的（如4096位）密钥可能无法放入512字节的 DNS UDP 响应包中
- 安全限制：小于1024位的密钥容易受到离线攻击
- 更大的密钥验证和签名时的 CPU 成本更高
- 密钥可以定期更换，因此其有效期可以较短
- 本规范的安全目标较为温和，与其他采用数字签名的系统的目标相比

关于密钥长度的更多讨论，请参见 [RFC3766]。

3.3.4. 其他算法

未来可能会定义其他算法。验证者（Verifiers）必须忽略未实现的算法的签名。

3.4.  规范化（Canonicalization）

一些邮件系统在传输过程中会修改邮件内容，可能导致签名失效。对于大多数签名者（Signers）而言，邮件的轻微修改对 DKIM 域名的验证影响不大。对于这些签名者，优先采用能抵抗适度传输中修改的规范化算法。

而其他签名者则要求任何微小的修改都应导致签名验证失败。这些签名者偏好不容忍传输中对签名邮件的任何修改的规范化算法。

一些签名者可能接受符合 [RFC5322] 等邮件标准的头字段的修改，但不接受对消息正文的任何修改。

为了满足所有需求，定义了两种规范化算法：一种是“简单”算法（simple），几乎不容忍任何修改；另一种是“宽松”算法（relaxed），可以容忍常见的修改，如空白字符替换和头字段换行。签名者（Signer）可以在签名时选择任意一种算法。若签名者未指定规范化算法，则默认为“简单”算法（simple）适用于头部和正文。验证者（Verifiers）必须实现这两种算法。头部和正文可以使用不同的规范化算法。未来可能会定义更多的规范化算法；验证者必须忽略使用未识别算法的签名。

规范化的作用是准备邮件内容以供签名或验证算法使用，绝不能改变传输的数据。以下描述头字段和正文的规范化方法。

【注意】：本节假设邮件已采用“网络正常”格式（文本为ASCII编码，行由CRLF分隔等）。关于消息规范化的详细信息，请参见第5.3节。

3.4.1.  “简单”头字段规范化算法（simple）

“简单”算法不对头字段做任何修改。头字段必须原样传递给签名或验证算法，不能进行大小写折叠，也不能更改空白字符。

3.4.2.  “宽松”头字段规范化算法（relaxed）

“宽松”算法按以下步骤依次处理：

- 将所有头字段名（不包括值）转换为小写。例如，将“SUBJect: AbC”转换为“subject: AbC”。

- 展开所有续行（续行指在RFC5322中定义的多行头字段，特别是带有换行符（CRLF）和空白字符（WSP）的行）时，必须去除CRLF，只保留空白字符。实现时不得删除头字段值末尾的CRLF。

- 将一行中的一个或多个WSP字符（空白字符）缩减为单个空格（SP）。

- 删除每个展开后头字段值末尾的所有WSP字符。

- 删除头字段名和其值之间、以及值后面（在冒号“:”之后）所有的WSP字符，但必须保留冒号。

3.4.3.  “简单”正文规范化算法（simple）

“简单”算法忽略正文末尾的所有空行（空行定义为去除行终止符后长度为零的行）。如果正文为空或没有尾部CRLF，则添加CRLF。除此之外，不做任何其他修改。正式定义为：将正文末尾的“*CRLF”转换为单个“CRLF”。

空正文（规范化为CRLF）对应的SHA-1（Base64编码）值为：

uoq1oCgLlTqpdDX/iUbLy7J1Wic=

SHA-256值为：

frcCV1k9oG9oKj3dpUqdJg1PxRT2RSN/XKdLCPjaYaY=

3.4.4.  “宽松”正文规范化算法（relaxed）

“宽松”算法必须依次执行以下步骤（a）和（b）：

a. 减少空白字符：

- 忽略行尾的所有空白字符（WSP），实现时不得删除行尾的CRLF。

- 将一行中的连续WSP字符缩减为单个空格（SP），包括换行折叠边界前后的空白。

b. 忽略正文末尾的所有空行（定义同上）。如果正文非空但未以CRLF结尾，则添加CRLF（仅在使用SMTP扩展或非SMTP传输机制时可能发生）。

空正文（规范化为null输入）的SHA-1（Base64）值为：

2jmj7l5rSw0yVb/vlWAYkK/YBwk=

SHA-256值为：

47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=

3.4.5.  规范化示例（仅供参考）

以下示例中，实际空白字符仅为清晰起见。实际输入输出文本用括号描述："<SP>"代表空格，"<HTAB>"代表制表符，"<CRLF>"代表回车换行序列。例如，“X <SP> Y”和“X<SP>Y”代表相同的三个字符。

示例1：一条消息内容如下：

A: <SP> X <CRLF>
B <SP> : <SP> Y <HTAB><CRLF>
               <HTAB> Z <SP><SP><CRLF>
<CRLF>
<SP> C <SP><CRLF>
D <SP><HTAB><SP> E <CRLF>
<CRLF>
<CRLF>

使用宽松规范化（头部和正文）后，得到的头部为：

a:X <CRLF>
b:Y <SP> Z <CRLF>

正文为：

<SP> C <CRLF>
D <SP> E <CRLF>

示例2：同一消息使用简单规范化（头部和正文）后，得到的头部为：

A: <SP> X <CRLF>
B <SP> : <SP> Y <HTAB><CRLF>
       <HTAB> Z <SP><SP><CRLF>

正文为：

<SP> C <SP><CRLF>
D <SP><HTAB><SP> E <CRLF>

示例3：使用宽松头部规范化和简单正文规范化后，得到的头部为：

a:X <CRLF>
b:Y <SP> Z <CRLF>

正文为：

<SP> C <SP><CRLF>
D <SP><HTAB><SP> E <CRLF>

3.5.  DKIM-Signature 头字段

电子邮件的签名存储在 DKIM-Signature 头字段中。该字段包含所有签名和密钥获取数据。DKIM-Signature值是第3.2节描述的标签列表（tag-list）。

应将 DKIM-Signature 头字段视为类似于 [RFC5322] 第3.6节定义的追踪头（trace header），因此不应重新排序，应放在消息的最前面。

在签名或验证过程中，始终将被签名的其他头字段（除 DKIM-Signature 之外）包括在签名计算中；但在计算或验证签名时，必须将该 DKIM-Signature 头字段中的“b=”标签（签名值）视为空字符串。未知标签（Tags）必须包含在签名计算中，但验证者（Verifiers）应忽略它们。其他被包括在签名中的 DKIM-Signature 头字段应视为普通头字段；特别是，“b=”标签没有特殊处理。

每个字段类型的编码如下。标记为 qp-section 的标签按照 [RFC2045] 第6.7节的 MIME 部分第1节的描述进行编码，额外将分号（“;”）转换为“=3B”，这实际上是一行 quoted-printable 编码的文本。dkim-quoted-printable 语法定义在第2.11节。

以下列出 DKIM-Signature 头字段中标签（Tags）及其类型和必需性。未识别的标签必须忽略。

- v= 版本（纯文本；必需）。定义适用于签名记录的规范版本。必须值为“1”，符合本版本的 DKIM 实现。

  ABNF：
  
  sig-v-tag = %x76 [FWS] "=" [FWS] 1*DIGIT

【提示】：DKIM-Signature 版本号可能随着新版本的发布而递增。

- a= 生成签名所用的算法（纯文本；必需）。验证者必须支持“rsa-sha1”和“rsa-sha256”；签名者（Signer）应优先使用“rsa-sha256”。详见第3.3节。

  ABNF：
  
  sig-a-tag = %x61 [FWS] "=" [FWS] sig-a-tag-alg
  sig-a-tag-alg = sig-a-tag-k "-" sig-a-tag-h
  sig-a-tag-k = "rsa" / x-sig-a-tag-k
  sig-a-tag-h = "sha1" / "sha256" / x-sig-a-tag-h
  x-sig-a-tag-k = ALPHA *(ALPHA / DIGIT)  ; 未来扩展
  x-sig-a-tag-h = ALPHA *(ALPHA / DIGIT)  ; 未来扩展

b= 签名数据（Base64编码；必需）。在此值中空白字符将被忽略，且在重新组装原始签名时必须忽略。特别地，签名过程可以安全地在此值的任意位置插入FWS（折叠空白）以符合行长度限制。关于签名的计算方式，请参见“签名者操作”（第5节）。

ABNF定义：
```
sig-b-tag       = %x62 [FWS] "=" [FWS] sig-b-tag-data
sig-b-tag-data  = base64string
```

c= 消息规范化方式（纯文本；可选，默认值为“simple/simple”）。此标签通知验证者用于准备签名的消息的规范化类型。它由两个由斜杠（%d47）分隔的名称组成，分别对应头部和正文的规范化算法。这些算法在第3.4节中有描述。如果只指定一个算法，则该算法用于头部，正文则使用“simple”。例如，“c=relaxed”与“c=relaxed/simple”具有相同含义。

ABNF定义：
```
sig-c-tag       = %x63 [FWS] "=" [FWS] sig-c-tag-alg
                  ["/" sig-c-tag-alg]
sig-c-tag-alg   = "simple" / "relaxed" / x-sig-c-tag-alg
x-sig-c-tag-alg = hyphenated-word    ; 供未来扩展使用
```

d= 声明对引入消息到邮件流的责任的SDID（纯文本；必需）。因此，SDID值用于形成公钥查询。SDID必须对应一个有效的DNS名称，该名称下发布了DKIM密钥记录。签名者创建和使用特定SDID所采用的约定和语义超出本规范范围，任何对这些约定和语义的使用亦如此。当验证者遇到不符合这些要求的签名时，必须认为该签名无效。

国际化域名必须按照[RFC5890]第2.3节的描述，编码为A标签。

ABNF定义：
```
sig-d-tag       = %x64 [FWS] "=" [FWS] domain-name
domain-name     = sub-domain 1*("." sub-domain)
                  ; 来源于[RFC5321]中的域名定义，
                  ; 不包括地址字面量
```

h= 已签名的头字段（纯文本，但请参见描述；必需）。这是由冒号分隔的头字段名列表，标识提交给签名算法的头字段。该字段必须包含完整的头字段列表，且顺序与提交给签名算法的顺序一致。字段可以包含在签名时不存在的头字段名；不存在的头字段不会影响签名计算（视为空输入，包括字段名、冒号、字段值及任何CRLF终止符）。字段可以多次出现，表示对应的头字段多次包含在头部哈希中。该字段不得包含正在创建或验证的DKIM-Signature头字段，但可以包含其他头字段。可以在冒号两侧加入折叠空白（FWS）。头字段名必须不区分大小写地与实际头字段名比较。此列表不能为空。关于选择签名的头字段的讨论请参见第5.4节，关于签署单个字段多次的要求请参见第5.4.2节。

ABNF定义：
```
sig-h-tag       = %x68 [FWS] "=" [FWS] hdr-name
                  *( [FWS] ":" [FWS] hdr-name )
```

【说明性说明】：通过“签名”不存在的头字段，签名者可以允许验证者检测到签名后对这些头字段的插入。然而，由于签名者不可能预知未来可能定义的所有头字段，此机制不能用来阻止任何未知头字段的添加。

【说明性备注】：在签名时不存在的字段“签名”不仅阻止字段和值被添加，还阻止无值字段的添加。

i= 代表责任的代理或用户标识符（AUID）（dkim-quoted-printable；可选，默认值为空本地部分，后跟“@”和“d=”标签中的域名）。其语法为标准电子邮件地址格式，本地部分可省略。地址的域部分必须与“d=”标签的值相同或为其子域。

国际化域名必须按照[RFC5890]第2.3节的描述，编码为A标签。

ABNF定义：
```
sig-i-tag       = %x69 [FWS] "=" [FWS] [ Local-part ] "@" domain-name
```

AUID的语法与电子邮件地址相同，但语义不必一致。特别是，域名不必在DNS中注册——可能无法解析——本地部分可以来自与邮箱无关的命名空间。命名空间的结构和语义由签名者决定。验证者或评估者对这些细节的了解或使用超出本规范范围。签名者可以选择用与用户电子邮件地址相同的命名空间，也可以采用其他方式表示其用户。签名者应在希望被评估为同一责任范围内的所有消息中使用相同的AUID，以便接收方可以将AUID作为比SDID更细粒度的稳定标识符。

【说明性备注】：标签“i=”中的本地部分是可选的，因为在某些情况下，签名者可能无法建立经过验证的个人身份。在这种情况下，签名者可能希望声明，虽然愿意代表域签名，但无法或不愿意承诺域内的具体用户名称。可以通过包括域部分但不包括本地部分来实现。

【说明性讨论】：本规范不要求“i=”标签的值必须与消息头中的任何身份信息匹配。这被视为验证者的策略问题。“i=”标签的值与其他头字段中的身份信息之间的约束旨在将基本的身份验证应用于与角色（如内容作者）相关的信任语义。信任是一个广泛且复杂的话题，信任机制容易受到各种攻击。除了最基本的绑定之外，“i=”值与其他身份的实际效果和安全性尚未得到充分验证，也不排除被攻击者破坏的可能性。因此，严格限制对这些选项的依赖。

l= 正文长度计数（纯文本无符号十进制整数；可选，默认为整个正文）。此标签通知验证者正文在规范化后在签名中所占的字节数，从正文前的CRLF之后的第一个字节开始计数（从0开始）。此值不得大于规范化后正文的实际字节数。详见第8.2节的讨论。

【说明性备注】：标签“l=”的值限制为最多76位十进制数字。此限制并非为了预测未来消息的大小，也不要求实现使用足够大的整数表示最大值，而是提醒实现者在验证时检查此标签的长度，并在解码时测试是否发生整数溢出。实现者可能需要将实际值限制在小于10^76的范围内，例如，为了让消息能存储在有限空间中。

ABNF定义：
```
sig-l-tag    = %x6c [FWS] "=" [FWS] 1*76DIGIT
```

q= 用于检索公钥的查询方法列表（纯文本；可选，默认值为“dns/txt”）。每个查询方法格式为“type[/options]”，其中选项的语法和语义依赖于类型和指定的选项。如果列出多个查询机制，查询机制的选择不得改变签名的解释。实现必须按列出顺序使用已识别的查询机制。未识别的查询机制应被忽略。

目前，唯一有效的值是“dns/txt”，定义了在本文档其他部分描述的DNS TXT资源记录（RR）查找算法。“dns”查询类型的唯一选项是“txt”，必须包括。验证者和签名者都必须支持“dns/txt”。

ABNF定义：
```
sig-q-tag        = %x71 [FWS] "=" [FWS] sig-q-tag-method
                  *([FWS] ":" [FWS] sig-q-tag-method)
```

【说明性说明】：s= 选择器，用于细分“d=”（域名）标签的命名空间（纯文本；必需）。国际化选择器名必须按照[RFC5890]第2.3节的描述，编码为A标签。

ABNF定义：
```
sig-s-tag    = %x73 [FWS] "=" [FWS] selector
```

t= 签名时间戳（纯文本无符号十进制整数；推荐，默认值为未知创建时间）。表示此签名的创建时间。格式为自1970年1月1日00:00:00 UTC起的秒数。值以十进制ASCII无符号整数表示，不必限制在31或32位整数范围内。实现应能处理至少到10^12（大约到公元200,000年）的值（可用40位存储）。为防止拒绝服务攻击，可能将超过12位的值视为无限。闰秒不计入。实现可以忽略时间戳在未来的签名。

ABNF定义：
```
sig-t-tag    = %x74 [FWS] "=" [FWS] 1*12DIGIT
```

x= 签名过期时间（纯文本无符号十进制整数；推荐，默认无过期时间）。格式与“t=”标签相同，为绝对日期，而非签名时间的时间差。值以十进制ASCII无符号整数表示，且与“t=”标签的值具有相同的限制。如果验证时间超过过期时间，签名可能被视为无效。验证时间应为消息首次在验证者管理域接收的时间（如果可靠可得）；否则应使用当前时间。如果“x=”标签存在，必须大于“t=”标签的值。

【说明性备注】：“x=”标签并非反重放的防护措施。

【说明性备注】：由于时钟漂移，接收者判断签名何时过期可能与发送者预期不完全一致。接收者可以加入“fudge factor”以容忍这种漂移。

ABNF定义：
```
sig-x-tag    = %x78 [FWS] "=" [FWS] 1*12DIGIT
```

z=复制的头字段（dkim引号打印，详见描述；可选，默认为空）。这是一个用竖线（"|"）分隔的列表，列出在消息签名时存在的选定头字段，包括字段名和字段值。并非必须包含签名时所有的头字段。此字段不必与"h="标签中列出的头字段相同。头字段文本本身必须对竖线（"|"，%x7C）字符进行编码（即，"z="中的竖线为元字符，任何实际出现在复制头字段中的竖线字符都必须编码）。注意，所有空白字符都必须编码，包括冒号与头字段值之间的空白。编码后，可以在任意位置添加折行白空（FWS）以避免行过长；此类空白不是头字段值的一部分，必须在解码前删除。

由"h="标签引用的头字段指的是消息的[RFC5322]头部中的字段，而不是"z="标签中复制的字段。复制的头字段值仅用于诊断目的。

ABNF定义：

sig-z-tag      = %x7A [FWS] "=" [FWS] sig-z-tag-copy
                 *( "|" [FWS] sig-z-tag-copy )
sig-z-tag-copy = hdr-name [FWS] ":" qp-hdr-value

示例：跨多行的签名头字段的示意（仅为参考）：

DKIM-Signature: v=1; a=rsa-sha256; d=example.net; s=brisbane;
   c=simple; q=dns/txt; i=@eng.example.net;
   t=1117574938; x=1118006938;
   h=from:to:subject:date;
   z=From:foo@eng.example.net|To:joe@example.com|
    Subject:demo=20run|Date:July=205,=202005=203:44:08=20PM=20-0700;
   bh=MTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTI=;
   b=dzdVyOfAKCdLXdJOc9G2q8LoXSlEniSbav+yuU4zGeeruD00lszZVoG4ZHRNiYzR

Crocker等人，见于标准追踪 [第25页]

RFC 6376  标准追踪  2011年9月

3.6.  密钥管理与表示

签名应用需要一定程度的保证，即验证用的公钥确实与声明的签名者相关联。许多应用通过使用由可信第三方颁发的公钥证书来实现这一点。然而，DKIM可以通过让验证者查询声称的签名者的DNS记录（或等效的安全机制）以检索公钥，从而实现足够的安全性，并显著提升扩展性。

DKIM的密钥可以存储在多种类型的密钥服务器中，格式也多样。密钥的存储和格式与DKIM算法的其余部分无关。

密钥查找算法的参数包括：查找类型（"q="标签）、签名者的域名（DKIM-Signature头字段中的"d="标签）以及选择器（"s="标签）。

public_key = dkim_find_key(q_val, d_val, s_val)

本文定义了一个绑定方式，使用DNS TXT资源记录（RR）分发密钥。未来可能会定义其他绑定方式。

3.6.1.  文本表示

预计许多密钥服务器会选择以非结构化文本格式（例如，XML格式不被视为非结构化文本）展示密钥。任何用以表示DKIM密钥的非结构化文本形式都必须遵循以下定义。

整体语法为第3.2节描述的标签列表。当前有效的标签如下。其他标签可以存在，但不理解的实现必须忽略。

v= 代表DKIM密钥记录的版本（纯文本；推荐，默认值为"DKIM1"）。如果指定，必须设置为"DKIM1"（不带引号）。此标签必须是记录中的第一个标签。以其他值开始的"v="标签的记录必须丢弃。注意，验证者在比较此值时必须进行字符串比较，例如，"DKIM1"与"DKIM1.0"不同。

ABNF定义：

key-v-tag    = %x76 [FWS] "=" [FWS] %x44.4B.49.4D.31

h= 允许的哈希算法（纯文本；可选，默认为允许所有算法）。列出可能使用的哈希算法的冒号分隔列表。未识别的算法必须忽略。详见第3.3节关于签名者和验证者实现的哈希算法的讨论。此标签中列出的算法集由签名者操作选择。

ABNF定义：

key-h-tag       = %x68 [FWS] "=" [FWS] key-h-tag-alg
                  *( [FWS] ":" [FWS] key-h-tag-alg )
key-h-tag-alg   = "sha1" / "sha256" / x-key-h-tag-alg
x-key-h-tag-alg = hyphenated-word   ; 未来扩展用

k= 密钥类型（纯文本；可选，默认"rsa"）。签名者和验证者必须支持"rsa"类型。表示在"p="标签中使用ASN.1 DER编码的[ITU-X660-1997] RSAPublicKey（详见[RFC3447]第3.1节和A.1.1节）。注意："p="标签还使用base64算法对值进行编码。未识别的密钥类型必须忽略。

ABNF定义：

key-k-tag        = %x76 [FWS] "=" [FWS] key-k-tag-type
key-k-tag-type   = "rsa" / x-key-k-tag-type
x-key-k-tag-type = hyphenated-word   ; 未来扩展用

n= 可能对人类感兴趣的注释（qp节；可选，默认为空）。没有程序会对其进行解释。在空间有限的密钥服务器（如DNS）中应谨慎使用此标签。此标签主要供管理员使用，而非终端用户。

ABNF定义：

key-n-tag    = %x6e [FWS] "=" [FWS] qp-section

p= 公钥数据（base64；必需）。空值表示该公钥已被撤销。此标签在编码为base64前的语法和语义由"p="标签定义。

说明：如果私钥被泄露或禁用（例如，外包合同终止），签名者可能会明确声明其知道该选择器，但所有使用该选择器的消息都应验证失败。验证者应对引用已撤销密钥的任何DKIM-Signature头字段返回错误码（详见第6.1.2节）。

ABNF定义：

key-p-tag    = %x70 [FWS] "=" [ [FWS] base64string]

说明：base64字符串允许在任意位置包含空白（FWS）；但任何CRLF后必须至少跟一个空白字符。实现者和管理员应确保选择器TXT RR符合此规范。

s= 服务类型（纯文本；可选，默认"*"）。用冒号分隔的服务类型列表。验证者在未列出对应类型时应忽略此记录。未识别的服务类型也应忽略。当前定义的服务类型包括：

*  匹配所有服务类型

email  电子邮件（不一定限于SMTP）

此标签旨在限制密钥的用途，以便未来其他服务定义使用DKIM。

ABNF定义：

key-s-tag        = %x73 [FWS] "=" [FWS] key-s-tag-type
                   *( [FWS] ":" [FWS] key-s-tag-type )
key-s-tag-type   = "email" / "*" / x-key-s-tag-type
x-key-s-tag-type = hyphenated-word   ; 未来扩展用

t= 标志，以冒号分隔的名称列表（纯文本；可选，默认无标志）。未识别的标志必须忽略。已定义的标志包括：

y  表示此域在测试DKIM。验证者不得将测试模式下的签名者的消息与未签名的邮件区别对待，即使签名验证失败。验证者可以追踪测试模式的结果以协助签名者。

s  所有使用"i="标签的DKIM-Signature头字段，其"i="标签右侧的域名值必须与"d="标签的值相同。即，"i="域名不得是"d="域名的子域。除非需要子域，否则建议使用此标志。

ABNF定义：

key-t-tag        = %x74 [FWS] "=" [FWS] key-t-tag-flag
                   *( [FWS] ":" [FWS] key-t-tag-flag )
key-t-tag-flag   = "y" / "s" / x-key-t-tag-flag
x-key-t-tag-flag = hyphenated-word   ; 未来扩展用

3.6.2.  DNS绑定

现定义一种使用DNS TXT RR作为密钥服务的绑定方式。所有实现必须支持此绑定。

3.6.2.1.  命名空间

所有DKIM密钥存储在名为"_domainkey"的子域中。举例：若DKIM-Signature中的"d="标签为"example.com"，"s="标签为"foo.bar"，则DNS查询应为"foo.bar._domainkey.example.com"。

3.6.2.2.  密钥存储的资源记录类型

使用的DNS资源记录类型由查询类型（"q="）标签的选项指定。本基础规范中定义的唯一选项是"txt"，表示使用TXT RR。未来可能会定义其他RR类型。

TXT RR中的字符串必须在使用前拼接在一起，中间不得有空白。TXT RR必须对特定选择器名唯一；即，如果一个RR集有多个记录，结果未定义。

TXT RR的编码方式参见第3.6.1节。

3.7.  计算消息哈希

签名和验证消息签名都始于对消息计算两个加密哈希的步骤。签名者将根据"签名者操作"（第5节）中描述的参数选择签名参数；验证者将使用被验证的DKIM-Signature头字段中指定的参数。在以下讨论中，将使用存在（验证时）或将创建（签名时）的DKIM-Signature头字段中的标签名。注意，规范化（第3.4节）仅用于准备签名或验证的电子邮件，不影响实际传输的邮件。

签名者/验证者必须计算两个哈希：一个覆盖消息体，另一个覆盖消息的选定头字段。

签名者必须按示意顺序计算。验证者可以按任何方便的顺序计算，只要结果在语义上与按此顺序计算的结果相同。

在哈希步骤1中，签名者/验证者必须对消息体进行哈希，使用"c="标签指定的正文规范化算法，并截断到"l="标签指定的长度。该哈希值随后转换为base64形式，插入（签名者）或与（验证者）DKIM-Signature头字段中的"bh="标签值进行比较。

在哈希步骤2中，签名者/验证者必须按以下顺序传递内容到哈希算法：

1. 由"h="标签指定的头字段，按标签中指定的顺序，使用"c="标签指定的头部规范化算法进行规范化。每个头字段必须以单个CRLF结束。

2. 存在（验证）或将插入（签名）的DKIM-Signature头字段，值中的"b="标签（包括所有空白）应删除（视为空字符串），使用"c="标签指定的头部规范化算法进行规范化，且不带尾随CRLF。

所有在DKIM-Signature头字段中的标签及其值都必须包含在加密哈希中，唯一例外是"b="（签名）标签的值部分，必须视为空字符串。所有标签即使不被验证者理解，也必须包含在内。该头字段在进行哈希时应在消息体之后处理，而非与其他头字段一起处理，并且必须按照"c="标签中的规范化方式进行规范化。DKIM-Signature头字段不得在其自身的"h="标签中出现，但其他DKIM-Signature头字段可以签名（详见第4节）。

在对将使用base64或quoted-printable编码传输的消息进行哈希时，签名者必须在编码后计算哈希。同样，验证者必须在解码base64或quoted-printable文本之前，将其值纳入哈希计算中。然而，哈希必须在传输层编码（如SMTP的"点填充"）之前完成（详见[RFC5321]）。

除了第3.4节中描述的规范化程序外，DKIM签名过程将消息的正文视为一个字节串。DKIM消息可以是纯文本格式，也可以是MIME格式；对MIME内容没有特殊处理。MIME格式的消息附件必须包含在签名内容中。

更正式地，签名算法的伪代码如下：

body-hash    =  hash-alg (canon-body, l-param)  
data-hash    =  hash-alg (h-headers, D-SIG, body-hash)  
signature    =  sig-alg (d-domain, selector, data-hash)  

其中：

- body-hash：通过使用hash-alg对正文进行哈希得到的输出。
- hash-alg：在"a"参数中指定的哈希算法。
- canon-body：正文的规范化表示，使用在"c"参数中指定的正文算法生成，定义见第3.4节，且不包括DKIM-Signature字段。
- l-param：是"l"参数中正文长度的值。
- data-hash：使用hash-alg算法对包括DKIM-Signature头在内的所有头部以及正文哈希值进行哈希的输出。
- h-headers：要签名的头部字段列表，按"h"参数中指定。
- D-SIG：规范化后的DKIM-Signature字段本身，不包括签名值部分，即为空参数值。
- signature：由签名算法生成的签名值。
- sig-alg：由"a"参数指定的签名算法。

- d-domain：在"d"参数中指定的域名。
- selector：在"s"参数中指定的选择器值。

注意：许多数字签名API同时提供哈希和使用RSA私钥的签名操作，通常通过一个"sign()"原语实现。在使用此类API时，算法中的最后两个步骤可能会合并为一次调用，既完成"a-hash-alg"的哈希，也完成"sig-alg"的签名。

3.8 输入要求

不符合[RFC5322]、[RFC2045]和[RFC2047]标准的消息，可能会被中间人尝试修正或解释。请参阅[RFC4409]第8节中的示例，了解常见的修改内容。这些“修正”可能会使DKIM签名失效或引发其他不良影响，包括影响消息的呈现方式。

因此，DKIM的设计假设输入内容是有效的。因此，签名者和验证者应采取合理措施，确保所处理的消息符合[RFC5322]、[RFC2045]及其他相关消息格式标准。

详见第8.15节的补充讨论。

3.9 输出要求

每个签名的验证结果最终会落入以下三种状态之一，本文称之为：

- SUCCESS：验证成功
- PERMFAIL：永久性、不可恢复的错误，例如签名验证失败
- TEMPFAIL：临时性、可恢复的错误，例如DNS查询超时

对于每个验证成功或产生TEMPFAIL结果的签名，DKIM算法的输出必须包括：

- 由签名标签"d="中的域名；
- 该签名验证尝试的结果。

输出还可以包含其他签名属性或结果元数据，包括已标记为PERMFAIL或被忽略的签名，供使用这些结果的模块参考。

详见第6.1节关于签名验证结果代码的讨论。

3.10 由父域签名

在某些情况下，域名希望代表其子域签名，而无需在每个子域中维护单独的选择器（密钥记录）。默认情况下，关联的私钥可以用来为其所在域的任何子域签名；例如，example.com的密钥记录可以用来验证子域sub.example.com或甚至sub1.sub2.example.com的消息。为了限制此类密钥的能力（当不希望如此时），可以在密钥记录的"t="标签中设置"s"标志，以限制AUID（"i="标签）域名的有效性。如果引用的密钥记录在"t="标签中包含"s"标志，则AUID的域名（"i="标签）必须与SDID（"d="标签）域名相同；如果没有此标志，则AUID的域名必须与SDID相同或是其子域。

3.11 SDID与AUID的关系

DKIM的主要任务是向接收端的身份评估者（Identity Assessor）传达一个代表责任身份的签名域标识符（SDID），同时可选地提供一个责任代理或用户标识符（AUID）。

因此，DKIM对接收端身份评估者的强制输出是一个单一的域名。在作为DKIM输出的范围内，该域名仅具有基本的域名语义；任何特定所有者的语义超出了DKIM的范围。也就是说，作为DKIM标识符，身份评估者不能假设附加的语义。

验证签名成功后，接收端的DKIM验证器必须将签名域标识符（d=）传达给使用的身份评估模块，并且可以（如果存在）传达AUID（i=）。

如果接收方试图推断这两个标识符的结构化语义，这属于启发式功能，超出DKIM的规范和语义范围。

因此，这类推断应由更高层的服务（如集成多种输入并进行启发式分析的投递处理过滤器）负责。

【附加说明】：本文档不要求SDID或AUID的值必须与其他消息头字段中的标识符匹配。这种关联应由身份评估者的策略决定。建立此类关联的目的是验证其他头字段中的值，从而基于该值进行信任评估。信任机制是一个广泛且复杂的话题，容易受到各种攻击。实际上，除了最基本的绑定外，SDID或AUID与其他身份的关联的有效性和安全性尚未得到充分验证，也难以防范攻击者的破坏。因此，依赖此类绑定应严格限制。尤其是，普通终端用户是否能信任通过SDID或AUID成功建立的任何保证，目前尚不明确。

4. 多重签名的语义

4.1 示例场景

消息可能有多重签名的原因有很多。例如，假设未来SHA-256被认为不够强，DKIM转而使用SHA-1024。一位签名者可能会立即用新算法签名，同时为了与尚未升级验证者的兼容性，继续用旧算法签名。实现方式是在消息中添加两个DKIM-Signature头字段，分别使用两种算法。未识别SHA-1024的旧验证者会跳过该签名，使用旧算法验证；新验证者可以任选签名，可能甚至根本不验证另一签名。

类似地，签名者可能会签署一条消息，包含所有头部字段且没有"l="标签（以满足严格验证者），以及另一份只签署部分头部字段并带有"l="标签（预料到消息在传输途中可能被修改）。验证者可以选择偏好的签名。

当然，消息也可能有多个签名，因为它经过多个签名者。常见的情况是，经过一个签名者签名的消息经过邮件列表转发，邮件列表也会对所有消息签名。假设两个签名都验证通过，接收者可以选择接受该消息，只要其中一个签名来自可信源。

特别地，接收者可能会将订阅的邮件列表加入白名单，允许接受来自可信列表的消息，即使发件人未知。也可能订阅一些可信度较低的列表（如没有反滥用保护的），只接受特定作者的消息，并对其他消息进行额外的滥用扫描。

另一个相关场景是转发服务，例如学术校友网站的转发地址。比如，接收者在members.example.org有一个地址，该站点的反滥用保护不够严格。此类接收者可能会对某些作者的消息绝对信任，但对未知作者经过转发验证的消息只持中等信任。

4.2 解释

签名者在消息上添加签名，只是创建了一个新的DKIM-Signature头字段，使用"h="参数的常规语义。签名者可以用第5.4节描述的方法对已有的DKIM-Signature头字段进行签名，以签署追踪头字段。

注意，签名者应意识到，对DKIM-Signature头字段进行签名可能会导致中间人（不识别该头字段为追踪头字段）误排布，从而破坏签名。因此，不建议对已有的DKIM-Signature头字段进行签名，尽管这是合法的。

【附加说明】：如果对带有多个实例的头字段进行签名，这些头字段总是从底部向上签名。因此，不可能只对特定的DKIM-Signature头字段签名。例如，若消息中已有A、B、C三个DKIM-Signature头字段，可以签署全部，也可以只签署B和C，或只签署C，但不能只签A、只签B、只签A和B、或只签A和C。

签名者可以用不同参数添加多个DKIM-Signature头字段。例如，在过渡期，签名者可能会用两种不同的哈希算法签名。

签名者不应删除自己签署的任何DKIM-Signature头字段，即使知道这些签名无法验证。

在评估多重签名的消息时，验证者应独立评估每个签名的有效性。例如，策略上不接受已弃用的加密算法的验证者会认为此类签名无效。验证者可以按任意顺序处理签名；比如，有些验证者可能会先验证与消息头中的From字段相关的签名，然后再验证其他签名。详见第6.1节关于签名选择的更多信息。

【附加说明】：验证者尝试关联有效签名与无效签名以推测签名失败原因是不建议的。特别是，没有通用方法能判断一个无效签名曾经是有效的。

验证者应持续验证签名，直到某个签名验证成功为止。为了防止潜在的拒绝服务攻击，验证者可以限制其尝试验证的签名总数。

如果验证模块报告某些签名的验证结果为PERMFAIL，身份评估者应忽略这些签名（见第6.1节），视其为不存在于消息中的签名。

5. 签名者操作

签名者应按顺序执行以下步骤。

5.1 判断是否应对邮件签名及由谁签名

签名者显然只能对其拥有私钥且知道相应公钥和选择器信息的域名的邮件进行签名。然而，除了缺少私钥之外，还有许多其他原因可能导致签名者选择不签名该邮件。

提示说明：签名者可以根据需要，将签名功能集成到邮件系统的任何部分，包括邮件用户代理（MUA）、提交服务器（SUBMISSION server）或邮件传输代理（MTA）。无论在哪个环节实现，签名者都应注意不要对可能存在问题的消息进行签名（从而承担责任）。特别是在受信任的环境中，签名域可能会根据本地策略从头部信息派生；提交服务器可能只会对经过正确认证和授权的用户的消息进行签名。

附加操作建议：提交服务器在对经过隐藏内部拓扑细节的出站网关MTA的Received头字段进行签名时，应避免签名这些字段。

如果由于某些原因无法对邮件进行签名，是否采取相应措施由本地政策决定。

5.2. 选择私钥和对应的选择器信息

本规范未定义签名者应如何选择使用哪一对私钥和选择器信息。目前，所有选择器在本规范中是等价的，因此选择主要应考虑管理便利。私钥的分发和管理也超出本文档范围。

操作建议：签名者在预期验证者在验证签名之前，选择的选择器对应的公钥可能已被撤销或删除时，不应使用相应的私钥进行签名。签名者应预料到验证者可以选择推迟验证，比如直到最终收件人实际阅读邮件时。特别是在轮换新密钥对时，应立即使用新私钥进行签名，并在合理的验证期限内保留旧公钥，之后再将其从密钥服务器中移除。

5.3. 规范消息以防止传输中的转换

某些消息，尤其是使用8位字符的消息，在传输过程中可能会被修改，例如转换为7位形式。这类转换会破坏DKIM签名。为了减少此类破坏的可能性，签名者应在签名前将消息转换为合适的MIME内容传输编码（如quoted-printable或base64），具体方法参见[RFC2045]。这种转换超出DKIM的范围，实际消息应由邮件用户代理（MUA）或邮件接收代理（MSA）在提交给DKIM算法之前，转换为7位MIME。

如果消息在提交给签名者时采用了任何会在传输前被修改的本地编码，必须在签名前将其转换为规范化的[RFC5322]形式。特别是，某些系统使用的裸CR或LF字符（作为本地行分隔符）必须在签名前转换为SMTP标准的CRLF序列。任何此类转换应应用于实际发送给收件人的消息，而不仅仅是应用于签名算法所处理的版本。

更一般地，签名者应签署其预期被验证者接收的消息版本，而非某些本地或内部的形式。

5.3.1. 体内容长度限制

可以指定一个体长度计数，用于限制签名计算仅覆盖消息体的前段（以字节为单位）。如果未指定体长度，则签名覆盖整个消息体。

操作理由：此功能常用于邮件列表会在消息后添加尾部信息（如退订说明），在未对这些尾部签名的情况下，体长度计数可以帮助验证者接受带有多余数据但签名有效的消息。

实际被哈希的长度应在DKIM-Signature头字段的"l="标签中注明（参见第3.5节）。体长度计数应按照规范化算法计算，例如，任何被规范化算法忽略的空白字符不计入长度。

长度为零表示整个消息体未被签名。

希望确保消息内容不被修改的签名者，应使用“simple”规范化算法（对头部和正文）并省略体长度计数。

详见第8.2节。

5.4. 确定要签名的头字段

必须签名（即包含在签名头字段的"h="标签中）发件人（From）头字段。签名者不应签署在传输过程中可能被合法修改或删除的头字段，特别是[RFC5321]明确允许在传输中修改或删除Return-Path头字段。签名者可以根据需要签署其他在签名时存在的头字段。

操作建议：选择签名哪些头字段并非易事。一种策略是签署所有存在的、不可重复的头字段；另一种是只签署可能会被显示或影响接收端处理的头字段；第三种是只签署“知名”头字段。请注意，验证者可能会对未签名的头字段持极端怀疑态度，甚至拒绝显示或忽略未被覆盖的签名。因此，建议签署诸如Date、Subject、Reply-To、Sender及所有MIME相关头字段。

DKIM-Signature头字段本身始终隐含签署，且不得包含在"h="标签中，除非用以指示其他已有签名也被签署。

签名者可以声称签署了不存在的头字段（即在"h="标签中列出某个头字段名，即使该字段在消息中不存在）。在计算签名时，未存在的头字段应视为空字符串（包括字段名、字段值、所有标点符号和尾随CRLF）。

操作理由：这允许签名者明确声明某个头字段不存在；如果后来添加了该字段，签名将失效。

注意：在签名时，头字段名只需列出一次，超过实际出现次数可以防止后续添加。例如，如果在签名时只有一个Comments头字段，列出两次Comments即可防止添加更多Comments字段；不必（但允许）列出三次或更多。

有关多实例头字段的规范化流程，请参见第5.4.2节。

签名者应注意避免签署可能在传输过程中被添加或重新排序的头字段。根据[RFC5322]，只有Trace头字段（如Received）和Resent-*块不能被重新排序。特别是，由于某些中间MTA可能会重新排序DKIM-Signature头字段，签署已存在的DKIM-Signature字段可能会带来错误。

操作提醒：尽管[RFC5322]未禁止头字段的重新排序，但中间MTA对多实例签名字段的重新排序会破坏DKIM签名，应避免此类行为。

实现者注意：虽然本规范未要求，但建议签署所有对终端用户可见的头字段，以防“间接垃圾邮件”。例如，如果未签署Subject字段，垃圾邮件发送者可以重发已签名的邮件，替换掉合法的主题，变成垃圾内容。

5.4.1. 推荐的签名内容

DKIM的加密算法旨在为消息附加一个标识符，既能抵抗正常传输中的变更，又能防止重放攻击。实现这些目标的关键在于选择哪些头字段纳入哈希，以及哪些字段应排除。

基本原则是选择构成“核心”内容的字段。这样，任何重放攻击都必须包括这些字段才能成功签名；而包含这些字段后，即使消息被转发给新收件人，消息的核心内容仍然有效。

常见的核心字段包括：

- From（必选；见第5.4节）
- Reply-To
- Subject
- Date
- To、Cc
- Resent-Date、Resent-From、Resent-To、Resent-Cc
- In-Reply-To、References
- List-Id、List-Help、List-Unsubscribe、List-Subscribe、List-Post、List-Owner、List-Archive

如果使用了"l="签名标签（见第3.5节），Content-Type字段也可能被包括在内，因为它可能被篡改，导致接收端显示完全不同的内容。

“核心”内容的定义存在权衡，对于某些字段是主观的。例如，Message-ID被视为核心内容之一，因为它有助于区分不同实例的同一消息。同样，如果将消息线程视为核心内容，In-Reply-To和References也应包括。

另一类可能感兴趣的字段是传达安全信息的字段，如Authentication-Results [RFC5451]。

排除字段的基本原则是：选择那些存在多个实例或在传输中可能被修改的字段。典型例子包括：

- Return-Path
- Received
- Comments、Keywords

注意，DKIM-Signature字段本身也不应包含在签名的头字段中，因为其处理方式另有规定。

通常，建议排除其他可选字段，以避免在验证前被合法添加或重新排序。尽管如此，由于应用场景繁多，某些特殊情况可能例外，比如某些特定的头字段可能不会被重复、修改或重新排序。

签名者应根据处理的消息类型和风险偏好选择规范化算法。例如，主要用于电子商务网站的购买收据，通常偏好“simple”规范化，因为这些消息不太可能被邮件列表或其他软件修改。而主要用于个人通信的邮件，可能更偏好“relaxed”规范化，以增强对传输中修改的抵抗力。

除非通过中介（如邮件列表）处理，否则“l=”标签可能没有实际益处，反而可能成为未授权添加内容的途径。使用“l=0”会允许完全篡改消息正文而不使签名失效，极端情况下应谨慎使用。此外，验证者有权视部分签名的正文为不可接受，建议谨慎使用。

5.4.2. 涉及多实例字段的签名

（此节内容未提供，建议后续补充。）

签名者在选择签署在消息中出现多次的现有头字段（如Received）时，必须签署该头字段在头部块中“物理上”最后一次出现的实例。希望签署多个此类头字段实例的签名者，必须在DKIM-Signature头字段的"h="标签中多次包含该头字段的名称，并且必须按照从头部字段块底部到顶部的顺序签署这些头字段。签名者可以在"h="中包含比实际对应的头字段更多的该头字段名称，以确保如果添加了额外的同名头字段，签名验证将失败。

示例说明：

如果签名者希望签署两个已存在的Received头字段，而现有头部包含：

Received: <A>  
Received: <B>  
Received: <C>  

那么生成的DKIM-Signature头字段应为：

DKIM-Signature: ... h=Received : Received :...

其中，<C>和<B>这两个Received头字段将按此顺序被签署。

---

5.5. 计算消息哈希和签名

签名者必须按照第3.7节的描述计算消息的哈希值，然后使用所选的公钥算法对其进行签名。这将生成一个包含正文哈希和头部哈希签名的DKIM-Signature头字段，其中该头字段包括DKIM-Signature本身。

诸如邮件列表管理器等实现了DKIM并在转发消息或修改头字段（例如插入退订信息）之前，应检查任何现有的签名，并且必须在重新签名之前进行这些修改。

---

5.6. 插入DKIM-Signature头字段

最后，签名者必须在传输电子邮件之前插入在前一步中创建的DKIM-Signature头字段。该头字段必须与用于计算哈希的内容相同，除了"b="标签的值必须是前一步中签名计算得到的适当签名哈希值，该签名由DKIM-Signature头字段中的"a="标签指定的算法签名，并使用与" s="标签中给出的选择器对应的私钥签名，如第5.2节所述。

DKIM-Signature头字段必须插入在任何其他DKIM-Signature字段之前。

说明：最简单的实现方式是在头部块的开头插入DKIM-Signature头字段，特别是可以放在任何已存在的Received头字段之前。这与将DKIM-Signature视为追踪头字段的做法是一致的。

---

6. 验证者的操作

由于签名者可以随时移除或撤销公钥，建议及时进行验证。在许多配置中，最及时的验证地点是在边界MTA接受消息时或之后不久。特别是不建议推迟验证直到最终用户访问消息。

边界或中间MTA可以验证消息的签名。已进行验证的MTA可以通过在传入消息中添加验证头字段来传达验证结果，这大大简化了用户的操作，用户可以使用现有的邮件用户代理（MUA）。大多数MUA具有根据消息头字段或内容过滤消息的能力，这些过滤器可以用来实现用户对未签名邮件的策略。

验证MTA可以对不可验证的邮件实施策略，无论是否在签名消息中应用验证头字段。

验证者必须产生一个语义上等同于按顺序执行第6.1节、6.1.1节和6.1.2节中列出的步骤的结果。实际上，为了提高性能，可以并行执行其中的几个步骤。

---

6.1. 从消息中提取签名

验证者尝试的DKIM-Signature头字段的顺序未定义；验证者可以按任意顺序尝试签名。例如，一个实现可能按文本顺序尝试签名，而另一个可能先尝试与From头字段内容匹配的身份签名，然后再尝试其他签名。验证者不得对多个DKIM-Signature头字段的顺序赋予最终意义。特别是，某些中继可能会以任意方式重新排序头字段。

说明：验证者可以利用签名的顺序作为签名顺序的线索（在没有其他信息的情况下）。此外，也可以考虑其他线索，比如将签名的主机与Received头字段进行关联。

消息在传输过程中签名的存活性不能得到保证，签名可能因非签名者的过错而验证失败。因此，验证者不应将存在一个或多个无效签名且没有有效签名的消息与完全没有签名的消息区别对待。

当签名成功验证后，验证者可以停止处理或尝试验证其他签名，具体取决于实现。验证者可以限制尝试的签名数量，以避免拒绝服务攻击（详见第8.4节）。

在以下描述中，"return status (explanation)"（其中"status"为"PERMFAIL"或"TEMPFAIL"之一）意味着验证者必须立即停止处理该签名。验证者应在存在其他签名时，继续尝试下一个签名，并完全忽略验证失败的签名。如果状态为"PERMFAIL"，表示签名失败，不应再尝试；如果为"TEMPFAIL"，表示当前无法验证，但可以稍后重试。验证者可以选择将消息延后处理，或尝试其他签名；如果没有有效签名，且任何签名返回TEMPFAIL状态，验证者可以安排稍后处理。

准备验证多个签名头字段的验证者应尝试处理下一个签名头字段（如果存在）。不过，验证者也可以记下无效签名的存在，以便在后续步骤中考虑。

说明：此要求的目的是允许存在无效签名但仍有有效签名的消息通过。例如，邮件列表可能会保留原始提交者的签名，即使列表知道它会修改消息以破坏该签名，列表也会插入自己的签名。在这种情况下，即使存在已知损坏的签名，消息仍应被视为有效。

对于每个待验证的签名，应按照顺序执行以下步骤，以确保结果在语义上等同于按该顺序执行。

---

6.1.1. 验证签名头字段

实现者必须严格验证DKIM-Signature头字段的格式和值；任何不一致或意外值都必须导致该头字段被完全忽略，并且验证器返回PERMFAIL（签名语法错误）。在此安全上下文中，“宽容接受”不是一个好策略。需要注意的是，允许DKIM-Signature头字段中存在未知标签（这是明确允许的），但如果出现"v="标签与本规范不一致的情况，验证器必须返回PERMFAIL（版本不兼容）。

说明：实现可以选择也验证由旧版本规范生成的签名。

如果第3.5节中列为“必需”的任何标签在DKIM-Signature头字段中缺失，验证器必须忽略该头字段并返回PERMFAIL（缺少必需标签的签名）。

说明：第3.5节列出的“必需”标签包括"v="、"a="、"b="、"bh="、"d="、"h="和"s="。如果本说明与第3.5节冲突，以第3.5节为准。

如果DKIM-Signature头字段不包含"i="标签，验证器应视为该标签的值为"@d"，其中"d"为" d="标签的值。

验证器必须确认" d="标签中指定的域与"i="标签中的域相同或为其父域。如果不一致，应忽略该DKIM-Signature头字段，并返回PERMFAIL（域名不匹配）。

如果"h="标签未包含From头字段，验证器必须忽略该DKIM-Signature头字段并返回PERMFAIL（未签署From字段）。

验证者可以忽略该DKIM-Signature头字段并返回PERMFAIL（签名已过期），如果它包含"x="标签且签名已过期。

验证者可以忽略该DKIM-Signature头字段，如果签名者在" d="标签中使用的域未与有效的签名实体相关联。例如，"d="值为"com"或"co.uk"的签名可以被忽略。不可接受的域名列表应可配置。

验证者也可以忽略该DKIM-Signature头字段并返回PERMFAIL（不可接受的签名头），如果签名未签署验证者视为必要的头字段，或者出于其他原因（如未签署MIME头字段可能引发某些攻击，验证者希望避免）。

---

6.1.2. 获取公钥

验证签名所需的公钥以完成验证过程。获取公钥的过程依赖于DKIM-Signature头字段中的"q="标签定义的查询类型。显然，只有在成功提取签名信息后，才需要检索公钥。

密钥管理和表示的详细信息在第3.6节中描述。验证者必须验证密钥记录，忽略任何格式错误的公钥记录。

说明：使用覆盖查询的通配符TXT资源记录（RR）可能会返回一个不太可能是有效DKIM密钥记录的响应。这不仅是DKIM的问题，也适用于许多其他类型的查询。处理DNS响应的客户端软件应考虑此问题。

在验证消息时，验证者必须以语义等同于按顺序执行的方式，执行以下步骤；在某些情况下，允许并行或重排这些步骤，只要语义不变。

1. 通过第3.6节描述的方法，使用"q="标签中的算法、"d="标签中的域和"s="标签中的选择器，检索公钥。

2. 如果公钥查询未响应，验证者可以返回TEMPFAIL（密钥不可用），以便稍后重试。

3. 如果查询失败是因为没有对应的密钥记录，验证者必须立即返回PERMFAIL（无密钥签名）。

4. 如果查询返回多个密钥记录，验证者可以选择其中之一，或轮询所有记录，执行剩余步骤，具体由实现决定。密钥记录的顺序未定义。如果轮询所有记录，"return ..."的后续措辞意味着“尝试下一个密钥记录；如果没有，则返回以正常方式尝试其他签名”。

5. 如果查询返回的结果不符合本规范定义的格式，验证程序必须忽略该密钥记录，并返回PERMFAIL（密钥语法错误）。强烈建议验证程序仔细验证密钥记录的语法，以避免潜在的攻击。特别是，验证程序必须忽略带有未实现版本代码（“v=”标签）的密钥。

6. 如果公共密钥记录中存在“h=”标签，并且在DKIM-Signature头字段中的“a=”标签所暗示的哈希算法未包含在“h=”标签的内容中，验证程序必须忽略该密钥记录，并返回PERMFAIL（不适用的哈希算法）。

7. 如果公共密钥数据（“p=”标签）为空，则表示该密钥已被吊销，验证程序必须将此视为签名验证失败，并返回PERMFAIL（密钥已吊销）。被吊销的密钥与已被删除的密钥记录在语义上没有区别。

8. 如果公共密钥数据不适用于“a=”和“k=”标签在DKIM-Signature头字段中定义的算法和密钥类型，验证程序必须立即返回PERMFAIL（不适用的密钥算法）。

6.1.3. 计算验证

给定签名者和公共密钥，验证签名的过程包括与以下步骤语义等价的操作。

1. 根据“c=”标签定义的算法、“l=”标签指定的正文长度，以及“h=”标签中的头字段名，准备消息的规范化版本（如第3.7节所述）（注意，此规范化版本并不实际替换原始内容）。在将“h=”标签中的头字段名与实际消息头字段匹配时，比较必须不区分大小写。

2. 根据“a=”标签指示的算法，从规范化的副本中计算消息哈希，如第3.7节所述。

3. 验证在前一步中计算的规范化消息正文的哈希值是否与“bh=”标签中传达的哈希值匹配。如果哈希不匹配，验证程序应忽略该签名并返回PERMFAIL（正文哈希未验证）。

4. 使用“b=”标签传达的签名，利用“a=”标签描述的公钥算法的机制，验证签名是否正确匹配头部哈希。如果验证失败，验证程序应忽略该签名并返回PERMFAIL（签名未验证）。

5. 否则，签名已正确验证。

【提示：实现者应注意，可能希望在计算哈希的同时并行发起公钥查询，因为在最终解密之前并不需要公钥。实现者也可以在验证消息头的签名之前，先验证“bh=”标签中列出的消息哈希是否与实际消息正文匹配；但如果正文哈希不匹配，则应视为整个签名验证失败。】

签名中的“l=”标签指定的正文长度限制了传递给验证算法的正文字节数。超出该限制的所有数据不由DKIM验证。因此，验证程序可能会对包含超出指示正文长度的字节的消息持怀疑态度，并可以选择将其视为无效签名（例如返回PERMFAIL（未签名内容））。

如果验证到此步骤，验证成功，DKIM会报告该签名的状态为“成功”。

6.2. 传达验证结果

验证程序希望将验证结果传达给邮件系统的其他部分，可以采用任何合适的方式。例如，验证程序可以在转发消息之前，向消息添加一个邮件头字段。任何此类头字段应插入在现有的DKIM-Signature或已有的认证状态头字段之前。可以使用“Authentication-Results:”头字段（[RFC5451]）来实现此目的。

【建议：为邮件客户端过滤器编写的提示：用于搜索验证结果头字段以明显标记已认证邮件的模式，应确保该头字段由验证域正确添加，并且验证的身份与邮件客户端显示的发件人身份一致。特别是，邮件客户端过滤器不应被攻击者添加的伪造验证结果头字段误导。为防范此类攻击，验证程序可以在验证后请求删除已有的验证结果头字段，然后再添加新的头字段。】

6.3. 解释结果/应用本地策略

本规范不涉及身份验证者可以采取的具体措施，但携带已验证SDID的邮件为身份验证者提供了未经过验证的邮件所不具备的机会。具体而言，经过验证的邮件创建了一个可预测的标识符，便于管理信任和声誉等决策。相反，未验证的邮件缺乏可靠的标识符，难以赋予信任和声誉。合理的做法是，将未验证的邮件视为没有任何信任且没有正面声誉。

通常，使用DKIM验证结果的模块不应仅因缺少签名或签名无法验证而拒绝邮件，否则会引发严重的互操作性问题。如果邮件传输代理（MTA）在SMTP会话中希望拒绝此类邮件（例如，与事先约定只接受签名邮件的对等方通信时），当签名缺失或验证失败时，应使用550/5.7.x的回复码。

如果验证程序集成在MTA中，且无法获取公钥（可能因为密钥服务器不可用），可以返回临时失败信息，使用如451/4.7.5的回复码，例如：

451 4.7.5 无法验证签名——密钥服务器不可用

临时失败（如无法访问密钥服务器或其他外部服务）应使用4xx的SMTP回复码。特别是，密码签名验证失败绝不能引发4xx的SMTP回复。

一旦签名验证成功，该信息必须传达给身份验证者（如明确的允许/白名单和声誉系统）和/或最终用户。如果SDID与“From:”头字段中的地址不同，邮件系统应确保读者能清楚识别实际的SDID。

验证失败的症状很明显——签名不验证，但确定具体原因可能较难。例如，找不到选择器，是因为已被删除，还是在传输过程中值被更改？签名行缺失，是因为从未存在，还是被过度激进的过滤器删除？出于诊断目的，应提供验证失败的具体原因，并可能记录在系统日志中。

如果邮件无法验证，应将其视为所有未验证的邮件一样处理，无论其是否看似已签名。

详见第8.15节的补充讨论。

7. IANA考虑事项

DKIM已在IANA注册了命名空间。在所有情况下，只有在已发布的RFC中记录且获得IETF共识的值，才会被分配（[RFC5226]）。本备忘录更新了这些注册表，特别是增加了“状态”列。所有注册到这些命名空间的值，必须包括被注册的名称、注册或更新的文档，以及其当前状态（“active”表示当前使用，“historic”表示不再使用）。

与[RFC4871]相比，本规范未定义新的标签，但其中一个被标记为“历史”。

此外，“电子邮件认证方法”注册表已修订为引用本更新。

7.1. 电子邮件认证方法注册表

“电子邮件认证方法”注册表已更新，注明“dkim”在本备忘录中定义。

7.2. DKIM-Signature标签规范

DKIM-Signature支持一组标签规范。IANA已建立“DKIM-Signature标签规范”注册表，用于存放可在DKIM-Signature字段中使用的标签规范。

【表格示例略，内容为标签类型、参考文档、状态等信息】

表1：DKIM-Signature标签规范注册表更新值

7.3. DKIM-Signature查询方法注册表

“q=”标签（第3.5节定义）提供一组查询方法。

IANA已建立“DKIM-Signature查询方法”注册表，用于存放用于检索密钥以验证签名的机制。

【表格示例略，内容为类型、选项、参考、状态等信息】

表2：DKIM-Signature查询方法注册表更新值

7.4. DKIM-Signature规范化注册表

“c=”标签（第3.5节定义）提供一种规范化算法的标识符，用于对消息的头部和正文进行规范化。

IANA已建立“DKIM-Signature规范化头部”注册表，用于存放在签名或验证前将消息转换为规范形式的算法。

【表格示例略，内容为类型、参考、状态等信息】

表3：DKIM-Signature规范化头部注册表更新值

【类似的正文内容还包括正文规范化算法的注册表、_domainkey DNS TXT资源记录标签规范、密钥类型注册表、哈希算法注册表等，具体内容略。】

7.5. _domainkey DNS TXT资源记录标签规范

_域名密钥（_domainkey）DNS TXT RR支持一组标签规范。IANA已建立“DKIM _domainkey DNS TXT记录标签规范”注册表，用于存放在DNS TXT资源记录中的标签规范。

【表格示例略，内容为类型、参考、状态】

表5：_domainkey DNS TXT记录标签规范注册表更新值

7.6. DKIM密钥类型注册表

“k=”标签（第3.6.1节）和“a=”标签（第3.5节）定义一组机制，用于解码DKIM签名。

IANA已建立“DKIM密钥类型”注册表，用于存放这些机制。

【表格示例略，内容为类型、参考、状态】

表6：DKIM密钥类型注册表更新值

7.7. DKIM哈希算法注册表

【内容未完，略。】

“h=” <key-h-tag>（在第3.6.1节中规定）和“a=” <sig-a-tag-h>（在第3.5节中规定）标签提供了一份机制列表，用于生成消息数据的摘要。

IANA已为此类机制建立了“DKIM哈希算法”注册表。

                  +--------+-------------------+--------+
                  |  类型  | 参考资料          | 状态   |
                  +--------+-------------------+--------+
                  |  sha1  | [FIPS-180-3-2008] | 活跃   |
                  | sha256 | [FIPS-180-3-2008] | 活跃   |
                  +--------+-------------------+--------+

表7：DKIM哈希算法注册表更新值

7.8.  DKIM服务类型注册表

“s=” <key-s-tag>（在第3.6.1节中规定）标签提供了此选择器可能适用的服务类型列表。

IANA已为服务类型建立了“DKIM服务类型”注册表。

                   +-------+-----------------+--------+
                   |  类型 | 参考资料        | 状态   |
                   +-------+-----------------+--------+
                   | email | （本文件）      | 活跃   |
                   |   *   | （本文件）      | 活跃   |
                   +-------+-----------------+--------+

表8：DKIM服务类型注册表更新值

---

Crocker 等人，标准轨迹 [第54页]

RFC 6376：DKIM签名 2011年9月

7.9.  DKIM选择器标志注册表

“t=” <key-t-tag>（在第3.6.1节中规定）标签提供了一个标志列表，用于修改对选择器的解释。

IANA已为“DKIM选择器标志”建立了额外标志的注册表。

                    +------+-----------------+--------+
                    | 类型 | 参考资料        | 状态   |
                    +------+-----------------+--------+
                    |   y  | （本文件）      | 活跃   |
                    |   s  | （本文件）      | 活跃   |
                    +------+-----------------+--------+

表9：DKIM选择器标志注册表更新值

---

7.10.  DKIM-Signature头字段

IANA已将DKIM-Signature添加到“永久消息头字段名称”注册表（参见 [RFC3864]），用于“mail”协议，参考本文件。

8.  安全注意事项

已观察到，任何试图遏制垃圾邮件流量的机制都可能成为攻击目标。必须仔细审查DKIM，以识别潜在的攻击向量及其漏洞。另请参见 [RFC4686]。

8.1.  ASCII艺术攻击

放宽的正文规范化算法可能使某些极端粗糙的“ASCII艺术”攻击成为可能，即通过调整单词间的空格来传达信息。如果对此有所担忧，应使用“简单”正文规范化算法。

8.2.  滥用正文长度限制（“l=”标签）

使用“l=”标签可能允许在未发出适当警告的情况下显示虚假内容。“l=”标签旨在增强签名的鲁棒性，适用于向既会修改内容又不签名其修改后消息的邮件列表发送消息。然而，使用“l=”标签可能被恶意中间人利用，修改消息内容，使其仅对攻击者有利。附加内容可能完全取代原始内容，欺骗最终收件人，破坏重复消息检测算法。

此类攻击的示例包括篡改MIME结构、利用邮件客户端（MUA）对HTML的宽松解析，以及绕过重复消息检测。

为防止此类攻击，签名者应极为谨慎使用此标签，评估者也可能选择忽略使用该标签的签名。

8.3.  私钥滥用

与其他使用公私钥对的安全应用一样，DKIM在密钥的处理和保护方面需要谨慎。私钥被泄露或被访问意味着攻击者或恶意软件可以用该域名签名邮件，冒充合法发件人。

因此，发放给用户的私钥（而非由管理域（ADMD）本身使用的密钥）存在安全风险，可能影响整个管理域。

更安全的架构是通过出站邮件传输代理（MTA）发送消息，利用现有技术（如SMTP认证）验证发件人身份，可能还会验证消息本身（如验证头部的合法性和内容的反垃圾检测），并用适合发件人地址的密钥签名。此类MTA还可以对每个用户的发信量进行控制，进一步限制恶意软件批量发送邮件的能力。

8.4.  密钥服务器拒绝服务攻击

由于密钥服务器是分布式的（可能为每个域单独部署），要在整个互联网范围内攻击以破坏此机制，所需攻击的服务器数量非常庞大。然而，针对单个域的密钥服务器也可能被攻击，阻碍该域的消息验证。这与攻击者阻断某个域的邮件交换服务的能力类似，影响的是发出邮件而非接收邮件。

一种变体是大量伪造签名的邮件从某个域发出，导致该域的密钥服务器被请求淹没，形成拒绝服务（见 [RFC4732]）。但鉴于验证的开销远低于处理邮件本身，发动此类攻击较为困难。

8.5.  针对DNS的攻击

由于DNS是密钥服务的基础绑定，必须考虑针对DNS的特定攻击。

虽然目前DNS存在安全漏洞（[RFC3833]），但这些安全问题促使了DNS安全扩展（DNSSEC）（[RFC4033]）的开发，所有DNS用户都将从中受益。

DKIM仅被视为一种“充分”的验证方法，不旨在提供强加密的作者身份或内容证明。其他技术如OpenPGP（[RFC4880]）和S/MIME（[RFC5751]）则能满足这些需求。

与DNS相关的第二个安全问题是，由于获取选择器相关数据和签名域策略而导致的DNS流量增加。广泛部署DKIM会显著增加对声明签名域的DNS查询。在大规模伪造的情况下，DNS服务器可能会面临大量查询。

一个特定的DNS安全问题是第2.3节中描述的“名称链攻击”[RFC3833]。在验证DKIM签名时，验证者可能被引导去检索攻击者选择的密钥记录。通过确保验证者使用的名称服务器（包括递归服务器）严格检查DNS响应中的“胶水”记录和其他附加信息，可以减轻此威胁。

8.6.  重放/垃圾邮件攻击

在此类攻击中，垃圾邮件发送者通过签名的邮件发出，依赖签名域（如大型知名邮箱提供商）的信誉，而非自身信誉，然后将该邮件大量转发给多个目标收件人。收件人看到来自知名域的有效签名，信任度提升，更可能将邮件投递和呈现给用户。

对此的部分解决方案包括使用信誉服务，标记特定邮箱地址用于垃圾邮件，或表明来自该签名者的消息可能是垃圾邮件。这需要实时检测机制以快速反应。然而，如果攻击者大量重发受害者的邮件以制造受害者为垃圾邮件源的假象，这些措施可能被滥用。

大型验证器可能能检测到在短时间内大量具有相同签名的邮件。较小的验证器也可以通过现有的协作系统获得类似的信息。

8.7.  撤销密钥的限制

当一个大型域检测到其用户的不良行为时，可能希望撤销用于签名该用户消息的密钥，以否认责任，特别是针对尚未验证或正被重放的消息。然而，如果出于可扩展性考虑，同一密钥被用于多个用户的签名，域的撤销能力会受到限制。已提出按地址逐一撤销密钥的机制，但仍需进一步研究其实用性和对DNS的负载影响。

8.8.  故意伪造的密钥记录

攻击者可能在DNS中发布故意格式错误的密钥记录，意在对不健壮的验证器造成拒绝服务攻击。攻击者可以通过向某个用户发送引用伪造密钥记录（可能不合法）的消息，诱使验证器读取错误的密钥记录。验证器必须彻底验证从DNS获取的所有密钥记录，并对故意或无意的格式错误保持鲁棒。

8.9.  故意伪造的DKIM-Signature头字段

验证器必须准备好接收包含格式错误的DKIM-Signature头字段的消息，并在依赖其内容之前，彻底验证该头字段。

8.10.  信息泄露

攻击者可以通过使用每消息唯一的选择器，并监控DNS中的密钥查找，判断某个签名何时被验证。这相当于一种“网页虫”式的验证时间追踪，而非消息被读取的时间。

8.11.  远程计时攻击

在某些情况下，可能通过远程计时攻击（[BONEH03]）提取私钥。实现应考虑对时间进行混淆，以防止此类攻击。

8.12.  头字段重排序

现有标准允许中间的邮件传输代理（MTA）对头字段进行重排序。如果签名者签署了两个或多个同名头字段，可能导致合法消息出现验证错误。特别是，签署任何现有的DKIM-Signature字段的签名者，可能会遇到消息验证失败的问题。

8.13.  RSA攻击

攻击者可能创建具有小指数的大RSA签名密钥，从而要求验证密钥也必须具有大指数。这会导致验证者在验证签名时消耗大量计算资源。验证者可以通过拒绝验证引用了具有不合理指数的密钥的签名，来避免此攻击。

通常，攻击者可能试图通过大量消息淹没验证器，造成拒绝服务。这与其他MTA的拒绝服务攻击类似，应采取相应措施。

8.14.  父域的不当签名

第3.10节描述的信任关系，可能被父域用来用子域的身份签名消息，而子域与父域在管理上无关。例如，.com注册局可能用example.com域中的“i=”值签名消息。由于管理界限可能在域名的任何位置，没有通用的解决方案。例如，在“example.podunk.ca.us”域中，有三个管理界限（podunk.ca.us、ca.us和us），任何一个都可能生成具有完整域身份的消息。

【说明：】这被视为一种可接受的风险，原因类似于域委托的风险。例如，上述情况中，任何一个子域都可以将“example.podunk.ca.us”委托给其选择的服务器，完全替换所有DNS提供的信息。验证器可以忽略来自不可信域（如“.com”）的签名（详见第6.1.1节）。

8.15.  涉及额外头字段的攻击

许多电子邮件组件，包括邮件传输代理（MTA）、邮件安全代理（MSA）、邮件用户代理（MUA）以及过滤模块，通常对消息格式的检查都比较宽松。这主要是出于多年来行业压力的结果，为了减少支持成本，行业倾向于对进入邮件流的内容采取宽容的态度；因此，不正确格式的消息在传输过程中常常被默默修正、被不修复地投递，或者被不恰当地显示（例如，只显示多个From:字段中的第一个）。

评估或应用DKIM输出的代理需要意识到，DKIM签名者可以对格式不正确的消息进行签名（例如，违反[RFC5322]的规定，比如在只允许出现一次的字段中出现多次），这些消息在传输过程中可能变得格式不正确，或者包含不真实或无效的头部或正文内容。对这类消息使用DKIM可能构成对接收者的攻击，尤其是在对签名的消息赋予额外信任而未充分评估签名者的情况下。

这些情况可能构成严重的攻击，但它们与DKIM本身无关；它们是对接收者或错误识别的发件人的攻击。

此外，代理不应错误地推断，只因为某个实例的头字段被签名，所有该字段的实例都被签名。

攻击者可以通过合法手段获得来自受攻击域的真实签名，但随后可以通过拦截或重放添加额外的头字段。在这种情况下，DKIM可以帮助检测在传输过程中添加特定字段的行为。这是通过让签名者在“h=”标签中列出字段名（例如，对于只有一个From字段的消息，写为“h=from:from:...”），这样在下游添加该字段的实例时，签名将无法验证（详见第3.5节）。本质上，这是一种明确的声明，表明签名者对这种格式不正确的消息不承担责任。

DKIM签名并验证其所指示的数据，且工作正常。因此，在这种情况下，DKIM已完成其职责——传递了经过验证的域名（“d=”值），并且根据DKIM签名的语义，签名者在某种程度上对存在问题的消息承担了一定责任。由身份评估者或其他后续代理根据需要对这类消息采取行动，例如降低消息（或签名者）的可信度、警告接收者，甚至拒绝投递，都是由他们决定的。

所有在邮件系统中执行宽松标准的组件，在引入DKIM时都需要重新审视其立场，特别是在考虑潜在攻击（如上述所述）时。

9. 参考文献

9.1. 标准性参考文献

[FIPS-180-3-2008] 美国商务部，“安全哈希标准”，FIPS PUB 180-3，2008年10月。

[ITU-X660-1997] “信息技术——ASN.1编码规则：基本编码规则（BER）、规范编码规则（CER）和区别编码规则（DER）”，1997年。

[RFC1034] Mockapetris, P.，“域名——概念与功能”，STD 13，RFC 1034，1987年11月。

[RFC2045] Freed, N. 和 N. Borenstein，“多用途互联网邮件扩展（MIME）第1部分：互联网消息正文格式”，RFC 2045，1996年11月。

[RFC2049] Freed, N. 和 N. Borenstein，“多用途互联网邮件扩展（MIME）第5部分：符合性标准与示例”，RFC 2049，1996年11月。

[RFC2119] Bradner, S.，“在RFC中用以指示需求级别的关键词”，BCP 14，RFC 2119，1997年3月。

[RFC3447] Jonsson, J. 和 B. Kaliski，“公钥密码学标准（PKCS）#1：RSA密码学规范第2.1版”，RFC 3447，2003年2月。

[RFC5234] Crocker, D. 和 P. Overell，“语法规范的增强BNF：ABNF”，STD 68，RFC 5234，2008年1月。

[RFC5321] Klensin, J.，“简单邮件传输协议”，RFC 5321，2008年10月。

[RFC5322] Resnick, P.（主编），“互联网消息格式”，RFC 5322，2008年10月。

[RFC5598] Crocker, D.，“互联网邮件架构”，RFC 5598，2009年7月。

[RFC5890] Klensin, J.，“国际化域名（IDNA）：定义与文档框架”，RFC 5890，2010年8月。

9.2. 说明性参考文献

[BONEH03] “远程定时攻击是切实可行的”，第12届USENIX安全研讨会论文集，2003年。

[RFC2047] Moore, K.，“多用途互联网邮件扩展（MIME）第3部分：非ASCII文本的消息头扩展”，RFC 2047，1996年11月。

[RFC3629] Yergeau, F.，“UTF-8：ISO 10646的变换格式”，STD 63，RFC 3629，2003年11月。

[RFC3766] Orman, H. 和 P. Hoffman，“用于交换对称密钥的公钥强度确定”，BCP 86，RFC 3766，2004年4月。

[RFC3833] Atkins, D. 和 R. Austein，“域名系统（DNS）的威胁分析”，RFC 3833，2004年8月。

[RFC3864] Klyne, G.，Nottingham, M. 和 J. Mogul，“消息头字段的注册程序”，BCP 90，RFC 3864，2004年9月。

[RFC4033] Arends, R.，Austein, R.，Larson, M.，Massey, D. 和 S. Rose，“DNS安全简介与需求”，RFC 4033，2005年3月。

[RFC4409] Gellens, R. 和 J. Klensin，“邮件提交协议”，RFC 4409，2006年4月。

[RFC4686] Fenton, J.，“激发域名密钥识别邮件（DKIM）威胁分析”，RFC 4686，2006年9月。

[RFC4732] Handley, M.，Rescorla, E. 和 IAB，“互联网拒绝服务（DoS）考虑事项”，RFC 4732，2006年12月。

[RFC4870] Delany, M.，“基于域名的电子邮件认证（DomainKeys）”，RFC 4870，2007年5月。

[RFC4871] Allman, E.，Callas, J.，Delany, M.，Libbey, M.，Fenton, J. 和 M. Thomas，“域名密钥识别邮件（DKIM）签名”，RFC 4871，2007年5月。

[RFC4880] Callas, J.，Donnerhacke, L.，Finney, H.，Shaw, D. 和 R. Thayer，“OpenPGP消息格式”，RFC 4880，2007年11月。

[RFC5226] Narten, T. 和 H. Alvestrand，“撰写IANA考虑事项部分的指南”，BCP 26，RFC 5226，2008年5月。

[RFC5451] Kucherawy, M.，“指示消息认证状态的消息头字段”，RFC 5451，2009年4月。

[RFC5585] Hansen, T.，Crocker, D. 和 P. Hallam-Baker，“域名识别邮件（DKIM）服务概述”，RFC 5585，2009年7月。

[RFC5672] Crocker, D.，“RFC 4871域名密钥识别邮件（DKIM）签名——更新”，RFC 5672，2009年8月。

[RFC5751] Ramsdell, B. 和 S. Turner，“安全/多用途互联网邮件扩展（S/MIME）第3.2版消息规范”，RFC 5751，2010年1月。

[RFC5863] Hansen, T.，Siegel, E.，Hallam-Baker, P. 和 D. Crocker，“域名识别邮件（DKIM）的开发、部署与操作”，RFC 5863，2010年5月。

[RFC6377] Kucherawy, M.，“域名识别邮件（DKIM）与邮件列表”，RFC 6377，2011年9月。

（以下省略，内容与前文类似，涉及更多相关标准和指南。）

附录A. 使用示例（仅供参考）

本节展示一封电子邮件从提交到最终投递的完整流程，说明各个组件如何协作。示例中使用的密钥详见附录C。

A.1. 用户撰写邮件

From: Joe SixPack <joe@football.example.com>  
To: Suzie Q <suzie@shopping.example.net>  
Subject: 晚餐准备好了吗？  
Date: 2003年7月11日 21:00:37 -0700（PDT）  
Message-ID: <20030712040037.46341.5F8J@football.example.com>

你好。

我们输了比赛。你饿了吗？

乔。

（图1：用户撰写邮件）

A.2. 邮件被签名

这封邮件由example.com的出站邮件服务器签名，内容如下：

DKIM-Signature: v=1; a=rsa-sha256; s=brisbane; d=example.com;  
c=simple/simple; q=dns/txt; i=joe@football.example.com;  
h=Received : From : To : Subject : Date : Message-ID;  
bh=2jUSOH9NhtVGCQWNr9BrIAPreKQjO6Sn7XIkfJVOzv8=;  
b=AuUoFEfDxTDkHlLXSZEpZj79LICEps6eda7W3deTVFOk4yAUoqOB...（省略）

签名所用的私钥由签名邮件服务器访问“brisbane”选择器对应的密钥。

（图2：邮件已签名）

A.3. 签名验证

通常由入站SMTP服务器或最终投递代理验证签名，也可以由中间的MTA执行验证。验证过程使用“d=”标签中的域名（example.com）和“s=”标签中的选择器（brisbane）来形成DNS查询：brisbane._domainkey.example.com。

验证从“h=”标签列出的最后一个Received头部开始，依次到From头部等，按顺序进行。验证以单个CRLF后跟正文（从“Hi.”开始）进行，采用“simple”方法进行规范化。验证结果（在此示例中）存放在X-Authentication-Results头部中。验证成功后，邮件内容如下：

X-Authentication-Results: shopping.example.net  
  header.from=joe@football.example.com; dkim=pass  
Received: from mout23.football.example.com (192.168.1.1)  
  by shopping.example.net with SMTP;  
  2003年7月11日 21:01:59 -0700（PDT）  
DKIM-Signature: v=1; a=rsa-sha256; s=brisbane; d=example.com;  
c=simple/simple; q=dns/txt; i=joe@football.example.com;  
h=Received : From : To : Subject : Date : Message-ID;  
bh=2jUSOH9NhtVGCQWNr9BrIAPreKQjO6Sn7XIkfJVOzv8=;  
b=AuUoFEfDxTDkHlLXSZEpZj79LICEps6eda7W3deTVFOk4yAUoqOB...（省略）

（图3：验证成功）

附录B. 使用示例（仅供参考）

DKIM的签名和验证可以在不同的操作场景中以多种方式使用。本附录讨论一些常见示例。

注意：本附录中的描述仅供参考，旨在说明在特定约束和需求下，DKIM可以采用的各种用法。这些示例并不旨在作为创建实现时的详细指导或解释。

B.1. 替代提交场景

在最简单的场景中，用户的MUA、MSA和互联网（边界）MTA都在同一管理环境下，使用相同的域名。因此，所有涉及提交和初始转发的组件都是相关的。然而，通常多个组件由不同的管理机构控制，这在签名域名的选择及其与常用邮件身份头字段的关系上带来了挑战。

B.1.1. 委托的业务功能

一些组织会将特定的业务功能委托给组织内外的不同团队。目标是授权该团队签名某些邮件，但限制其签名的内容。DKIM的“s=”选择器标签便于实现这种受限授权。例如，合法的邮件营销提供商和企业福利提供商就是此类委托业务的例子。

在这种场景中，受委托的团队需要用客户公司的域名签署邮件。同时，客户通常不愿意为提供者注册一个允许其代表域内任意地址发送邮件的密钥。

管理这些用例的方法多样。一种方式是，客户组织负责所有DNS查询服务（如DNS）管理，另一种则是通过DNS委托，让受委托的团队负责管理DKIM密钥记录。

如果客户组织负责全部DNS管理，外包公司可以生成一对密钥，将公钥提供给客户，由客户在DNS中用唯一的选择器注册。客户因此可以随时撤销委托密钥的使用。

如果客户希望委托团队管理DNS，则可以让带有选择器的域名指向提供商的DNS服务器。提供商随后负责创建和维护该选择器的所有签名信息。这样，客户不能限制签名的本地部分（local-part），但可以通过删除DNS委托记录来撤销签名权限。

B.1.2. PDA及类似设备

PDA设备展示了在每个域中使用多个密钥的必要性。假设约翰·多伊（John Doe）希望能够使用其公司邮箱地址jdoe@example.com发送消息，但他的电子邮件设备无法建立虚拟私人网络（VPN）连接到公司网络，原因可能是设备功能有限或其互联网接入提供商施加了限制。如果该设备配备了由example.com域管理员注册的私钥，并安装了相应的软件用于签名消息，那么约翰可以在设备上对消息进行签名，然后通过接入服务提供商的外发网络传输。

B.1.3. 漫游用户

漫游用户常常会遇到使用非其本地服务器的SMTP服务器的情况，例如在会议或许多酒店中。在这种情况下，由提交服务添加的签名将使用不同于用户本地系统的身份。

理想情况下，漫游用户应通过VPN或运行SMTP认证（SMTP AUTH）在端口587上的提交服务器连接回其主服务器。如果签名可以在漫游用户的笔记本电脑上完成，那么他们可以在提交前签名，尽管这样存在被进一步修改的高风险。如果这两种方式都无法实现，这些漫游用户将无法使用其域密钥进行签名后发送邮件。

Crocker 等人              标准追踪                   [第68页]

RFC 6376                     DKIM签名               2011年9月

B.1.4. 独立（自助服务亭）消息提交

独立服务，例如自助服务亭和基于网页的信息服务，与用户没有持续的电子邮件服务关系，但用户偶尔会请求代表他们发送邮件。例如，提供新闻的网站通常允许读者将文章转发给朋友。这通常使用读者自己的电子邮件地址，以表明作者身份。这有时被称为“Evite”问题，得名于同名网站，允许用户向朋友发送邀请。

通常的处理方式是，继续在消息的From头字段中放置读者的电子邮件地址，但在Sender头字段中放入由邮件发布网站拥有的地址。该发布网站随后可以用其域名对消息进行签名，提供给接收的电子邮件站点有用的信息，从而可以将签名域与最初的提交电子邮件角色相关联。

接收站点通常希望向其最终用户提供有关以此方式中介的邮件的信息。虽然不同方法的实际效果仍需通过人因可用性研究验证，但一种常用技术是验证系统重写From头字段，显示已验证的地址，例如：From: John Doe via news@news-site.example <jdoe@example.com>。（注意，这样的重写会破坏签名，除非在验证完成后进行。）

B.2. 替代投递场景

电子邮件常常在一个邮箱中接收，但其地址与最初提交时使用的地址不同。在这种情况下，中介机制在最初使用的地址上操作，然后将消息传递到最终目的地。这一中介过程对DKIM签名提出了一些挑战。

B.2.1. 关联地址（Affinity Addresses）

“关联地址”允许用户拥有一个地址，即使在更换不同的电子邮件提供商时也保持稳定。它们通常与校友会、专业组织和娱乐组织相关联，这些组织希望与用户保持长期关系。这些域通常提供转发功能，并且常配有验证用户身份、允许更改转发地址的网页应用程序。然而，这些服务通常依赖用户通过其服务提供商的MTA（邮件传输代理）发送外发邮件。因此，用关联地址域名签名的邮件，并非由拥有该域的组织管理的实体签名。

利用DKIM，关联域可以通过网页应用程序允许用户注册每个用户的密钥，用于代表其关联地址签名。用户会拿走密钥对的私钥部分，关联域则在DNS中公布公钥部分供验证者访问。

这也是利用用户级密钥的另一种应用，关联地址所用的域通常会拥有大量的用户级密钥。或者，关联域可以管理外发邮件，运行一个邮件提交代理（MSA），在接受和签名消息前对用户进行认证。当然，这依赖于用户的服务提供商没有阻止相关的TCP端口用于邮件提交。

B.2.2. 简单地址别名（.forward）

在某些情况下，收件人可以配置电子邮件地址，使邮件自动从原地址转发到另一个地址，例如通过Unix的.forward文件。在这种情况下，邮件通常由收件人域的邮件处理服务转发，未作修改，除了在消息中添加Received头字段和更改信封收件人地址外。在这种情况下，最终邮箱的收件人可能能够验证原始签名，因为签名内容未被更改，而DKIM可以验证消息签名。

B.2.3. 邮件列表和转发者

接收并重新提交消息的服务行为多种多样。主要例子包括邮件列表（统称“转发器”），从不修改消息内容（除了添加Received头和更改信封信息）到会添加头字段、修改主题、在正文末尾添加内容或以某种方式重排正文。简单的转发器产生的消息与自动别名服务类似。更复杂的系统实际上会创建一条新消息。

不修改正文或已签名头字段的转发器，可能会保持原有签名的有效性，也可以选择为消息添加自己的签名。

那些以可能使现有签名失效的方式修改消息的转发器，尤其适合添加自己的签名（例如：mailing-list-name@example.net）。由于重新签名意味着对消息内容负责，这些签发的转发器通常会有选择性地转发或重新签名，只在收到有效签名或有其他依据确认消息未被伪造时操作。

主要作为邮件再分发者的系统，常会在消息中添加Sender头字段，标明签名所用的地址。这会删除任何已存在的Sender头字段（符合[RFC5322]的要求），并在消息中加入新的DKIM-Signature头，包含转发者的签名、公钥及相关信息。

有关更多相关主题和讨论，请参见[RFC6377]。

附录C. 生成公钥（仅供参考）

默认签名是对完整电子邮件内容的RSA签名的SHA-256摘要。为便于说明，本文使用openssl命令描述密钥和签名的管理机制。生成适用于DKIM的1024位未加密私钥的一种方法是：

$ openssl genrsa -out rsa.private 1024

为了增强安全性，还可以添加“-passin”参数对私钥进行加密。使用此参数时，后续步骤中会要求输入密码。服务器可能更倾向于使用硬件加密支持。

“genrsa”步骤会生成一个名为rsa.private的文件，内容类似于：

-----BEGIN RSA PRIVATE KEY-----
MIICXwIBAAKBgQDwIRP/UC3SBsEmGqZ9ZJW3/DkMoGeLnQg1fWn7/zYtIxN2SnFC
jxOCKG9v3b4jYfcTNh5ijSsq631uBItLa7od+v/RtdC2UzJ1lWT947qR+Rcac2gb
to/NMqJ0fzfVjH4OuKhitdY9tf6mcwGjaNBcWToIMmPSPDdQPNUYckcQ2QIDAQAB
AoGBALmn+XwWk7akvkUlqb+dOxyLB9i5VBVfje89Teolwc9YJT36BGN/l4e0l6QX
/1//6DWUTB3KI6wFcm7TWJcxbS0tcKZX7FsJvUz1SbQnkS54DJck1EZO/BLa5ckJ
gAYIaqlA9C0ZwM6i58lLlPadX/rtHb7pWzeNcZHjKrjM461ZAkEA+itss2nRlmyO
n1/5yDyCluST4dQfO8kAB3toSEVc7DeFeDhnC1mZdjASZNvdHS4gbLIA1hUGEF9m
3hKsGUMMPwJBAPW5v/U+AWTADFCS22t72NUurgzeAbzb1HWMqO4y4+9Hpjk5wvL/
eVYizyuce3/fGke7aRYw/ADKygMJdW8H/OcCQQDz5OQb4j2QDpPZc0Nc4QlbvMsj
7p7otWRO5xRa6SzXqqV3+F0VpqvDmshEBkoCydaYwc2o6WQ5EBmExeV8124XAkEA
qZzGsIxVP+sEVRWZmW6KNFSdVUpk3qzK0Tz/WjQMe5z0UunY9Ax9/4PVhp/j61bf
eAYXunajbBSOLlx4D+TunwJBANkPI5S9iylsbLs6NkaMHV6k5ioHBBmgCak95JGX
GMot/L2x0IYyMLAz6oLWh2hm7zwtb0CgOrPo1ke44hFYnfc=
-----END RSA PRIVATE KEY-----

提取公钥部分的方法是：

$ openssl rsa -in rsa.private -out rsa.public -pubout -outform PEM

生成的rsa.public文件内容类似于：

-----BEGIN PUBLIC KEY-----
MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDwIRP/UC3SBsEmGqZ9ZJW3/DkM
oGeLnQg1fWn7/zYtIxN2SnFCjxOCKG9v3b4jYfcTNh5ijSsq631uBItLa7od+v/R
tdC2UzJ1lWT947qR+Rcac2gbto/NMqJ0fzfVjH4OuKhitdY9tf6mcwGjaNBcWToI
MmPSPDdQPNUYckcQ2QIDAQAB
-----END PUBLIC KEY-----

此公钥（不含BEGIN和END标签）应放入DNS中：

$ORIGIN _domainkey.example.org.
brisbane IN  TXT  ("v=DKIM1; p=MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQ"
                   "KBgQDwIRP/UC3SBsEmGqZ9ZJW3/DkMoGeLnQg1fWn7/zYt"
                   "IxN2SnFCjxOCKG9v3b4jYfcTNh5ijSsq631uBItLa7od+v"
                   "/RtdC2UzJ1lWT947qR+Rcac2gbto/NMqJ0fzfVjH4OuKhi"
                   "tdY9tf6mcwGjaNBcWToIMmPSPDdQPNUYckcQ2QIDAQAB")

C.1. 与DomainKeys密钥记录的兼容性

DKIM密钥记录在许多情况下被设计为向后兼容DomainKeys [RFC4870]（在DomainKeys背景下有时称为“选择器记录”）。但存在一个不兼容的方面需要特别注意。“g=”标签值在DomainKeys和[RFC4871]密钥记录中可以提供对特定本地部分（local-part）密钥有效性的更细粒度控制。在DomainKeys中，空值的“g=”是对域内所有地址有效的。这与原始DKIM规范（[RFC4871]）中的用法不同，后者中空值的“g=”对任何地址都无效。特别是请参见[RFC4870]第3.2.3节中的示例公钥记录。

C.2. 与RFC 4871的兼容性

虽然在本版本的DKIM规范中，“g=”标签已被废弃（因此必须忽略），但建议签名者不要在密钥记录中包含“g=”标签，因为一些符合[RFC4871]的验证器在未来一段时间内仍会使用。

附录D. 邮件用户代理（MUA）注意事项（仅供参考）

在验证DKIM签名时，处理系统有时会将结果提供给收件人的MUA。如何以有助于用户理解的方式呈现这些信息，仍是持续进行的人因可用性研究的课题。通常，MUA会突出显示签名的SDID，试图向用户展示声称负责该消息的身份。实现方式可以是视觉提示（如图形）、在备用视图中显示地址，甚至可能重写原始From地址以显示验证信息。有些MUA会指示哪些头字段受到签名保护。这可以通过对签名的头字段显示正面标识、对未签名的头字段显示负面标识、隐藏未签名的头字段，或这些方法的组合来实现。如果MUA使用视觉提示标识已签名的头字段，可能需要注意不要以可能被最终用户误解为已签名的方式显示未签名的头字段。如果消息中有“l=”标签且其值未延伸到消息末尾，MUA还可能隐藏或标记未签名的正文部分。

上述信息并非详尽无遗。MUA可以选择突出显示、强调、隐藏或以其他方式显示任何其认为对最终用户重要的信息。

附录E. 自RFC 4871以来的变更

- 根据积累的经验，优化了摘要和引言部分。

- 更新了各种参考文献。

- 解决了一些勘误（详见 http://www.rfc-editor.org/）：

  * 1376 已应用

  * 1377 已应用

  * 1378 已应用

  * 1379 已应用

  * 1380 已应用

  * 1381 已应用

  * 1382 已应用

  * 1383 已废弃（不再适用）

  * 1384 已应用

  * 1386 已应用

  * 1461 已应用

  * 1487 已应用

  * 1532 已应用

  * 1596 已应用

以下是英文内容的中文翻译：

```
   o  添加了相关架构文件的介绍部分。

   o  简要讨论了数据完整性问题的介绍部分已添加。

   o  允许一定程度的时钟漂移。

   o  从密钥记录中删除了 "g=" 标签。实现报告指出该标签未被使用。

   o  移除了关于 DNS 中通配符的错误说明。

   o  在大多数地方删除了关于 SMTP 的特定建议。

   o  减少了（非规范性）建议的签名内容列表，并重新整理了该部分的文本。

Crocker 等人              标准轨迹                   [第74页]

RFC 6376                     DKIM 签名               2011年9月

   o  通过重写伪代码，澄清了签名生成算法。

   o  添加了多个术语子部分，引用自 [RFC5672]。同时，在整个文档中开始使用这些术语（例如，SDID、AUID）。

   o  添加了规定输入和输出要求的章节。输入要求解决了工作组提出的安全性问题（另见安全注意事项中的新章节）。输出要求则引用自 [RFC5672]。

   o  添加了讨论与 DomainKeys（[RFC4870]）记录兼容性的附录子部分。

   o  将 [RFC5451] 作为示例，介绍了传达 DKIM 验证结果的方法。

   o  移除了关于 "l=" 签名标签可能用途的建议。

   o  更新了 IANA 注册表。

   o  添加了两个关于格式错误消息攻击的安全注意事项章节。

   o  进行了各种校对编辑。

附录 F. 致谢

   之前的 IETF 版本的 DKIM [RFC4871] 由 Eric Allman、Jon Callas、Mark Delany、Miles Libbey、Jim Fenton 和 Michael Thomas 编辑。

   该规范是经过长时间合作努力的成果，包括 Russ Allbery、Edwin Aoki、Claus Assmann、Steve Atkins、Rob Austein、Fred Baker、Mark Baugher、Steve Bellovin、Nathaniel Borenstein、Dave Crocker、Michael Cudahy、Dennis Dayman、Jutta Degener、Frank Ellermann、Patrik Faeltstroem、Mark Fanto、Stephen Farrell、Duncan Findlay、Elliot Gillum、Olafur Gudmundsson、Phillip Hallam-Baker、Tony Hansen、Sam Hartman、Arvel Hathcock、Amir Herzberg、Paul Hoffman、Russ Housley、Craig Hughes、Cullen Jennings、Don Johnsen、Harry Katz、Murray S. Kucherawy、Barry Leiba、John Levine、Charles Lindsey、Simon Longsdale、David Margrave、Justin Mason、David Mayne、Thierry Moreau、Steve Murphy、Russell Nelson、Dave Oran、Doug Otis、Shamim Pirzada、Juan Altmayer Pizzorno、Sanjay Pol、Blake Ramsdell、Christian Renaud、Scott Renfro、Neil Rerup、Eric Rescorla、Dave Rossetti、Hector Santos、Jim Schaad、Spamhaus.org 团队、Malte S. Stretz、Robert Sanders、Rand Wacker、Sam Weiler 和 Dan Wing。

   早期的 DomainKeys 是 DKIM 的主要来源之一。关于 DomainKeys 的更多信息请参见 [RFC4870]。

   本次修订得到了 Steve Atkins、Mark Delany、J.D. Falk、Jim Fenton、Michael Hammer、Barry Leiba、John Levine、Charles Lindsey、Jeff Macdonald、Franck Martin、Brett McDowell、Doug Otis、Bill Oxley、Hector Santos、Rolf Sonneveld、Michael Thomas 和 Alessandro Vesely 的贡献。

作者联系方式

   Dave Crocker（编辑）
   Brandenburg InternetWorking
   675 Spruce Dr.
   Sunnyvale, CA  94086
   美国

   电话：+1.408.246.8253
   电子邮箱：dcrocker@bbiw.net
   网址：http://bbiw.net

   Tony Hansen（编辑）
   AT&T 实验室
   200 Laurel Ave. South
   Middletown, NJ  07748
   美国

   电子邮箱：tony+dkimsig@maillennium.att.com

   Murray S. Kucherawy（编辑）
   Cloudmark
   128 King St., 2nd Floor
   旧金山，加利福尼亚  94107
   美国

   电子邮箱：msk@cloudmark.com

Crocker 等人              标准轨迹                   [第76页]
```