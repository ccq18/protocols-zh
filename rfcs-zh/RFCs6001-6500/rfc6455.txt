# RFC 6455 中文翻译 (stub)
# 原文文件: ../../rfcs/RFCs6001-6500/rfc6455.txt

互联网工程任务组（IETF）                          I. Fette
意见征求稿编号：6455                                  谷歌公司
标准轨道类别：标准追踪                                    A. Melnikov
ISSN：2070-1721                                               Isode有限公司
                                                           2011年12月


                         WebSocket协议

摘要

   WebSocket协议使得在受控环境中运行不可信代码的客户端与已选择接受该代码通信的远程主机之间实现双向通信成为可能。其所采用的安全模型是基于源的安全模型，通常由网页浏览器使用。该协议由一个开启握手（handshake）开始，随后是基于TCP的基本消息封装。该技术的目标是为基于浏览器的应用提供一种无需打开多个HTTP连接（例如使用XMLHttpRequest或<iframe>及长轮询）即可实现与服务器双向通信的机制。

本备忘录的状态

   这是一个互联网标准追踪文档。

   本文档由互联网工程任务组（IETF）制定，代表IETF社区的共识。它已经过公开审查，并获得互联网工程指导组（IESG）批准发布。关于互联网标准的更多信息，请参见RFC 5741的第2节。

   有关本文件当前状态、任何勘误以及提供反馈的方法，请访问 http://www.rfc-editor.org/info/rfc6455。

版权声明

   本文件的版权归2011年IETF信托及被列为作者的个人所有。保留所有权利。

   本文件受BCP 78和IETF信托关于IETF文件的法律规定（http://trustee.ietf.org/license-info）约束，适用于本文件发布之日。请仔细阅读这些文件，它们描述了您对本文件的权利和限制。从本文件中提取的代码组件必须包括简化BSD许可证文本（详见信托法律规定第4.e节），且提供时不附带任何担保。

Fette & Melnikov             标准追踪                    [第1页]

RFC 6455                 WebSocket协议            2011年12月

目录

   1.  引言 . . . . . . . . . . . . . . . . . . . . . . . . .  4
     1.1.  背景 . . . . . . . . . . . . . . . . . . . . . . .  4
     1.2.  协议概述  . . . . . . . . . . . . . . . . . . . .  5
     1.3.  开始握手  . . . . . . . . . . . . . . . . . . .  6
     1.4.  结束握手  . . . . . . . . . . . . . . . . . . .  9
     1.5.  设计理念  . . . . . . . . . . . . . . . . . .  9
     1.6.  安全模型 . . . . . . . . . . . . . . . . . . 10
     1.7.  与TCP和HTTP的关系 . . . . . . . . . . . . 11
     1.8.  建立连接  . . . . . . . . . . . . . . . . . 11
     1.9.  使用WebSocket协议的子协议  . . . . . . 12
   2.  合规性要求 . . . . . . . . . . . . . . . . . . . 12
     2.1.  术语和其他约定  . . . . . . . . . . . . 13
   3.  WebSocket URI  . . . . . . . . . . . . . . . . . 14
   4.  开始握手  . . . . . . . . . . . . . . . . . . . 14
     4.1.  客户端要求  . . . . . . . . . . . . . . 14
     4.2.  服务器端要求 . . . . . . . . . . . . . 20
       4.2.1.  读取客户端的开始握手  . . . . . . 21
       4.2.2.  发送服务器的开始握手  . . . . . 22
     4.3.  新的握手头字段的ABNF定义  . . . . 25
     4.4.  支持多个WebSocket协议版本  . . . . 26
   5.  数据封装 . . . . . . . . . . . . . . . . . . 27
     5.1.  概述 . . . . . . . . . . . . . . . . . 27
     5.2.  基础封装协议  . . . . . . . . . . . 28
     5.3.  客户端到服务器的掩码处理  . . . 32
     5.4.  分片  . . . . . . . . . . . . . . 33
     5.5.  控制帧  . . . . . . . . . . . . 36
       5.5.1.  关闭  . . . . . . . . . . 36
       5.5.2.  Ping  . . . . . . . . 37
       5.5.3.  Pong  . . . . . . . . 37
     5.6.  数据帧  . . . . . . . . . . 38
     5.7.  示例  . . . . . . . . . . 38
     5.8.  可扩展性  . . . . . . . 39
   6.  发送和接收数据  . . . . . . . 39
     6.1.  发送数据  . . . . . . . 39
     6.2.  接收数据  . . . . . . . 40
   7.  关闭连接  . . . . . . . . . 41
     7.1.  定义  . . . . . . . . 41
       7.1.1.  关闭WebSocket连接  . . . 41
       7.1.2.  启动WebSocket关闭握手  . . 42
       7.1.3.  WebSocket关闭握手已启动  . 42
       7.1.4.  WebSocket连接已关闭  . . 42
       7.1.5.  WebSocket关闭代码  . . . 42

7.1.6. WebSocket连接关闭原因 .............................. 43  
7.1.7. WebSocket连接失败 .................................... 43  
7.2. 异常关闭 ................................................. 44  
7.2.1. 客户端发起的关闭 .................................... 44  
7.2.2. 服务器发起的关闭 .................................... 44  
7.2.3. 从异常关闭中恢复 .................................... 44  
7.3. 正常关闭连接 ............................................ 45  
7.4. 状态码 .................................................. 45  
7.4.1. 已定义的状态码 ...................................... 45  
7.4.2. 保留状态码范围 ...................................... 47  
8. 错误处理 .................................................. 48  
8.1. 处理UTF-8编码数据中的错误 .............................. 48  
9. 扩展 ...................................................... 48  
9.1. 协商扩展 ................................................ 48  
9.2. 已知扩展 ................................................ 50  
10. 安全考虑 ................................................. 50  
10.1. 非浏览器客户端 ........................................ 50  
10.2. 来源（Origin）相关考虑 ................................. 50  
10.3. 对基础设施的攻击（掩码攻击） .......................... 51  
10.4. 实现特定的限制 ........................................ 52  
10.5. WebSocket客户端认证 ................................... 53  
10.6. 连接的机密性与完整性 .................................. 53  
10.7. 处理无效数据 .......................................... 53  
10.8. WebSocket握手中SHA-1的使用 ............................ 54  
11. IANA考虑 ................................................. 54  
11.1. 新URI方案的注册 ........................................ 54  
11.1.1. "ws"方案的注册 .................................... 54  
11.1.2. "wss"方案的注册 ................................... 55  
11.2. "WebSocket" HTTP升级关键词的注册 ....................... 56  
11.3. 新HTTP头字段的注册 .................................... 57  
11.3.1. Sec-WebSocket-Key .................................... 57  
11.3.2. Sec-WebSocket-Extensions ............................... 58  
11.3.3. Sec-WebSocket-Accept .................................. 58  
11.3.4. Sec-WebSocket-Protocol ................................ 59  
11.3.5. Sec-WebSocket-Version ................................. 60  
11.4. WebSocket扩展名注册表 .................................. 61  
11.5. WebSocket子协议名注册表 ................................ 61  
11.6. WebSocket版本号注册表 .................................. 62  
11.7. WebSocket关闭码编号注册表 ............................... 64  
11.8. WebSocket操作码注册表 .................................. 65  
11.9. WebSocket帧头位注册表 .................................. 66  
12. 从其他规范中使用WebSocket协议 ............................ 66  
13. 致谢 ...................................................... 67  
14. 参考文献 .................................................. 68  
14.1. 核心参考文献 .......................................... 68  
14.2. 补充参考文献 .......................................... 69

|Origin| 头字段 [RFC6454] 用于防止网页浏览器中使用 WebSocket API 的脚本对 WebSocket 服务器进行未授权的跨源访问。服务器会获知发起 WebSocket 连接请求的脚本的源（origin）。如果服务器不希望接受来自该源的连接，可以选择通过发送适当的 HTTP 错误码来拒绝连接。该头字段由浏览器客户端发送；对于非浏览器客户端，如果在相应的上下文中合理，也可以发送此头字段。

最后，服务器必须向客户端证明它已收到客户端的 WebSocket 握手，以确保不接受非 WebSocket 连接。这可以防止攻击者通过 XMLHttpRequest [XMLHttpRequest] 或表单提交，向 WebSocket 服务器发送精心构造的数据包，从而欺骗服务器。

为了证明握手已被接收，服务器需要结合两部分信息生成响应。第一部分来自客户端握手中的 |Sec-WebSocket-Key| 头字段：

    Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==

对于此头字段，服务器应取其值（即头字段中的内容，例如去除前后的空白后进行 base64 编码 [RFC4648] 的版本），并将其与全局唯一标识符（GUID，[RFC4122]）"258EAFA5-E914-47DA-95CA-C5AB0DC85B11" 以字符串形式连接。这个 GUID 不太可能被不理解 WebSocket 协议的网络端点使用。然后，服务器对连接后的字符串进行 SHA-1 哈希（160 位）[FIPS.180-3]，并进行 base64 编码（参见 [RFC4648] 第4节），得到的值在服务器的握手响应中返回。

具体来说，例如上述例子中，|Sec-WebSocket-Key| 的值为 "dGhlIHNhbXBsZSBub25jZQ=="，服务器会将字符串 "258EAFA5-E914-47DA-95CA-C5AB0DC85B11" 连接到它，形成 "dGhlIHNhbXBsZSBub25jZQ==258EAFA5-E914-47DA-95CA-C5AB0DC85B11"。然后对该字符串进行 SHA-1 哈希，得到的二进制值再进行 base64 编码，结果为 "s3pPLMBiTxaQ9kYGzzhZRbK+xOo="。此值会在 |Sec-WebSocket-Accept| 头字段中回显。

服务器的握手响应比客户端的握手要简单得多。第一行是状态行，状态码为 101：

    HTTP/1.1 101 Switching Protocols

任何非 101 的状态码都表示 WebSocket 握手未完成，HTTP 的语义仍然适用。状态码后跟随响应头。

|Connection| 和 |Upgrade| 头字段完成 HTTP 升级过程。|Sec-WebSocket-Accept| 头字段表明服务器是否愿意接受连接。如果存在，该字段必须包含客户端在 |Sec-WebSocket-Key| 中发送的随机数（nonce）与预定义的 GUID 的哈希值。任何其他值都不应被视为服务器接受连接的标志。

示例响应如下：

    HTTP/1.1 101 Switching Protocols
    Upgrade: websocket
    Connection: Upgrade
    Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=

客户端会检查这些字段。如果 |Sec-WebSocket-Accept| 的值不符合预期、该字段缺失，或 HTTP 状态码不是 101，连接将不会建立，WebSocket 帧也不会被发送。

还可以包含选项字段。在此版本的协议中，主要的选项字段是 |Sec-WebSocket-Protocol|，它指示服务器已选择的子协议。WebSocket 客户端会验证服务器是否包含了在握手中指定的某个值。支持多子协议的服务器必须根据客户端的握手选择一个子协议，并在握手中明确指出。

示例：

    Sec-WebSocket-Protocol: chat

服务器还可以设置与 cookie 相关的选项字段，用于 _设置_ cookies，如 [RFC6265] 所述。

1.4. 关闭握手

_此部分为非规范性内容。_

关闭握手比起始握手要简单得多。

任一端可以发送带有特定控制序列的控制帧，开始关闭握手（详见第5.5.1节）。收到此类控制帧后，另一端会回应一个 Close 帧（如果尚未发送），然后第一端关闭连接，确信不会有更多数据传输。

在发送指示关闭连接的控制帧后，任何一端都不会再发送数据；在收到指示关闭的控制帧后，另一端会丢弃所有后续接收的数据。

两个端点可以同时发起关闭握手，这是安全的。

关闭握手旨在补充 TCP 的关闭握手（FIN/ACK），因为 TCP 的关闭握手并非总是端到端可靠，尤其在存在拦截代理和中间设备时。

通过发送 Close 帧并等待对方的 Close 帧，可以避免某些情况下数据被不必要地丢失。例如，在某些平台上，如果在接收队列中还有数据时关闭套接字，会发送 RST 包，导致接收端的 recv() 调用失败，即使仍有数据待读取。

1.5. 设计理念

_此部分为非规范性内容。_

WebSocket 协议的设计原则是尽可能少的帧结构（唯一的帧结构是为了使协议由流式转为基于帧的，并支持区分 Unicode 文本和二进制帧）。预期应用层会在 WebSocket 之上叠加元数据，就像应用层（如 HTTP）在 TCP 之上叠加元数据一样。

从概念上讲，WebSocket 实际上只是 TCP 之上的一层，主要功能包括：

- 为浏览器添加基于源的安全模型
- 添加寻址和协议命名机制，以支持在一个端口上运行多个服务和在一个 IP 地址上支持多个主机名
- 在 TCP 之上实现帧机制，回归到 TCP 构建的 IP 数据包机制，但没有长度限制
- 在带内（in-band）加入额外的关闭握手，设计用于在存在代理和中间设备的环境中工作

除此之外，WebSocket 不会添加其他内容。它的目标是尽可能接近直接暴露原始 TCP 给脚本，考虑到 Web 的限制。它还设计成其服务器可以与 HTTP 服务器共享端口，通过使握手成为有效的 HTTP 升级请求。虽然可以用其他协议建立客户端-服务器通信，但 WebSocket 的目标是提供一种相对简单的协议，能与 HTTP 和现有的 HTTP 基础设施（如代理）共存，并在安全考虑下尽可能接近 TCP。它还加入了简化使用和保持简单的设计，比如消息语义的引入。

该协议具有可扩展性，未来版本可能引入多路复用等新概念。

1.6. 安全模型

_此部分为非规范性内容。_

WebSocket 协议采用浏览器使用的源模型，限制网页可以联系 WebSocket 服务器的范围。当 WebSocket 由专用客户端直接使用（即非通过网页浏览器的网页）时，源模型不再适用，因为客户端可以提供任何任意的源字符串。

该协议旨在避免与现有协议（如 SMTP [RFC5321] 和 HTTP）建立连接，同时允许 HTTP 服务器选择支持此协议。这通过严格且复杂的握手过程实现，并限制在握手完成前可以插入到连接中的数据量（从而限制服务器受到的影响）。

同样，协议也旨在避免在向 WebSocket 服务器发送其他协议（尤其是 HTTP）数据时建立连接，例如提交 HTML 表单到 WebSocket 服务器。这主要通过要求服务器证明已读取握手内容实现，只有握手中包含了适当部分，且这些部分只能由 WebSocket 客户端发送，服务器才能成功证明。特别是在撰写本文时，字段以 |Sec-| 开头的字段不能被攻击者仅通过 HTML 和 JavaScript API（如 XMLHttpRequest [XMLHttpRequest]）从网页浏览器设置。

1.7. 与 TCP 和 HTTP 的关系

_此部分为非规范性内容。_

WebSocket 协议是一个独立的基于 TCP 的协议。它与 HTTP 的唯一关系在于，其握手被 HTTP 服务器解释为升级请求。

默认情况下，WebSocket 使用端口 80（普通连接）和端口 443（通过 TLS [RFC2818] 隧道的连接）。

1.8. 建立连接

_此部分为非规范性内容。_

当连接到一个由 HTTP 服务器共享的端口（在端口 80 和 443 上的流量中很常见）时，WebSocket 连接在 HTTP 服务器看来像是一个带有升级提议的普通 GET 请求。在配置较简单、只有一个 IP 地址和单一服务器处理所有流量的场景中，这可能为基于 WebSocket 协议的系统部署提供一种实际途径。在更复杂的环境（如负载均衡、多服务器）中，单独为 WebSocket 连接设置一组主机可能更易于管理。撰写本文时，需注意端口 80 和 443 的连接成功率差异较大，端口 443 的成功率明显更高，但这一情况可能随时间变化。

1.9. 使用 WebSocket 协议的子协议

_此部分为非规范性内容。_

客户端可以在握手中包含 |Sec-WebSocket-Protocol| 字段，向服务器请求使用特定的子协议。如果指定了，服务器必须在响应中包含相同字段及所选的子协议值，连接才能建立。

这些子协议名称应按照第 11.5 节注册。为避免潜在冲突，建议使用包含子协议发起者域名的 ASCII 版本。例如，假设示例公司（Example Corporation）创建了一个名为 "chat" 的子协议，供网页上的多个服务器实现，他们可以命名为 "chat.example.com"。如果示例组织（Example Organization）将其竞争的子协议命名为 "chat.example.org"，那么两个子协议可以由不同的服务器同时实现，服务器会根据客户端发送的值动态选择使用哪个子协议。

子协议可以通过更改名称实现向后不兼容的版本控制，例如从 "bookings.example.net" 改为 "v2.bookings.example.net"。WebSocket 客户端会将它们视为完全不同的子协议。向后兼容的版本控制可以通过重用相同的子协议字符串，但在设计时要考虑支持这种扩展性。

2. 合规性要求

本规范中的所有图示、示例和注释为非规范性内容，所有明确标记为非规范性的章节亦是如此。其余内容均为规范性内容。

本文件中的“必须”、“不得”、“要求”、“应”、“不应”、“建议”、“不建议”、“推荐”、“可以”和“可选”等关键词，均应按照 [RFC2119] 的定义进行解释。

以下是该英文内容的中文翻译：

```
在算法中以祈使句形式表达的需求（例如“去除任何前导空格字符”或“返回false并中止这些步骤”）应按照引入该算法时所用关键词（“MUST”、“SHOULD”、“MAY”等）的含义进行解释。








Fette & Melnikov             标准轨迹                   [第12页]


RFC 6455                 WebSocket协议             2011年12月


以算法或具体步骤表达的符合性要求可以以任何方式实现，只要最终结果等效即可。（特别是，本规范中定义的算法旨在易于理解，并非追求性能。）

2.1 术语与其他约定

_ASCII_ 指的是在[ANSI.X3-4.1986]中定义的字符编码方案。

本文件引用UTF-8值，并使用STD 63 [RFC3629]中定义的UTF-8符号格式。

诸如命名算法或定义的关键术语用 _此_ 表示。

头字段或变量的名称用 |此| 表示。

变量值用 /此/ 表示。

本文提及的“_失败WebSocket连接_”的过程在第7.1.7节中定义。

_将字符串转换为ASCII小写_意味着将范围U+0041到U+005A（即拉丁大写字母A到Z）中的所有字符替换为对应范围U+0061到U+007A（即拉丁小写字母a到z）中的字符。

以_ASCII不区分大小写_的方式比较两个字符串意味着逐码点进行完全相等的比较，除了范围U+0041到U+005A（大写字母A到Z）与范围U+0061到U+007A（小写字母a到z）中的字符被视为匹配。

本文中“URI”一词的定义参照[RFC3986]。

当实现需要作为WebSocket协议的一部分“发送”数据时，实现可以任意延迟实际传输，例如缓冲数据以减少IP包的数量。

注意，本文件在不同章节中同时使用了[RFC5234]和[RFC2616]的ABNF变体。








Fette & Melnikov             标准轨迹                   [第13页]


RFC 6455                 WebSocket协议             2011年12月


3.  WebSocket URI

本规范定义了两种URI方案，使用RFC 5234 [RFC5234]中定义的ABNF语法，以及由URI规范[RFC3986]定义的术语和ABNF产生式。

          ws-URI = "ws:" "//" host [ ":" port ] path [ "?" query ]
          wss-URI = "wss:" "//" host [ ":" port ] path [ "?" query ]

          host = <在[RFC3986]第3.2.2节中定义的host>
          port = <在[RFC3986]第3.2.3节中定义的端口>
          path = <在[RFC3986]第3.3节中定义的路径-可空>
          query = <在[RFC3986]第3.4节中定义的查询>

端口部分是可选的；“ws”方案的默认端口为80，“wss”方案的默认端口为443。

如果方案部分匹配“wss”且不区分大小写，则URI被称为“安全的”，并且据说“安全标志已设置”。

“资源名”（在第4.1节中也称为 /resource name/）可以通过连接以下内容构造：

- 如果路径部分为空，则为“/”
- 路径部分
- 如果查询部分非空，则为“?”
- 查询部分

在WebSocket URI的上下文中，片段标识符毫无意义，且不得在这些URI中使用。与任何URI方案一样，当字符“#”不表示片段起始时，必须将其转义为%23。

4.  建立握手

4.1 客户端要求

为了_建立WebSocket连接_，客户端需要打开连接并发送本节定义的握手请求。连接最初被定义为处于CONNECTING状态。客户端需要提供/host/、/port/、/resource name/和/secure/标志，这些都是第3节中讨论的WebSocket URI的组成部分，以及一份将要使用的/protocols/和/extensions/列表。此外，如果客户端是网页浏览器，还需提供/origin/。








Fette & Melnikov             标准轨迹                   [第14页]


RFC 6455                 WebSocket协议             2011年12月

在受控环境中运行的客户端，例如绑定到特定运营商的移动设备上的浏览器，可以将连接管理的责任委托给网络中的其他代理。在这种情况下，为本规范的目的，客户端被视为包括手机软件和任何此类代理。

当客户端需要_建立WebSocket连接_，给定一组（/host/、/port/、/resource name/和/secure/标志），以及一份/protocols/和/extensions/列表，且在网页浏览器的情况下还包括/origin/，它必须打开连接，发送开启握手，并读取服务器的响应握手。本节将详细说明如何打开连接、应发送什么内容以及如何解释服务器的响应。以下术语将来自第3节，例如“/host/”和“/secure/标志”。

1. 传入此算法的WebSocket URI的组成部分（/host/、/port/、/resource name/和/secure/标志）必须符合第3节中定义的WebSocket URI规范。如果任何组成部分无效，客户端必须_失败WebSocket连接_并中止这些步骤。

2. 如果客户端已经与远程主机（IP地址）通过/host/和/port/对建立了WebSocket连接，即使远程主机由其他名称识别，客户端也必须等待该连接建立或失败。连接中最多只能有一个处于CONNECTING状态。如果尝试同时建立多个到同一IP地址的连接，客户端必须将它们串行化，确保一次只进行一个连接。

   如果客户端无法确定远程主机的IP地址（例如，所有通信都通过执行DNS查询的代理服务器进行），那么在此步骤中，客户端必须假设每个主机名都指向不同的远程主机，并且应限制同时挂起的连接总数为一个合理的低值（例如，客户端可能允许同时挂起到a.example.com和b.example.com的连接，但如果请求同时连接到单一主机的连接数达到30个，则可能不允许）。例如，在网页浏览器环境中，客户端需要考虑用户打开的标签页数量，以设置同时挂起连接的限制。

   注意：这使得脚本更难通过大量打开WebSocket连接来进行拒绝服务攻击。服务器在受到攻击时，可以通过在关闭连接前暂停，进一步减轻自身负载，因为这会降低客户端重新连接的速率。

   注意：客户端与单一远程主机之间已建立的WebSocket连接没有数量限制。服务器可以拒绝接受来自连接数过多的主机/IP地址的连接，或在高负载时断开资源占用过多的连接。

3.  _代理使用_：如果客户端配置为在使用WebSocket协议连接到/host/和/port/时使用代理，则应连接到该代理，并请求其打开到/host/和/port/的TCP连接。

   例如：如果客户端对所有流量都使用HTTP代理，则在尝试连接到example.com的80端口时，可能会向代理服务器发送如下内容：

       CONNECT example.com:80 HTTP/1.1
       Host: example.com

   如果需要密码，连接可能如下：

       CONNECT example.com:80 HTTP/1.1
       Host: example.com
       Proxy-authorization: Basic ZWRuYW1vZGU6bm9jYXBlcyE=

   如果客户端未配置使用代理，则应直接建立到/host/和/port/的TCP连接。

   注意：不提供专门UI选择WebSocket连接代理的实现，建议使用SOCKS5 [RFC1928]代理（如果可用），或者在无法使用SOCKS5时，优先选择为HTTPS配置的代理，而非HTTP代理。

   作为代理自动配置脚本的用途，必须用/host/、/port/、/resource name/和/secure/标志构造URI，遵循第3节中定义的WebSocket URI格式。

   注意：WebSocket协议可以通过代理自动配置脚本中的方案（“ws”表示未加密连接，“wss”表示加密连接）识别。

4. 如果无法打开连接，无论是直接连接失败还是代理返回错误，客户端必须_失败WebSocket连接_并中止连接尝试。

5. 如果/secure/为true，客户端必须在建立连接后、发送握手数据之前，进行TLS握手 [RFC2818]。如果TLS握手失败（例如，服务器证书无法验证），则客户端必须_失败WebSocket连接_并中止连接。否则，之后在此通道上的所有通信都必须通过加密隧道进行 [RFC5246]。

   客户端必须在TLS握手中使用服务器名称指示扩展 [RFC6066]。

一旦与服务器建立了连接（包括通过代理或TLS加密隧道的连接），客户端必须向服务器发送开启握手。握手由HTTP升级请求组成，并附带一份必需和可选的头字段列表。此握手的具体要求如下。

1.  握手必须是符合[RFC2616]规定的有效HTTP请求。

2.  请求的方法必须是GET，HTTP版本必须至少为1.1。

   例如，如果WebSocket URI是“ws://example.com/chat”，则第一个请求行应为“GET /chat HTTP/1.1”。

3.  请求的“Request-URI”部分必须与第3节中定义的/resource name/匹配（相对URI），或是一个绝对的http/https URI，解析后应具有与对应的ws/wss URI相匹配的/resource name/、/host/和/port/。

4.  请求必须包含一个|Host|头字段，其值应包含/host/，可选地后跟“:”和/port/（当未使用默认端口时）。

5.  请求必须包含一个|Upgrade|头字段，其值必须包含“websocket”关键字。

6.  请求必须包含一个|Connection|头字段，其值必须包含“Upgrade”标记。

7.  请求必须包含一个名为|Sec-WebSocket-Key|的头字段。该字段的值必须是一个随机选择的16字节值的nonce，经过base64编码（参见[RFC4648]第4节）。每次连接时，nonce都必须随机生成。

   例如：如果随机选择的值是字节序列0x01 0x02 0x03 0x04 0x05 0x06 0x07 0x08 0x09 0x0a 0x0b 0x0c 0x0d 0x0e 0x0f 0x10，则该头字段的值为“AQIDBAUGBwgJCgsMDQ4PEC==”。

8.  请求必须包含一个名为|Origin| [RFC6454]的头字段（如果请求来自浏览器客户端）。如果来自非浏览器客户端，且该客户端的语义符合此处为浏览器客户端描述的用例，则可以包含此头字段。该字段的值是建立连接的上下文的ASCII序列化的源（origin）。关于此字段值的构造细节，请参见[RFC6454]。
```

以下是英文内容的中文翻译：

```
        例如，如果从 www.example.com 下载的代码试图连接到 ww2.example.com，头字段的值将是 "http://www.example.com"。

   9.   请求必须包含一个名为 |Sec-WebSocket-Version| 的头字段。该头字段的值必须为 13。

        注意：虽然本文件的草案版本（-09、-10、-11 和 -12）已被发布（它们主要由编辑变更和澄清组成，并未对传输协议进行更改），但值 9、10、11 和 12 并未被用作 |Sec-WebSocket-Version| 的有效值。这些值在 IANA 注册表中被保留，但未被使用，也不会被使用。

   10.  请求可以包含一个名为 |Sec-WebSocket-Protocol| 的头字段。如果存在，该值表示一个或多个用逗号分隔的子协议，客户端希望使用，优先级由高到低排序。组成此值的元素必须是非空字符串，字符范围为 U+0021 到 U+007E（不包括定义在 [RFC2616] 中的分隔符字符），且所有字符串都必须是唯一的。该头字段值的 ABNF 表示为 1#token，其构造和规则定义参照 [RFC2616]。

Fette & Melnikov             标准轨迹                   [第18页]

RFC 6455                 WebSocket 协议               2011年12月

   11.  请求可以包含一个名为 |Sec-WebSocket-Extensions| 的头字段。如果存在，该值表示客户端希望使用的协议级扩展。该头字段的解释和格式在第9.1节中描述。

   12.  请求可以包含任何其他头字段，例如 cookies [RFC6265] 和/或与认证相关的头字段，如 |Authorization| 头字段 [RFC2616]，这些将根据定义它们的文档进行处理。

一旦客户端的开场握手已发送，客户端必须等待服务器的响应，然后才能发送任何后续数据。客户端必须按如下方式验证服务器的响应：

   1.  如果从服务器收到的状态码不是 101，客户端应根据 HTTP [RFC2616] 的程序处理响应。特别地，如果收到 401 状态码，客户端可能会进行身份验证；服务器可能会用 3xx 状态码重定向客户端（但客户端不一定要遵循）；等等。否则，继续执行以下步骤。

   2.  如果响应中缺少 |Upgrade| 头字段，或 |Upgrade| 头字段的值不是 "websocket"（不区分大小写的匹配），客户端必须 _WebSocket 连接失败_。

   3.  如果响应中缺少 |Connection| 头字段，或 |Connection| 头字段不包含与 "Upgrade" 不区分大小写匹配的标记，客户端必须 _WebSocket 连接失败_。

   4.  如果响应中缺少 |Sec-WebSocket-Accept| 头字段，或其值不是对 |Sec-WebSocket-Key|（作为字符串，不是 base64 解码）与字符串 "258EAFA5-E914-47DA-95CA-C5AB0DC85B11" 拼接后进行 SHA-1 哈希并用 base64 编码的值（忽略前后空白），客户端必须 _WebSocket 连接失败_。

   5.  如果响应中包含 |Sec-WebSocket-Extensions| 头字段，并且该字段指示使用了未在客户端握手中提出的扩展（服务器指示了未请求的扩展），客户端必须 _WebSocket 连接失败_。（关于如何解析此头字段以确定请求的扩展，详见第9.1节。）

   6.  如果响应中包含 |Sec-WebSocket-Protocol| 头字段，并且该字段指示使用了未在客户端握手中提出的子协议（服务器指示了未请求的子协议），客户端必须 _WebSocket 连接失败_。

如果服务器的响应不符合本节和第4.2.2节中定义的握手要求，客户端必须 _WebSocket 连接失败_。

请注意，根据 [RFC2616]，HTTP 请求和响应中的所有头字段名都是不区分大小写的。

如果验证通过上述方式，响应被视为 _WebSocket 连接已建立_，连接处于 OPEN 状态。 _Extensions In Use_ 被定义为一个（可能为空的）字符串，其值等于服务器握手中提供的 |Sec-WebSocket-Extensions| 头字段的值，或如果该头字段不存在，则为空值。 _Subprotocol In Use_ 被定义为服务器握手中 |Sec-WebSocket-Protocol| 头字段的值，或如果不存在，则为空值。此外，如果服务器握手中的任何头字段指示应设置 cookies（如 [RFC6265] 所定义），这些 cookies 被称为 _在服务器开场握手期间设置的 Cookies_。

4.2.  服务器端要求

服务器可以将连接管理委托给网络上的其他代理，例如负载均衡器和反向代理。在这种情况下，从本规范的角度看，服务器包括从第一个终止 TCP 连接的设备到处理请求并发送响应的服务器的所有部分。

示例：数据中心可能有一台服务器响应 WebSocket 请求并进行适当的握手，然后将连接传递给另一台服务器以实际处理数据帧。就本规范而言，“服务器”是这两台计算机的组合。

4.2.1.  读取客户端的开场握手

当客户端启动 WebSocket 连接时，它会发送其部分的开场握手。服务器必须解析此握手的至少一部分，以获取生成服务器端握手所需的信息。

客户端的开场握手由以下部分组成。如果服务器在读取握手时发现客户端未发送符合以下描述的握手（注意，根据 [RFC2616]，头字段的顺序并不重要），包括但不限于任何违反 ABNF 语法的情况，服务器必须停止处理客户端的握手，并返回带有适当错误码（如 400 Bad Request）的 HTTP 响应。

   1.  一个 HTTP/1.1 或更高版本的 GET 请求，包括一个“Request-URI” [RFC2616]，应被解释为第3节定义的 /资源名/，或包含该资源名的绝对 HTTP/HTTPS URI。

   2.  一个 |Host| 头字段，包含服务器的权威信息。

   3.  一个 |Upgrade| 头字段，值为 "websocket"，视为不区分大小写的 ASCII 值。

   4.  一个 |Connection| 头字段，包含标记 "Upgrade"，视为不区分大小写的 ASCII 值。

   5.  一个 |Sec-WebSocket-Key| 头字段，值为经过 base64 编码（参见 [RFC4648] 第4节）的值，解码后长度为 16 字节。

   6.  一个 |Sec-WebSocket-Version| 头字段，值为 13。

   7.  可选的 |Origin| 头字段。所有浏览器客户端都会发送此字段。不包含此字段的连接请求不应被视为来自浏览器客户端。

   8.  可选的 |Sec-WebSocket-Protocol| 头字段，列出客户端希望使用的协议，按偏好顺序排列。

   9.  可选的 |Sec-WebSocket-Extensions| 头字段，列出客户端希望使用的扩展。此头字段的解释在第9.1节中讨论。

   10.  其他可选头字段，例如用于发送 cookies 或请求认证的字段。未知的头字段将被忽略，遵循 [RFC2616]。

4.2.2.  发送服务器的开场握手

当客户端建立 WebSocket 连接时，服务器必须完成以下步骤以接受连接并发送服务器的开场握手。

   1.  如果连接发生在 HTTPS（HTTP-over-TLS）端口上，执行 TLS 握手。如果失败（例如，客户端在扩展的客户端问候“server_name”扩展中指示的主机名服务器未托管），则关闭连接；否则，之后的所有通信（包括服务器的握手）都必须通过加密隧道进行 [RFC5246]。

   2.  服务器可以执行额外的客户端认证，例如返回 401 状态码并附带相应的 |WWW-Authenticate| 头字段（详见 [RFC2616]）。

   3.  服务器可以使用 3xx 状态码重定向客户端 [RFC2616]。注意，此步骤可以与前述的可选认证步骤同时发生、之前或之后。

   4.  建立以下信息：

       /origin/
          客户端握手中的 |Origin| 头字段指示建立连接的脚本的来源。来源被序列化为 ASCII 并转换为小写。服务器可以使用此信息判断是否接受该连接。如果服务器不验证来源，则会接受任何来源的连接。如果服务器不希望接受此连接，必须返回适当的 HTTP 错误码（如 403 Forbidden）并中止本节描述的 WebSocket 握手。详细信息请参见第10节。

       /key/
          客户端握手中的 |Sec-WebSocket-Key| 头字段包含一个 base64 编码的值，解码后长度为 16 字节。此（编码的）值用于生成服务器的握手，以表示接受连接。服务器无需对 |Sec-WebSocket-Key| 进行 base64 解码。

       /version/
          客户端握手中的 |Sec-WebSocket-Version| 头字段包含客户端尝试使用的 WebSocket 协议版本。如果此版本与服务器理解的版本不符，服务器必须中止本节描述的 WebSocket 握手，并返回适当的 HTTP 错误码（如 426 Upgrade Required），以及一个 |Sec-WebSocket-Version| 头字段，指示服务器支持的版本。

       /resource name/
          代表服务器提供的服务的标识符。如果服务器提供多个服务，则该值应从客户端握手中的“Request-URI” [RFC2616] 中的资源名派生。如果请求的服务不可用，服务器必须返回适当的 HTTP 错误码（如 404 Not Found）并中止 WebSocket 握手。

       /subprotocol/
          表示服务器准备使用的子协议的单一值或 null。所选值必须从客户端握手中的 |Sec-WebSocket-Protocol| 字段中选择（如果有的话），由服务器愿意用于此连接的值中选取。如果客户端握手中没有此类头字段，或服务器不同意任何请求的子协议，则唯一可接受的值为 null。此类字段的缺失等同于 null（意味着如果服务器不愿意同意任何建议的子协议，则不得在响应中发送 |Sec-WebSocket-Protocol| 头字段）。空字符串与 null 不同，也不是此字段的合法值。该头字段值的 ABNF 表示为 (token)，构造和规则定义参照 [RFC2616]。

       /extensions/
          表示服务器准备使用的协议级扩展的（可能为空的）列表。如果服务器支持多个扩展，则该值必须从客户端握手中的 |Sec-WebSocket-Extensions| 字段中选择一个或多个值。此字段的缺失等同于 null。空字符串与 null 不同，也不是此字段的合法值。
```

用途。客户端未列出的扩展名不得列出。关于这些值应如何选择和解释的方法在第9.1节中进行了讨论。

5. 如果服务器选择接受传入的连接，必须回复一个有效的HTTP响应，指示以下内容。

1. 根据RFC 2616 [RFC2616]的状态行，响应码为101。此类响应可能类似于“HTTP/1.1 101 Switching Protocols”。

2. 一个|Upgrade|头字段，值为“websocket”，符合RFC 2616 [RFC2616]的规定。

3. 一个|Connection|头字段，值为“Upgrade”。

4. 一个|Sec-WebSocket-Accept|头字段。该字段的值通过将在第4.2.2节第4步中定义的|key|（在步骤4中定义）与字符串“258EAFA5-E914-47DA-95CA-C5AB0DC85B11”连接，取此连接值的SHA-1哈希，得到一个20字节的值，然后进行Base64编码（参见[RFC4648]第4节），得到最终值。

此头字段的ABNF [RFC2616]定义如下：

Sec-WebSocket-Accept = base64-value-non-empty  
base64-value-non-empty = (1*base64-data [ base64-padding ]) | base64-padding  
base64-data = 4base64-character  
base64-padding = (2base64-character "==") | (3base64-character "=")  
base64-character = ALPHA | DIGIT | "+" | "/"

注意：例如，如果客户端握手中的|Sec-WebSocket-Key|头字段值为“dGhlIHNhbXBsZSBub25jZQ==”，服务器会在其后附加字符串“258EAFA5-E914-47DA-95CA-C5AB0DC85B11”，形成字符串“dGhlIHNhbXBsZSBub25jZQ==258EAFA5-E914-47DA-95CA-C5AB0DC85B11”。然后，服务器对该字符串进行SHA-1哈希，得到的值为0xb3 0x7a 0x4f 0x2c 0xc0 0x62 0x4f 0x16 0x90 0xf6 0x46 0x06 0xcf 0x38 0x59 0x45 0xb2 0xbe 0xc4 0xea。此值随后进行Base64编码，得到“s3pPLMBiTxaQ9kYGzzhZRbK+xOo=”，并在|Sec-WebSocket-Accept|头字段中返回。

5. 可选的|Sec-WebSocket-Protocol|头字段，值为第4步中定义的子协议。

6. 可选的|Sec-WebSocket-Extensions|头字段，值为第4.2.2节第4步中定义的扩展名。如果要使用多个扩展，可以全部列在一个|Sec-WebSocket-Extensions|头字段中，或分布在多个该头字段的实例中。

这完成了服务器的握手。如果服务器在完成这些步骤后没有中止WebSocket握手，认为WebSocket连接已建立，处于OPEN状态。此时，服务器可以开始发送（和接收）数据。

4.3. 新的握手中使用的头字段的ABNF规则总结

本节使用[RFC2616]第2.1节中的ABNF语法/规则，包括“隐含的*LWS规则”。

注意，本节中使用的ABNF约定如下。一些规则的名称对应相应头字段的名称。这些规则描述了相应头字段的值，例如，Sec-WebSocket-Key的ABNF规则描述了|Sec-WebSocket-Key|头字段值的语法。带有“-Client”后缀的ABNF规则仅在客户端发出的请求中使用；带有“-Server”后缀的规则仅在服务器发出的响应中使用。例如，Sec-WebSocket-Protocol-Client的ABNF规则描述了客户端发给服务器的|Sec-WebSocket-Protocol|头字段值的语法。

客户端在握手过程中可以发送的新的头字段包括：

Sec-WebSocket-Key = base64-value-non-empty  
Sec-WebSocket-Extensions = extension-list  
Sec-WebSocket-Protocol-Client = 1#token  
Sec-WebSocket-Version-Client = version

base64-value-non-empty = (1*base64-data [ base64-padding ]) | base64-padding  
base64-data = 4base64-character  
base64-padding = (2base64-character "==") | (3base64-character "=")  
base64-character = ALPHA | DIGIT | "+" | "/"  
extension-list = 1#extension  
extension = extension-token *( ";" extension-param )  
extension-token = registered-token  
registered-token = token

extension-param = token [ "=" (token | quoted-string) ]  
; 使用引号字符串语法变体时，引用字符串后的值必须符合'token'的ABNF。

NZDIGIT = "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"  
version = DIGIT | (NZDIGIT DIGIT) | ("1" DIGIT DIGIT) | ("2" DIGIT DIGIT)  
; 限制在0-255范围内，且无前导零。

服务器在握手过程中可以向客户端发送的新的头字段包括：

Sec-WebSocket-Extensions = extension-list  
Sec-WebSocket-Accept = base64-value-non-empty  
Sec-WebSocket-Protocol-Server = token  
Sec-WebSocket-Version-Server = 1#version

4.4. 支持多个WebSocket协议版本

本节提供一些关于在客户端和服务器中支持多个WebSocket协议版本的指导。

客户端可以利用WebSocket版本广告能力（|Sec-WebSocket-Version|头字段）最初请求其偏好的WebSocket协议版本（不一定是客户端支持的最新版本）。如果服务器支持请求的版本且握手消息其他部分有效，服务器将接受该版本。如果服务器不支持请求的版本，必须用包含所有愿意使用的版本的|Sec-WebSocket-Version|头字段（或多个该头字段实例）作出响应。此时，如果客户端支持其中一个被广告的版本，可以使用新版本值重复WebSocket握手。

以下示例演示上述版本协商过程：

请求示例：
GET /chat HTTP/1.1  
Host: server.example.com  
Upgrade: websocket  
Connection: Upgrade  
...  
Sec-WebSocket-Version: 25

服务器响应可能如下：
HTTP/1.1 400 Bad Request  
...  
Sec-WebSocket-Version: 13, 8, 7

注意，服务器的最后响应也可能如下：
HTTP/1.1 400 Bad Request  
...  
Sec-WebSocket-Version: 13  
Sec-WebSocket-Version: 8, 7

客户端随后重复符合版本13的握手：
GET /chat HTTP/1.1  
Host: server.example.com  
Upgrade: websocket  
Connection: Upgrade  
...  
Sec-WebSocket-Version: 13

任意“应用数据”，占用帧中除“扩展数据”之外的剩余部分。“应用数据”的长度等于有效载荷长度减去“扩展数据”的长度。

基础帧结构协议由以下ABNF [RFC5234]正式定义。需要注意的是，这些数据的表示是二进制的，而非ASCII字符。因此，长度为1比特、取值为%x0或%x1的字段，表示为单个比特，其值为0或1，而不是代表字符“0”或“1”的完整字节（八位组）。长度为4比特、取值在%x0到F之间的字段，也由4个比特表示，而不是ASCII字符或完整字节（八位组）表示这些值。[RFC5234]没有规定字符编码：“规则最终转化为一串终端值，有时称为字符。在ABNF中，字符仅仅是一个非负整数。在某些上下文中，会指定特定的映射（编码）将值映射到字符集（如ASCII）。”这里，指定的编码是二进制编码，每个终端值用指定的比特数编码，不同字段的比特数不同。

---

WebSocket帧结构定义如下（ABNF格式）：

```abnf
ws-frame                = frame-fin
                          / frame-rsv1
                          / frame-rsv2
                          / frame-rsv3
                          / frame-opcode
                          / frame-masked
                          / frame-payload-length
                          [ frame-masking-key ]
                          frame-payload-data

frame-fin               = %x0 ; 该消息是否有后续帧，0表示有，1表示这是最后一帧
                        / %x1 ; 这是该消息的最后一帧

frame-rsv1              = %x0 / %x1 ; 1比特，除非协商另有规定，否则必须为0
frame-rsv2              = %x0 / %x1 ; 1比特，除非协商另有规定，否则必须为0
frame-rsv3              = %x0 / %x1 ; 1比特，除非协商另有规定，否则必须为0

frame-opcode            = frame-opcode-non-control
                        / frame-opcode-control
                        / frame-opcode-cont

frame-opcode-cont       = %x0 ; 续帧
frame-opcode-non-control= %x1 ; 文本帧
                        / %x2 ; 二进制帧
                        / %x3-7 ; 保留，用于未来非控制帧
frame-opcode-control    = %x8 ; 连接关闭
                        / %x9 ; Ping
                        / %xA ; Pong
                        / %xB-F ; 保留，用于未来控制帧

frame-masked            = %x0 ; 未掩码，未携带掩码键
                        / %x1 ; 已掩码，携带掩码键（1比特）

frame-payload-length    = ( %x00-7D ) ; 7比特长度，范围0-125
                        / ( %x7E frame-payload-length-16 ) ; 7+16比特长度
                        / ( %x7F frame-payload-length-63 ) ; 7+64比特长度

frame-payload-length-16 = %x0000-FFFF ; 16比特长度
frame-payload-length-63 = %x0000000000000000-7FFFFFFFFFFFFFFF ; 64比特长度

frame-masking-key       = 4( %x00-FF ) ; 仅在frame-masked为1时存在，4字节（32比特）

frame-payload-data      = (frame-masked-extension-data
                           frame-masked-application-data)
                        / (frame-unmasked-extension-data
                           frame-unmasked-application-data)
                        ; 根据是否掩码，选择相应数据

frame-masked-extension-data     = *( %x00-FF ) ; 未来扩展用，n*8比特
frame-masked-application-data   = *( %x00-FF ) ; n*8比特
frame-unmasked-extension-data   = *( %x00-FF ) ; 未来扩展用，n*8比特
frame-unmasked-application-data = *( %x00-FF ) ; n*8比特
```

### 5.3 客户端到服务器的掩码

- 掩码帧的`frame-masked`字段必须设置为1（见5.2节）。
- 掩码键完全包含在帧中（见5.2节的`frame-masking-key`），用于掩码“有效载荷数据”，包括“扩展数据”和“应用数据”。
- 掩码键由客户端随机选择，必须从允许的32位值集中选取，且不可预测。掩码键应由强熵源生成，不能让服务器或代理轻易预测后续帧的掩码键。掩码键的不可预测性对于防止恶意应用程序操控数据非常重要（参见RFC 4086 [RFC4086]关于安全随机数的讨论）。
- 掩码不会影响“有效载荷数据”的长度。将掩码数据转为未掩码数据（或反之）时，采用以下算法（无论是掩码还是解掩码，步骤相同）：

  ```
  transformed-octet-i = original-octet-i XOR masking-key-octet-j
  其中 j = i MOD 4
  ```

- 有效载荷长度（在帧中由`frame-payload-length`指示）不包括掩码键的长度。它表示“有效载荷数据”的字节数，即掩码键之后的字节数。

### 5.4 分片

- 分片的主要目的是在不知道消息总大小时，避免在开始时就必须缓冲整个消息。若不支持分片，端点必须缓冲整个消息以便在发送第一个字节前计算长度。支持分片后，服务器或中间设备可以选择合理的缓冲区大小，满了就写入一段到网络。
- 另一用途是多路复用，避免单一逻辑通道上的大消息垄断输出通道，从而将消息拆分成更小的片段以更好地共享输出通道（注意：多路复用扩展在本文档中未描述）。
- 除非扩展另有规定，帧没有语义意义。中间设备可以合并或拆分帧（如果未协商扩展，或已协商扩展且理解其规则），但不能依赖特定帧边界。
- 分片规则：
  - 未分片的消息由单个设置了FIN位（见5.2节）且操作码非0的帧组成。
  - 分片的消息由一帧FIN位未设置、操作码非0的帧开始，后续零个或多个FIN位未设置、操作码为0的帧，最后由一帧FIN位设置、操作码为0的帧结束。概念上，分片消息等同于将所有片段的有效载荷拼接成一个大消息，但在有扩展的情况下，可能不成立，因为扩展定义了“扩展数据”的解释。例如，“扩展数据”可能只在第一个片段开始时存在，并应用于后续片段，或者每个片段中都存在“扩展数据”且只适用于该片段。
  - 在没有“扩展数据”的情况下，示例说明分片工作原理：
  
    例子：一个文本消息被分为三个片段，第一个片段操作码为0x1，FIN位未设置；第二个片段操作码为0x0，FIN未设置；第三个片段操作码为0x0，FIN位已设置。

- 控制帧（见5.5节）可以插入到分片中，但控制帧本身不能被分片。
- 消息的所有片段必须按发送顺序传递给接收方。
- 一个消息的所有片段类型（文本、二进制或保留操作码）必须一致，且由第一个片段的操作码决定。
- 除非控制帧不能被插入，否则允许在分片中插入控制帧。
- 发送端可以为非控制消息创建任意大小的片段。
- 客户端和服务器必须支持接收分片和非分片消息。
- 控制帧不能被分片，中间设备不得试图更改控制帧的分片状态。
- 如果使用了保留位且其含义未知，中间设备不得更改消息的分片状态。
- 在协商了扩展的连接中，中间设备不得更改消息的分片状态，除非它理解相关扩展的语义。
- 由于上述规则，消息的所有片段类型（由第一个片段的操作码定义）必须一致，通常为文本、二进制或保留操作码。
- 注意：如果控制帧不能插入，像Ping这样的控制帧延迟会很长，尤其是在大消息后面。因此，支持在分片中处理控制帧是必要的。

### 实现说明
- 在没有扩展的情况下，接收端无需缓冲整个帧即可处理。例如，使用流式API时，可以逐部分传递帧数据给应用程序。但请注意，这一假设可能不适用于未来所有WebSocket扩展。

---

### 5.5 控制帧

- 控制帧由操作码的最高位为1的操作码标识。目前定义的控制帧操作码包括0x8（关闭）、0x9（Ping）和0xA（Pong）。0xB到0xF的操作码预留用于未来定义的控制帧。
- 控制帧用于传达WebSocket的状态信息，可以在分片消息中插入。
- 所有控制帧的有效载荷长度必须不超过125字节，且不能被分片。

#### 5.5.1 关闭帧
- 关闭帧的操作码为0x8。

关闭帧（Close frame）可以包含一个主体（即“应用数据”部分），用以指示关闭的原因，例如一端点正在关闭、接收到的帧过大，或接收到的帧格式不符合预期。如果存在主体，主体的前两个字节必须是一个无符号的2字节整数（以网络字节序表示），代表状态码，具体定义见第7.4节。在这两个字节之后，主体可以包含UTF-8编码的数据，值为/原因/，但其解释不在本规范范围内。这些数据不一定是人类可读的，但可能对调试或传递与开启连接的脚本相关的信息有用。由于这些数据不保证为人类可读，客户端不得将其显示给最终用户。

由客户端发出的关闭帧必须按照第5.3节的规定进行掩码。

应用程序在发送关闭帧后，必须不再发送任何数据帧。

如果一端点收到关闭帧且之前未曾发送关闭帧，则必须立即发送一个关闭帧作为回应（通常会回显收到的状态码）。应尽快完成此操作。端点也可以延迟发送关闭帧，直到当前消息发送完毕（例如，如果大部分碎片化消息已发送完毕，端点可以在发送剩余碎片后再发送关闭帧）。但不能保证已发送关闭帧的端点会继续处理后续数据。

在双方都发送和接收了关闭消息后，端点应认为WebSocket连接已关闭，并必须关闭底层的TCP连接。服务器必须立即关闭TCP连接；客户端应等待服务器关闭连接，但可以在发送和接收关闭消息后任何时间关闭连接，例如，如果在合理时间内未收到服务器的TCP关闭确认。

如果客户端和服务器同时发送关闭消息，双方都已发送和接收了关闭消息，应视为WebSocket连接已关闭，并关闭底层的TCP连接。

5.5.2.  Ping

Ping帧的操作码为0x9。

Ping帧可以包含“应用数据”。

收到Ping帧后，端点必须回应一个Pong帧，除非已收到关闭帧。应尽快回应。Pong帧的相关内容在第5.5.3节中讨论。

端点可以在连接建立后、关闭前的任何时间发送Ping帧。

注意：Ping帧既可以用作保持连接，也可以用来验证远端端点是否仍然响应。

5.5.3.  Pong

Pong帧的操作码为0xA。

第5.5.2节中规定了Ping和Pong帧的共同要求。

回应Ping帧的Pong帧必须具有与被回应的Ping帧中的“应用数据”相同的内容。

如果端点收到Ping帧且尚未对之前的Ping帧发送Pong，则可以选择只对最近处理的Ping帧发送Pong。

Pong帧也可以主动发送，作为单向心跳机制。对主动发送的Pong帧不需要回应。

5.6.  数据帧

数据帧（如非控制帧）由操作码（opcode）标识，且操作码的最高位为0。目前定义的用于数据的操作码包括0x1（文本）和0x2（二进制）。操作码0x3至0x7预留用于未来定义的非控制帧。

数据帧携带应用层和/或扩展层的数据。操作码决定数据的解释方式：

文本

“有效载荷数据”是UTF-8编码的文本数据。注意，某个文本帧可能只包含部分UTF-8序列，但整个消息必须是有效的UTF-8。重组消息中的无效UTF-8将按照第8.1节的规定处理。

二进制

“有效载荷数据”是任意二进制数据，其解释完全由应用层决定。

5.7. 示例

- 单帧未掩码文本消息

  * 0x81 0x05 0x48 0x65 0x6c 0x6c 0x6f（包含“Hello”）

- 单帧掩码文本消息

  * 0x81 0x85 0x37 0xfa 0x21 0x3d 0x7f 0x9f 0x4d 0x51 0x58（包含“Hello”）

- 分片未掩码文本消息

  * 0x01 0x03 0x48 0x65 0x6c（包含“Hel”）

  * 0x80 0x02 0x6c 0x6f（包含“lo”）

- 未掩码的Ping请求与掩码的Ping响应

  * 0x89 0x05 0x48 0x65 0x6c 0x6c 0x6f（包含“Hello”内容，但内容可变）

  * 0x8a 0x85 0x37 0xfa 0x21 0x3d 0x7f 0x9f 0x4d 0x51 0x58（内容为“Hello”，与Ping请求的内容匹配）

- 单个未掩码帧中的256字节二进制消息

  * 0x82 0x7E 0x0100 [256字节二进制数据]

- 单个未掩码帧中的64KiB二进制消息

  * 0x82 0x7F 0x0000000000010000 [65536字节二进制数据]

5.8. 扩展性

该协议设计允许扩展，以增加基础协议的功能。连接的端点必须在开启握手期间协商任何扩展的使用。本规范提供了操作码0x3至0x7和0xB至0xF，以及“扩展数据”字段和帧头中的frame-rsv1、frame-rsv2、frame-rsv3位，用于扩展。扩展的协商在第9.1节中详细讨论。以下是一些预期的扩展用途（此列表既不完整也不具有强制性）：

- “扩展数据”可以放在“应用数据”之前的“有效载荷数据”中。

- 保留位可以为每帧的特殊需求预留。

- 可以定义保留的操作码值。

- 如果需要更多操作码值，可以为操作码字段预留位。

- 可以定义保留位或“扩展”操作码，用以在“有效载荷数据”中分配额外的位，从而定义更大的操作码或更多的每帧位。

6.  发送与接收数据

6.1.  发送数据

要通过WebSocket连接“发送一个包含/data/的WebSocket消息”，端点必须执行以下步骤：

1. 端点必须确保WebSocket连接处于OPEN状态（参见第4.1和4.2.2节）。如果连接状态在任何时候发生变化，端点必须中止后续步骤。

2. 端点必须将/data/封装在第5.2节定义的WebSocket帧中。如果要发送的数据很大，或在开始发送时未能一次性获取全部数据，端点也可以选择将数据拆分成多个帧，按照第5.4节的定义进行封装。

3. 包含数据的第一个帧的操作码（frame-opcode）必须设置为第5.2节中定义的适当值，以便接收端将其解释为文本或二进制数据。

4. 最后一个包含数据的帧的FIN位（frame-fin）必须设置为1（参见第5.2节）。

5. 如果数据由客户端发送，帧必须按照第5.3节的规定进行掩码。

6. 如果已协商任何扩展（第9节），可能还需考虑扩展的相关规定。

7. 形成的所有帧必须通过底层网络连接传输。

6.2.  接收数据

端点通过监听底层网络连接来接收WebSocket数据。收到的数据必须按照第5.2节定义的WebSocket帧进行解析。如果收到控制帧（第5.5节），必须按照第5.5节的规定处理。收到数据帧（第5.6节）后，端点必须根据第5.2节中的操作码（frame-opcode）记下数据的“类型”。该帧的“应用数据”即为消息的/data/。如果该帧是未分片的完整消息（第5.4节），则称“已接收WebSocket消息”，类型为/type/，数据为/data/。如果该帧是碎片化消息的一部分，后续数据帧的“应用数据”将被拼接成/data/。当通过FIN位（frame-fin）指示的最后一个碎片到达时，即表示“已接收WebSocket消息”，数据为/data/（由所有碎片的“应用数据”拼接而成），类型为/type/（由第一个碎片确定）。后续的数据帧应被视为属于新的WebSocket消息。

扩展（第9节）可能会改变数据的读取语义，特别是消息边界的定义。扩展除了在“应用数据”前添加“扩展数据”外，还可以修改“应用数据”的内容（如压缩）。

服务器必须去除从客户端接收的数据帧的掩码（第5.3节）。

7.  关闭连接

7.1.  定义

7.1.1.  关闭WebSocket连接

要“关闭WebSocket连接”，端点必须关闭底层的TCP连接。端点应使用一种优雅关闭TCP连接的方法，同时关闭TLS会话（如适用），并丢弃任何可能已接收的尾部字节。必要时，端点可以采用任何可用手段关闭连接，例如在受到攻击时。

在大多数正常情况下，服务器应首先关闭TCP连接，以使其保持TIME_WAIT状态，而客户端不会（因为这样可以在最大段生存时间（2MSL）内重新打开连接，且TIME_WAIT状态不会影响服务器，因为TIME_WAIT连接在新SYN到来时会立即重新建立）。在异常情况下（如长时间未收到服务器的TCP关闭确认），客户端可以主动发起TCP关闭。因此，当服务器被指示“关闭WebSocket连接”时，应立即发起TCP关闭；当客户端被指示执行相同操作时，应等待服务器发起TCP关闭。

在C语言中使用Berkeley sockets实现优雅关闭的示例：调用shutdown()函数，参数为SHUT_WR，之后调用recv()直到返回值为0（表示对端也已正常关闭），最后调用close()关闭套接字。

7.1.2.  启动WebSocket关闭握手

要“启动WebSocket关闭握手”，端点必须发送一个关闭控制帧（第5.5.1节），其状态码设置为/code/，关闭原因（第7.1.6节）可选，内容为/reason/。一旦端点既发送又接收了关闭控制帧，应按照第7.1.1节的定义“关闭WebSocket连接”。

7.1.3.  WebSocket关闭握手已开始

无论是发送还是接收关闭控制帧，都称为“WebSocket关闭握手已开始”，此时WebSocket连接处于CLOSING状态。

7.1.4.  WebSocket连接已关闭

当底层的TCP连接关闭时，称为“WebSocket连接已关闭”，此时WebSocket连接处于CLOSED状态。如果在WebSocket关闭握手完成后TCP连接才关闭，则称WebSocket连接“已被干净地关闭”。

如果无法建立WebSocket连接，也会说“WebSocket连接已关闭”，但不是“干净地”关闭。

7.1.5 WebSocket连接关闭码

根据第5.5.1和第7.4节的定义，关闭控制帧可能包含一个状态码，用以指示关闭的原因。WebSocket连接的关闭可以由任一端发起，可能同时发生。_WebSocket连接关闭码_定义为应用实现此协议时在第一个收到的关闭控制帧中包含的状态码（第7.4节）。如果该关闭控制帧不包含状态码，则认为关闭码为1005。如果WebSocket已关闭且未收到任何关闭控制帧（例如底层传输连接丢失），则关闭码为1006。

注意：两个端点可能对“WebSocket连接关闭码”的值不一致。例如，远端端点发送了关闭帧，但本地应用尚未从其套接字接收缓冲区读取到包含关闭帧的数据，且本地应用又自主决定关闭连接并发送了关闭帧，那么两个端点都已发送和接收了关闭帧，但可能不会再发送更多的关闭帧。每个端点会将对方发来的状态码视为“WebSocket连接关闭码”。因此，在两个端点“独立启动WebSocket关闭握手”且时间大致相同时，双方可能对“WebSocket连接关闭码”的值不一致。

7.1.6 WebSocket连接关闭原因

根据第5.5.1和第7.4节的定义，关闭控制帧可能包含一个状态码，表示关闭的原因，后面跟着UTF-8编码的数据，这些数据的解释由端点自行决定，不由本协议定义。WebSocket连接的关闭可以由任一端发起，可能同时发生。_WebSocket连接关闭原因_定义为在应用实现此协议时，收到的第一个关闭控制帧中状态码后面的UTF-8编码数据。如果没有此类数据，则为空字符串。

注意：遵循第7.1.5节的逻辑，两个端点可能对“WebSocket连接关闭原因”不一致。

7.1.7 使WebSocket连接失败

某些算法和规范要求端点“使WebSocket连接失败”。为此，客户端必须“关闭WebSocket连接”，并可以以适当方式向用户报告问题（对开发者尤为有用）。同样，服务器也必须“关闭WebSocket连接”，并应记录问题。

如果在端点需要“使WebSocket连接失败”之前，连接已建立，则端点应在关闭连接前，发送带有适当状态码（第7.4节）的关闭帧。端点可以省略发送关闭帧，如果它认为对方不太可能接收或处理关闭帧（例如由于导致连接失败的错误性质）。端点在被指示“使WebSocket连接失败”后，不得继续处理来自远端的任何数据（包括响应的关闭帧）。

除非上述情况或应用层（如使用WebSocket API的脚本）另有说明，客户端不应随意关闭连接。

7.2 异常关闭

7.2.1 客户端发起的关闭

某些算法，特别是在握手期间，要求客户端“使WebSocket连接失败”。为此，客户端必须按照第7.1.7节的定义“使WebSocket连接失败”。

如果在任何时候底层传输层连接意外丢失，客户端必须“使WebSocket连接失败”。

除非上述情况或应用层另有规定（如使用WebSocket API的脚本），客户端不应随意关闭连接。

7.2.2 服务器发起的关闭

某些算法要求或建议服务器在握手期间“中止WebSocket连接”。为此，服务器只需“关闭WebSocket连接”（第7.1.1节）。

7.2.3 从异常关闭中恢复

异常关闭可能由多种原因引起。这类关闭可能是暂时性错误的结果，此时重新连接可能会恢复正常操作。也可能是非暂时性问题，如果每个客户端都经历异常关闭并立即持续尝试重连，服务器可能会遭受类似拒绝服务的攻击。这样的场景可能导致服务无法及时恢复或恢复变得非常困难。

为防止这种情况，客户端在异常关闭后应采用某种退避策略尝试重连。

首次重连应延迟一段随机时间。随机延迟的参数由客户端自行决定；在0到5秒之间随机选择一个值是合理的初始延迟，但客户端也可以根据经验和具体应用选择不同的间隔。

如果首次重连失败，后续重连应逐渐延长延迟时间，采用如截断的二进制指数退避等方法。

7.3 正常关闭连接

服务器可以在任何时候关闭WebSocket连接。客户端不应随意关闭连接。任何一端都应通过遵循“开始WebSocket关闭握手”的程序（第7.1.2节）来发起关闭。

7.4 状态码

在关闭已建立的连接（例如，发送关闭帧后，握手完成后）时，端点可以指示关闭原因。对原因的解释以及端点应采取的措施未在本规范中定义。规范定义了一组预定义的状态码，并规定了哪些范围可以由扩展、框架或终端应用使用。状态码及任何相关的文本消息是关闭帧的可选组成部分。

7.4.1 已定义的状态码

端点在发送关闭帧时，可以使用以下预定义状态码。

1000

表示正常关闭，意味着连接建立的目的已达成。

1001

表示端点“即将离开”，如服务器关闭或浏览器导航到其他页面。

1002

表示端点因协议错误而终止连接。

1003

表示端点因收到无法接受的类型数据（如只理解文本数据的端点收到二进制消息）而终止连接。

1004

保留。未来可能会定义具体含义。

1005

1005是保留值，端点不得在关闭控制帧中设置此状态码。它用于预期状态码应指示没有实际状态码的应用场景。

1006

1006是保留值，端点不得在关闭控制帧中设置此状态码。它用于预期状态码应指示连接异常关闭（如未发送或接收关闭帧）。

1007

表示端点因收到与消息类型不符的数据（如文本消息中含非UTF-8数据）而终止连接。

1008

表示端点因收到违反其策略的消息而终止连接。这是一个通用状态码，在没有更合适状态码（如1003或1009）或需要隐藏具体策略细节时使用。

1009

表示端点因收到过大的消息而终止连接。

1010

表示客户端期望服务器协商一个或多个扩展，但未在WebSocket握手的响应中收到。需要的扩展应在关闭帧的/原因/部分中列出。注意，此状态码不由服务器使用，因为服务器可以直接失败WebSocket握手。

1011

表示服务器因遇到无法满足请求的意外情况而终止连接。

1015

1015是保留值，端点不得在关闭控制帧中设置此状态码。它用于预期状态码应指示因TLS握手失败（如无法验证服务器证书）而关闭连接。

7.4.2 保留状态码范围

0-999

此范围内的状态码未被使用。

1000-2999

此范围内的状态码由本协议、未来修订版或在公开规范中明确的扩展定义。

3000-3999

此范围内的状态码由库、框架和应用程序使用，直接注册于IANA。其具体含义未由本协议定义。

4000-4999

此范围内的状态码为私有使用，不能注册。可由WebSocket应用之间的事先协议使用。其含义未由本协议定义。

8. 错误处理

8.1 处理UTF-8编码数据中的错误

当端点应将字节流解释为UTF-8，但发现该字节流实际上不是有效的UTF-8流时，必须“使WebSocket连接失败”。此规则在握手期间和后续数据交换中均适用。

9. 扩展

WebSocket客户端可以请求扩展，WebSocket服务器可以接受部分或全部请求的扩展。服务器不得响应未被请求的扩展。如果在协商中包含扩展参数，则这些参数必须符合相应扩展的规范。

客户通过包含 |Sec-WebSocket-Extensions| 头字段来请求扩展，该字段遵循HTTP头字段的正常规则（参见 [RFC2616] 第4.2节），且该头字段的值由以下ABNF [RFC2616]定义。注意，本节使用的是 [RFC2616] 中的ABNF语法/规则，包括“隐含的*LWS规则”。如果在协商过程中，客户端或服务器收到的值不符合以下ABNF定义，接收方必须立即_中断WebSocket连接_。

         Sec-WebSocket-Extensions = extension-list
         extension-list = 1#extension
         extension = extension-token *( ";" extension-param )
         extension-token = registered-token
         registered-token = token
         extension-param = token [ "=" (token | quoted-string) ]
             ;当使用引号字符串语法变体时，必须符合
             ;引号字符串反转义后的值应符合'token'的ABNF。

请注意，像其他HTTP头字段一样，此头字段可以在多行中拆分或合并。因此，以下两种写法是等价的：

         Sec-WebSocket-Extensions: foo
         Sec-WebSocket-Extensions: bar; baz=2

等同于

         Sec-WebSocket-Extensions: foo, bar; baz=2

任何使用的extension-token都必须是已注册的令牌（参见第11.4节）。提供的任何扩展参数必须为该扩展定义。注意，客户端仅提供要使用的广告扩展，除非服务器表示希望使用该扩展，否则不得使用它们。

扩展的顺序是有意义的。多个扩展之间的交互可能在定义扩展的文档中有所说明。在没有此类定义的情况下，理解为客户端请求中列出的头字段代表其偏好，列表中越靠前的选项越优先。服务器响应中列出的扩展代表实际在连接中使用的扩展。如果扩展修改了数据和/或帧结构，操作顺序应与服务器在握手响应中列出的顺序一致。

例如，如果有两个扩展“foo”和“bar”，且服务器发送的 |Sec-WebSocket-Extensions| 头字段值为“foo, bar”，那么对数据的操作将按“bar(foo(data))”的顺序进行，无论是对数据本身（如压缩）还是对帧结构的修改（可能会“堆叠”）。

以下是一些非规范示例（为了可读性，长行已折叠）：

         Sec-WebSocket-Extensions: deflate-stream
         Sec-WebSocket-Extensions: mux; max-channels=4; flow-control,
          deflate-stream
         Sec-WebSocket-Extensions: private-extension

服务器通过在 |Sec-WebSocket-Extensions| 头字段中包含一个或多个客户端请求的扩展，来接受一个或多个扩展。对任何扩展参数的解释，以及服务器对客户端请求参数集的有效响应，将由各个扩展自行定义。

9.2 已知扩展

扩展提供了一种机制，允许实现选择性启用额外的协议特性。本文档未定义任何扩展，但实现可以使用单独定义的扩展。

10. 安全注意事项

本节描述了适用于WebSocket协议的一些安全考虑事项。具体的安全考虑将在本节的子节中详细说明。

10.1 非浏览器客户端

WebSocket协议通过检查 |Origin| 头字段（见下文）来保护可信应用（如网页浏览器）内运行的恶意JavaScript。例如，详见第1.6节。对于功能更强大的客户端，这些假设可能不成立。

虽然该协议旨在由网页中的脚本使用，但也可以由主机直接使用。这些主机代表自己行动，因此可能会发送伪造的 |Origin| 头字段，误导服务器。因此，服务器应谨慎，不应假设直接与已知来源的脚本通信，必须考虑到可能以意想不到的方式访问。特别是，服务器不应相信任何输入一定有效。

示例：如果服务器将输入用作SQL查询的一部分，所有输入文本都应在传递给SQL服务器前进行转义，以防止SQL注入。

10.2 来源考虑

不打算处理任何网页输入、仅面向特定站点的服务器，应验证 |Origin| 字段是否为预期的来源。如果指示的来源不可接受，服务器应以HTTP 403 Forbidden状态码响应WebSocket握手。

|Origin| 头字段用于防范未受信任方（通常是执行在可信客户端环境中的JavaScript应用的作者）发起的攻击。客户端可以联系服务器，并通过 |Origin| 头机制，决定是否授予JavaScript应用扩展通信权限。其目的不是阻止非浏览器建立连接，而是确保受信任的浏览器在潜在恶意JavaScript控制下，不能伪造WebSocket握手。

10.3 对基础设施的攻击（掩码机制）

除了端点可能成为WebSocket攻击的目标外，Web基础设施的其他部分（如代理）也可能成为攻击对象。

在协议开发过程中，曾进行一项实验，演示了对代理的攻击，导致缓存代理被污染 [TALKING]。攻击的基本方式是建立到“攻击者”控制的服务器的连接，执行类似WebSocket的HTTP升级，然后在升级连接上发送看似针对特定已知资源（如广泛部署的追踪脚本或广告网络资源）的GET请求的伪造数据。远端服务器会响应类似伪造GET请求的响应，这些响应会被部分中间代理缓存，从而污染缓存。攻击的最终效果是，用户访问攻击者控制的网站时，攻击者可能污染该用户及其背后其他用户的缓存，并在其他源上运行恶意脚本，破坏Web安全模型。

为了避免对已部署中间件的此类攻击，单纯在应用数据前加上不符合HTTP的帧结构是不够的，因为无法穷尽检测所有非符合HTTP的中间件是否跳过此类帧结构并错误处理。为此，采用的防御措施是对客户端到服务器的所有数据进行掩码，防止远端脚本（攻击者）控制数据在传输中的表现，从而无法构造被中间件误解为HTTP请求的消息。

客户端必须为每个帧选择新的掩码密钥，使用不可预测的算法（例如，从强随机数生成器中抽取）。如果使用相同的密钥或存在可识别的密钥选择模式，攻击者可以构造掩码后的消息，使其看似HTTP请求（通过用下一次掩码密钥掩码，将攻击者希望在传输线上看到的消息）。

此外，一旦开始传输某帧，应用层提供的数据（载荷）不得被修改，否则攻击者可以在帧的初始数据为已知值（如全零）时，计算出掩码密钥，然后修改未发送完的帧中的数据，使其在掩码后看似HTTP请求（这与前述使用可预测掩码密钥的问题类似）。如果需要发送额外数据或修改已准备好发送的数据，必须在新帧中用新掩码密钥重新发送。

简而言之，一旦开始传输一帧，远端脚本（应用）不得修改其内容。

此防护模型旨在防止客户端发送看似HTTP请求的数据。因而，必须对客户端到服务器的传输数据进行掩码。服务器到客户端的数据可以伪装成响应，但为了实现此目的，客户端也应能伪造请求。因此，不认为有必要对双向数据都进行掩码（服务器到客户端的数据不掩码）。

尽管掩码提供了保护，但不符合规范的HTTP代理仍可能受到此类攻击的影响，尤其是当客户端和服务器未应用掩码时。

10.4 实现相关限制

具有特定平台或实现限制（如帧大小或多帧重组后总消息大小）的实现，必须防止超出这些限制。例如，恶意端点可能试图耗尽对端的内存，或通过发送单个大帧（如2^60大小）或大量碎片帧（组成碎片化消息）进行拒绝服务攻击。此类实现应对帧大小和重组后总消息大小设置限制。

10.5 WebSocket客户端认证

该协议未规定服务器在WebSocket握手期间如何认证客户端。服务器可以使用任何通用HTTP服务器支持的客户端认证机制，如Cookies、HTTP认证或TLS认证。

10.6 连接的机密性与完整性

连接的机密性和完整性由在TLS（wss URIs）上运行WebSocket协议提供支持。WebSocket实现必须支持TLS，并应在与对端通信时使用TLS。

对于使用TLS的连接，TLS提供的安全性很大程度上取决于TLS握手中协商的算法强度。例如，某些TLS密码机制不提供连接机密性。为了获得合理的保护水平，客户端应仅使用强密码算法。“Web安全上下文：用户界面指南” [W3C.REC-wsc-ui-20100812] 讨论了什么构成强TLS算法。[RFC5246] 在附录A.5和D.3中提供了更多指导。

10.7 无效数据的处理

传入的数据必须始终由客户端和服务器端进行验证。
如果在任何时候，端点收到了它无法理解或违反某些安全标准的数据，或者当端点检测到与预期值不符的握手开启（例如，客户端请求中的路径或来源不正确），端点可以断开TCP连接。如果在成功完成WebSocket握手后收到无效数据，端点应在关闭连接之前，发送一个带有适当状态码（第7.4节）的关闭帧。使用带有适当状态码的关闭帧有助于诊断问题。如果在WebSocket握手期间收到无效数据，服务器应返回一个适当的HTTP [RFC2616]状态码。

一种常见的安全问题是使用错误的编码方式发送文本数据。本协议规定，带有文本数据类型（而非二进制或其他类型）的消息应包含UTF-8编码的数据。虽然仍会指示长度，且实现此协议的应用应使用长度来确定帧的实际结束，但以不正确的编码方式发送数据可能会破坏基于此协议构建的应用的假设，导致数据误解、数据丢失或潜在的安全漏洞。

10.8.  WebSocket握手中SHA-1的使用

本文档描述的WebSocket握手不依赖于SHA-1的任何安全属性，例如碰撞抗性或对第二预像攻击的抗性（如[RFC4270]所述）。

11. IANA考虑事项

11.1. 新的URI方案注册

11.1.1. "ws"方案注册

|ws| URI标识一个WebSocket服务器及其资源名。

方案名称
   ws

状态
   永久

方案语法
   使用RFC5234定义的ABNF语法和RFC3986中的终端符：
   
       "ws:" "//" authority path-abempty [ "?" query ]

其中，<path-abempty>和<query>部分构成发往服务器的资源名，用以标识所需的服务类型。其他组成部分的含义与[RFC3986]中描述的一致。

方案语义
   该方案唯一的操作是使用WebSocket协议建立连接。

编码注意事项
   由上述语法排除的主机部分字符必须按照[RFC3987]或其替代方案，将Unicode字符转换为ASCII。为了方案规范化，IDN形式的主机名及其punycode转换被视为等价（参见[RFC3987]第5.3.3节）。

   其他部分中被排除的字符也必须先用UTF-8编码，再用URI [RFC3986]和IRI [RFC3987]定义的百分比编码形式将对应字节转换为ASCII。

使用此URI方案的应用/协议
   WebSocket协议

互操作性考虑
   使用WebSocket需要HTTP版本1.1或更高。

安全考虑
   详见“安全考虑”部分。

联系方式
   HYBI工作组 <hybi@ietf.org>

作者/变更控制
   IETF <iesg@ietf.org>

参考文献
   RFC 6455

11.1.2. "wss"方案注册

|wss| URI标识一个WebSocket服务器及其资源名，表示该连接上的流量将通过TLS保护（包括TLS的标准优势，如数据机密性、完整性和端点认证）。

方案名称
   wss

状态
   永久

方案语法
   使用RFC5234定义的ABNF语法和RFC3986中的终端符：
   
       "wss:" "//" authority path-abempty [ "?" query ]

其中，<path-abempty>和<query>部分构成发往服务器的资源名，用以标识所需的服务类型。其他组成部分的含义与[RFC3986]中描述的一致。

方案语义
   该方案唯一的操作是使用TLS加密的WebSocket协议建立连接。

编码注意事项
   由上述语法排除的主机部分字符必须按照[RFC3987]或其替代方案，将Unicode字符转换为ASCII。IDN形式的主机名及其punycode转换视为等价（参见[RFC3987]第5.3.3节）。

   其他部分中被排除的字符也必须先用UTF-8编码，再用URI [RFC3986]和IRI [RFC3987]定义的百分比编码形式将对应字节转换为ASCII。

使用此URI方案的应用/协议
   WebSocket协议（通过TLS）

互操作性考虑
   使用WebSocket需要HTTP版本1.1或更高。

安全考虑
   详见“安全考虑”部分。

联系方式
   HYBI工作组 <hybi@ietf.org>

作者/变更控制
   IETF <iesg@ietf.org>

参考文献
   RFC 6455

11.2. WebSocket HTTP升级关键词注册

本节定义了在HTTP升级令牌注册表中注册的关键词，依据RFC 2817 [RFC2817]。

令牌名称
   WebSocket

作者/变更控制
   IETF <iesg@ietf.org>

联系方式
   HYBI <hybi@ietf.org>

参考文献
   RFC 6455

11.3. 新的HTTP头字段注册

11.3.1. Sec-WebSocket-Key

本节描述在永久消息头字段名注册表 [RFC3864] 中注册的头字段。

头字段名
   Sec-WebSocket-Key

适用协议
   http

状态
   标准

作者/变更控制
   IETF

规范文件
   RFC 6455

相关信息
   该头字段仅用于WebSocket开启握手。

Sec-WebSocket-Key头字段在WebSocket开启握手中由客户端发往服务器，用以提供部分信息，帮助服务器证明其已收到有效的WebSocket握手。这有助于确保服务器不会接受来自非WebSocket客户端（如HTTP客户端）的连接，避免被滥用向WebSocket服务器发送数据。

Sec-WebSocket-Key在HTTP请求中不得出现多于一次。

11.3.2. Sec-WebSocket-Extensions

本节描述在永久消息头字段名注册表 [RFC3864] 中注册的头字段。

头字段名
   Sec-WebSocket-Extensions

适用协议
   http

状态
   标准

作者/变更控制
   IETF

规范文件
   RFC 6455

相关信息
   该头字段仅用于WebSocket开启握手。

在WebSocket开启握手中，客户端首先发出该头字段，随后服务器也会发回，用以协商连接期间使用的协议扩展集。

Sec-WebSocket-Extensions可以在HTTP请求中多次出现（逻辑上等同于一个包含所有值的单一头字段），但在HTTP响应中不得出现多于一次。

11.3.3. Sec-WebSocket-Accept

本节描述在永久消息头字段名注册表 [RFC3864] 中注册的头字段。

头字段名
   Sec-WebSocket-Accept

适用协议
   http

状态
   标准

作者/变更控制
   IETF

规范文件
   RFC 6455

相关信息
   该头字段仅用于WebSocket开启握手。

服务器在WebSocket开启握手中发出该头字段，用以确认服务器愿意建立WebSocket连接。该字段在HTTP响应中不得出现多于一次。

11.3.4. Sec-WebSocket-Protocol

本节描述在永久消息头字段名注册表 [RFC3864] 中注册的头字段。

头字段名
   Sec-WebSocket-Protocol

适用协议
   http

状态
   标准

作者/变更控制
   IETF

规范文件
   RFC 6455

相关信息
   该头字段仅用于WebSocket开启握手。

在WebSocket开启握手中，客户端发出该头字段，服务器也会返回，用以确认子协议。这允许脚本选择子协议，并确保服务器同意提供该子协议。

Sec-WebSocket-Protocol可以在HTTP请求中多次出现（逻辑上等同于一个包含所有值的单一头字段），但在HTTP响应中不得出现多于一次。

11.3.5. Sec-WebSocket-Version

本节描述在永久消息头字段名注册表 [RFC3864] 中注册的头字段。

头字段名
   Sec-WebSocket-Version

适用协议
   http

状态
   标准

作者/变更控制
   IETF

规范文件
   RFC 6455

相关信息
   该头字段仅用于WebSocket开启握手。

客户端在WebSocket开启握手中发出该字段，指示连接的协议版本。服务器据此正确解析握手和后续数据，若无法理解则关闭连接。服务器在握手错误时也会向客户端返回该字段，内容为服务器支持的版本列表。

注意：较高版本号不一定向下兼容较低版本。

Sec-WebSocket-Version在HTTP响应中可以多次出现（逻辑上等同于一个包含所有值的单一头字段），但在HTTP请求中不得出现多于一次。

11.4. WebSocket扩展名注册表

本规范创建了一个新的IANA注册表，用于WebSocket扩展名，遵循RFC 5226 [RFC5226]中的原则。

该注册表由IANA维护以下信息：

扩展标识符
   扩展的标识符，用于在第11.3.2节注册的|Sec-WebSocket-Extensions|头字段中。

扩展通用名
   扩展的常用名称。

扩展定义
   说明该扩展的定义文档。

已知的不兼容扩展
   列出与本扩展已知不兼容的其他扩展标识符。

WebSocket扩展名采用“先到先得”的IANA注册政策 [RFC5226]。

此注册表目前无初始值。

11.5. WebSocket子协议名注册表

本规范创建了一个新的IANA注册表，用于WebSocket子协议名，遵循RFC 5226 [RFC5226]中的原则。

该注册表由IANA维护以下信息：

子协议标识符
   子协议的标识符，用于在第11.3.4节注册的|Sec-WebSocket-Protocol|头字段中。

子协议通用名
   子协议的常用名称。

子协议定义
   说明子协议的定义文档。

WebSocket子协议名采用“先到先得”的注册政策 [RFC5226]。

11.6. WebSocket版本号注册表

本规范为WebSocket版本号创建了一个新的IANA注册表，以便按照RFC 5226 [RFC5226]中制定的原则，用于WebSocket协议。

作为该注册表的一部分，IANA维护以下信息：

版本号
- 在本规范第4.1节中规定了用于|Sec-WebSocket-Version|的版本号。该值必须是一个非负整数，范围在0到255（含）之间。

参考
- 请求新版本号或草案名称（见下文）时所引用的文档。

状态
- “临时”或“标准”。具体描述见下文。

一个版本号被指定为“临时”或“标准”。

“标准”版本号在RFC中有文档记录，用于标识WebSocket协议的主要、稳定版本，例如由本RFC定义的版本。“标准”版本号遵循“IETF审查”注册政策 [RFC5226]。

“临时”版本号在互联网草案中有文档记录，用于帮助实现者识别和互操作已部署的WebSocket协议版本，例如在本RFC发布之前开发的版本。“临时”版本号遵循“专家审查”注册政策 [RFC5226]，HYBI工作组的主席（或若工作组关闭，则由IETF应用领域的区域主管）为最初的指定专家。

IANA已在注册表中添加了以下初始值：

+--------+-----------------------------------------+----------+
|版本号  |                参考                    |  状态    |
+--------+-----------------------------------------+----------+
| 0      | draft-ietf-hybi-thewebsocketprotocol-00 | 临时     |
| 1      | draft-ietf-hybi-thewebsocketprotocol-01 | 临时     |
| 2      | draft-ietf-hybi-thewebsocketprotocol-02 | 临时     |
| 3      | draft-ietf-hybi-thewebsocketprotocol-03 | 临时     |
| 4      | draft-ietf-hybi-thewebsocketprotocol-04 | 临时     |
| 5      | draft-ietf-hybi-thewebsocketprotocol-05 | 临时     |
| 6      | draft-ietf-hybi-thewebsocketprotocol-06 | 临时     |
| 7      | draft-ietf-hybi-thewebsocketprotocol-07 | 临时     |
| 8      | draft-ietf-hybi-thewebsocketprotocol-08 | 临时     |
| 9      | 保留                                   |          |
| 10     | 保留                                   |          |
| 11     | 保留                                   |          |
| 12     | 保留                                   |          |
| 13     | RFC 6455                                | 标准     |
+--------+-----------------------------------------+----------+

11.7. WebSocket关闭代码编号注册表

本规范为WebSocket连接关闭代码编号创建了一个新的IANA注册表，遵循RFC 5226 [RFC5226]中的原则。

作为该注册表的一部分，IANA维护以下信息：

状态码
- 表示WebSocket连接关闭原因的状态码，依据本文件第7.4节。状态码为1000到4999之间的整数。

含义
- 状态码的具体含义。每个状态码必须具有唯一的含义。

联系人
- 预留状态码实体的联系方式。

参考
- 请求状态码及定义其含义的稳定文档。对于范围在1000-2999的状态码，此项为必填；对于范围在3000-3999的状态码，建议填写。

WebSocket关闭代码编号的注册要求根据其范围不同而不同。用于本协议及其后续版本或扩展的状态码请求，须遵循“标准行动”、“规范要求”（意味着“指定专家”）或“IESG审查”注册政策，建议在1000-2999范围内。用于库、框架和应用程序的状态码请求，须遵循“先到先得”注册政策，建议在3000-3999范围内。4000-4999范围的状态码为私用，申请时应说明是用于WebSocket协议（或未来版本）、扩展或库/框架/应用程序。

IANA已在注册表中添加了以下初始值：

|状态码|含义|联系人|参考|
|-------|----------------|--------------|--------|
| 1000  | 正常关闭     | hybi@ietf.org | RFC 6455 |
| 1001  | 正在离开     | hybi@ietf.org | RFC 6455 |
| 1002  | 协议错误     | hybi@ietf.org | RFC 6455 |
| 1003  | 不支持的数据 | hybi@ietf.org | RFC 6455 |
| 1004  | ---保留---   | hybi@ietf.org | RFC 6455 |
| 1005  | 无状态码接收 | hybi@ietf.org | RFC 6455 |
| 1006  | 异常关闭     | hybi@ietf.org | RFC 6455 |
| 1007  | 无效帧负载   | hybi@ietf.org | RFC 6455 |
| 1008  | 策略违规     | hybi@ietf.org | RFC 6455 |
| 1009  | 消息过大     | hybi@ietf.org | RFC 6455 |
| 1010  | 必须扩展     | hybi@ietf.org | RFC 6455 |
| 1011  | 服务器内部错误 | hybi@ietf.org | RFC 6455 |
| 1015  | TLS握手      | hybi@ietf.org | RFC 6455 |

11.8. WebSocket操作码注册表

本规范为WebSocket操作码创建了一个新的IANA注册表，遵循RFC 5226 [RFC5226]中的原则。

作为该注册表的一部分，IANA维护以下信息：

操作码
- 表示WebSocket帧的类型，定义在第5.2节。操作码为0到15之间的整数。

含义
- 操作码值的具体含义。

参考
- 请求操作码的规范。

WebSocket操作码编号遵循“标准行动”注册政策 [RFC5226]。

IANA已在注册表中添加了以下初始值：

|操作码|含义|参考|
|-------|------------------|--------|
| 0     | 续传帧           | RFC 6455 |
| 1     | 文本帧           | RFC 6455 |
| 2     | 二进制帧         | RFC 6455 |
| 8     | 连接关闭帧       | RFC 6455 |
| 9     | Ping帧           | RFC 6455 |
| 10    | Pong帧           | RFC 6455 |

11.9. WebSocket帧头位注册表

本规范为WebSocket帧头位创建了一个新的IANA注册表，遵循RFC 5226 [RFC5226]中的原则。该注册表控制第5.2节中标记为RSV1、RSV2和RSV3的位的分配。

这些位为未来版本或扩展预留。

WebSocket帧头位的分配遵循“标准行动”注册政策 [RFC5226]。

12. 从其他规范使用WebSocket协议

WebSocket协议旨在由其他规范使用，为动态用户定义内容提供通用机制，例如在定义脚本API的规范中。

此类规范首先需要“建立WebSocket连接”，提供以下算法：

- 目标地址，包括/host/和/port/。

- 资源名（/resource name/），允许在一个主机和端口上识别多个服务。

- 安全标志（/secure/），若连接为加密连接则为true，否则为false。

- 负责连接的源（origin）[RFC6454]的ASCII序列化。

- （可选）标识在WebSocket连接上层的协议字符串。

/host/、/port/、/resource name/和/secure/标志通常通过解析WebSocket URI的步骤获得。如果URI未指定WebSocket，则解析失败。

如果在任何时候需要关闭连接，规范应使用“关闭WebSocket连接”算法（第7.1.1节）。

第7.1.4节定义了“WebSocket连接关闭”的条件。

在连接开启期间，规范还需处理“已接收WebSocket消息”（第6.2节）等情况。

要向已打开的连接发送数据/data/，规范应使用“发送WebSocket消息”（第6.1节）算法。

13. 致谢

特别感谢Ian Hickson，他是本协议的原始作者和编辑。本规范的初始设计得益于许多WHATWG成员和邮件列表的参与。对该规范的贡献未按章节追踪，但所有贡献者名单可在WHATWG的HTML规范中查看，网址为 http://whatwg.org/html5。

还特别感谢John Tamplin，提供了大量“数据帧”部分的文本。

也感谢Adam Barth，为“数据掩码”部分提供了大量文本和背景研究。

此外，感谢Lisa Dusseault对应用领域的审查（以及帮助启动此项工作）、Richard Barnes的通用艺术审查，以及Magnus Westerlund的传输领域审查。还要感谢HYBI工作组的前任和现任主席们——Joe Hildebrand、Salvatore Loreto和Gabriel Montenegro，他们在幕后不懈努力推动工作进展。最后，特别感谢负责的区域主管Peter Saint-Andre。

感谢以下参与HYBI工作组邮件列表讨论、提出建议和/或提供详细审查的人员（名单可能不完整）：Greg Wilkins、John Tamplin、Willy Tarreau、Maciej Stachowiak、Jamie Lokier、Scott Ferguson、Bjoern Hoehrmann、Julian Reschke、Dave Cridland、Andy Green、Eric Rescorla、Inaki Baz Castillo、Martin Thomson、Roberto Peon、Patrick McManus、Zhong Yu、Bruce Atherton、Takeshi Yoshino、Martin J. Duerst、James Graham、Simon Pieters、Roy T. Fielding、Mykyta Yevstifeyev、Len Holgate、Paul Colomiets、Piotr Kulaga、Brian Raymor、Jan Koehler、Joonas Lehtolahti、Sylvain Hellegouarch、Stephen Farrell、Sean Turner、Pete Resnick、Peter Thorson、Joe Mason、John Fallows、Alexander Philippou。请注意，上述人员未必都认可最终成果。

14. 参考文献

14.1. 必要性参考文献

[ANSI.X3-4.1986]
- 美国国家标准协会，“编码字符集——7位美国信息交换标准代码”，ANSI X3.4，1986。

[FIPS.180-3]
- 美国国家标准与技术研究院，“安全哈希标准”，FIPS PUB 180-3，2008年10月，<http://csrc.nist.gov/publications/fips/fips180-3/fips180-3_final.pdf>。

[RFC1928]
- Leech, M.等，“SOCKS协议第5版”，RFC 1928，1996年3月。

[RFC2119]
- Bradner, S.，“在RFC中用以指示需求级别的关键词”，BCP 14，RFC 2119，1997年3月。

[RFC2616]
- Fielding, R.等，“超文本传输协议——HTTP/1.1”，RFC 2616，1999年6月。

[RFC2817]
- Khare, R.和S. Lawrence，“在HTTP/1.1中升级到TLS”，RFC 2817，2000年5月。

[RFC2818]
- Rescorla, E.，“通过TLS的HTTP”，RFC 2818，2000年5月。

[RFC3629]
- Yergeau, F.，“UTF-8，ISO 10646的变换格式”，STD 63，RFC 3629，2003年11月。

[RFC3864]
- Klyne, G.等，“消息头字段的注册程序”，BCP 90，RFC 3864，2004年9月。

[RFC3986]
- Berners-Lee, T.等，“统一资源标识符（URI）：通用语法”，STD 66，RFC 3986，2005年1月。

[RFC3987]
- Duerst, M.和M. Suignard，“国际化资源标识符（IRIs）”，RFC 3987，2005年1月。

[RFC4086]
- Eastlake, D.等，“安全的随机性要求”，BCP 106，RFC 4086，2005年6月。

[RFC4648]
- Josefsson, S.，“Base16、Base32和Base64数据编码”，RFC 4648，2006年10月。

[RFC5226]
- Narten, T.和H. Alvestrand，“撰写IANA考虑事项部分的指南”，BCP 26，RFC 5226，2008年5月。

[RFC5234]
- Crocker, D.和P. Overell，“增强BNF用于语法规范：ABNF”，STD 68，RFC 5234，2008年1月。

[RFC5246]
- Dierks, T.和E. Rescorla，“传输层安全（TLS）协议第1.2版”，RFC 5246，2008年8月。

[RFC6066]
- Eastlake, D.，“传输层安全（TLS）扩展：扩展定义”，RFC 6066，2011年1月。

[RFC6454]
- Barth, A.，“Web源概念”，RFC 6454，2011年12月。

14.2. 补充性参考文献

以下是英文内容的中文翻译：

```
   [RFC4122]  Leach, P., Mealling, M., 和 R. Salz，“通用唯一标识符（UUID）URN命名空间”，RFC 4122，2005年7月。





Fette 和 Melnikov             标准追踪                   [第69页]


RFC 6455                 WebSocket协议            2011年12月


   [RFC4270]  Hoffman, P. 和 B. Schneier，“互联网协议中的加密哈希攻击”，RFC 4270，2005年11月。

   [RFC5321]  Klensin, J.，“简单邮件传输协议”，RFC 5321，2008年10月。

   [RFC6202]  Loreto, S.，Saint-Andre, P.，Salsano, S.，和 G. Wilkins，“双向HTTP中长轮询和流的已知问题与最佳实践”，RFC 6202，2011年4月。

   [RFC6265]  Barth, A.，“HTTP状态管理机制”，RFC 6265，2011年4月。

   [TALKING]  Huang, L-S.，Chen, E.，Barth, A.，Rescorla, E.，和 C. Jackson，“为了娱乐和盈利而自言自语”，2010年，<http://w2spconf.com/2011/papers/websocket.pdf>。

   [W3C.REC-wsc-ui-20100812]
              Roessler, T. 和 A. Saldhana，“Web安全上下文：用户界面指南”，万维网联盟推荐标准REC-wsc-ui-20100812，2010年8月，
              <http://www.w3.org/TR/2010/REC-wsc-ui/>。

              最新版本可在
              <http://www.w3.org/TR/wsc-ui/> 获取。

   [WSAPI]    Hickson, I.，“WebSocket API”，W3C工作草案WD-websockets-20110929，2011年9月，
              <http://www.w3.org/TR/2011/WD-websockets-20110929/>。

              最新版本可在
              <http://www.w3.org/TR/websockets/> 获取。

   [XMLHttpRequest]
              van Kesteren, A.，编辑，“XMLHttpRequest”，W3C候选推荐标准CR-XMLHttpRequest-20100803，2010年8月，
              <http://www.w3.org/TR/2010/CR-XMLHttpRequest-20100803/>。

              最新版本可在
              <http://www.w3.org/TR/XMLHttpRequest/> 获取。









Fette 和 Melnikov             标准追踪                   [第70页]


RFC 6455                 WebSocket协议            2011年12月


作者联系方式

   Ian Fette
   谷歌公司

   电子邮件：ifette+ietf@google.com
   网址：   http://www.ianfette.com/


   Alexey Melnikov
   Isode有限公司
   5 Castle Business Village
   36 Station Road
   Hampton, Middlesex  TW12 2BX
   英国

   电子邮件：Alexey.Melnikov@isode.com


































Fette 和 Melnikov             标准追踪                   [第71页]
```