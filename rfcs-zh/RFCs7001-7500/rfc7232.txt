# RFC 7232 中文翻译 (stub)
# 原文文件: ../../rfcs/RFCs7001-7500/rfc7232.txt

互联网工程任务组（IETF）                  R. Fielding，主编
征求意见稿：7232                                              Adobe
废止：2616                                              J. Reschke，主编
类别：标准轨道                                              greenbytes
ISSN：2070-1721                                              2014年6月

      超文本传输协议（HTTP/1.1）：条件请求

摘要

   超文本传输协议（HTTP）是一种无状态的应用层协议，用于分布式、协作式超文本信息系统。本文件定义了HTTP/1.1中的条件请求，包括用于指示状态变化的元数据头字段、用于对这些状态设置前提条件的请求头字段，以及在一个或多个前提条件评估为假时构造响应的规则。

本备忘录的状态

   这是一个互联网标准轨道的文档。

   本文件由互联网工程任务组（IETF）制定，代表了IETF社区的共识。它已经过公开审查，并获得互联网工程指导组（IESG）批准发布。关于互联网标准的更多信息，请参见RFC 5741的第2节。

   有关本文件当前状态、任何勘误以及提供反馈的方法，可以访问 http://www.rfc-editor.org/info/rfc7232。



















Fielding & Reschke           标准轨道                    [第1页]


RFC 7232              HTTP/1.1 条件请求                2014年6月


版权声明

   版权所有（c）2014 IETF信托及本文档作者。保留所有权利。

   本文档受BCP 78和IETF信托关于IETF文档的法律规定（http://trustee.ietf.org/license-info）约束，适用于本文档发布之日。请仔细阅读这些文件，它们描述了您对本文件的权利和限制。从本文档中提取的代码组件必须包含简化BSD许可证文本（详见信托法律规定第4.e节），且提供时不附带任何担保。

   本文件可能包含在2008年11月10日之前发布或公开的IETF文档或贡献的内容。这些内容的版权控制人可能未授予IETF信托允许在IETF标准流程之外修改此类内容的权利。在未获得版权控制人充分授权的情况下，不能对本文件进行修改，也不能在IETF标准流程之外创建其衍生作品，除非是为了将其格式化为RFC或翻译成非英语语言。

























Fielding & Reschke           标准轨道                    [第2页]


RFC 7232              HTTP/1.1 条件请求                2014年6月


目录

   1. 引言 ....................................................4
      1.1. 合规性与错误处理 ....................................4
      1.2. 语法符号 ............................................4
   2. 校验器 ..................................................5
      2.1. 弱校验器与强校验器 ..................................5
      2.2. 最后修改时间 ........................................7
           2.2.1. 生成 ..........................................7
           2.2.2. 比较 ..........................................8
      2.3. 实体标签（ETag） ....................................9
           2.3.1. 生成 .........................................10
           2.3.2. 比较 .........................................10
           2.3.3. 示例：内容协商资源的实体标签变化 ............11
      2.4. 何时使用实体标签和最后修改时间 ....................12
   3. 前提条件请求头字段 .....................................13
      3.1. If-Match ..............................................13
      3.2. If-None-Match .........................................14
      3.3. If-Modified-Since .....................................16
      3.4. If-Unmodified-Since ...................................17
      3.5. If-Range ..............................................18
   4. 状态码定义 ...............................................18
      4.1. 304 未修改 ...........................................18
      4.2. 412 前提条件失败 .....................................19
   5. 评估 .....................................................19
   6. 优先级 ...................................................20
   7. IANA考虑事项 ............................................22
      7.1. 状态码注册 ..........................................22
      7.2. 头字段注册 ..........................................22
   8. 安全考虑 ...............................................22
   9. 致谢 ....................................................23
   10. 参考文献 ..............................................24
      10.1. 核心参考 ..........................................24
      10.2. 补充参考 ..........................................24
   附录A. 与RFC 2616的变更 ....................................25
   附录B. 导入的ABNF ...........................................25
   附录C. 收集的ABNF ...........................................26
   索引 .........................................................27










Fielding & Reschke           标准轨道                    [第3页]


RFC 7232              HTTP/1.1 条件请求                2014年6月


1. 引言

   条件请求是HTTP请求（[RFC7231]）的一种，包含一个或多个头字段，用于在应用请求方法到目标资源之前测试某个前提条件。本文件定义了HTTP/1.1中的条件请求机制，依据[RFC7230]中定义的体系结构、语法符号和合规标准。

   条件GET请求是HTTP缓存更新的最高效机制（[RFC7234]）。条件还可以应用于会引起状态变化的方法，如PUT和DELETE，以防止“丢失更新”问题：即一个客户端意外覆盖了另一个并行操作的客户端的工作。

   条件请求的前提条件基于目标资源的整体状态（其当前值集）或在先前获取的表示中观察到的状态（该值集中的某个值）。一个资源可能有多个当前表示，每个表示具有其自身的可观察状态。条件请求机制假设请求到“选定表示”的映射（[RFC7231]第3节）在一段时间内保持一致，前提是服务器打算利用条件请求。无论如何，如果映射不一致且服务器无法选择合适的表示，则在前提条件评估为假时不会造成任何损害。

   本规范（第3节）定义的条件请求前提条件在适用时（第5节）根据其优先级（第6节）进行评估。

1.1. 合规性与错误处理

   本文档中的关键词“必须”、“不得”、“必需”、“应”、“不应”、“建议”、“不建议”、“推荐”、“可以”和“可选”均按[RFC2119]的定义解释。

   关于合规性标准和错误处理的考虑在[RFC7230]第2.5节中定义。

1.2. 语法符号

   本规范采用[RFC5234]中的增强巴科斯-诺尔范式（ABNF）符号，结合[RFC7230]第7节定义的列表扩展，允许用“#”操作符紧凑定义逗号分隔的列表（类似于“*”操作符表示重复）。附录B描述了从其他文档导入的规则，附录C展示了所有列表操作符展开后的标准ABNF语法。

2. 校验器

   本规范定义了两种常用的资源状态观察和测试前提条件的元数据：修改日期（第2.2节）和不透明实体标签（第2.3节）。此外，HTTP的各种扩展（如Web分布式创作与版本控制WebDAV，[RFC4918]）也定义了反映资源状态的其他元数据，但超出了本规范的范围。当在前提条件中使用时，资源的元数据值被称为“校验器”。

2.1. 弱校验器与强校验器

   校验器有两种：强和弱。弱校验器易于生成，但在比较时用途有限。强校验器适合比较，但生成可能非常困难（有时甚至不可能）且效率低下。HTTP不会强制所有资源都使用相同强度的校验器，而是暴露所用校验器的类型，并限制弱校验器作为前提条件的使用场景。

   “强校验器”是指在表示数据发生变化时（即在对GET的200（OK）响应的有效载荷中可观察到的变化）其值也会变化的表示元数据。

   强校验器可能因除表示数据变化之外的原因而变化，例如表示元数据的语义重要部分（如Content-Type）发生变化，但出于服务器的最佳利益，只有在需要使远程缓存和创作工具中的存储响应失效时才改变其值。

   缓存条目可能会无限期存在，无论其过期时间如何。因此，缓存可能会尝试用很久以前获得的校验器验证条目。强校验器在所有与某资源相关的表示版本中是唯一的，但不意味着不同资源的表示之间也具有唯一性（即，同一强校验器可能同时用于多个资源的表示，也不意味着这些表示是等价的）。

   实际中使用的强校验器多种多样。最优的基于严格的版本控制：每次表示变更都生成唯一的节点名和修订号，确保在响应前可用。也可以使用对表示数据应用的抗碰撞哈希函数，只要在响应头发出前已计算好摘要，且每次验证请求不需重新计算摘要即可。若资源存在仅在元数据上不同的多个表示（如内容协商中不同媒体类型但数据格式相同），则需要在校验器中加入额外信息以区分这些表示。

   相反，弱校验器是指在表示数据每次变更时可能不变化的表示元数据。这种弱点可能源于计算值的限制（如时钟分辨率）、无法确保所有表示的唯一性，或资源所有者希望将表示按某种自定义的等价集分组而非唯一序列。服务器应在认为先前的表示不可接受作为当前表示的替代时，更新弱实体标签。换句话说，只要希望缓存失效旧响应，就应更改弱实体标签。

   例如，基于动态测量的每秒变化的天气报告，其表示可以按等价集分组（从服务器角度看）使用相同的弱校验器，以允许缓存的表示在合理时间内有效（可能根据服务器负载或天气状况动态调整）。类似地，若表示的修改时间只以秒为单位，可能也是弱校验器——在单秒内多次修改并在修改间检索的情况下。

   另外，如果两个表示在同一时间共享同一校验器，且它们的表示数据完全相同，则该校验器也是弱的。例如，若服务器对带有gzip内容编码的表示和未编码的表示都使用相同的校验器，则该校验器为弱校验器。但如果两个同时存在的表示仅在表示元数据上不同（如不同的媒体类型），它们可以共享同一个强校验器。

   强校验器适用于所有条件请求，包括缓存验证、部分内容范围和“避免丢失更新”。弱校验器仅在客户端不要求与之前获取的表示数据完全相等时使用，例如验证缓存条目或限制网页遍历只关注近期变化。

2.2. 最后修改时间

   “Last-Modified”头字段在响应中提供一个时间戳，指示服务器认为所选表示最后一次被修改的日期和时间（在处理请求结束时确定）。

     Last-Modified = HTTP-date

   使用示例：

     Last-Modified: Tue, 15 Nov 1994 12:45:26 GMT

2.2.1. 生成

   服务器应为任何可以合理且一致地确定最后修改日期的表示发送Last-Modified头。因为在条件请求和缓存新鲜度评估（[RFC7234]）中使用它，可以显著减少互联网中的HTTP流量，并有助于提升服务的可扩展性和可靠性。

   一个表示通常由多个部分组成，背后是资源接口。最后修改时间通常是这些部分中最后一次变更的时间。具体如何为某个资源确定该值，是超出本规范范围的实现细节。HTTP关心的是，接收者如何利用Last-Modified的值发起条件请求和测试本地缓存响应的有效性。

一个源服务器应尽可能在生成响应的日期字段值时，获取表示的最后修改时间（Last-Modified）值。这可以帮助接收方准确判断资源的修改时间，尤其是在响应生成时间附近资源发生变化时。

具有时钟的源服务器不得发送晚于其消息发出时间（Date）之上的 Last-Modified 日期。如果最后修改时间是由某些实现特定的元数据推导而来，且根据源服务器的时钟显示为未来某个时间，那么源服务器必须用消息发出时间替换该值。这可以防止未来的修改日期对缓存验证产生不良影响。

没有时钟的源服务器不得为响应分配 Last-Modified 值，除非这些值由其他系统或用户（具有可靠时钟）与资源相关联。

2.2.2 比较

当 Last-Modified 时间用作请求中的验证器时，除非可以推断其为强验证器，否则它默认为弱验证器，判断依据如下规则：

- 验证器由源服务器与资源的实际当前验证器进行比较，且源服务器可靠地知道在验证器所涵盖的时间段内，资源没有发生两次变化。

或者

- 客户端在使用 If-Modified-Since、If-Unmodified-Since 或 If-Range 头字段时，缓存中存在对应资源的条目，并且

- 该缓存条目包含一个 Date 值，表示源服务器发送原始响应的时间，以及

- 所提供的 Last-Modified 时间至少比 Date 值早60秒。

或者

- 中间缓存将验证器与其缓存条目中的验证器进行比较，且

- 该缓存条目包含一个 Date 值，表示源服务器发送原始响应的时间，以及

- 所提供的 Last-Modified 时间至少比 Date 值早60秒。

此方法依赖于这样一个事实：如果在同一秒内，源服务器发送了两个不同的响应，但它们的 Last-Modified 时间相同，那么至少其中一个响应的 Date 值会等于其 Last-Modified 时间。60秒的限制是为了防止 Date 和 Last-Modified 值由不同的时钟或在响应准备过程中不同时间生成而引起的问题。如果认为60秒太短，实现可以使用更长的时间。

2.3. ETag

响应中的 "ETag" 头字段提供了当前资源表示的实体标签（entity-tag），由请求处理结束时确定。实体标签是一个不透明的验证器，用于区分同一资源的多个表示，无论这些表示是否因资源状态变化、内容协商（导致同时存在多个有效表示）或两者共同作用而不同。实体标签由一个不透明的引号括起来的字符串组成，可能带有弱验证器前缀。

示例：

```
ETag: "xyzzy"
ETag: W/"xyzzy"
ETag: ""
```

实体标签可以是弱验证器或强验证器，默认为强验证器。如果源服务器提供的实体标签不满足强验证器的所有特性（见第2.1节），则必须用 "W/" 前缀标记为弱验证器。

实体标签在存储修改日期不便、HTTP日期值的秒级分辨率不足或修改日期未被一致维护的情况下，比修改日期更可靠。

生成示例：

```
ETag: "xyzzy"
ETag: W/"xyzzy"
ETag: ""
```

2.3.1 生成

实体标签的设计原则是：只有服务提供者（资源的拥有者）最了解资源的实现，能选择最准确高效的验证机制，并将其映射为一串便于比较的字节序列。由于实体标签是一个不透明值，客户端无需了解其构造方式。

例如，某些实现会用内部版本号（可能结合内容协商的变体标识符）来区分不同表示；其他实现可能用内容的抗碰撞哈希值、文件属性的组合或具有亚秒级分辨率的修改时间。

源服务器应为任何可以合理且一致检测到变化的表示发送实体标签，因为在条件请求和缓存新鲜度验证（[RFC7234]）中使用实体标签，可以显著减少HTTP网络流量，提升服务的可扩展性和可靠性。

2.3.2 比较

实体标签的比较函数有两种，取决于比较上下文是否允许使用弱验证器：

- 强比较：两个实体标签相等当且仅当它们都不是弱验证器且其不透明部分逐字符匹配。

- 弱比较：两个实体标签相等当且仅当其不透明部分逐字符匹配，无论是否标记为“弱”。

示例（以下表格展示不同实体标签对在强和弱比较中的结果）：

| ETag 1 | ETag 2 | 强比较 | 弱比较 |
|---------|---------|---------|---------|
| W/"1"  | W/"1"  | 不匹配 | 匹配    |
| W/"1"  | W/"2"  | 不匹配 | 不匹配  |
| W/"1"  | "1"    | 不匹配 | 匹配    |
| "1"    | "1"    | 匹配   | 匹配    |

2.3.3 示例：内容协商资源的实体标签变化

考虑一个经过内容协商（第3.4节 [RFC7231]）的资源，其响应表示根据请求中的 Accept-Encoding 头字段（第5.3.4节 [RFC7231]）变化：

请求示例：

```
GET /index HTTP/1.1
Host: www.example.com
Accept-Encoding: gzip
```

此时，响应可能使用 gzip 编码，也可能不使用。示例（未使用 gzip）：

```
HTTP/1.1 200 OK
Date: Fri, 26 Mar 2010 00:05:00 GMT
ETag: "123-a"
Content-Length: 70
Vary: Accept-Encoding
Content-Type: text/plain

Hello World!
Hello World!
...
```

如果使用 gzip 编码，响应示例：

```
HTTP/1.1 200 OK
Date: Fri, 26 Mar 2010 00:05:00 GMT
ETag: "123-b"
Content-Length: 43
Vary: Accept-Encoding
Content-Type: text/plain
Content-Encoding: gzip

...二进制数据...
```

注意：内容编码是表示数据的属性，因此内容编码的内容表示（content-encoded representation）必须有不同的实体标签，以避免缓存更新和范围请求时的冲突。而传输编码（第4节 [RFC7230]）仅在消息传输期间应用，不会影响实体标签。

2.4 何时使用实体标签和 Last-Modified 日期

在对 GET 或 HEAD 请求的 200（OK）响应中，源服务器应：

- 除非无法生成，否则应发送实体标签验证器。

- 如果性能考虑支持，应可以发送弱实体标签而非强实体标签，或在无法发送强实体标签时使用。

- 如果可行，应发送 Last-Modified 值。

简而言之，理想情况下，源服务器在成功响应中应同时提供强实体标签和 Last-Modified 值。

客户端应：

- 在任何缓存验证请求（使用 If-Match 或 If-None-Match）中，必须携带源服务器提供的实体标签。

- 如果只提供了 Last-Modified 值（使用 If-Modified-Since），则在非子范围验证请求中（即不使用 Range 请求）应携带该值。

- 如果只提供了 Last-Modified（由 HTTP/1.0 源服务器提供），在子范围验证请求中（使用 If-Unmodified-Since）可以携带该值，用户代理应提供禁用此功能的方式。

- 如果源服务器提供了实体标签和 Last-Modified 值，验证请求应同时携带两者，以支持 HTTP/1.0 和 HTTP/1.1 缓存的正确响应。

If-Match 头字段可以被缓存和中间设备忽略，因为它不适用于已存储的响应。

3.2.  If-None-Match

  "If-None-Match" 头字段使请求方法变为条件性，条件是接收方缓存或源服务器没有目标资源的任何当前表示（当字段值为 "*" 时），或者拥有的某个表示的实体标签（entity-tag）与字段值中列出的不匹配。

  接收方在比较实体标签（Section 2.3.2）时，必须使用弱比较函数，因为即使表示数据发生变化，弱实体标签仍可用于缓存验证。

  例子：
  
  - If-None-Match: "xyzzy"
  - If-None-Match: W/"xyzzy"
  - If-None-Match: "xyzzy", "r2d2xxxx", "c3piozzzz"
  - If-None-Match: W/"xyzzy", W/"r2d2xxxx", W/"c3piozzzz"
  - If-None-Match: *

  主要用于条件GET请求，以在最小的事务开销下高效更新缓存信息。当客户端希望更新一个或多个带有实体标签的存储响应时，应在发起GET请求时生成包含这些实体标签的If-None-Match头字段；这样，接收服务器可以返回304（未修改）状态码，表示其中某个存储响应与所选表示匹配。

  也可以用"*"值的If-None-Match，防止在客户端认为目标资源没有当前表示时，使用不安全的请求方法（如PUT）意外修改资源（参见[RFC7231]第4.2.1节）。这是一种“丢失更新”问题的变体，可能在多个客户端尝试为目标资源创建初始表示时出现。

  接收服务器在收到If-None-Match头字段后，必须在执行请求方法（Section 5）之前评估条件。如果字段值为"*"，且服务器已有目标资源的当前表示，则条件为假；如果字段值为实体标签列表，且其中任何标签与所选表示的实体标签匹配，则条件为假。

  如果条件为假，服务器不得执行请求方法，而应返回：
  - 对于GET或HEAD请求，返回304（未修改）
  - 对于其他请求方法，返回412（预条件失败）

  关于缓存处理收到的If-None-Match头字段的要求，详见[RFC7234]第4.3.2节。

3.3.  If-Modified-Since

  "If-Modified-Since" 头字段使GET或HEAD请求变为条件请求，条件是所选表示的修改日期比字段值中的日期更新。如果没有变化，则避免传输表示数据。

  格式：
  
  - If-Modified-Since = HTTP-date

  示例：
  
  - If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT

  如果请求中包含If-None-Match头字段，接收方必须忽略If-Modified-Since。因为在实际中，If-None-Match提供的条件更为准确，通常优先使用。两者只在为了与不支持If-None-Match的旧中间设备兼容时才会同时使用。

  接收方必须在字段值不是有效HTTP日期或请求方法不是GET或HEAD时忽略If-Modified-Since。

  还应以源服务器的时钟为准，解释If-Modified-Since中的时间戳。

  主要用途：
  1）高效更新没有实体标签的缓存表示；
  2）限制网页遍历范围，只获取最近更改的资源。

  在缓存更新中，通常用缓存消息的Last-Modified字段值生成If-Modified-Since字段。这在时钟不同步或服务器只匹配精确时间戳时最兼容（例如，因源服务器时钟校正或从存档恢复导致的“时间倒退”问题）。有时缓存会用其他数据（如缓存消息的Date头字段或收到消息的本地时间）生成该字段，尤其当缓存消息没有Last-Modified字段时。

  在限制检索范围到近期时间窗口时，用户代理会基于其本地时钟或之前响应中的Date头字段生成If-Modified-Since值。若源服务器只匹配精确时间戳，用户代理可能无法限制数据传输。

  源服务器在收到If-Modified-Since头字段后，应在执行请求（Section 5）前评估条件。如果目标资源的最后修改时间早于或等于字段值，服务器应返回304（未修改），只包含有助于识别或更新缓存的元数据（如ETag、Last-Modified等）。

  关于缓存处理收到的If-Modified-Since头字段的要求，详见[RFC7234]第4.3.2节。

3.4.  If-Unmodified-Since

  "If-Unmodified-Since" 头字段使请求方法变为条件性，条件是目标资源的最后修改日期早于或等于字段值中的日期。与If-Match类似，但当用户代理没有实体标签时使用。

  格式：
  
  - If-Unmodified-Since = HTTP-date

  示例：
  
  - If-Unmodified-Since: Sat, 29 Oct 1994 19:43:31 GMT

  如果请求中包含If-Match头字段，接收方必须忽略If-Unmodified-Since。因为在实际中，If-Match提供的条件更为准确，通常优先使用。两者只在为了与不支持If-Match的旧中间设备兼容时才会同时使用。

  如果字段值不是有效HTTP日期，接收方必须忽略。

  还应以源服务器的时钟为准，解释时间戳。

  主要用于：
  - 以状态变更方法（如POST、PUT、DELETE）防止意外覆盖，尤其在没有实体标签的资源上；
  - 也可用于安全方法，若目标表示未匹配已存储的表示，则中止请求。

  源服务器在收到该头字段后，应在执行请求前评估条件。如果目标资源的最后修改时间比字段值晚，服务器应返回：
  - 412（预条件失败），
  - 或在确认请求请求状态变更且最终状态已反映在目标资源当前状态时，返回2xx（成功）状态码（表示请求已成功，但用户代理未察觉到，因为之前的响应丢失或被其他用户代理更改）。

  在后一种情况下，除非能验证请求是由同一用户代理的前一次变更的重复，否则不应在响应中包含验证器头字段。

  由于不适用已存储响应，缓存和中间设备可以忽略If-Unmodified-Since头字段。

3.5.  If-Range

  "If-Range" 头字段提供一种特殊的条件请求机制，类似于If-Match和If-Unmodified-Since，但指示接收方在验证器不匹配时忽略Range头字段，从而传输新的所选表示而不是返回412（预条件失败）。详见[RFC7233]第3.2节。

4.  状态码定义

4.1.  304 未修改

  304（未修改）状态码表示已收到条件GET或HEAD请求，如果条件为真，应返回200（OK）响应；如果条件为假，则返回304。也就是说，服务器无需传输目标资源的表示，因为客户端已拥有有效的表示，服务器只需引导客户端使用已存储的表示，就像是一个200响应的有效载荷。

  生成304响应的服务器必须包含在200响应中会出现的以下头字段：Cache-Control、Content-Location、Date、ETag、Expires 和 Vary。

  由于304响应的目的是在客户端已有缓存表示时最小化信息传输，除非这些元数据用于引导缓存更新（如Last-Modified可能有用），否则不应生成其他表示元数据。

  关于接收304响应的缓存的要求，详见[RFC7234]第4.3.4节。若条件请求由客户端（如用户代理及其缓存）发起，且通过共享代理转发，代理应将304响应转发给客户端。

  304响应不能包含消息体，必须在头字段后第一个空行后终止。

4.2.  412 预条件失败

  412（预条件失败）状态码表示请求头中的一个或多个条件在服务器端测试时为假。此响应允许客户端对资源状态（当前表示和元数据）设置预条件，从而在资源处于意外状态时阻止请求方法的应用。

5.  评估

  除非下文另有说明，接收缓存或源服务器必须在成功执行正常请求检查后、在执行请求方法（Section 5）之前，评估收到的预条件。如果在没有这些条件的情况下对同一请求的响应不是2xx（成功）或412（预条件失败），则应忽略所有预条件。换句话说，重定向和失败优先于条件请求中的预条件评估。

  非目标资源的源服务器（不能作为目标资源请求的缓存）不得评估本规范定义的条件请求头字段，且在请求转发时应转发它们，因为发起客户端希望由能提供当前表示的服务器进行评估。同样，接收请求时也应忽略这些条件头字段，特别是在请求方法（如CONNECT、OPTIONS、TRACE）不涉及选择或修改表示时。

条件请求头字段由HTTP的扩展定义，可能对所有接收者、目标资源的整体状态或一组资源设置条件。例如，WebDAV中的“If”头字段可以使请求基于多个资源的各种方面（如锁定状态）变为有条件的，前提是接收者理解并实现该字段（[RFC4918]，第10.4节）。

虽然条件请求头字段被定义为可以与HEAD方法一起使用（以保持HEAD的语义与GET一致），但发送有条件的HEAD请求没有实际意义，因为成功响应的大小与304（未修改）响应相差无几，而且比412（预条件失败）响应更有用。

6. 优先级

当请求中存在多个条件请求头字段时，评估这些字段的顺序变得重要。实际上，本规范定义的字段会按照一个一致的逻辑顺序进行实现，因为“丢失更新”预条件比缓存验证要求更严格，经过验证的缓存比部分响应更高效，实体标签（ETag）被认为比日期验证器更准确。

接收者缓存或源服务器必须按照以下顺序评估本规范定义的请求预条件：

1. 如果接收者是源服务器且存在If-Match，评估If-Match预条件：
   - 若条件成立，继续第3步；
   - 若条件不成立，响应412（预条件失败），除非可以确定状态更改请求已成功（参见第3.1节）。

2. 如果接收者是源服务器，且不存在If-Match，但存在If-Unmodified-Since，评估该预条件：
   - 若条件成立，继续第3步；
   - 若条件不成立，响应412（预条件失败），除非可以确定状态更改请求已成功（参见第3.4节）。

3. 如果存在If-None-Match，评估该预条件：
   - 若条件成立，跳到第5步；
   - 若条件对GET/HEAD请求不成立，响应304（未修改）；
   - 若条件对其他请求方法不成立，响应412（预条件失败）。

4. 如果请求方法为GET或HEAD，且不存在If-None-Match，但存在If-Modified-Since，评估该预条件：
   - 若条件成立，跳到第5步；
   - 若条件不成立，响应304（未修改）。

5. 如果请求方法为GET，且Range和If-Range都存在，评估该预条件：
   - 若验证器匹配且Range规范适用于所选表示，响应206（部分内容）[RFC7233]。

6. 否则，
   - 所有条件都满足，执行请求的操作，并根据成功或失败响应。

任何扩展HTTP/1.1的条件请求头字段的定义，都应明确其在评估顺序上的预期，与本规范定义的字段及其他实际存在的条件字段相协调。

7. IANA考虑事项

7.1 状态码注册

“超文本传输协议（HTTP）状态码注册表”位于<http://www.iana.org/assignments/http-status-codes>，已更新以下注册：

| 值   | 描述               | 参考             |
|-------|---------------------|------------------|
| 304   | 未修改             | 第4.1节          |
| 412   | 预条件失败         | 第4.2节          |

7.2 头字段注册

HTTP头字段在<http://www.iana.org/assignments/message-headers/>的“消息头”注册表中注册。本文件定义了以下HTTP头字段，其相关注册已根据永久注册（见[BCP90]）更新：

| 头字段名             | 协议   | 状态     | 参考       |
|---------------------|--------|----------|------------|
| ETag                | http   | 标准     | 第2.3节    |
| If-Match            | http   | 标准     | 第3.1节    |
| If-Modified-Since   | http   | 标准     | 第3.3节    |
| If-None-Match       | http   | 标准     | 第3.2节    |
| If-Unmodified-Since | http   | 标准     | 第3.4节    |
| Last-Modified       | http   | 标准     | 第2.2节    |

变更控制者为：“IETF（iesg@ietf.org）- 互联网工程任务组”。

8. 安全注意事项

本节旨在告知开发者、信息提供者和用户关于HTTP条件请求机制的已知安全隐患。更一般的安全考虑在HTTP的“消息语法与路由”[RFC7230]和“语义与内容”[RFC7231]中已有说明。

本规范定义的验证器并非旨在确保表示的有效性、防止恶意篡改或检测中间人攻击。它们最多能在参与方行为良好的情况下，提高缓存更新效率和实现乐观的并发写入。最坏的情况是条件验证失败，客户端收到的响应与无条件请求的HTTP交换没有本质区别。

实体标签（ETag）可能被滥用，带来隐私风险。例如，某站点可能故意构造语义上无效但对用户或用户代理唯一的实体标签，将其作为长时间有效的缓存响应中的一部分，然后在后续条件请求中读取该标签，以重新识别用户或用户代理。这样的识别标签在用户代理保留原始缓存条目的期间，将成为持久标识符。缓存表示的用户代理应确保在用户执行隐私保护操作（如清除存储的Cookies或切换到隐私浏览模式）时，清除或替换缓存。

9. 致谢

详见[RFC7230]第10节。

10. 参考文献

10.1 必要性参考文献

[RFC2119] Bradner, S.，“用于指示RFC中需求级别的关键词”，BCP 14，RFC 2119，1997年3月。

[RFC5234] Crocker, D.（主编）和P. Overell，“语法规范的增强BNF：ABNF”，STD 68，RFC 5234，2008年1月。

[RFC7230] Fielding, R.（主编）和J. Reschke（主编），“超文本传输协议（HTTP/1.1）：消息语法与路由”，RFC 7230，2014年6月。

[RFC7231] Fielding, R.（主编）和J. Reschke（主编），“超文本传输协议（HTTP/1.1）：语义与内容”，RFC 7231，2014年6月。

[RFC7233] Fielding, R.（主编）、Lafon, Y.（主编）和J. Reschke（主编），“超文本传输协议（HTTP/1.1）：范围请求”，RFC 7233，2014年6月。

[RFC7234] Fielding, R.（主编）、Nottingham, M.（主编）和J. Reschke（主编），“超文本传输协议（HTTP/1.1）：缓存”，RFC 7234，2014年6月。

10.2 说明性参考文献

[BCP90] Klyne, G.、Nottingham, M. 和J. Mogul，“消息头字段的注册程序”，BCP 90，RFC 3864，2004年9月。

[RFC2616] Fielding, R.、Gettys, J.、Mogul, J.、Frystyk, H.、Masinter, L.、Leach, P. 和T. Berners-Lee，“超文本传输协议——HTTP/1.1”，RFC 2616，1999年6月。

[RFC4918] Dusseault, L.（主编），“Web分布式创作与版本控制的HTTP扩展（WebDAV）”，RFC 4918，2007年6月。

10.3 RFC 2616的变更内容

- 扩展并澄清了验证器弱点的定义（第2.1节）。
- 弱实体标签现在允许在所有请求中使用，除了范围请求（第2.1和3.2节）。
- ETag头字段的ABNF已更改，不再使用引号字符串，避免转义问题（第2.3节）。
- 定义了ETag以提供所选表示的实体标签，从而明确其适用范围（如PUT响应）（第2.3节）。
- 评估条件请求的优先级已被定义（第6节）。

10.4 导入的ABNF

核心规则包括在[RFC5234]的附录B.1中定义的：ALPHA（字母）、CR（回车）、CRLF（回车换行）、CTL（控制字符）、DIGIT（数字0-9）、DQUOTE（双引号）、HEXDIG（十六进制字符）、LF（换行）、OCTET（任意8位数据序列）、SP（空格）、VCHAR（可见US-ASCII字符）。

以下规则在[RFC7230]中定义：
- OWS = <OWS，见[RFC7230]第3.2.3节>
- obs-text = <obs-text，见[RFC7230]第3.2.6节>

其他部分定义的规则：
- HTTP-date = <HTTP-date，见[RFC7231]第7.1.1.1节>

10.5 收集的ABNF

在下方的收集ABNF中，列表规则按[RFC7230]第1.2节展开。

ETag = entity-tag

HTTP-date = <HTTP-date，见[RFC7231]第7.1.1.1节>

If-Match = "*" / ( *( "," OWS ) entity-tag *( OWS "," [ OWS entity-tag ] ) )
If-Modified-Since = HTTP-date
If-None-Match = "*" / ( *( "," OWS ) entity-tag *( OWS "," [ OWS entity-tag ] ) )
If-Unmodified-Since = HTTP-date

Last-Modified = HTTP-date

OWS = <OWS，见[RFC7230]第3.2.3节>

entity-tag = [ weak ] opaque-tag
etagc = "!" / %x23-7E ; '#'到'~'
obs-text = <obs-text，见[RFC7230]第3.2.6节>
opaque-tag = DQUOTE *etagc DQUOTE

weak = %x57.2F ; W/

（全文到此结束）