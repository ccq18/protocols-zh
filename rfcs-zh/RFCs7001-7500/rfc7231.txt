# RFC 7231 中文翻译 (stub)
# 原文文件: ../../rfcs/RFCs7001-7500/rfc7231.txt

互联网工程任务组（IETF）                  R. Fielding，主编
意见征求稿：7231                                              Adobe
废止：2616                                              J. Reschke，主编
更新：2817                                                 greenbytes
类别：标准轨道                                              2014年6月
ISSN：2070-1721


     超文本传输协议（HTTP/1.1）：语义与内容

摘要

   超文本传输协议（HTTP）是一种无状态的应用层协议，用于分布式、协作式的超文本信息系统。本文件定义了HTTP/1.1消息的语义，包括请求方法、请求头字段、响应状态码和响应头字段，以及消息的有效载荷（元数据和正文内容）和内容协商机制。

本备忘录的状态

   这是一个互联网标准轨道的文档。

   本文件由互联网工程任务组（IETF）制定，代表IETF社区的共识。已经过公开审查，并由互联网工程指导组（IESG）批准发布。关于互联网标准的更多信息，请参见RFC 5741的第2节。

   有关本文件当前状态、任何勘误以及反馈方式的信息，可在 http://www.rfc-editor.org/info/rfc7231 获取。

（以下为版权声明、目录、引言等内容的翻译省略，全文内容较长，以下为部分节译）

1. 引言

   每个超文本传输协议（HTTP）消息都是请求或响应。服务器在连接上监听请求，解析每个接收的消息，依据目标资源的语义作出响应，返回一个或多个响应消息。客户端构造请求消息以表达特定意图，接收响应后判断意图是否实现，并据此解释结果。本文件定义了HTTP/1.1的请求和响应语义，依据[RFC7230]中的架构。

   HTTP提供了一个统一的接口，用于与资源（第2节）交互，无论其类型、性质或实现方式如何，通过操作和传输表示（第3节）。

   HTTP的语义包括每个请求方法（第4节）所表达的意图、可能在请求头字段中描述的扩展语义、状态码的含义（第6节）以及响应头字段中可能包含的其他控制数据和资源元数据（第7节）。

   本文还定义了描述载荷应如何被接收方解释的表示元数据、可能影响内容选择的请求头字段，以及统称为“内容协商”的各种选择算法（第3.4节）。

1.1. 合规性与错误处理

   本文中的关键词“必须”、“不得”、“要求”、“应”、“不应”、“建议”、“可”、“可选”均按[RFC2119]的定义解释。

   合规性标准和错误处理的考虑在[RFC7230]的第2.5节中定义。

1.2. 语法符号

   本规范采用[RFC5234]定义的增强巴克斯-诺尔范式（ABNF）符号，结合第7节中的列表扩展（在[RFC7230]中定义），允许用“#”操作符紧凑定义逗号分隔的列表（类似“*”操作符表示重复）。附录C描述了从其他文档导入的规则，附录D展示了展开所有列表操作符的标准ABNF语法。

（以下内容为资源、表示、请求方法、头字段、状态码、响应头字段、安全考虑、致谢、参考文献、附录等章节的标题和部分内容的翻译，全文较长，建议根据需要查阅。）

2. 资源

   HTTP请求的目标称为“资源”。HTTP不限制资源的性质，只定义了与资源交互的接口。每个资源由统一资源标识符（URI）唯一标识（第2.7节）。客户端构造HTTP/1.1请求时，会以多种形式（第5.3节）发送目标URI。服务器在接收请求后，重建目标资源的有效请求URI（第5.5节）。

   HTTP的设计目标之一是将资源识别与请求语义分离，这通过将请求语义赋予请求方法（第4节）和少数请求修改头字段（第5节）实现。如果请求方法的语义与URI本身暗示的语义发生冲突（第4.2.1节），则优先采用方法的语义。

3. 表示

   由于资源可以是任何事物，且HTTP提供的统一接口类似于通过消息与另一端的独立实体交互的窗口，因此需要一种抽象来表示（“取代”）该事物的当前或期望状态。这一抽象称为“表示”[REST]。

   对于HTTP而言，“表示”是反映某资源过去、现在或期望状态的信息，格式应能通过协议方便传输，包括一组表示元数据和可能无限的表示数据流。

   源服务器可能提供或能生成多个表示，每个都旨在反映目标资源的当前状态。在这种情况下，源服务器会使用某种算法（通常基于内容协商）选择最适合特定请求的表示。所选表示用于提供条件请求的评估数据（第RFC7232）以及构建对GET请求的200（成功）和304（未修改）响应的载荷。

（后续章节详细定义了表示元数据、处理表示数据、内容编码、内容传输编码等内容。）

……（全文内容较长，以上为部分节译示意）

媒体类型 = type "/" subtype *( OWS ";" OWS parameter )
type = token
subtype = token

类型/子类型后面可以跟随参数，参数以名称=值对的形式出现。

参数 = token "=" ( token / quoted-string )

字段中的type、subtype和参数名都是不区分大小写的。
参数值可能区分大小写，也可能不区分，具体取决于参数名的语义。参数的存在与否可能对媒体类型的处理具有重要意义，这取决于其在媒体类型注册表中的定义。

匹配token产生式的参数值可以作为token传输，也可以放在引号字符串中。引号内和引号外的值是等价的。例如，以下几种写法都表示相同的内容，但为了保持一致性，首选第一种：

  text/html;charset=utf-8
  text/html;charset=UTF-8
  Text/HTML;Charset="utf-8"
  text/html; charset="utf-8"

互联网媒体类型应按照[BCP13]中定义的程序向IANA注册。

注意：与其他头字段中的类似结构不同，媒体类型参数不允许在"="字符两边出现空白字符（即使是“错误”的空白）。

3.1.1.2. 字符集（Charset）

HTTP使用字符集名称来指示或协商文本表示的字符编码方案[RFC6365]。字符集由不区分大小写的token标识。

字符集 = token

字符集名称应按照[RFC2978]中定义的程序在IANA“字符集”注册表中注册（<http://www.iana.org/assignments/character-sets>）。

3.1.1.3. 规范化与文本默认值

为了实现系统间的互操作性，互联网媒体类型应注册为规范形式。通过HTTP传输的表示应采用规范形式，原因与多用途互联网邮件扩展（MIME）[RFC2045]中描述的类似。然而，电子邮件的性能特性（如存储和转发消息）与HTTP和Web（基于服务器的信息服务）有很大不同。此外，为了兼容旧的邮件传输协议，MIME对格式的限制不适用于HTTP（详见附录A）。

MIME的规范形式要求“文本”类型的子类型使用CRLF作为文本行的换行符。HTTP允许传输仅用CR或LF表示换行的文本媒体，只要整个表示中的换行符保持一致。HTTP的发送方可以生成，接收方必须能够解析由CRLF、CR或LF组成的换行符。此外，HTTP中的文本媒体不限于使用字节13（CR）和10（LF）作为换行符的字符集。这种对换行符的灵活性仅适用于被赋予“text”媒体类型的表示中的文本，不适用于“multipart”类型或载荷体之外的HTTP元素（如头字段）。

如果表示采用内容编码（content-coding）进行编码，则其底层数据在编码前应符合上述定义的格式。

3.1.1.4. 多部分类型（Multipart Types）

MIME定义了多种“multipart”类型——在单个消息体中封装一个或多个表示。所有multipart类型共享一种通用语法，详见[RFC2046]第5.1.1节，并在媒体类型值中包含boundary参数。消息体本身是协议元素；发送方必须只使用CRLF表示各部分之间的换行。

HTTP消息框架不使用boundary作为消息体长度的指示，但在生成或处理载荷的实现中可能会用到。例如，"multipart/form-data"类型常用于携带表单数据（详见[RFC2388]），而"multipart/byteranges"类型由本规范定义，用于某些206（部分内容）响应中（详见[RFC7233]）。

3.1.1.5. 内容类型（Content-Type）

"Content-Type"头字段指示关联表示的媒体类型：可以是消息载荷中的表示，也可以是根据消息语义选择的表示。所指示的媒体类型定义了数据的格式以及接收方在接收消息后，解码任何由Content-Encoding指示的内容编码后，打算如何处理这些数据。

内容类型 = media-type

媒体类型在第3.1.1.1节中定义。示例：

  Content-Type: text/html; charset=ISO-8859-4

如果生成包含载荷体的消息的发送方，除非其不知道所包含表示的媒体类型，否则应在该消息中包含Content-Type头字段。如果没有提供Content-Type头字段，接收方可以假设媒体类型为"application/octet-stream"（[RFC2046]第4.5.1节），或自行检查数据以确定其类型。

实际上，资源所有者并不总是正确配置其源服务器以提供正确的Content-Type，导致一些客户端会检查载荷内容并覆盖指定的类型。这种做法可能导致错误的结论，增加安全风险（如“权限提升”）。此外，仅通过检查数据格式无法判断发送者的意图：许多数据格式对应多个仅在处理语义上不同的媒体类型。建议实现者提供禁用“内容嗅探”的机制。

3.1.2. 编码（Encoding）用于压缩或完整性

3.1.2.1. 内容编码（Content Codings）

内容编码值表示已应用或可以应用于表示的编码变换。内容编码主要用于在不丢失底层媒体类型身份和信息的前提下，对表示进行压缩或其他有用的变换。通常，表示以编码形式存储、直接传输，只有在最终接收方解码。

内容编码 = token

所有内容编码值不区分大小写，应在“HTTP内容编码注册表”中注册（详见第8.4节）。它们在Accept-Encoding（第5.3.4节）和Content-Encoding（第3.1.2.2节）头字段中使用。

本规范定义的内容编码值包括：

  - compress（和x-compress）：详见[RFC7230]第4.2.1节。
  - deflate：详见[RFC7230]第4.2.2节。
  - gzip（和x-gzip）：详见[RFC7230]第4.2.3节。

3.1.2.2. 内容编码（Content-Encoding）

"Content-Encoding"头字段指示在媒体类型固有编码之外，应用到表示上的内容编码，从而说明需要应用哪些解码机制以获得Content-Type头字段所指的媒体类型数据。Content-Encoding主要用于在不丢失底层媒体类型身份的情况下，对表示的数据进行压缩。

内容编码 = 1#content-coding

示例：

  Content-Encoding: gzip

如果对表示应用了一个或多个编码，应用编码的发送方必须生成一个列出所有内容编码的Content-Encoding头字段，顺序为应用顺序。关于编码参数的其他信息可以由本规范未定义的其他头字段提供。

不同于传输编码（Transfer-Encoding，第3.3.1节[RFC7230]），Content-Encoding中列出的编码是表示的特性；表示本身是以编码形式定义的，除非元数据定义中另有说明，否则所有关于表示的其他元数据都与编码形式相关。通常，表示只在渲染或类似用途之前解码。

如果媒体类型本身包含固有编码（如总是压缩的数据格式），即使编码算法相同，也不会在Content-Encoding中重复列出。只有在某些特殊情况下，为了某些奇怪的原因，编码会被再次应用以形成表示。类似地，源服务器可能会发布多种不同编码方式的相同数据表示，区别仅在于编码是否作为Content-Type的一部分或Content-Encoding的一部分定义，因为不同的用户代理在处理每个响应时可能表现不同（例如，弹出“另存为...”对话框，而不是自动解压和渲染内容）。

如果请求中的表示采用了不被接受的内容编码，源服务器可以返回415（不支持的媒体类型）状态码。

3.1.3. 受众语言（Audience Language）

3.1.3.1. 语言标签（Language Tags）

语言标签由[RFC5646]定义，用于标识人类用以交流信息的自然语言。计算机语言被明确排除在外。

HTTP在Accept-Language和Content-Language头字段中使用语言标签。Accept-Language使用第5.3.5节定义的更宽泛的language-range产生式，而Content-Language使用下面定义的language-tag产生式。

  language-tag = <Language-Tag, 见[RFC5646], 第2.1节>

语言标签是由一个或多个不区分大小写的子标签组成，子标签之间用连字符（“-”，%x2D）连接。在大多数情况下，语言标签由一个主要子标签（标识一类相关语言，例如“en”代表英语）组成，后面可以跟一系列细化或缩小范围的子标签（例如“en-CA”代表加拿大使用的英语变体）。标签中不允许有空白字符。示例标签包括：

  fr, en-US, es-419, az-Arab, x-pig-latin, man-Nkoo-GN

详见[RFC5646]。

3.1.3.2. 内容语言（Content-Language）

"Content-Language"头字段描述表示的目标受众的自然语言。注意，这可能不等同于表示中使用的所有语言。

内容语言 = 1#language-tag

标签定义详见第3.1.3.1节。Content-Language的主要作用是让用户根据自己的偏好识别和区分不同的表示。例如，如果内容仅面向丹麦语读者，合适的字段是：

  Content-Language: da

如果未指定Content-Language，默认表示内容面向所有语言受众。这可能意味着发送方未将其视为特定自然语言，或不知道其目标语言。

对于面向多种受众的内容，可以列出多种语言。例如，一份“怀唐伊条约”的译本，既有毛利语原文，也有英文版本，应该写为：

  Content-Language: mi, en

但仅因为表示中包含多种语言，并不意味着它面向多种语言受众。例如，一本初学者的语言教材，如《拉丁语入门》，显然是面向英语读者的。在这种情况下，Content-Language应只包括“en”。

Content-Language可以应用于任何媒体类型，不仅限于文本文件。

3.1.4. 识别（Identification）

3.1.4.1. 识别表示（Identifying a Representation）

当完整或部分表示在消息载荷中传输时，通常希望发送方提供，或接收方自行确定，与该表示对应的资源的标识符。

对于请求消息：

- 如果请求包含Content-Location头字段，则发送方声明载荷是由Content-Location字段值标识的资源的表示。但除非能通过其他方式验证（本规范未定义），否则此声明不能被信任。该信息仍可能对修订历史链接有用。

- 否则，载荷未被识别。

对于响应消息，按照以下规则依次尝试，直到找到匹配项：

1. 如果请求方法是GET或HEAD，并且响应状态码为200（OK）、204（无内容）、206（部分内容）或304（未修改），那么负载是由有效请求URI所标识资源的表现形式（参见[RFC7230]第5.5节）。

2. 如果请求方法是GET或HEAD，并且响应状态码为203（非权威信息），那么负载是由中间实体提供的目标资源的可能已被修改或增强的表现形式。

3. 如果响应中包含Content-Location头字段，并且其字段值引用的URI与有效请求URI相同，那么负载是由该URI所标识资源的表现形式。

4. 如果响应中包含Content-Location头字段，并且其字段值引用的URI不同于有效请求URI，则发送方声称负载是由Content-Location字段值所标识资源的表现形式。然而，除非能通过其他方式（本规范未定义）验证，否则不能相信此类声明。

5. 否则，负载无法确定。

3.1.4.2. 内容位置（Content-Location）

“Content-Location”头字段引用一个URI，可以作为与本消息负载中的表现形式对应的特定资源的标识符。换句话说，如果在生成此消息时对该URI执行GET请求，则200（OK）响应将包含与本消息负载中所包含的表现形式相同的内容。

Content-Location = 绝对URI / 部分URI

Content-Location的值不是有效请求URI的替代（参见[RFC7230]第5.5节），它是表现形式的元数据。它具有与在[RFC2557]第4节中定义的MIME正文部分的同名头字段相同的语法和语义。然而，它在HTTP消息中的出现对HTTP接收方具有一些特殊含义。

如果在2xx（成功）响应消息中包含Content-Location，并且其值（转换为绝对URI后）指向的URI与有效请求URI相同，则接收方可以认为负载是该资源在消息发起时间的最新表现形式。对于GET（第4.3.1节）或HEAD（第4.3.2节）请求，这与服务器未提供Content-Location时的默认语义相同。对于如PUT（第4.3.4节）或POST（第4.3.3节）这类会改变状态的请求，它意味着服务器的响应包含该资源的最新表现形式，从而将其与仅报告操作状态的表现形式（例如“操作成功！”）区分开来。这允许作者应用程序在不需要后续GET请求的情况下更新其本地副本。

如果在2xx（成功）响应中包含Content-Location，并且其字段值指向的URI不同于有效请求URI，则源服务器声称该URI是与所包含表现形式对应的不同资源的标识符。只有当两个标识符属于同一资源所有者时，这种声明才可信，但这无法通过HTTP程序化地验证。

- 对于对GET或HEAD请求的响应，表示有效请求URI指向一个内容协商的资源，Content-Location字段值是所选表现形式的更具体的标识符。

- 对于对状态变更方法（如POST）返回的201（已创建）响应，若Content-Location字段值与Location字段值相同，则表示该负载是新创建资源的当前表现形式。

- 否则，Content-Location指示该负载是关于请求操作状态的表现形式，且在给定URI处可以获得相同的报告（未来可用GET访问）。例如，通过POST请求完成的购买交易可能在200（OK）响应中包含收据文档，Content-Location字段值提供了未来检索该收据副本的标识符。

发送Content-Location的用户代理声明其值指向其最初获取所包含表现形式内容的来源（在用户代理进行任何修改之前）。换句话说，用户代理提供了指向原始表现形式源的反向链接。

接收包含Content-Location字段的请求消息的源服务器必须将该信息视为临时请求上下文，而非应原样保存为表现形式的元数据。源服务器可以利用该上下文指导请求处理或将其保存用于其他用途（如源链接或版本控制元数据），但不得利用此类上下文信息改变请求的语义。

例如，如果客户端对协商资源发起PUT请求，且源服务器接受该请求（无重定向），那么该资源的最新状态应与PUT中提供的表现形式一致。Content-Location不能用作反向内容选择标识符，仅用于更新协商的表现形式之一。如果用户代理希望实现后者的语义，应直接将PUT应用于Content-Location URI。

3.2. 表现形式数据

与HTTP消息相关联的表现形式数据，要么作为消息的负载体（payload）提供，要么通过消息语义和有效请求URI引用。表现形式数据的格式和编码由表现形式元数据头字段定义。

表现形式数据的类型由Content-Type和Content-Encoding头字段决定。这些定义了一个两层的有序编码模型：

representation-data := Content-Encoding( Content-Type( bits ) )

3.3. 负载语义

一些HTTP消息会传输完整或部分的表现形式作为“负载”。在某些情况下，负载可能只包含相关表现形式的头字段（如HEAD响应），或只包含表现形式数据的某些部分（如206（部分内容）状态码）。

请求中负载的目的由方法语义定义。例如，PUT请求（第4.3.4节）负载中的表现形式代表目标资源在请求成功应用时的期望状态；而POST请求（第4.3.3节）负载中的表现形式代表待由目标资源处理的信息。

在响应中，负载的目的由请求方法和响应状态码共同决定。例如，对GET（第4.3.1节）请求的200（OK）响应的负载代表目标资源在消息发起时间的当前状态；而对POST请求的相同状态码的负载可能代表处理结果或应用处理后目标资源的新状态。带有错误状态码的响应通常包含描述错误条件的负载，说明错误状态及建议的后续步骤。

专门描述负载而非相关表现形式的头字段被称为“负载头字段”。由于它们对消息解析的影响，负载头字段在本规范的其他部分定义。

+-------------------+----------------------------+
| 头字段名          | 定义于...                  |
+-------------------+----------------------------+
| Content-Length    | [RFC7230]第3.3.2节        |
| Content-Range     | [RFC7233]第4.2节           |
| Trailer           | [RFC7230]第4.4节           |
| Transfer-Encoding | [RFC7230]第3.3.1节        |
+-------------------+----------------------------+

3.4. 内容协商

当响应传达负载信息（无论成功或错误）时，源服务器通常有多种方式表示这些信息，例如不同的格式、语言或编码。同样，不同用户或用户代理可能具有不同的能力、特性或偏好，这可能影响最优的表现形式选择。为此，HTTP提供了内容协商机制。

本规范定义了两种在协议中可见的内容协商模式：“主动”协商（proactive），即服务器根据用户代理声明的偏好选择表现形式；以及“被动”协商（reactive），即服务器提供一组表现形式供用户代理选择。其他内容协商模式还包括“条件内容”，表现形式由多个部分组成，根据用户代理参数选择性渲染；“主动内容”，表现形式中包含脚本，根据用户代理特性发起额外（更具体）请求；以及“透明内容协商”（[RFC2295]），由中间实体执行内容选择。这些模式并不互斥，各自的适用性和实用性存在权衡。

请注意，在所有情况下，HTTP本身并不理解资源的语义。源服务器对请求的响应一致性（包括内容协商的不同维度）以及资源表现形式的“相似性”，完全由选择或生成响应的实体或算法决定。HTTP对幕后操作一无所知。

3.4.1. 主动协商

当用户代理在请求中传递内容协商偏好，以促使服务器端的算法选择其偏好的表现形式时，称为主动协商（又称服务器驱动协商）。选择依据是响应的可用表现形式（如语言、内容编码等）与请求中提供的各种信息（包括第5.3节的显式协商字段和隐式特征，如客户端网络地址或User-Agent字段的部分内容）进行比较。

主动协商的优势在于：当从多种表现形式中选择的算法难以向用户代理描述，或服务器希望在首次响应中提供“最佳猜测”以避免后续请求的往返延迟（如果“最佳猜测”已足够满足用户需求）。为了改善服务器的猜测，用户代理可以在请求中加入描述其偏好的请求头字段。

主动协商存在严重缺点：

- 由于需要完全了解用户代理的能力和响应的预期用途（例如，用户是希望在屏幕上查看还是打印出来），服务器不可能准确判断“最佳”表现形式。

- 在每个请求中描述能力可能既低效（因为大部分响应只有单一表现形式）又可能危及用户隐私。

- 增加源服务器的实现复杂性及响应生成算法的复杂度。

- 限制响应在共享缓存中的重用性。

用户代理不能保证主动协商偏好会被始终遵守，因为源服务器可能未实现主动协商，或可能决定发送不符合用户偏好的响应（如返回406（未接受）状态码）更为合适。

响应中常会包含Vary头字段（第7.1.4节），以指示在内容协商中使用了哪些请求部分。

3.4.2. 被动协商

使用响应式协商（也称为代理驱动的协商）时，用户代理在收到源服务器的初始响应后，会根据包含备用表示资源列表的响应内容，选择最佳的响应表示（无论状态码如何）。如果用户代理对初始响应的表示不满意，可以根据列表中的元数据，向一个或多个备用资源发起GET请求，以获取该响应的不同形式的表示。备用选项的选择可以由用户代理自动完成，也可以由用户通过生成的（可能是超文本的）菜单手动选择。

请注意，上述内容指的是响应的表示，通常不是指资源的表示。只有当提供这些备用表示的响应具有表示目标资源的语义（例如，对GET请求的200（OK）响应）或具有提供指向目标资源备用表示链接的语义（例如，对GET请求的300（多重选择）响应）时，备用表示才被视为目标资源的表示。

服务器可能选择不在初始响应中发送除备用列表之外的其他表示，从而表明更倾向于用户代理进行响应式协商。例如，状态码为300（多重选择）和406（未接受）响应中列出的备用信息，旨在让用户或用户代理根据这些信息进行反应和选择。

响应式协商在以下情况下具有优势：当响应内容会在常用维度（如类型、语言或编码）上变化时；当源服务器无法通过请求本身判断用户代理的能力时；以及在公共缓存被用来分散服务器负载和减少网络使用的场景中。

然而，响应式协商也存在缺点：它需要向用户代理传输备用列表，如果在头部区域传输，会降低用户感知的延迟；此外，还需要发起第二个请求以获取备用表示。本文档未定义支持自动选择的机制，但不排除将此机制作为扩展开发的可能性。

4. 请求方法

4.1 概述

请求方法标识符是请求语义的主要来源，它指示客户端发起此请求的目的，以及客户端期望的成功结果。

请求方法的语义可能会受到请求中某些头字段（第5节）语义的进一步限定，前提是这些限定不与方法的基本语义冲突。例如，客户端可以在请求中加入条件请求头字段（第5.2节），使请求的操作依赖于目标资源的当前状态（[RFC7232]）。

方法 = token

HTTP最初设计为分布式对象系统的接口。请求方法被设想为对目标资源应用语义，就像调用已定义的方法一样。方法标识符区分大小写，因为它可能用作面向对象系统中区分大小写的方法名的网关。

不同于分布式对象，HTTP中的标准请求方法不是针对特定资源的，因为统一接口能提供更好的可见性和网络系统中的重用性[REST]。一旦定义，标准方法在应用于任何资源时应具有相同的语义，但每个资源可以自行决定是否实现或允许这些语义。

本文档定义了多种在HTTP中常用的标准方法，详见下表。按照惯例，标准方法全部用大写ASCII字母表示。

| 方法     | 描述                                              | 节   |
| -------- | ------------------------------------------------- | ---- |
| GET      | 传输目标资源的当前表示                            | 4.3.1 |
| HEAD     | 与GET相同，但只传输状态行和头部信息                | 4.3.2 |
| POST     | 对请求负载执行资源特定的处理                        | 4.3.3 |
| PUT      | 用请求负载替换目标资源的所有当前表示              | 4.3.4 |
| DELETE   | 删除目标资源的所有当前表示                        | 4.3.5 |
| CONNECT  | 建立到目标资源所指服务器的隧道                      | 4.3.6 |
| OPTIONS  | 描述目标资源的通信选项                            | 4.3.7 |
| TRACE    | 在到目标资源的路径上执行消息环回测试                | 4.3.8 |

所有通用服务器必须支持GET和HEAD方法，其他方法为可选。

除了本文档定义的标准方法外，已为HTTP使用标准化的其他方法。这些方法应在IANA维护的“超文本传输协议（HTTP）方法注册表”中注册（第8.1节）。

目标资源允许的方法集可以在Allow头字段（第7.4.1节）中列出，但允许的方法集可能会动态变化。当接收到未被识别或未被源服务器实现的请求方法时，源服务器应返回状态码501（未实现）。当请求方法被源服务器识别但不允许用于目标资源时，应返回状态码405（方法不被允许）。

4.2 常用方法属性

4.2.1 安全方法

如果请求方法的定义语义基本上是只读的，即客户端在应用安全方法后不请求也不期望源服务器发生任何状态变化，则该方法被视为“安全”。合理使用安全方法通常不会造成任何伤害、财产损失或对源服务器的异常负担。

虽然“安全”定义不阻止实现中包含潜在有害行为、非完全只读或会引发副作用的操作，但重要的是，客户端未请求这些行为，也不应对此负责。例如，大多数服务器在每次响应完成后会将请求信息追加到访问日志中，这被视为安全，即使日志存储可能满了导致服务器崩溃。同样，通过Web广告点击发起的安全请求，可能会引发广告账户的收费。

根据本规范定义，GET、HEAD、OPTIONS和TRACE方法被定义为安全。

区分安全与非安全方法的目的是让自动检索（爬虫）和缓存性能优化（预取）在不引发危害的情况下工作。此外，它还允许用户代理在处理潜在不可信内容时，对非安全方法的自动使用施加适当限制。

用户代理在向用户展示潜在操作时，应区分安全与非安全方法，使用户在请求之前能意识到潜在的危险。

当资源的参数在请求URI中起到选择操作的作用时，资源所有者有责任确保该操作符合请求方法的语义。例如，Web内容编辑软件常在查询参数中使用“do=delete”等操作。如果此类资源的目的是执行不安全的操作，则资源所有者必须在使用安全请求方法访问时禁用或禁止该操作，否则在自动化进程对每个URI进行GET请求以维护链接、预取或建立搜索索引时，可能会产生不良后果。

4.2.2 幂等方法

如果多次使用相同方法发起的请求对服务器的预期效果与单次请求相同，则该请求方法被视为“幂等”。本规范定义的PUT、DELETE以及安全请求方法都是幂等的。

与安全方法类似，幂等性只影响用户请求的内容；服务器可以为每个请求单独记录日志、保留版本控制历史或执行其他非幂等的副作用。

幂等方法的优势在于，如果通信失败，客户端可以自动重复请求。例如，客户端发出PUT请求后，连接在未收到响应前关闭，客户端可以重新建立连接并重试该幂等请求。即使原始请求成功，重复请求也应产生相同的预期效果，但响应可能不同。

4.2.3 可缓存方法

请求方法可以被定义为“可缓存”，意味着对其的响应可以被存储以供未来重用（具体要求见[RFC7234]）。通常，安全且不依赖于当前或权威响应的请求方法被定义为可缓存；本规范将GET、HEAD和POST定义为可缓存，尽管绝大多数缓存实现只支持GET和HEAD。

4.3 方法定义

4.3.1 GET

GET方法请求传输目标资源的当前表示。它是信息检索的主要机制，也是几乎所有性能优化的核心。因此，当人们谈论通过HTTP检索某些可识别信息时，通常指的就是发起GET请求。

将资源标识符视为远程文件系统路径，将表示视为该文件内容的副本，虽然在许多实现中确实如此（参见第9.1节的安全考虑）。但实际上，没有此类限制。资源的HTTP接口可以是内容对象树、数据库记录的程序视图，或其他信息系统的网关。即使URI映射机制绑定到文件系统，源服务器也可能配置为将请求作为输入执行文件，并将输出作为表示返回，而不是直接传输文件。无论如何，只有源服务器需要知道每个资源标识符与实现的对应关系，以及如何在响应GET时选择和发送目标资源的当前表示。

客户端可以通过在请求中加入Range头字段（第5节），将GET的语义改为“范围请求”，只请求部分内容。

GET请求的负载（请求体）没有定义的语义；在GET请求中携带负载可能会导致某些实现拒绝请求。

GET请求的响应是可缓存的；缓存可以用它来满足后续的GET和HEAD请求，除非由Cache-Control头字段（[RFC7234]第5.2节）另行指示。

4.3.2 HEAD

HEAD 方法与 GET 方法相同，唯一的区别在于服务器在响应中不得发送消息体（即响应在头部部分结束后即终止）。服务器应在对 HEAD 请求的响应中发送与对 GET 请求相同的头字段，除了可以省略载荷相关的头字段（第3.3节）。此方法可用于获取所选表示的元数据，而无需传输表示数据，常用于测试超文本链接的有效性、可访问性和最近的修改情况。

HEAD 请求消息中的载荷没有定义的语义；在 HEAD 请求中发送载荷体可能会导致某些现有实现拒绝该请求。

HEAD 请求的响应是可缓存的；除非由 Cache-Control 头字段（第5.2节 [RFC7234]）另行指示，否则缓存可以使用其满足后续的 HEAD 请求。HEAD 响应也可能影响之前缓存的 GET 响应；详见 [RFC7234] 第4.3.5节。

4.3.3. POST

POST 方法请求目标资源根据资源自身的特定语义处理请求中包含的表示。例如，POST 常用于以下功能（以及其他）：

- 向数据处理过程提供一块数据，例如在 HTML 表单中输入的字段；
- 向公告栏、新闻组、邮件列表、博客或类似的文章组发布消息；
- 创建一个尚未由源服务器识别的新资源；
- 向资源的现有表示追加数据。

源服务器通过根据处理结果选择适当的状态码来指示响应的语义；几乎所有由本规范定义的状态码都可能在 POST 的响应中出现（例外包括 206（部分内容）、304（未修改）和 416（请求范围不满足））。

如果成功处理 POST 请求后在源服务器上创建了一个或多个资源，源服务器应发送包含 Location 头字段的 201（已创建）响应，提供所创建主要资源的标识符（第7.1.2节）以及描述请求状态的表示，同时引用新资源。

POST 请求的响应只有在包含明确的新鲜度信息时才可缓存（参见 [RFC7234] 第4.2.1节）。然而，POST 缓存的实现并不普遍。对于希望客户端能缓存 POST 结果以便后续 GET 重用的情况，源服务器可以发送包含结果的 200（成功）响应和 Content-Location 头字段，其值与 POST 的实际请求 URI 相同（第3.1.4.2节）。

如果处理 POST 的结果等同于现有资源的表示，源服务器可以通过发送带有现有资源标识符的 303（查看其他）响应，将用户代理重定向到该资源。这一做法的好处是为用户代理提供资源标识符，并通过更适合共享缓存的方法传输表示，尽管如果用户代理未缓存该表示，则会增加一次请求。

4.3.4. PUT

PUT 方法请求将目标资源的状态创建或替换为请求消息载荷中定义的表示。成功的 PUT 表示，后续对同一目标资源的 GET 请求应返回一个等价的表示（200（成功）响应）。但不能保证状态变化一定可观察到，因为目标资源可能被其他用户代理并行操作，或在收到后续 GET 请求前由源服务器进行动态处理。成功的响应仅表示在处理时用户代理的意图已实现。

如果目标资源没有当前表示且 PUT 成功创建了一个，则源服务器必须返回 201（已创建）响应，并包含指向新资源的标识符的 Location 头字段。如果目标资源已有表示且被成功修改以符合请求中的表示，源服务器应返回 200（成功）或 204（无内容）响应，表示请求已成功完成。

源服务器应忽略 PUT 请求中未识别的头字段（即不将其作为资源状态的一部分存储）。

源服务器应验证 PUT 表示是否符合目标资源的任何约束，尤其是在使用内部配置（如 URI 相关信息）设置 GET 响应中的表示元数据时。当 PUT 表示与目标资源不一致时，源服务器应尝试使其一致（通过转换表示或更改资源配置），或返回包含足够信息说明原因的错误响应。建议使用 409（冲突）或 415（不支持的媒体类型）状态码，后者特别针对 Content-Type 值的约束。

例如，若目标资源配置为始终具有 "text/html" 的 Content-Type，而 PUT 表示的 Content-Type 为 "image/jpeg"，源服务器应采取以下措施之一：

a. 重新配置目标资源以反映新的媒体类型；
b. 转换 PUT 表示为与资源一致的格式后再存储；
c. 拒绝请求，返回 415（不支持的媒体类型），并说明目标资源仅支持 "text/html"，可能还会提供指向其他资源的链接。

HTTP 不具体定义 PUT 方法如何影响源服务器的状态，超出用户代理请求意图和源服务器响应语义的表达范围。它也未定义资源的具体含义（超出 HTTP 提供的接口），以及资源状态如何存储、存储变化如何影响资源表示，或源服务器如何将资源状态转化为表示。通常，所有关于资源接口的实现细节都由服务器隐藏。

源服务器不得在成功响应 PUT 时发送验证头字段（如 ETag 或 Last-Modified），除非请求的表示数据在存储前未经过任何变换（即新表示与请求中的表示数据完全一致），且验证字段反映了新表示。这一要求使用户代理能确认存储的表示体是否为最新，从而避免不必要的重复请求，并确保响应中的验证字段可用于未来的条件请求（第5.2节）。

POST 和 PUT 方法的根本区别在于它们的意图不同：POST 请求的目标资源旨在根据资源自身的语义处理包含的表示；而 PUT 请求的表示被定义为替换目标资源的状态。因此，PUT 的意图是幂等的，且对中间人可见，尽管具体效果只有源服务器知道。

正确理解 PUT 请求假设用户代理知道目标资源。代表客户端选择合适 URI 的服务，应使用 POST 而非 PUT。如果源服务器不打算对目标资源执行请求中的状态变更，而希望将变更应用到其他资源（如资源已迁移到不同 URI），则必须返回适当的 3xx（重定向）响应，用户代理可以自行决定是否重定向。

对目标资源的 PUT 请求可能对其他资源产生副作用。例如，一个文章可能有一个 URI 用于标识“当前版本”（一个资源），而不同版本的 URI 代表不同的资源（曾经与当前版本共享相同状态的资源）。对“当前版本” URI 的成功 PUT 可能会创建一个新版本资源，或在目标资源状态变化的同时，建立相关资源之间的链接。

允许对某一目标资源执行 PUT 的源服务器，必须对包含 Content-Range 头字段（第4.2节 [RFC7233]）的请求返回 400（错误请求），因为载荷很可能是部分内容误被作为完整表示 PUT。部分内容更新可以通过针对具有重叠部分的状态的单独资源，或使用专门定义的部分更新方法（如 [RFC5789] 中定义的 PATCH 方法）实现。

对 PUT 方法的响应不可缓存。如果成功的 PUT 请求经过缓存，且缓存中存有针对有效请求 URI 的响应，则这些响应将被失效（参见 [RFC7234] 第4.4节）。

4.3.5. DELETE

DELETE 方法请求源服务器删除目标资源与其当前功能之间的关联。实际上，这类似于 UNIX 中的 rm 命令：它表达了对源服务器 URI 映射的删除操作，而不是期望之前关联的信息被删除。

如果目标资源有一个或多个当前表示，它们可能会被源服务器销毁，也可能不会，存储空间也可能会被回收，这完全取决于资源的性质及其由源服务器的实现（超出本规范范围）。同样，资源的其他实现方面（如数据库或网关连接）也可能需要在删除后被停用或存档。一般而言，假设源服务器只允许对其有明确删除机制的资源执行 DELETE。

允许使用 DELETE 方法的资源较少——其主要用途是在远程创作环境中，用户对其效果有一定预期。例如，之前通过 PUT 创建的资源，或在 POST 请求的 201（已创建）响应后由 Location 头字段标识的资源，可能允许相应的 DELETE 请求以撤销这些操作。同样，定制的用户代理实现也可能支持删除操作。

一种创作功能，例如使用HTTP进行远程操作的修订控制客户端，可能会基于假设服务器的URI空间已被设计成对应于一个版本库而使用DELETE方法。

如果成功应用DELETE方法，原始服务器应当返回：
- 202（已接受）状态码，表示该操作可能会成功但尚未执行；
- 204（无内容）状态码，表示操作已执行且不需要提供更多信息；
- 200（成功）状态码，表示操作已执行，且响应消息中包含描述状态的表示。

DELETE请求消息中的有效载荷没有定义的语义；在DELETE请求中发送载荷体可能会导致某些现有实现拒绝该请求。

对DELETE方法的响应不可缓存。如果DELETE请求经过的缓存中存有针对有效请求URI的响应，这些响应将被作废（参见[RFC7234]第4.4节）。

4.3.6.  CONNECT

CONNECT方法请求接收方建立到请求目标所标识的目标源服务器的隧道，如果成功，之后将限制其行为为盲转发数据包（双向），直到隧道关闭。隧道通常用于通过一个或多个代理创建端到端的虚拟连接，然后可以使用TLS（传输层安全协议，[RFC5246]）进行安全保护。

CONNECT仅用于向代理发起请求。接收请求的源服务器可以用2xx（成功）状态码响应，表示已建立连接，但大多数源服务器不支持CONNECT。

发起CONNECT请求的客户端必须使用请求目标的授权形式（参见[RFC7230]第5.3节），即请求目标只包括主机名和端口号，用冒号分隔。例如：

```
CONNECT server.example.com:80 HTTP/1.1
Host: server.example.com:80
```

代理可以通过直接连接到请求目标，或如果配置为使用其他代理，则将CONNECT请求转发到下一个入站代理来建立隧道。任何2xx（成功）响应都表示，发起方（以及所有入站代理）将在成功响应的header部分结束后立即切换到隧道模式；在那之后接收的数据来自请求目标所标识的服务器。任何非成功响应都表示隧道尚未建立，连接仍由HTTP控制。

当隧道中介检测到任一端关闭连接时，隧道即被关闭：中介必须尝试将来自已关闭端的任何未发出的数据传送到另一端，关闭两个连接，然后丢弃任何未传送完的数据。

可能需要使用代理认证以建立隧道。例如：

```
CONNECT server.example.com:80 HTTP/1.1
Host: server.example.com:80
Proxy-Authorization: basic aGVsbG86d29ybGQ=
```

建立到任意服务器的隧道存在重大风险，尤其当目标端口是众所周知或保留的TCP端口，不用于Web流量。例如，向“example.com:25”发起CONNECT请求，可能意味着代理连接到SMTP的保留端口；如果允许，可能会被用来中转垃圾邮件。支持CONNECT的代理应限制其使用范围，仅限于已知端口或可配置的安全请求目标白名单。

服务器不得在对CONNECT的2xx（成功）响应中发送Transfer-Encoding或Content-Length头字段。客户端必须忽略在成功响应中收到的任何Content-Length或Transfer-Encoding头。

CONNECT请求中的载荷没有定义的语义；在CONNECT请求中发送载荷体可能会导致某些现有实现拒绝请求。

对CONNECT方法的响应不可缓存。

4.3.7. OPTIONS

OPTIONS方法请求关于目标资源的通信选项信息，可以是在源服务器或中间代理上。此方法允许客户端在不执行资源操作的情况下，确定资源的选项和/或要求，或服务器的能力。

带有星号（“*”）作为请求目标的OPTIONS请求（参见[RFC7230]第5.3节）适用于整个服务器，而非特定资源。由于服务器的通信选项通常依赖于具体资源，星号请求主要用作“ping”或“无操作”类型的方法；它除了让客户端测试服务器能力外不执行其他操作。例如，可以用来测试代理是否符合HTTP/1.1标准。

如果请求目标不是星号，OPTIONS请求适用于与目标资源通信时可用的选项。

服务器对成功的OPTIONS响应应当包含可能指示服务器实现的可选功能的头字段（如Allow），包括未来可能定义的扩展。响应负载（如果有）也可能以机器可读或人类可读的形式描述通信选项。此类表示的标准格式未由本规范定义，但未来的HTTP扩展可能会定义。若无载荷，服务器必须生成Content-Length字段，值为“0”。

客户端可以在OPTIONS请求中加入Max-Forwards头字段，以指定请求链中的特定接收者（参见第5.1.2节）。代理在转发请求时不得生成Max-Forwards头，除非请求本身已包含该字段。

生成包含载荷的OPTIONS请求的客户端必须发送描述该表示媒体类型的有效Content-Type头字段。虽然本规范未定义此类载荷的用途，但未来的HTTP扩展可能会利用OPTIONS体进行更详细的资源查询。

对OPTIONS方法的响应不可缓存。

4.3.8. TRACE

TRACE方法请求远程应用层回环请求消息。最终接收者应将收到的消息（除下述某些字段外）反映回客户端，作为状态为200（成功）响应的消息体，内容类型为“message/http” ([RFC7230]第8.3.1节)。最终接收者可以是源服务器或在请求中首次收到Max-Forwards值为零（0）的第一个服务器（参见第5.1.2节）。

客户端不得在TRACE请求中生成可能泄露敏感信息的请求头字段。例如，用户代理不应在TRACE请求中发送存储的用户凭据（[RFC7235]）或Cookies（[RFC6265]]）。最终接收者应在生成响应体时排除可能包含敏感数据的请求头字段。

TRACE允许客户端查看请求链另一端接收的内容，用于测试或诊断。Via头字段（[RFC7230]第5.7.1节）特别重要，因为它作为请求链的追踪。Max-Forwards头字段允许客户端限制请求链的长度，有助于测试在无限循环中转发消息的代理链。

客户端不得在TRACE请求中发送消息体。

对TRACE方法的响应不可缓存。

当接收到包含完整请求行和头部字段的HTTP/1.1（或更高版本）请求时，且该请求头中包含“100-continue”预期并指示请求消息体将随后的情况下，源服务器必须立即作出响应，要么根据仅通过检查请求行和头部字段即可确定的最终状态码立即响应，要么发送一个立即的“100（Continue）”响应，以鼓励客户端继续发送请求的消息体。源服务器不得等待消息体到达后再发送“100（Continue）”响应。

代理服务器在接收到包含完整请求行和头部字段的HTTP/1.1（或更高版本）请求时，且该请求头中包含“100-continue”预期并指示请求消息体将随后的情况下，必须立即作出响应，要么根据仅通过检查请求行和头部字段即可确定的最终状态码立即响应，要么开始将请求转发到源服务器，即向下一个入站服务器发送相应的请求行和头部字段。如果代理根据配置或之前的交互认为下一个入站服务器只支持HTTP/1.0，则可以生成一个立即的“100（Continue）”响应，以鼓励客户端开始发送消息体。

注意：Expect头字段是在HTTP/1.1 [RFC2068]最初发布后添加的，作为请求中间响应“100（Continue）”的手段，以及指示必须理解的扩展机制。然而，扩展机制未被客户端广泛使用，必须理解的要求也未被许多服务器实现，导致扩展机制变得无用。为简化“100-continue”的定义和处理，本规范已删除扩展机制。

5.1.2. Max-Forwards（最大转发次数）

“Max-Forwards”头字段提供了一种机制，结合TRACE（第4.3.8节）和OPTIONS（第4.3.7节）请求方法，用于限制请求被代理转发的次数。当客户端试图追踪一个似乎在中途失败或出现环路的请求时，这个机制非常有用。

Max-Forwards = 1*DIGIT（一个或多个数字）

Max-Forwards的值是一个十进制整数，表示该请求消息还能被转发的剩余次数。

每个中间节点在接收到包含Max-Forwards头字段的TRACE或OPTIONS请求时，必须在转发请求前检查并更新其值。如果接收到的值为零（0），中间节点不得转发请求，而应作为最终接收者响应。如果接收到的Max-Forwards值大于零，中间节点必须在转发的请求中生成一个更新后的Max-Forwards字段，其值为原值减一（1）或目标服务器支持的最大值（较小者）。

接收方可以忽略任何其他请求方法中收到的Max-Forwards头字段。

5.2. 条件请求

HTTP条件请求头字段[RFC7232]允许客户端对目标资源的状态设置先决条件，以确保在条件不成立时不执行对应的方法语义。每个条件由目标资源的先前表示的验证器集与当前表示的验证器集（第7.2节）进行比较，从而判断目标资源自客户端已知的某一状态以来是否发生了变化。这种判断的效果取决于方法的语义和条件的选择，详见[RFC7232]第5节。

| 头字段名             | 定义位置                     |
|---------------------|------------------------------|
| If-Match            | [RFC7232]第3.1节             |
| If-None-Match       | [RFC7232]第3.2节             |
| If-Modified-Since | [RFC7232]第3.3节             |
| If-Unmodified-Since | [RFC7232]第3.4节             |
| If-Range          | [RFC7233]第3.2节             |

5.3. 内容协商

以下请求头字段由用户代理（客户端）发出，用于主动协商响应内容，详见第3.4.1节。这些字段中的偏好设置适用于响应中的任何内容，包括目标资源的表示、错误或处理状态的表示，甚至可能包括协议中出现的杂项文本字符串。

| 头字段名             | 定义位置                     |
|---------------------|------------------------------|
| Accept              | 第5.3.2节                     |
| Accept-Charset      | 第5.3.3节                     |
| Accept-Encoding     | 第5.3.4节                     |
| Accept-Language     | 第5.3.5节                     |

5.3.1. 质量值（Q值）

许多主动协商的请求头字段都使用一个通用参数“q”（不区分大小写）来为相关内容类型的偏好赋予相对“权重”。这个权重被称为“质量值”或“q值”，因为在服务器配置中也常用相同的参数名为不同表示的相对质量赋值。

权重值被归一化为0到1之间的实数，其中0.001表示最不偏好，1表示最偏好；值为0表示“不可接受”。如果没有“q”参数，默认值为1。

weight = OWS ";" OWS "q=" qvalue  
qvalue = ( "0" [ "." 0*3DIGIT ] ) / ( "1" [ "." 0*3("0") ] )

发送方不得在“q”值后生成超过三位的小数。用户配置这些值时也应限制在相同范围内。

5.3.2. Accept（接受类型）

“Accept”头字段由用户代理用来指定可接受的响应媒体类型。它可以用来表明请求仅限于一小部分期望的类型，例如请求内联图片。

Accept = #( media-range [ accept-params ] )

media-range = ( "*/*" / ( type "/" "*" ) / ( type "/" subtype ) ) *( OWS ";" OWS parameter )  
accept-params = weight *( accept-ext )  
accept-ext = OWS ";" OWS token [ "=" ( token / quoted-string ) ]

星号“*”用于将媒体类型分组到范围中，“*/*”表示所有媒体类型，“type/*”表示该类型的所有子类型。媒体范围可以包含适用于该范围的媒体类型参数。

每个媒体范围后面可能跟随零个或多个媒体类型参数（如字符集）、一个可选的“q”参数（表示相对偏好，详见第5.3.1节）以及零个或多个扩展参数。如果存在扩展参数（accept-ext），则“q”参数是必需的，因为它作为两个参数集之间的分隔符。

注意：使用“q”参数名来区分媒体类型参数和Accept扩展参数是出于历史习惯。虽然这限制了名为“q”的媒体类型参数不能用于媒体范围，但鉴于IANA媒体类型注册表中没有“q”参数，且在Accept中很少使用任何媒体类型参数，这种限制被认为不太可能成为问题。未来注册的媒体类型应避免使用“q”作为参数名。

示例：

Accept: audio/*; q=0.2, audio/basic

理解为：“我偏好audio/basic，但如果没有，则接受任何音频类型，前提是其质量在80%以上”。

没有任何Accept头字段的请求意味着用户代理接受任何媒体类型的响应。如果请求中包含Accept字段，但响应的任何表示都不在接受列表中，源服务器可以选择返回406（Not Acceptable）响应，或者忽略该字段，将响应视为不受内容协商限制。

更复杂的示例：

Accept: text/plain; q=0.5, text/html,  
        text/x-dvi; q=0.8, text/x-c

可以理解为：“text/html”和“text/x-c”是同等偏好的媒体类型，但如果不存在，则发送“text/x-dvi”表示；如果也不存在，则发送“text/plain”。

媒体范围可以被更具体的媒体范围或具体的媒体类型覆盖。如果多个媒体范围适用于某一类型，则最具体的优先。例如：

Accept: text/*, text/plain, text/plain;format=flowed, */*

优先级为：

1.  text/plain;format=flowed  
2.  text/plain  
3.  text/*  
4.  */*

与某一类型匹配的最高优先级的媒体范围决定该类型的质量因子。例如：

Accept: text/*;q=0.3, text/html;q=0.7, text/html;level=1,  
        text/html;level=2;q=0.4, */*;q=0.5

会得到如下对应值：

| 媒体类型                | 质量值 |
|------------------------|--------|
| text/html;level=1     | 1      |
| text/html             | 0.7    |
| text/plain            | 0.3    |
| image/jpeg            | 0.5    |
| text/html;level=2     | 0.4    |
| text/html;level=3     | 0.7    |

注意：用户代理可能会为某些媒体范围预设默认的质量值，但除非是无法与其他渲染代理交互的封闭系统，否则应允许用户配置这些默认值。

5.3.3. Accept-Charset（接受字符集）

“Accept-Charset”头字段由用户代理用来指示可接受的字符集。支持更全面或特殊用途字符集的用户代理可以通过此字段向源服务器表明其能力。

Accept-Charset = 1#( ( charset / "*" ) [ weight ] )

字符集名称定义在第3.1.1.2节。用户代理可以为每个字符集关联一个质量值，表示对该字符集的偏好，详见第5.3.1节。例如：

Accept-Charset: iso-8859-5, unicode-1-1;q=0.8

如果Accept-Charset字段中出现“*”，则表示匹配所有未在该字段中明确提及的字符集。如果没有“*”，则未在字段中明确列出的字符集被视为“不可接受”。

没有任何Accept-Charset头字段的请求意味着用户代理接受任何字符集的响应。除非特别配置，大多数通用用户代理不会发送Accept-Charset，因为详细列出支持的字符集可以帮助服务器识别用户。

如果请求中包含Accept-Charset字段，但响应的任何表示都不在接受列表中，源服务器可以返回406（Not Acceptable）响应，或忽略该字段，将资源视为不受内容协商限制。

5.3.4. Accept-Encoding（接受内容编码）

“Accept-Encoding”头字段由用户代理用来指示响应中可接受的内容编码（第3.1.2.1节）。使用“identity”标记表示不接受任何编码。

Accept-Encoding = #( codings [ weight ] )  
codings = content-coding / "identity" / "*"

每个编码值可以关联一个质量值，表示偏好，详见第5.3.1节。星号“*”匹配任何未在头字段中明确列出的内容编码。

示例：

Accept-Encoding: compress, gzip  
Accept-Encoding:  
Accept-Encoding: *  
Accept-Encoding: compress;q=0.5, gzip;q=1.0  
Accept-Encoding: gzip;q=1.0, identity; q=0.5, *;q=0

没有包含Accept-Encoding头字段的请求意味着用户代理对内容编码没有偏好。虽然这允许服务器在响应中使用任何内容编码，但并不意味着用户代理能够正确处理所有编码。

服务器用以下规则测试某个内容编码是否被接受：

1. 如果请求中没有Accept-Encoding字段，则用户代理认为任何内容编码都是可接受的。

2. 如果表示没有内容编码，则默认认为是可接受的，除非Accept-Encoding字段明确排除它，特别是通过“identity;q=0”或“*;q=0”且没有更具体的“identity”条目。

3. 如果表示的内容编码在Accept-Encoding字段列出的内容编码中，则它是可接受的，除非伴随的q值为0（根据第5.3.1节的定义，q值为0表示“不接受”）。

4. 如果多个内容编码都被接受，则优先选择具有最高非零q值的内容编码。

带有空字段值的Accept-Encoding头字段意味着用户代理不希望响应中包含任何内容编码。如果请求中存在Accept-Encoding头字段，但响应的所有表示都不在接受列表中，原始服务器应发送不带任何内容编码的响应。

注意：大多数HTTP/1.0应用程序不识别或遵守与内容编码相关的q值。这意味着q值可能不起作用，也不允许与x-gzip或x-compress一起使用。

5.3.5.  Accept-Language

“Accept-Language”头字段由用户代理用来指示响应中偏好的自然语言集合。语言标签定义在第3.1.3.1节。

Accept-Language = 1#( language-range [ weight ] )
language-range  = <language-range, 见[RFC4647]第2.1节>

每个语言范围可以附带一个质量值，表示用户对该范围指定的语言的偏好估计，定义在第5.3.1节。例如：

Accept-Language: da, en-gb;q=0.8, en;q=0.7

意味着：“我偏好丹麦语，但也接受英式英语和其他类型的英语。”

没有任何Accept-Language头字段的请求意味着用户代理会接受任何语言的响应。如果请求中存在该字段，但响应的所有表示都没有匹配的语言标签，原始服务器可以选择忽略该头字段（将响应视为不进行内容协商）或响应406（Not Acceptable）。但后者不鼓励，因为这样可能阻止用户访问他们可能使用的内容（例如通过翻译软件）。

注意：一些接收方会将语言标签的列出顺序视为优先级递减的指示，尤其是对于具有相等质量值（没有值即等同于q=1）的标签。然而，这种行为不能完全依赖。为了保持一致性和最大化互操作性，许多用户代理会为每个语言标签分配唯一的质量值，并按递减顺序列出它们。关于语言优先级列表的更多讨论见[RFC4647]第2.3节。

匹配方面，[RFC4647]第3节定义了几种匹配方案。实现可以根据需求提供最合适的匹配方案。“基本过滤”方案（[RFC4647]第3.3.1节）与之前在[RFC2616]第14.4节中定义的HTTP匹配方案相同。

出于隐私考虑，用户可能不希望在每个请求中都发送包含全部语言偏好的Accept-Language头字段（第9.7节）。

由于可理解性高度依赖于个人用户，用户代理需要允许用户控制语言偏好（通过配置用户代理或默认使用用户可控的系统设置）。没有提供此类控制的用户代理不得发送Accept-Language头字段。

注意：用户代理在设置偏好时应提供指导，因为用户很少熟悉上述语言匹配的细节。例如，用户可能假设选择“en-gb”后，如果没有英国英语版本，也会得到任何英语文档。此时，用户代理可以建议添加“en”以获得更好的匹配。

5.4. 认证凭据

用于携带认证凭据的两个头字段，定义见[RFC7235]。注意，各种自定义的用户认证机制也会使用Cookie头字段（定义见[RFC6265]）。

+---------------------+--------------------------+
| 头字段名            | 定义于...                |
+---------------------+--------------------------+
| Authorization       | [RFC7235]第4.2节        |
| Proxy-Authorization | [RFC7235]第4.4节        |
+---------------------+--------------------------+

5.5. 请求上下文

以下请求头字段提供关于请求上下文的额外信息，包括用户、用户代理和请求背后的资源信息。

+-------------------+---------------+
| 头字段名          | 定义于...      |
+-------------------+---------------+
| From              | 第5.5.1节     |
| Referer           | 第5.5.2节     |
| User-Agent        | 第5.5.3节     |
+-------------------+---------------+

5.5.1. From

“From”头字段包含控制请求用户代理的人的电子邮件地址。该地址应为机器可用的，定义在[RFC5322]第3.4节的“mailbox”中：

From = mailbox

mailbox = <mailbox, 见[RFC5322]第3.4节>

示例：

From: webmaster@example.org

非机器人用户代理很少会发送From头字段。用户代理应在没有用户明确配置的情况下避免发送此字段，因为这可能与用户的隐私或其站点的安全策略冲突。

机器人用户代理应发送有效的From头字段，以便负责运行机器人的人员在出现问题（如发送过多、不需要或无效请求）时可以联系。

服务器不应使用From头字段进行访问控制或认证，因为大多数接收方会假设该字段值是公开信息。

5.5.2. Referer

“Referer”[拼写错误]头字段允许用户代理指定一个URI引用，表示从中获取目标URI的资源（即“引荐人”，但字段名拼写有误）。生成Referer字段值时，用户代理不得包含URI引用的片段和用户信息部分（如果有的话，见[RFC3986]）。

Referer = 绝对URI / 部分URI

该字段允许服务器生成指向其他资源的反向链接，用于简单的分析、日志、优化缓存等。它还能帮助发现过时或拼写错误的链接以便维护。一些服务器用Referer字段来拒绝来自其他站点的链接（所谓的“深度链接”）或限制跨站请求伪造（CSRF），但并非所有请求都包含该字段。

示例：

Referer: http://www.example.org/hypertext/Overview.html

如果目标URI来自没有自己URI的源（如用户键盘输入或用户书签/收藏中的条目），用户代理必须要么不包含Referer字段，要么将其值设为“about:blank”。

Referer字段可能泄露请求上下文或浏览历史信息，存在隐私风险，尤其是当引荐资源的标识符包含个人信息（如账户名）或本应保密的资源（如防火墙后或内部的安全服务）。大多数通用用户代理在引荐资源为本地“file”或“data”URI时不会发送Referer头字段。如果引荐页面通过安全协议接收，用户代理不得在非安全HTTP请求中发送Referer头字段。详见第9.4节的安全考虑。

一些中间件会无差别地删除出站请求中的Referer字段，这可能会影响对CSRF攻击的防护，危害用户。希望限制Referer信息泄露的中间件和用户代理扩展应只进行特定修改，比如用伪名替换内部域名或截断查询和路径部分。当请求目标与请求中的方案和主机相同时，中间件不应修改或删除Referer字段。

5.5.3. User-Agent

“User-Agent”头字段包含发起请求的用户代理信息，服务器常用它来识别报告的互操作性问题范围、绕过或定制响应以避免特定用户代理限制，以及进行浏览器或操作系统使用情况的分析。除非特别配置不发送，否则用户代理应在每个请求中包含User-Agent字段。

User-Agent = product *( RWS ( product / comment ) )

该字段值由一个或多个产品标识符组成，每个后跟零个或多个注释（见[RFC7230]第3.2节），共同标识用户代理软件及其重要子产品。通常，产品标识符按其识别用户代理软件的重要性递减的顺序列出。每个产品标识符由名称和可选的版本组成。

product = token ["/" product-version]
product-version = token

发件人应限制生成的产品标识符，仅用于识别产品，不得包含广告或其他非必要信息。产品版本部分不应包含非版本标识符（即，同一产品的不同版本应仅在版本部分不同）。

示例：

User-Agent: CERN-LineMode/2.15 libwww/2.17b3

用户代理不应生成包含不必要细节的User-Agent字段，也不应允许第三方添加子产品。过长或过于详细的字段值会增加请求延迟，并可能导致用户被识别（“指纹识别”）。

同样，建议不要使用其他实现的产品标识符来声明兼容性，因为这会规避字段的设计目的。如果用户代理伪装成不同的用户代理，接收方可以假设用户有意希望看到为该标识用户代理定制的响应，即使这些响应可能不完全适用于实际使用的用户代理。

以下是英文内容的中文翻译：

```
   o  1xx（信息性）：请求已被接收，正在继续处理

   o  2xx（成功）：请求已被成功接收、理解并接受

   o  3xx（重定向）：需要采取进一步的操作以完成请求

   o  4xx（客户端错误）：请求存在语法错误或无法完成

字段与 Reschke  规范追踪  [第47页]

RFC 7231             HTTP/1.1 语义与内容            2014年6月

   下面列出的状态码在本规范、[RFC7232]第4节、[RFC7233]第4节以及[RFC7235]第3节中定义。这里列出的原因短语仅为建议——它们可以被本地等价物替换，而不影响协议。

   默认情况下，标记为可缓存的状态码（例如，本规范中的200、203、204、206、300、301、404、405、410、414和501）可以被缓存以启发式过期，除非方法定义或明确的缓存控制另有规定 [RFC7234]；所有其他状态码默认不可缓存。

+------+-------------------------------+--------------------------+
| 代码 | 原因短语                     | 定义于...                |
+------+-------------------------------+--------------------------+
| 100  | 继续                         | 第6.2.1节               |
| 101  | 升级协议                     | 第6.2.2节               |
| 200  | 成功                         | 第6.3.1节               |
| 201  | 已创建                       | 第6.3.2节               |
| 202  | 已接受                       | 第6.3.3节               |
| 203  | 非权威性信息                 | 第6.3.4节               |
| 204  | 无内容                       | 第6.3.5节               |
| 205  | 重置内容                     | 第6.3.6节               |
| 206  | 部分内容                     | [RFC7233]第4.1节        |
| 300  | 多重选择                     | 第6.4.1节               |
| 301  | 永久移动                     | 第6.4.2节               |
| 302  | 临时找到                     | 第6.4.3节               |
| 303  | 参见其他                     | 第6.4.4节               |
| 304  | 未修改                       | [RFC7232]第4.1节        |
| 305  | 使用代理                     | 第6.4.5节               |
| 307  | 临时重定向                   | 第6.4.7节               |
| 400  | 错误请求                     | 第6.5.1节               |
| 401  | 未授权                       | [RFC7235]第3.1节        |
| 402  | 需要付费                     | 第6.5.2节               |
| 403  | 禁止访问                     | 第6.5.3节               |
| 404  | 未找到                       | 第6.5.4节               |
| 405  | 方法不允许                   | 第6.5.5节               |
| 406  | 不可接受                     | 第6.5.6节               |
| 407  | 代理认证要求                 | [RFC7235]第3.2节        |
| 408  | 请求超时                     | 第6.5.7节               |
| 409  | 冲突                         | 第6.5.8节               |
| 410  | 已删除                       | 第6.5.9节               |
| 411  | 需要内容长度                 | 第6.5.10节              |
| 412  | 前提条件失败                 | [RFC7232]第4.2节        |
| 413  | 请求实体过大                 | 第6.5.11节              |
| 414  | 请求URI过长                  | 第6.5.12节              |
| 415  | 不支持的媒体类型             | 第6.5.13节              |
| 416  | 请求范围不满足               | [RFC7233]第4.4节        |
| 417  | 预期失败                     | 第6.5.14节              |
| 426  | 需要升级                     | 第6.5.15节              |
| 500  | 服务器内部错误               | 第6.6.1节               |
| 501  | 未实现                       | 第6.6.2节               |
| 502  | 网关错误                     | 第6.6.3节               |
| 503  | 服务不可用                   | 第6.6.4节               |
| 504  | 网关超时                     | 第6.6.5节               |
| 505  | 不支持的HTTP版本             | 第6.6.6节               |
+------+-------------------------------+--------------------------+

请注意，此列表并不详尽——不包括其他规范中定义的扩展状态码。完整的状态码列表由IANA维护。详情请参见第8.2节。

6.2.  信息性1xx状态码

   1xx（信息性）状态码表示中间响应，用于在完成请求动作并发送最终响应之前，传达连接状态或请求进展。1xx响应在状态行之后的第一个空行（表示头部结束的空行）处终止。由于HTTP/1.0未定义任何1xx状态码，服务器不得向HTTP/1.0客户端发送1xx响应。

   客户端必须能够解析在最终响应之前接收的一个或多个1xx响应，即使客户端不预期如此。用户代理可以忽略意外的1xx响应。

   代理必须转发1xx响应，除非代理本身请求生成了该响应。例如，如果代理在转发请求时添加了“Expect: 100-continue”字段，则不必转发相应的100（继续）响应。

6.2.1.  100 继续

   100（继续）状态码表示已接收请求的初始部分，尚未被服务器拒绝。服务器打算在完整接收并处理请求后，发送最终响应。

   当请求包含带有100-continue预期的Expect头字段时，100响应表示服务器希望接收请求体（详见第5.1.1节）。客户端应继续发送请求，并忽略100响应。

   如果请求不包含带有100-continue预期的Expect头字段，客户端可以直接忽略此中间响应。

6.2.2.  101 升级协议

   101（切换协议）状态码表示服务器理解并愿意根据[RFC7230]第6.7节中的Upgrade头字段，切换所用的应用协议。服务器必须在响应中生成Upgrade头字段，指示在结束101响应的空行后立即切换到的协议。

   服务器只会在有利于切换时才同意切换协议。例如，切换到更新版本的HTTP可能比旧版本更有优势，切换到实时同步协议可能在传输使用此类功能的资源时更有益。

6.3.  成功的2xx状态码

   2xx（成功）类别的状态码表示客户端的请求已被成功接收、理解并接受。

6.3.1.  200 成功

   200（成功）状态码表示请求已成功。响应中的负载内容取决于请求方法。根据本规范定义的方法，负载的主要含义可总结为：

   GET  获取目标资源的表示；

   HEAD  获取与GET相同的表示，但不包含表示数据；

   POST  表示操作的状态或结果；

   PUT、DELETE  表示操作的状态；

   OPTIONS  表示通信选项；

   TRACE  表示由终端服务器接收的请求消息的表示。

   除了对CONNECT的响应外，200响应总是带有负载，尽管源服务器可以生成空内容的负载。如果不需要负载，源服务器应返回204（无内容）。对于CONNECT，由于成功的结果是隧道，紧接在响应头之后立即开始传输数据，因此不允许携带负载。

   200响应默认可缓存；即除非方法定义或明确的缓存控制另有规定（参见[RFC7234]第4.2.2节）。

6.3.2.  201 已创建

   201（已创建）状态码表示请求已被满足，并导致一个或多个新资源的创建。由请求创建的主要资源通过响应中的Location头字段标识，或如果未收到Location字段，则由实际请求URI标识。

   201响应的负载通常描述并链接到所创建的资源。有关验证器头字段（如ETag和Last-Modified）在201响应中的含义和用途，请参见第7.2节。

6.3.3.  202 已接受

   202（已接受）状态码表示请求已被接受处理，但处理尚未完成。请求可能最终会被处理，也可能因某些原因被拒绝。HTTP中没有机制重新发送异步操作的状态码。

   202响应具有故意的不确定性。其目的是允许服务器接受某些其他处理请求（例如，每天只运行一次的批处理），而无需用户代理保持连接直到处理完成。此响应的负载应描述请求的当前状态，并指向（或嵌入）一个状态监控，向用户提供请求何时可能完成的估计。

6.3.4.  203 非权威性信息

   203（非权威性信息）状态码表示请求成功，但返回的负载已被中转代理（[RFC7230]第5.7.2节）修改，非源服务器的200（成功）响应。这允许代理通知接收者已应用变换，因为这可能影响后续内容的决策。例如，未来的内容验证请求可能只在相同请求路径（通过相同代理）上适用。

   203响应类似于[RFC7234]第5.5节中的214“变换已应用”警告码，但具有更广泛的适用性。

   203响应默认可缓存；除非方法定义或明确的缓存控制另有规定（参见[RFC7234]第4.2.2节）。

6.3.5.  204 无内容

   204（无内容）状态码表示服务器已成功完成请求，且响应负载中没有额外内容。响应头中的元数据指示目标资源及其在请求操作后所采用的表示。

   例如，如果对PUT请求返回204，并且响应中包含ETag头字段，则说明PUT成功，ETag值为新表示的实体标签。

   204响应允许服务器指示操作已成功应用于目标资源，同时暗示用户代理无需离开当前“文档视图”（如果有的话）。服务器假设用户代理会根据其界面向用户显示成功信息，并将响应中的任何新或更新的元数据应用于其活动的表示。

   例如，204状态码常用于文档编辑界面中的“保存”操作，保存后文档仍可供用户编辑。它也常用于自动数据传输频繁的界面，如分布式版本控制系统。

   由于不能包含消息体，204响应在头部字段之后的第一个空行处终止。

   204响应默认可缓存；除非方法定义或明确的缓存控制另有规定（参见[RFC7234]第4.2.2节）。

6.3.6.  205 重置内容

   205（重置内容）状态码表示服务器已完成请求，并希望用户代理重置“文档视图”，即引发请求的视图，恢复到从源服务器接收的原始状态。
```

此响应旨在支持一种常见的数据输入使用场景，即用户接收支持数据输入的内容（如表单、记事本、画布等），在该空间中输入或操作数据，导致所输入的数据在请求中被提交，然后数据输入机制被重置以便用户可以轻松发起另一次输入操作。

由于205状态码意味着不会提供额外内容，服务器在205响应中不得生成有效载荷。换句话说，服务器必须采取以下措施之一：a）在响应中包含一个内容长度为0的Content-Length头字段；b）在响应中包含一个Transfer-Encoding头字段，值为chunked，并且消息体由一个零长度的块组成；或c）在发送完结束头部部分的空行后立即关闭连接。

6.4. 重定向 3xx

3xx（重定向）状态码类别表示用户代理需要采取进一步行动以完成请求。如果提供了Location头字段（第7.1.2节），用户代理可以自动将请求重定向到由该字段值引用的URI，即使具体的状态码未被理解。自动重定向在处理非安全方法（如在第4.2.1节中定义的）时需要谨慎，因为用户可能不希望重定向不安全的请求。

重定向有几种类型：

1. 指示资源可能在不同URI上的重定向，如状态码301（永久移动）、302（找到）和307（临时重定向）所示。

2. 提供多个匹配资源的选择，每个都能代表原始请求目标，如状态码300（多重选择）。

3. 重定向到由Location字段标识的不同资源，该资源可以作为对请求的间接响应，如状态码303（查看其他）。

4. 重定向到之前缓存的结果，如状态码304（未修改）。

注意：在HTTP/1.0中，状态码301（永久移动）和302（找到）首次定义用于第一类重定向（[RFC1945]第9.3节）。早期用户代理在是否将重定向目标的方法保持为原请求的方法（如POST）或改写为GET上存在分歧。虽然HTTP最初为301和302定义了前者的语义（以匹配其在CERN的最初实现），并为303（查看其他）定义了后者的语义，但逐渐普遍做法趋向于将301和302也视为后者的语义。HTTP/1.1的第一个修订版增加了307（临时重定向），以表示前者的语义而不受不同实践的影响。十多年后，大多数用户代理仍会对301和302进行方法重写；因此，本规范在请求为POST时使该行为符合规范。

客户端应检测并干预循环重定向（即“无限”重定向环）。

注意：早期版本的规范建议最多允许五次重定向（[RFC2068]第10.3节）。内容开发者应意识到某些客户端可能实现了此类固定限制。

6.4.1. 300 多重选择

状态码300（多重选择）表示目标资源有多种表现形式，每种都有其更具体的标识符，并提供关于备选方案的信息，以便用户（或用户代理）通过重定向请求到一个或多个这些标识符，从而选择最合适的表现形式。换句话说，服务器希望用户代理进行反应式协商，以选择最适合其需求的表现形式（第3.4节）。

如果服务器有偏好选择，应在响应中生成包含偏好URI的Location头字段。用户代理可以使用该字段值进行自动重定向。

对于除HEAD之外的请求方法，服务器应在300响应中生成包含表示元数据和URI参考的有效载荷，用户或用户代理可以从中自动选择最偏好的一个。如果理解提供的媒体类型，用户代理可以自动从列表中选择。由于HTTP试图保持与其载荷定义的正交性，本规范未定义自动选择的具体格式。实际上，表现形式通常以易于解析的格式提供，用户代理认为可接受，依据共享的设计或内容协商，或采用一些常用的超文本格式。

默认情况下，300响应是可缓存的；除非方法定义或明确的缓存控制（见[RFC7234]第4.2.2节）另有说明。

注意：最初关于300状态码的提案定义URI头字段为提供备选表现形式的列表，使其可用于200、300和406响应，并在对HEAD方法的响应中传输。然而，由于部署不足和语法上的分歧，URI和后续提案Alternates都被从本规范中删除。可以通过一组Link头字段（[RFC5988]）传达列表，每个字段的关系为“alternate”，但部署存在“鸡生蛋”问题。

6.4.2. 301 永久移动

状态码301（永久移动）表示目标资源已被分配了新的永久URI，未来对该资源的引用应使用这些URI之一。具有链接编辑能力的客户端应自动将对有效请求URI的引用重新链接到服务器发送的一个或多个新引用（如果可能）。

服务器应在响应中生成包含新永久URI的Location头字段。用户代理可以使用该字段值进行自动重定向。服务器的响应载荷通常包含一段简短的超文本说明，带有指向新URI的超链接。

注意：出于历史原因，用户代理在后续请求中可能将请求方法从POST改为GET。如果不希望这样，可以使用307（临时重定向）状态码。

301响应默认可缓存；除非方法定义或明确的缓存控制另有说明。

6.4.3. 302 找到

状态码302（找到）表示目标资源暂时位于不同的URI下。由于重定向可能会被偶尔更改，客户端应继续使用有效请求URI进行未来请求。

服务器应在响应中生成包含不同URI的Location头字段。用户代理可以使用该字段值进行自动重定向。响应载荷通常包含一段简短的超文本说明，带有指向不同URI的超链接。

注意：出于历史原因，用户代理在后续请求中可能将请求方法从POST改为GET。如不希望如此，可使用307（临时重定向）。

6.4.4. 303 查看其他

状态码303（查看其他）表示服务器将用户代理重定向到由Location头字段指示的不同资源，旨在对原始请求提供间接响应。用户代理可以对该URI发起检索请求（如果使用HTTP，则为GET或HEAD），该请求也可能被重定向，最终将结果作为对原始请求的答复。注意，Location头字段中的新URI不等同于实际请求的URI。

此状态码适用于任何HTTP方法。主要用于将POST操作的输出重定向到选定的资源，因为这样可以以可单独识别、书签化和缓存的形式提供POST响应的内容，而不依赖于原始请求。

对GET请求的303响应表示，原始服务器没有可通过HTTP传输的目标资源的表现形式。然而，Location字段的值指向一个描述目标资源的资源，向该资源发起检索请求可能会得到对接收者有用的表现形式，而不意味着它代表了原始目标资源。关于可表现的内容、表现形式的充分性以及有用的描述，超出了HTTP的范围。

除对HEAD请求的响应外，303响应的表现形式应包含一段简短的超文本说明，带有指向Location头字段中相同URI的超链接。

6.4.5. 305 使用代理

状态码305（使用代理）曾在本规范的早期版本中定义，现在已被废弃（见附录B）。

6.4.6. 306（未使用）

状态码306在早期版本中定义，但现已不再使用，且该代码已被保留。

6.4.7. 307 临时重定向

状态码307（临时重定向）表示目标资源暂时位于不同的URI下，用户代理在自动重定向到该URI时不得更改请求方法。由于重定向可能随时间变化，客户端应继续使用原始有效请求URI进行未来请求。

服务器应在响应中生成包含不同URI的Location头字段。用户代理可以使用该字段值进行自动重定向。响应载荷通常包含一段简短的超文本说明，带有指向不同URI的超链接。

注意：此状态码类似于302（找到），但不允许将请求方法从POST改为GET。本规范未为301（永久移动）定义等价的对应状态码（[RFC7238]定义了308（永久重定向）用于此目的）。

6.5. 客户端错误 4xx

4xx（客户端错误）状态码类别表示客户端似乎存在错误。除非响应HEAD请求，否则服务器应返回包含错误说明的表现形式，说明错误情况是临时的还是永久的。这些状态码适用于任何请求方法。用户代理应向用户显示任何包含的表现形式。

6.5.1. 400 错误请求

状态码400（错误请求）表示服务器无法处理请求，原因被认为是客户端错误（如请求语法错误、请求消息框架无效或请求路由欺骗等）。

如果请求中提供了认证凭据，服务器会认为这些凭据不足以授予访问权限。客户端不应自动使用相同的凭据重复请求。客户端可以使用新的或不同的凭据重新发起请求，但请求可能因与凭据无关的其他原因而被禁止。

希望“隐藏”当前存在的被禁止目标资源的原始服务器可以选择返回状态码404（未找到）作为响应。

6.5.4.  404 未找到

404（未找到）状态码表示原始服务器未找到目标资源的当前表示，或不愿意披露该资源是否存在。404状态码不表明这种缺失的表示是临时的还是永久的；如果服务器知道（可能通过某些可配置的方式）该条件可能是永久的，则更倾向于使用410（已移除）状态码。

默认情况下，404响应是可缓存的；除非方法定义或明确的缓存控制（参见[RFC7234]第4.2.2节）另有说明。

6.5.5.  405 方法不被允许

405（方法不被允许）状态码表示请求行中所用的方法被原始服务器识别，但不被目标资源支持。原始服务器必须在405响应中生成Allow头字段，列出目标资源当前支持的方法。

默认情况下，405响应是可缓存的；除非方法定义或明确的缓存控制另有说明（参见[RFC7234]第4.2.2节）。

6.5.6.  406 不可接受

406（不可接受）状态码表示目标资源没有符合请求中主动协商头字段（第5.3节）所要求的当前表示，且服务器不愿意提供默认表示。

服务器应生成一个负载，列出可用的表示特征及对应的资源标识符，供用户或用户代理选择最合适的一个。用户代理可以自动从该列表中选择最合适的选项，但本规范未定义自动选择的标准（详见第6.4.1节）。

6.5.7.  408 请求超时

408（请求超时）状态码表示服务器在预期等待的时间内未收到完整的请求消息。服务器应在响应中发送“关闭”连接选项（第6.1节[RFC7230]），因为408意味着服务器已决定关闭连接而不是继续等待。如果客户端有未完成的请求在传输中，客户端可以在新连接上重试该请求。

6.5.8.  409 冲突

409（冲突）状态码表示请求无法完成，因为与目标资源的当前状态存在冲突。这种情况通常用户可以解决冲突后重新提交请求。服务器应生成包含足够信息的负载，让用户识别冲突的原因。

冲突最可能发生在PUT请求中。例如，如果使用版本控制，且PUT的表示包含与之前（第三方）请求所做更改冲突的内容，原始服务器可能用409响应表示无法完成请求。在这种情况下，响应内容可能包含有助于基于版本历史合并差异的信息。

6.5.9.  410 已移除

410（已移除）状态码表示访问目标资源的权限已不再存在，且这种情况很可能是永久的。如果原始服务器不知道或无法判断该状态是否为永久，应该使用404（未找到）状态码。

410响应主要用于通知用户资源已被故意移除，建议删除对该资源的远程链接。这在有限期的促销服务或不再由原始服务器所有者管理的个人资源中较为常见。无需将所有永久不可用的资源都标记为“已移除”或长时间保持该标记，具体由服务器所有者自行决定。

410响应默认可缓存；除非方法定义或明确的缓存控制（参见[RFC7234]第4.2.2节）另有说明。

6.5.10.  411 需要长度

411（需要长度）状态码表示服务器拒绝接受没有定义Content-Length的请求（第3.3.2节[RFC7230]）。如果请求中添加了有效的Content-Length头字段，客户端可以重试该请求。

6.5.11.  413 请求实体过大

413（请求实体过大）状态码表示服务器拒绝处理请求，因为请求负载超出了服务器愿意或能够处理的范围。服务器可以关闭连接以阻止客户端继续请求。

如果这种情况是临时的，服务器应生成Retry-After头字段，指示这是临时的，以及客户端可以在何时重试。

6.5.12.  414 请求URI过长

414（请求URI过长）状态码表示服务器拒绝服务请求，因为请求目标（第5.3节[RFC7230]）比服务器愿意处理的长度更长。这种罕见情况可能发生在客户端错误地将POST请求转换为带有长查询信息的GET请求，或客户端陷入重定向的“黑洞”（如重定向的URI前缀指向自身的后缀），或服务器受到试图利用潜在安全漏洞的攻击。

414响应默认可缓存；除非方法定义或明确的缓存控制（参见[RFC7234]第4.2.2节）另有说明。

6.5.13.  415 不支持的媒体类型

415（不支持的媒体类型）状态码表示原始服务器拒绝服务请求，因为请求负载的格式不被目标资源支持。格式问题可能由请求中指示的Content-Type或Content-Encoding引起，也可能通过直接检查数据发现。

6.5.14.  417 期望失败

417（期望失败）状态码表示请求中的Expect头字段（第5.1.1节）中提出的期望未被至少一个接收服务器满足。

6.5.15.  426 需要升级

426（需要升级）状态码表示服务器拒绝使用当前协议执行请求，但可能在客户端升级到其他协议后支持。服务器必须在426响应中包含Upgrade头字段，指明所需的协议（第6.7节[RFC7230]）。

示例：

```
HTTP/1.1 426 Upgrade Required
Upgrade: HTTP/3.0
Connection: Upgrade
Content-Length: 53
Content-Type: text/plain

此服务需要使用HTTP/3.0协议。
```

6.6.  服务器错误5xx

5xx（服务器错误）类别的状态码表示服务器意识到自身出错或无法执行请求的方法。除非响应HEAD请求，服务器应返回包含错误原因的表示，说明错误是临时的还是永久的。用户代理应将任何包含的表示内容显示给用户。这些响应码适用于任何请求方法。

6.6.1.  500 内部服务器错误

500（内部服务器错误）表示服务器遇到未预料的情况，阻止其完成请求。

6.6.2.  501 未实现

501（未实现）表示服务器不支持完成请求所需的功能。当服务器不识别请求方法，且无法支持该方法时，应返回此状态码。该响应默认可缓存；除非方法定义或明确的缓存控制另有说明。

6.6.3.  502 错误的网关

502（错误的网关）表示作为网关或代理的服务器在尝试完成请求时，从上游服务器收到无效响应。

6.6.4.  503 服务不可用

503（服务不可用）表示服务器目前无法处理请求，原因可能是临时过载或计划维护，且预计经过一段时间后会恢复。服务器可以在响应中包含Retry-After头字段，建议客户端等待的时间。

注意：存在503状态码并不意味着服务器必须在过载时使用它。一些服务器可能只是拒绝连接。

6.6.5.  504 网关超时

504（网关超时）表示作为网关或代理的服务器未能及时从上游服务器获得响应，从而无法完成请求。

6.6.6.  505 不支持的HTTP版本

505（不支持的HTTP版本）表示服务器不支持或拒绝支持请求中使用的HTTP主要版本。服务器表明无法或不愿意用与客户端相同的主要版本完成请求（详见[RFC7230]第2.6节），除非通过此错误消息。服务器应生成一个描述为何不支持该版本及支持的其他协议的表示。

7.  响应头字段

响应头字段允许服务器传递关于响应的额外信息，超出状态行中的内容。这些头字段提供关于服务器、目标资源的进一步访问信息或相关资源的信息。

虽然每个响应头字段都有明确的含义，但通常其具体语义可能会根据请求方法和/或响应状态码的语义进一步细化。

7.1.  控制数据

响应头字段可以提供补充状态码的控制数据，指导缓存行为，或指示客户端下一步操作。

+-------------------+--------------------------+
| 头字段名          | 定义于...                |
+-------------------+--------------------------+
| Age               | [RFC7234]第5.1节          |
| Cache-Control     | [RFC7234]第5.2节          |
| Expires           | [RFC7234]第5.3节          |
| Date              | 第7.1.1.2节               |
| Location          | 第7.1.2节                 |
| Retry-After       | 第7.1.3节                 |
| Vary              | 第7.1.4节                 |
| Warning           | [RFC7234]第5.5节          |
+-------------------+--------------------------+

7.1.1.  原始日期

7.1.1.1.  日期/时间格式

在1995年前，服务器常用三种不同的格式来传达时间戳。为了兼容旧实现，本文定义了这三种格式。首选格式是互联网消息格式[RFC5322]中日期和时间的固定长度和单一区域子集。

HTTP-date = IMF-fixdate / obs-date

首选格式示例：

Sun, 06 Nov 1994 08:49:37 GMT  ; IMF-fixdate

两个过时格式的示例：

星期日，1994年11月6日 08:49:37 GMT；过时的RFC 850格式
星期日，1994年11月6日 08:49:37；ANSI C的asctime()格式

解析HTTP头字段中的时间戳值的接收方必须接受所有三种HTTP日期格式。当发送方生成包含一个或多个HTTP日期定义的时间戳的头字段时，必须以IMF-fixdate格式生成这些时间戳。

HTTP日期值表示为协调世界时（UTC）的一种实例。前两种格式通过“GMT”这个三字母缩写表示UTC，"GMT"是UTC的前身；而asctime格式中的值假定为UTC。由本地时钟生成HTTP日期值的发送方应使用NTP（[RFC5905]）或类似协议将其时钟同步到UTC。

首选格式：

    IMF-fixdate  = day-name "," SP date1 SP time-of-day SP GMT
    ; 这是格式的固定长度/时区/大小写子集
    ; 参见[RFC5322]第3.3节

    day-name     = %x4D.6F.6E ; "Mon"，区分大小写
                 / %x54.75.65 ; "Tue"，区分大小写
                 / %x57.65.64 ; "Wed"，区分大小写
                 / %x54.68.75 ; "Thu"，区分大小写
                 / %x46.72.69 ; "Fri"，区分大小写
                 / %x53.61.74 ; "Sat"，区分大小写
                 / %x53.75.6E ; "Sun"，区分大小写

字段与Reschke的标准追踪 [第65页]

RFC 7231  HTTP/1.1语义与内容 2014年6月

    date1        = day SP month SP year
                 ; 例如：02 Jun 1982

    day          = 2DIGIT
    month        = %x4A.61.6E ; "Jan"，区分大小写
                 / %x46.65.62 ; "Feb"，区分大小写
                 / %x4D.61.72 ; "Mar"，区分大小写
                 / %x41.70.72 ; "Apr"，区分大小写
                 / %x4D.61.79 ; "May"，区分大小写
                 / %x4A.75.6E ; "Jun"，区分大小写
                 / %x4A.75.6C ; "Jul"，区分大小写
                 / %x41.75.67 ; "Aug"，区分大小写
                 / %x53.65.70 ; "Sep"，区分大小写
                 / %x4F.63.74 ; "Oct"，区分大小写
                 / %x4E.6F.76 ; "Nov"，区分大小写
                 / %x44.65.63 ; "Dec"，区分大小写
    year         = 4DIGIT

    GMT          = %x47.4D.54 ; "GMT"，区分大小写

    time-of-day  = hour ":" minute ":" second
                 ; 00:00:00 - 23:59:60（闰秒）

    hour         = 2DIGIT
    minute       = 2DIGIT
    second       = 2DIGIT

过时的格式：

    obs-date     = rfc850-date / asctime-date

    rfc850-date  = day-name-l "," SP date2 SP time-of-day SP GMT
    date2        = day "-" month "-" 2DIGIT
                 ; 例如：02-Jun-82

    day-name-l   = %x4D.6F.6E.64.61.79    ; "Monday"，区分大小写
                 / %x54.75.65.73.64.61.79 ; "Tuesday"，区分大小写
                 / %x57.65.64.6E.65.73.64.61.79 ; "Wednesday"，区分大小写
                 / %x54.68.75.72.73.64.61.79 ; "Thursday"，区分大小写
                 / %x46.72.69.64.61.79 ; "Friday"，区分大小写
                 / %x53.61.74.75.72.64.61.79 ; "Saturday"，区分大小写
                 / %x53.75.6E.64.61.79 ; "Sunday"，区分大小写

    asctime-date = day-name SP date3 SP time-of-day SP year
    date3        = month SP ( 2DIGIT / ( SP 1DIGIT ))
                 ; 例如：Jun  2

HTTP-date区分大小写。发送方不得在HTTP-date中生成除语法中明确包含的SP之外的额外空白字符。day-name、day、month、year和time-of-day的语义与对应的互联网消息格式结构（[RFC5322]第3.3节）中定义的相同。

接收方在处理使用rfc850-date格式（使用两位数年份）的时间戳值时，必须将看似超过50年未来的时间戳解释为表示过去最近的年份，其最后两位数字相同。

鼓励接收方在解析时间戳时具有鲁棒性，除非字段定义另有限制。例如，消息偶尔会通过HTTP从非HTTP源转发，可能会生成互联网消息格式定义的任何日期和时间规范。

注意：HTTP对日期/时间戳格式的要求仅适用于协议流中的使用。实现不必在用户界面、请求日志等中使用这些格式。

7.1.1.2. 日期

“Date”头字段表示消息的起始时间和日期，其语义与[RFC5322]第3.6.1节定义的起始日期字段（orig-date）相同。字段值为HTTP-date，定义见第7.1.1.1节。

    Date = HTTP-date

示例：

    Date: Tue, 15 Nov 1994 08:12:31 GMT

当生成Date头字段时，发送方应尽可能用最接近消息生成时间的时间值。理论上，日期应代表在生成有效载荷之前的瞬间；实际操作中，日期可以在消息起始的任何时间生成。

如果没有协调世界时的合理时钟，起源服务器不得发送Date头字段。响应为1xx（信息性）或5xx（服务器错误）状态码时，起源服务器可以选择性地发送Date头字段。其他情况下，必须发送。

接收方的时钟收到没有Date头字段的响应时，应记录收到的时间，并在消息被缓存或转发时添加相应的Date头字段。

用户代理可以在请求中添加Date头字段，但通常不会这样做，除非认为对服务器有用。例如，某些自定义HTTP应用可能会在请求中携带Date，以便服务器根据用户代理和服务器的时钟差异调整请求的解释。

7.1.2. 位置（Location）

“Location”头字段在某些响应中用于指示与响应相关的特定资源。关系类型由请求方法和状态码的语义共同定义。

    Location = URI-reference

字段值为单一的URI引用。当其为相对引用（[RFC3986]第4.2节）时，最终值通过解析相对于请求的有效URI（[RFC3986]第5节）得到。

对于201（已创建）响应，Location值指向由请求创建的主要资源。对于3xx（重定向）响应，Location值指向自动重定向的目标资源。

如果3xx响应中的Location值没有片段部分，用户代理必须将重定向处理为继承请求目标URI的片段（即，重定向继承原始引用的片段（如果有））。

例如，针对URI引用"http://www.example.org/~tim"的GET请求可能会得到一个包含以下头字段的303（查看其他）响应：

    Location: /People.html#tim

提示用户代理重定向到"http://www.example.org/People.html#tim"

同样，针对URI引用"http://www.example.org/index.html#larry"的GET请求可能会得到一个包含以下头字段的301（永久移动）响应：

    Location: http://www.example.net/index.html

提示用户代理重定向到"http://www.example.net/index.html#larry"，保留原始片段标识符。

在某些情况下，Location值中的片段标识符可能不适用。例如，201（已创建）响应中的Location头字段应提供特定于已创建资源的URI。

注意：一些接收方会尝试从无效的URI引用的Location字段中恢复。此规范不强制或定义此类处理，但出于鲁棒性考虑允许这样做。

注意：Content-Location头字段（第3.1.4.2节）不同于Location，Content-Location指示与所包含表示最具体的资源。因此，响应中可能同时包含Location和Content-Location头字段。

7.1.3. 重试-后（Retry-After）

服务器在响应中发送“Retry-After”头字段，指示用户代理在发起后续请求前应等待的时间。当与503（服务不可用）响应一起发送时，表示服务预计在一段时间内对客户端不可用；当与任何3xx（重定向）响应一起发送时，表示请求被重定向前，用户代理应等待的最短时间。

该字段的值可以是HTTP-date或延迟秒数（delay-seconds）。

    Retry-After = HTTP-date / delay-seconds

delay-seconds为非负十进制整数，表示秒数。

示例：

    Retry-After: Fri, 31 Dec 1999 23:59:59 GMT
    Retry-After: 120

第二个示例表示等待2分钟。

7.1.4.  变体（Vary）

响应中的“Vary”头字段描述除请求方法、Host头和请求目标之外，可能影响源服务器选择和表示此响应的请求消息部分。值可以是单个星号（“*”）或请求头字段名的列表（不区分大小写）。

    Vary = "*" / 1#field-name

“*”表示请求的任何部分都可能影响响应的选择，可能包括消息语法之外的元素（例如，客户端的网络地址）。接收方无法在不转发请求到源服务器的情况下判断此响应是否适合后续请求。代理不得生成值为“*”的Vary字段。

由逗号分隔的请求头字段名列表表示，命名的请求头字段（称为选择头字段）可能在选择响应表示时起作用。潜在的选择头字段不限于本规范定义的字段。

例如，响应包含：

    Vary: accept-encoding, accept-language

表示源服务器在选择内容时可能考虑了请求的Accept-Encoding和Accept-Language字段（或缺失情况）。

源服务器可能出于两个目的在响应中包含Vary字段：

1. 通知缓存接收方，除非后续请求的对应字段值与原始请求相同，否则不得使用此响应满足后续请求（[RFC7234]第4.1节）。换句话说，Vary扩展了匹配新请求与存储缓存条目的缓存键。

2. 通知用户代理，此响应受内容协商（第5.3节）影响，如果在后续请求中提供了额外参数，可能会返回不同的表示（主动协商）。

除非变异无法跨越或源服务器被有意配置为阻止缓存透明，否则应在其选择表示的算法中包含Vary头字段。例如，不必在Vary中包含Authorization字段名，因为跨用户的重用受到字段定义的限制（[RFC7235]第4.2节）。同样，源服务器也可以使用Cache-Control指令（[RFC7234]第5.2节）来取代Vary，如果它认为变异不那么重要，且Vary对缓存性能的影响成本较高。

7.2.  校验器头字段（Validator Header Fields）

校验器头字段传达关于所选表示的元数据（第3节）。在对安全请求的响应中，校验器字段描述源服务器在处理响应时选择的表示。请注意，根据状态码的语义，响应所用的表示不一定与作为响应负载的表示相同。

在对状态变更请求的成功响应中，校验器字段描述已由请求处理替换掉之前所选表示的新表示。

例如，201（已创建）响应中的ETag头字段传达新创建资源的实体标签（entity-tag），以便在后续条件请求中使用，防止“丢失更新”问题（[RFC7232]）。

+-------------------+--------------------------+
| 头字段名称        | 定义于...                |
+-------------------+--------------------------+
| ETag             | [RFC7232] 第2.3节       |
| Last-Modified    | [RFC7232] 第2.2节       |
+-------------------+--------------------------+








Fielding & Reschke           标准轨迹                   [第71页]


RFC 7231             HTTP/1.1语义与内容             2014年6月


7.3.  认证挑战

   认证挑战指示客户端在未来请求中可以提供认证凭据的机制。

   +--------------------+--------------------------+
   | 头字段名称         | 定义于...                |
   +--------------------+--------------------------+
   | WWW-Authenticate   | [RFC7235] 第4.1节       |
   | Proxy-Authenticate | [RFC7235] 第4.3节       |
   +--------------------+--------------------------+

7.4.  响应上下文

   其余的响应头字段提供关于目标资源的更多信息，供后续请求潜在使用。

   +-------------------+--------------------------+
   | 头字段名称        | 定义于...                |
   +-------------------+--------------------------+
   | Accept-Ranges     | [RFC7233] 第2.3节       |
   | Allow             | 第7.4.1节               |
   | Server            | 第7.4.2节               |
   +-------------------+--------------------------+

7.4.1.  Allow

   "Allow" 头字段列出目标资源支持的方法集。此字段的目的是纯粹通知接收方与资源相关的有效请求方法。

     Allow = #method

   使用示例：

     Allow: GET, HEAD, PUT

   实际允许的方法集由源服务器在每次请求时定义。源服务器必须在返回405（方法不允许）响应时生成Allow字段，也可以在其他任何响应中生成。空的Allow字段值表示该资源不允许任何方法，如果资源被临时禁用（如配置中），在405响应中可能会出现。

   代理服务器不得修改Allow头字段——它不需要理解所有指示的方法，也能根据通用消息处理规则处理请求。





Fielding & Reschke           标准轨迹                   [第72页]


RFC 7231             HTTP/1.1语义与内容             2014年6月


7.4.2.  Server

   "Server" 头字段包含关于源服务器处理请求所用软件的信息，客户端常用此信息帮助识别报告的互操作性问题范围，绕过或定制请求以避免特定的服务器限制，以及进行服务器或操作系统使用的分析。源服务器可以在响应中生成Server字段。

     Server = product *( RWS ( product / comment ) )

   Server字段值由一个或多个产品标识符组成，每个后跟零个或多个注释（[RFC7230] 第3.2节），共同标识源服务器软件及其重要子产品。按照惯例，产品标识符按其识别源服务器软件的重要性递减列出。每个产品标识符由名称和可选版本组成，定义见第5.5.3节。

   示例：

     Server: CERN/3.0 libwww/2.17

   源服务器不应生成包含不必要细节的Server字段，也应限制第三方添加子产品。过长且细节丰富的Server字段值会增加响应延迟，并可能泄露内部实现细节，稍微增加攻击者发现和利用已知安全漏洞的难度。

8.  IANA注意事项

8.1.  方法注册表

   "超文本传输协议（HTTP）方法注册表"定义了请求方法标记的命名空间（第4节）。该注册表已建立并由<http://www.iana.org/assignments/http-methods>维护。





Fielding & Reschke           标准轨迹                   [第73页]


RFC 7231             HTTP/1.1语义与内容             2014年6月


8.1.1.  程序

   HTTP方法的注册必须包括以下字段：

   o  方法名称（见第4节）

   o  是否安全（"yes"或"no"，见第4.2.1节）

   o  是否幂等（"yes"或"no"，见第4.2.2节）

   o  规范文本的指针

   添加到此命名空间的值需要经过IETF审查（见[RFC5226]第4.1节）。

8.1.2.  新方法的考虑事项

   标准化的方法是通用的；即，它们可能适用于任何资源，而不限于某一特定媒体类型、资源类型或应用。因此，建议新方法在不针对单一应用或数据格式的文档中注册，因为正交技术应有正交的规范。

   由于消息解析（[RFC7230]第3.3节）需要与方法语义无关（HEAD请求除外），新方法的定义不能改变解析算法，也不能禁止请求或响应消息中存在消息体。新方法的定义可以规定只允许零长度消息体，例如通过要求Content-Length头字段值为"0"。

   新方法的定义应指明其是否安全（第4.2.1节）、是否幂等（第4.2.2节）、是否可缓存（第4.2.3节）、如果请求中存在有效载荷，相关的语义，以及该方法对头字段或状态码语义的任何细化。如果新方法可缓存，其定义应描述缓存如何以及在何种条件下存储响应并用以满足后续请求。新方法还应说明是否可以条件化（第5.2节），以及在条件不成立时服务器如何响应。同样，如果新方法可能对部分响应语义（[RFC7233]）有用，也应予以说明。

      注意：避免定义以"M-"开头的方法名，因为该前缀可能被误解为具有[RFC2774]赋予的语义。





Fielding & Reschke           标准轨迹                   [第74页]


RFC 7231             HTTP/1.1语义与内容             2014年6月


8.1.3.  注册

   "超文本传输协议（HTTP）方法注册表"已填充以下注册项：

   +---------+------+------------+--------------+
   | 方法    | 安全 | 幂等       | 参考文献     |
   +---------+------+------------+--------------+
   | CONNECT | 否   | 否         | 第4.3.6节    |
   | DELETE  | 否   | 是         | 第4.3.5节    |
   | GET     | 是   | 是         | 第4.3.1节    |
   | HEAD    | 是   | 是         | 第4.3.2节    |
   | OPTIONS | 是   | 是         | 第4.3.7节    |
   | POST    | 否   | 否         | 第4.3.3节    |
   | PUT     | 否   | 是         | 第4.3.4节    |
   | TRACE   | 是   | 是         | 第4.3.8节    |
   +---------+------+------------+--------------+

8.2.  状态码注册表

   "超文本传输协议（HTTP）状态码注册表"定义了响应状态码标记的命名空间（第6节）。该注册表由<http://www.iana.org/assignments/http-status-codes>维护。

   本节取代了之前在[RFC2817]第7.1节中定义的HTTP状态码注册程序。

8.2.1.  程序

   注册必须包括以下字段：

   o  状态码（3位数字）

   o  简短描述

   o  规范文本的指针

   添加到HTTP状态码命名空间的值需要经过IETF审查（见[RFC5226]第4.1节）。





Fielding & Reschke           标准轨迹                   [第75页]


RFC 7231             HTTP/1.1语义与内容             2014年6月


8.2.2.  新状态码的考虑事项

   当需要表达当前状态码未定义的响应语义时，可以注册新的状态码。状态码是通用的；它们可能适用于任何资源，而不限于某一特定媒体类型、资源类型或HTTP应用。建议新状态码在不针对单一应用的文档中注册。

   新状态码必须属于第6节定义的类别之一。为了让现有解析器能处理响应消息，新状态码不能禁止携带有效载荷，但可以要求有效载荷为空（如设置Content-Length为"0"）。

   对尚未广泛部署的新状态码提议，应避免在未达成明确共识前为其分配具体数字；可以使用类似"4NN"或"3N0"到"3N9"的符号，表示所提议状态码的类别，而不提前占用数字。

   新状态码的定义应说明引发该状态码响应的请求条件（如请求头字段和/或方法的组合），以及对响应头字段的依赖（如必需字段、可修改语义的字段，以及在使用新状态码时对头字段语义的进一步细化）。

   定义还应说明该状态码是否可缓存。所有状态码在响应中具有明确新鲜度信息时都可以缓存，但标记为可缓存的状态码可以在没有明确新鲜度信息的情况下缓存。定义还应限制缓存行为（详见[RFC7234]）。

   最后，定义应指明该状态码的有效载荷是否与某个已识别的资源有关联（第3.1.4.1节）。

8.2.3.  注册项

   状态码注册表已更新，加入以下注册项：





Fielding & Reschke           标准轨迹                   [第76页]


RFC 7231             HTTP/1.1语义与内容             2014年6月


   +-------+------------------------------+--------------+
   | 值    | 描述                         | 参考文献     |
   +-------+------------------------------+--------------+
   | 100   | 继续                         | 第6.2.1节    |
   | 101   | 切换协议                     | 第6.2.2节    |
   | 200   | 成功                         | 第6.3.1节    |
   | 201   | 已创建                       | 第6.3.2节    |
   | 202   | 已接受                       | 第6.3.3节    |
   | 203   | 非权威性信息                 | 第6.3.4节    |
   | 204   | 无内容                       | 第6.3.5节    |
   | 205   | 重置内容                     | 第6.3.6节    |
   | 300   | 多重选择                     | 第6.4.1节    |
   | 301   | 永久移动                     | 第6.4.2节    |
   | 302   | 找到                         | 第6.4.3节    |
   | 303   | 参见其他                     | 第6.4.4节    |
   | 305   | 使用代理                     | 第6.4.5节    |
   | 306   | （未使用）                   | 第6.4.6节    |
   | 307   | 临时重定向                   | 第6.4.7节    |
   | 400   | 错误请求                     | 第6.5.1节    |
   | 402   | 需要付款                     | 第6.5.2节    |
   | 403   | 禁止                         | 第6.5.3节    |
   | 404   | 未找到                       | 第6.5.4节    |
   | 405   | 方法不允许                   | 第6.5.5节    |
   | 406   | 不可接受                     | 第6.5.6节    |
   | 408   | 请求超时                     | 第6.5.7节    |
   | 409   | 冲突                         | 第6.5.8节    |
   | 410   | 已删除                       | 第6.5.9节    |
   | 411   | 需要长度                     | 第6.5.10节   |
   | 413   | 有效载荷过大                 | 第6.5.11节   |
   | 414   | URI过长                      | 第6.5.12节   |
   | 415   | 不支持的媒体类型             | 第6.5.13节   |
   | 417   | 期望失败                     | 第6.5.14节   |
   | 426   | 需要升级                     | 第6.5.15节   |
   | 500   | 服务器内部错误               | 第6.6.1节    |
   | 501   | 未实现                       | 第6.6.2节    |
   | 502   | 网关错误                     | 第6.6.3节    |
   | 503   | 服务不可用                   | 第6.6.4节    |
   | 504   | 网关超时                     | 第6.6.5节    |
   | 505   | 不支持的HTTP版本              | 第6.6.6节    |
   +-------+------------------------------+--------------+

8.3.  头字段注册表

   HTTP头字段在"消息头"注册表中注册，注册表位于<http://www.iana.org/assignments/message-headers>，由[BCP90]定义。




Fielding & Reschke           标准轨迹                   [第77页]


RFC 7231             HTTP/1.1语义与内容             2014年6月


8.3.1.  新头字段的考虑事项

   头字段是键值对，用于传达关于消息、有效载荷、目标资源或连接（即控制数据）的信息。关于HTTP消息中头字段语法的通用定义见[RFC7230]第3.2节。

   头字段名的要求在[BCP90]中定义。

   规范定义新字段的作者应尽量保持名称简短，除非该头字段永不在互联网使用，否则不应在名称前加"X-"前缀。（"X-"前缀的用法在实践中被大量滥用；其本意是作为避免专有软件或内联网处理中的命名冲突的机制，因为该前缀能确保私有名称不会与新注册的互联网名称冲突；详见[BCP178]。）

新的头字段值通常使用ABNF（[RFC5234]）定义其语法，必要时结合[RFC7230]第7节中扩展的定义，并且通常限制在US-ASCII字符范围内。需要更大字符范围的头字段可以使用如[RFC5987]中定义的编码方式。

在字段解析（[RFC7230]第3.2.4节）时，会去除原始字段值中的前导和尾随空白。对于值中前导或尾随空白具有特殊意义的字段定义，必须使用诸如引号字符串（[RFC7230]第3.2.6节）等容器语法。

由于逗号（","）被用作字段值之间的通用分隔符，如果允许在字段值中出现逗号，则需要谨慎处理。通常，将可能包含逗号的组件用双引号括起来，使用引号字符串的ABNF规则。

例如，文本日期和URI（其中任何一个都可能包含逗号）可以安全地在字段值中表示为：

```
  Example-URI-Field: "http://example.com/a.html,foo",
                     "http://without-a-comma.example.com/"
  Example-Date-Field: "Sat, 04 May 1996", "Wed, 14 Sep 2005"
```

注意，几乎总是使用引号作为引号字符串的界定符；在双引号内使用不同的语法可能会引起不必要的混淆。

许多头字段采用包括（不区分大小写）命名参数的格式（例如，定义在第3.1.1.5节的Content-Type）。允许参数值既可以是未引号的标记（token），也可以是引号字符串（quoted-string），这样接收方可以使用现有的解析器组件。当同时允许这两种形式时，参数值的含义应与所用语法无关（例如，参见第3.1.1.1节中关于媒体类型参数处理的说明）。

建议定义新头字段的规范作者考虑记录以下内容：

- 该字段是单值还是可以是由逗号分隔的列表（参见[RFC7230]第3.2节）。

  如果不使用列表语法，应说明在字段多次出现时的处理方式（合理的默认是忽略该字段，但这不一定总是正确的）。

  注意，中间件和软件库可能会将多个字段实例合并成一个，尽管字段定义不允许列表语法。一个稳健的格式应允许接收方检测到这些情况（良好的示例：“Content-Type”，逗号只能出现在引号字符串内；不良示例：“Location”，逗号可能出现在URI中）。

- 该字段在何种条件下可以使用；例如，仅在响应或请求中，所有消息中，或仅在对特定请求方法的响应中等。

- 该字段是否应由理解它的源服务器在PUT请求时存储。

- 该字段的语义是否会因上下文（如现有的请求方法或状态码）而进一步细化。

- 是否适合在Connection头字段中列出该字段名（即该字段是否为hop-by-hop；参见[RFC7230]第6.1节）。

- 中间件允许在何种条件下插入、删除或修改该字段的值。

- 是否适合在Vary响应头字段中列出该字段名（例如，当请求头字段被源服务器的内容选择算法使用时；参见第7.1.4节）。

- 该字段在 trailers 中是否有用或允许使用（参见[RFC7230]第4.1节）。

- 该字段是否应在重定向过程中被保留。

- 该字段是否引入任何额外的安全考虑，例如泄露隐私相关数据。

8.3.2. 注册

“消息头”注册表已更新，加入以下永久注册项：

+-------------------+----------+----------+-----------------+
| 头字段名          | 协议     | 状态     | 参考            |
+-------------------+----------+----------+-----------------+
| Accept            | http     | 标准     | 第5.3.2节       |
| Accept-Charset    | http     | 标准     | 第5.3.3节       |
| Accept-Encoding   | http     | 标准     | 第5.3.4节       |
| Accept-Language   | http     | 标准     | 第5.3.5节       |
| Allow             | http     | 标准     | 第7.4.1节       |
| Content-Encoding  | http     | 标准     | 第3.1.2.2节     |
| Content-Language  | http     | 标准     | 第3.1.3.2节     |
| Content-Location  | http     | 标准     | 第3.1.4.2节     |
| Content-Type      | http     | 标准     | 第3.1.1.5节     |
| Date              | http     | 标准     | 第7.1.1.2节     |
| Expect            | http     | 标准     | 第5.1.1节       |
| From              | http     | 标准     | 第5.5.1节       |
| Location          | http     | 标准     | 第7.1.2节       |
| Max-Forwards      | http     | 标准     | 第5.1.2节       |
| MIME-Version      | http     | 标准     | 附录A.1节       |
| Referer           | http     | 标准     | 第5.5.2节       |
| Retry-After       | http     | 标准     | 第7.1.3节       |
| Server            | http     | 标准     | 第7.4.2节       |
| User-Agent        | http     | 标准     | 第5.5.3节       |
| Vary              | http     | 标准     | 第7.1.4节       |
+-------------------+----------+----------+-----------------+

上述注册的变更控制者为：“IETF（iesg@ietf.org）——互联网工程任务组”。

8.4 内容编码注册表

“HTTP内容编码注册表”定义了内容编码名称的命名空间（[RFC7230]第4.2节）。该注册表由<http://www.iana.org/assignments/http-parameters>维护。

8.4.1 注册流程

内容编码的注册必须包括以下字段：

- 名称

- 描述

- 规范文本的指针

内容编码的名称不得与传输编码（[RFC7230]第4节）中的名称重叠，除非编码转换完全相同（如[RFC7230]第4.2节定义的压缩编码）。

向此命名空间添加的值需要经过IETF审查（参见[RFC5226]第4.1节），并且必须符合本节定义的内容编码目的。

8.4.2 注册

“HTTP内容编码注册表”已更新，加入以下注册项：

+----------+------------------------------+--------------+
| 名称     | 描述                         | 参考         |
+----------+------------------------------+--------------+
| identity | 保留（“无编码”的同义词，见| 第5.3.4节    |
|          | Accept-Encoding）            |              |
+----------+------------------------------+--------------+

9. 安全考虑

本节旨在向开发者、信息提供者和用户介绍与HTTP语义及其在互联网传输信息中的使用相关的已知安全问题。关于消息语法、解析和路由的考虑在[RFC7230]第9节中已有讨论。

以下列出的问题并不详尽。大多数与HTTP语义相关的安全问题集中在保护服务器端应用（HTTP接口背后的代码）、保护用户代理处理通过HTTP接收的负载，或确保互联网的安全使用，而非协议本身的安全。各组织维护关于Web应用安全的专题信息和最新研究链接（例如[OWASP]）。

9.1 基于文件名和路径名的攻击

源服务器常利用本地文件系统管理请求URI到资源表示的映射。大多数文件系统未设计用以防范恶意文件或路径名。因此，源服务器应避免访问具有特殊系统意义的名称，以免在映射请求目标到文件、文件夹或目录时引发安全问题。

例如，UNIX、Windows等操作系统使用“..”作为路径组件，表示上一级目录，且使用特殊命名路径或文件名向系统设备发送数据。其他存储系统中也可能存在类似的命名惯例。类似地，本地存储系统在处理无效或意外字符、重组分解字符、大小写不敏感名称的大小写归一化时，可能偏向用户友好而非安全。

此类特殊名称的攻击多集中在拒绝服务（如指示服务器读取COM端口）或泄露配置和源文件（不应被公开提供）。

9.2 基于命令、代码或查询注入的攻击

源服务器常用URI中的参数作为识别系统服务、选择数据库条目或数据源的手段。然而，接收到的数据不能被信任。攻击者可能构造请求中的任何元素（方法、请求目标、头字段或正文），使其在经过命令调用、语言解释器或数据库接口时被误解为命令、代码或查询。

例如，SQL注入是一种常见攻击，将额外的查询语言插入请求目标或头字段（如Host、Referer等）。如果直接在SELECT语句中使用接收的数据，可能会被解释为数据库命令而非普通字符串。这类漏洞非常普遍，尽管很容易预防。

通常，资源实现应避免在被处理或解释为指令的上下文中使用请求数据。参数应与固定字符串比较，并据此采取行动，而非传递到未准备好处理不可信数据的接口。非固定参数的数据应经过严格过滤或编码，以防误解。

类似地，存储和后续处理请求数据（如日志、监控工具或嵌入脚本的数据格式）时，也应考虑安全。

9.3 个人信息泄露

客户端通常掌握大量个人信息，包括用户提供的用于交互的资料（如姓名、位置、邮箱、密码、加密密钥等）以及用户浏览行为的记录（如历史、书签等）。实现应防止无意中泄露这些信息。

9.4 URI中敏感信息的泄露

URI旨在共享而非安全，即使它们指向安全资源。URI常在显示屏上显示、打印页面模板中出现，或存储在未加密的书签列表中。因此，不应在URI中包含敏感、个人识别或可能泄露的内容。

服务提供者应避免使用GET表单提交敏感数据，因为这会将数据放在请求目标中。许多服务器、代理和用户代理会在日志或显示中记录请求目标，可能被第三方看到。应优先使用POST表单提交。

由于Referer头字段会向目标站点透露请求的上下文，包括用户的浏览历史和可能的个人信息（在引用资源的URI中），因此在安全性考虑中对Referer的限制也被提出（参见第5.5.2节）。

9.5 重定向后片段的泄露

虽然URI中的片段标识符不会在请求中发送，但实现者应意识到它们会被用户代理和响应引发的扩展或脚本看到。特别是在发生重定向且原始请求的片段标识符被继承到Location中的新引用时，可能会导致一个站点的片段信息泄露给另一个站点。如果第一个站点在片段中使用个人信息，应确保重定向到其他站点时包含（可能为空的）片段部分，以阻止继承。

9.6 产品信息的泄露

用户代理（第5.5.3节）、Via（[RFC7230]第5.7.1节）和Server（第7.4.2节）头字段通常会泄露关于各自发送者软件系统的信息。从理论上讲，这可能会让攻击者更容易利用已知的安全漏洞；但实际上，攻击者往往会尝试所有潜在的漏洞，而不管所使用的软件版本是否明显。

作为网络防火墙入口的代理应采取特殊措施，防止传输可能识别防火墙后主机的头信息。Via头字段允许中间人用假名替换敏感的机器名。

9.7. 浏览器指纹识别

浏览器指纹识别是一套通过浏览器的唯一特征集，随着时间识别特定用户代理的技术。这些特征可能包括与TCP行为、功能能力和脚本环境相关的信息，尤其是通过HTTP传递的那些独特特征。指纹识别被视为一种隐私问题，因为它可以在没有用户控制的情况下追踪用户代理的行为。许多通用用户代理（即网页浏览器）已采取措施减少其指纹特征。

有一些请求头字段可能会向服务器泄露足够唯一的信息，从而实现指纹识别。最明显的是From头字段，尽管预计只有在用户希望自我识别时才会发送。同样，Cookie头字段也是故意设计用以实现重新识别的，因此指纹识别的担忧主要在用户代理禁用或限制Cookie的情况下才成立。

User-Agent头字段可能包含足够的信息，结合其他特征，唯一识别某一设备，尤其是在用户代理发送关于用户系统或扩展的详细信息时。然而，用户最少预料到的唯一信息来源是主动协商（第5.3节），包括Accept、Accept-Charset、Accept-Encoding和Accept-Language头字段。

除了指纹识别的担忧外，详细使用Accept-Language头字段还可能泄露用户认为私密的信息。例如，理解某一语言集可能与某一特定族裔群体的成员身份密切相关。为减少此类隐私泄露，用户代理可以选择不发送Accept-Language，除非访问已白名单的站点，或者在检测到可能有用的语言协商的Vary头字段后通过交互决定。

在使用代理以增强隐私的环境中，用户代理应对主动协商头字段的发送保持保守。提供高度可配置头字段的通用用户代理应告知用户过多细节可能带来的隐私损失。作为极端隐私保护措施，代理可以过滤中继请求中的主动协商头字段。

10. 致谢

详见[RFC7230]第10节。

11. 参考文献

11.1. 必要性参考文献

[RFC2045] Freed, N. 和 N. Borenstein，“多用途互联网邮件扩展（MIME）第1部分：互联网消息体格式”，RFC 2045，1996年11月。

[RFC2046] Freed, N. 和 N. Borenstein，“多用途互联网邮件扩展（MIME）第2部分：媒体类型”，RFC 2046，1996年11月。

[RFC2119] Bradner, S.，“在RFC中用以指示需求级别的关键词”，BCP 14，RFC 2119，1997年3月。

[RFC3986] Berners-Lee, T.，Fielding, R. 和 L. Masinter，“统一资源标识符（URI）：通用语法”，STD 66，RFC 3986，2005年1月。

[RFC4647] Phillips, A.（主编）和 M. Davis（主编），“语言标签匹配”，BCP 47，RFC 4647，2006年9月。

[RFC5234] Crocker, D.（主编）和 P. Overell，“语法规范的扩展BNF：ABNF”，STD 68，RFC 5234，2008年1月。

[RFC5646] Phillips, A.（主编）和 M. Davis（主编），“识别语言的标签”，BCP 47，RFC 5646，2009年9月。

[RFC6365] Hoffman, P. 和 J. Klensin，“IETF中的国际化术语”，BCP 166，RFC 6365，2011年9月。

[RFC7230] Fielding, R.（主编）和 J. Reschke（主编），“超文本传输协议（HTTP/1.1）：消息语法与路由”，RFC 7230，2014年6月。

[RFC7232] Fielding, R.（主编）和 J. Reschke（主编），“超文本传输协议（HTTP/1.1）：条件请求”，RFC 7232，2014年6月。

[RFC7233] Fielding, R.（主编）、Lafon, Y.（主编）和 J. Reschke（主编），“超文本传输协议（HTTP/1.1）：范围请求”，RFC 7233，2014年6月。

[RFC7234] Fielding, R.（主编）、Nottingham, M.（主编）和 J. Reschke（主编），“超文本传输协议（HTTP/1.1）：缓存”，RFC 7234，2014年6月。

[RFC7235] Fielding, R.（主编）和 J. Reschke（主编），“超文本传输协议（HTTP/1.1）：认证”，RFC 7235，2014年6月。

11.2. 说明性参考文献

[BCP13] Freed, N.、Klensin, J. 和 T. Hansen，“媒体类型规范与注册程序”，BCP 13，RFC 6838，2013年1月。

[BCP178] Saint-Andre, P.、Crocker, D. 和 M. Nottingham，“废弃应用协议中的“X-”前缀及类似结构”，BCP 178，RFC 6648，2012年6月。

[BCP90] Klyne, G.、Nottigham, M. 和 J. Mogul，“消息头字段的注册程序”，BCP 90，RFC 3864，2004年9月。

[OWASP] van der Stock, A.（主编），“构建安全Web应用和Web服务指南”，OWASP 2.0.1，2005年7月，<https://www.owasp.org/>。

[REST] Fielding, R.，“网络软件架构的风格与设计”，加州大学欧文分校博士论文，2000年9月，<http://roy.gbiv.com/pubs/dissertation/top.htm>。

[RFC1945] Berners-Lee, T.、Fielding, R. 和 H. Nielsen，“超文本传输协议——HTTP/1.0”，RFC 1945，1996年5月。

[RFC2049] Freed, N. 和 N. Borenstein，“多用途互联网邮件扩展（MIME）第5部分：符合性标准与示例”，RFC 2049，1996年11月。

[RFC2068] Fielding, R.、Gettys, J.、Mogul, J.、Nielsen, H. 和 T. Berners-Lee，“超文本传输协议——HTTP/1.1”，RFC 2068，1997年1月。

[RFC2295] Holtman, K. 和 A. Mutz，“HTTP中的透明内容协商”，RFC 2295，1998年3月。

[RFC2388] Masinter, L.，“表单值返回：multipart/form-data”，RFC 2388，1998年8月。

[RFC2557] Palme, F.、Hopmann, A.、Shelness, N. 和 E. Stefferud，“HTML（MHTML）等聚合文档的MIME封装”，RFC 2557，1999年3月。

[RFC2616] Fielding, R.、Gettys, J.、Mogul, J.、Frystyk, H.、Masinter, L.、Leach, P. 和 T. Berners-Lee，“超文本传输协议——HTTP/1.1”，RFC 2616，1999年6月。

[RFC2774] Frystyk, H.、Leach, P. 和 S. Lawrence，“HTTP扩展框架”，RFC 2774，2000年2月。

[RFC2817] Khare, R. 和 S. Lawrence，“在HTTP/1.1中升级到TLS”，RFC 2817，2000年5月。

[RFC2978] Freed, N. 和 J. Postel，“IANA字符集注册程序”，BCP 19，RFC 2978，2000年10月。

[RFC5226] Narten, T. 和 H. Alvestrand，“撰写IANA考虑事项部分的指南”，BCP 26，RFC 5226，2008年5月。

[RFC5246] Dierks, T. 和 E. Rescorla，“传输层安全（TLS）协议第1.2版”，RFC 5246，2008年8月。

[RFC5322] Resnick, P.，“互联网消息格式”，RFC 5322，2008年10月。

[RFC5789] Dusseault, L. 和 J. Snell，“HTTP的PATCH方法”，RFC 5789，2010年3月。

[RFC5905] Mills, D.、Martin, J.（主编）、Burbank, J. 和 W. Kasch，“网络时间协议第4版：协议与算法规范”，RFC 5905，2010年6月。

[RFC5987] Reschke, J.，“超文本传输协议（HTTP）头字段参数的字符集和语言编码”，RFC 5987，2010年8月。

[RFC5988] Nottingham, M.，“Web链接”，RFC 5988，2010年10月。

[RFC6265] Barth, A.，“HTTP状态管理机制”，RFC 6265，2011年4月。

[RFC6266] Reschke, J.，“在超文本传输协议（HTTP）中使用Content-Disposition头字段”，RFC 6266，2011年6月。

[RFC7238] Reschke, J.，“超文本传输协议（HTTP）状态码308（永久重定向）”，RFC 7238，2014年6月。

11.3. 附录A：HTTP与MIME的差异

HTTP/1.1采用了许多为互联网消息格式[RFC5322]和多用途互联网邮件扩展（MIME）[RFC2045]定义的结构，以允许消息体以多种开放的表现形式传输，并支持可扩展的头字段。然而，RFC 2045仅关注电子邮件；HTTP的应用具有许多不同于电子邮件的特性，因此，HTTP也具有不同于MIME的特性。这些差异经过精心设计，旨在优化二进制连接的性能、允许更自由地使用新媒体类型、简化日期比较，以及考虑一些早期HTTP服务器和客户端的实践。

本附录描述了HTTP与MIME在具体方面的差异。代理和网关在处理严格MIME环境时，应了解这些差异并在必要时进行相应转换。

A.1. MIME-Version

HTTP不是一个MIME兼容协议，但消息可以包含单一的MIME-Version头字段，以指示构造该消息所用的MIME协议版本。使用MIME-Version头字段表明该消息完全符合MIME协议（见[RFC2045]）。发送方负责确保在导出HTTP消息到严格MIME环境时尽可能完全符合。

A.2. 转换为规范形式

MIME要求在传输前将互联网邮件体部分转换为规范形式，如[RFC2049]第4节所述。本文件第3.1.1.3节描述了通过HTTP传输时“text”媒体类型子类型允许的形式。 [RFC2046]要求“text”类型的内容将换行符表示为CRLF，并禁止在换行符之外使用CR或LF。HTTP允许在文本内容中使用CRLF、裸CR和裸LF作为换行符。

HTTP到严格MIME环境的代理或网关应将第3.1.1.3节描述的文本媒体类型中的所有换行符转换为RFC 2049的规范形式CRLF。但这可能会受到Content-Encoding的影响，并且HTTP允许使用某些不使用字节13和10（即CR和LF）表示换行的字符集。

转换可能会破坏对原始内容应用的任何加密校验和，除非原始内容已是规范形式。因此，建议对在HTTP中使用此类校验和的内容采用规范形式。

A.3. 日期格式的转换

HTTP/1.1使用一组受限的日期格式（第7.1.1.1节）以简化日期比较。其他协议的代理和网关应确保消息中的Date头字段符合HTTP/1.1的格式之一，并在必要时进行重写。

A.4. 内容编码的转换

MIME没有类似HTTP/1.1中Content-Encoding头字段的概念。由于它作为媒体类型的修饰符，HTTP到MIME协议的代理或网关应更改Content-Type头字段的值或在转发前解码表示。某些实验性应用在Internet邮件中使用了带有“;conversions=<content-coding>”参数的Content-Type，功能类似于Content-Encoding，但该参数不属于MIME标准。

A.5. 内容传输编码的转换

HTTP不使用MIME的Content-Transfer-Encoding字段。MIME协议到HTTP的代理或网关应在响应传递给HTTP客户端前移除任何Content-Transfer-Encoding。

从HTTP到MIME协议的代理或网关负责确保消息格式和编码适合该协议的安全传输，“安全传输”由所用协议的限制定义。若这样做能提高安全传输的可能性，应对数据进行相应的转换和标记。

A.6. MHTML与行长度限制

共享MHTML [RFC2557] 代码的HTTP实现需要注意MIME行长度限制。由于HTTP本身没有此限制，因此HTTP不会折叠长行。通过HTTP传输的MHTML消息遵循所有MHTML的约定，包括行长度限制和折叠、规范化等，因为HTTP以载荷的形式传输消息体，除了“multipart/byteranges”类型（[RFC7233]的附录A）外，不会解释内容或其中可能包含的任何MIME头行。

附录B. 与RFC 2616的变更

本次修订的主要变化是编辑方面的：提取消息语法，将HTTP语义划分为核心功能、条件请求、部分请求、缓存和认证等单独文档。修订了符合性语言，明确针对需求，改进了术语，区分了载荷、表现形式和资源。

新增一项要求：当URI中嵌入的语义与请求方法不一致时，应禁用这些语义，因为这是导致互操作性失败的常见原因。（第2节）

增加了一种算法，用于判断载荷是否与特定标识符相关联。（第3.1.4.1节）

移除了文本媒体类型的默认字符集ISO-8859-1；默认值现在由媒体类型定义决定。同样，Accept-Charset头字段中对ISO-8859-1的特殊处理也已移除。（第3.1.1.3节和第5.3.3节）

将Content-Location的定义更改为不再影响解析相对URI引用的基础URI，这是由于实现支持不佳以及可能破坏内容协商资源中的相对链接的负面影响。（第3.1.4.2节）

为了与[RFC7230]中的方法中立解析算法保持一致，GET方法的定义被放宽，允许请求中包含主体，尽管主体对GET没有意义。（第4.3.1节）

服务器不再需要处理所有Content-*头字段，且明确禁止在PUT请求中使用Content-Range。（第4.3.4节）

将CONNECT方法的定义从[RFC2817]移至本规范。（第4.3.6节）

定义OPTIONS和TRACE请求方法为安全的。（第4.3.7节和第4.3.8节）

由于广泛部署的实现存在缺陷，移除了Expect头字段的扩展机制。（第5.1.1节）

Max-Forwards头字段仅限于OPTIONS和TRACE方法使用；之前扩展方法也可以使用它。（第5.1.2节）

建议在没有适用引用URI时，将Referer头字段的值设为about:blank，以区别于未发送或已移除Referer字段的情况。（第5.5.2节）

以下状态码现在可被缓存（即可以在没有明确新鲜度信息的情况下存储和重用）：204、404、405、414、501。（第6节）

将201（Created）状态描述更改为允许创建多个资源的可能性。（第6.3.2节）

将203（非权威信息）的定义扩大到包括载荷转换的情况。（第6.3.4节）

自动重定向安全的请求方法集不再封闭；用户代理可以根据请求方法的语义自行判断。重定向状态码301、302和307不再对响应载荷和用户交互提出规范性要求。（第6.4节）

将状态码301和302更改为允许用户代理将POST方法重写为GET。（第6.4.2节和第6.4.3节）

将303（See Other）状态码的描述更改为允许在提供明确新鲜度信息时进行缓存，并为GET请求的303响应添加了具体定义。（第6.4.4节）

由于安全考虑，305（Use Proxy）状态码已被废弃，原因是涉及代理的带内配置存在风险。（第6.4.5节）

将400（Bad Request）状态码的定义放宽，不再仅限于语法错误。（第6.5.1节）

将426（Upgrade Required）状态码引入自[RFC2817]。（第6.5.15节）

关于HTTP日期和Date头字段的要求目标已缩小为只针对生成日期的系统，而非所有发送日期的系统。（第7.1.1节）

将Location头字段的语法更改为允许所有URI引用，包括相对引用和片段，以及在何时不适用片段的说明。（第7.1.2节）

将has been reclassified as a response header field，移除在PUT请求中指定的选项。关于Allow内容的要求已放宽，因此客户端不必总是信任其值。（第7.4.1节）

定义了Method Registry（方法注册表）。（第8.1节）

重定义了状态码注册表，之前定义在[RFC2817]第7.1节。（第8.2节）

内容编码的注册变更为需要IETF审查。（第8.4节）

Content-Disposition头字段已被移除，因其由[RFC6266]定义。

Content-MD5头字段已被移除，因为其在部分响应中的实现不一致。

附录C. 导入的ABNF

以下核心规则通过引用包含，定义在[RFC5234]的附录B.1中：ALPHA（字母）、CR（回车）、CRLF（回车换行）、CTL（控制字符）、DIGIT（十进制0-9）、DQUOTE（双引号）、HEXDIG（十六进制0-9/A-F/a-f）、HTAB（水平制表符）、LF（换行）、OCTET（任何8位数据序列）、SP（空格）和VCHAR（任何可见US-ASCII字符）。

以下规则在[RFC7230]中定义：

BWS = <BWS，见[RFC7230]第3.2.3节>  
OWS = <OWS，见[RFC7230]第3.2.3节>  
RWS = <RWS，见[RFC7230]第3.2.3节>  
URI-reference = <URI引用，见[RFC7230]第2.7节>  
absolute-URI = <绝对URI，见[RFC7230]第2.7节>  
comment = <注释，见[RFC7230]第3.2.6节>  
field-name = <字段名，见[RFC7230]第3.2节>  
partial-URI = <部分URI，见[RFC7230]第2.7节>  

附录D. 收集的ABNF

在下方收集的ABNF中，列表规则按[RFC7230]第1.2节展开。

Accept = [ ( "," / ( media-range [ accept-params ] ) ) *( OWS "," [ OWS ( media-range [ accept-params ] ) ] ) ]  
Accept-Charset = *( "," OWS ) ( ( charset / "*" ) [ weight ] ) *( OWS "," [ OWS ( charset / "*" ) [ weight ] ) ]  
Accept-Encoding = [ ( "," / ( codings [ weight ] ) ) *( OWS "," [ OWS ( codings [ weight ] ) ] ) ]  
Accept-Language = *( "," OWS ) ( language-range [ weight ] ) *( OWS "," [ OWS ( language-range [ weight ] ) ] )  
Allow = [ ( "," / method ) *( OWS "," [ OWS method ] ) ]

BWS = <BWS，见[RFC7230]第3.2.3节>  
Content-Encoding = *( "," OWS ) content-coding *( OWS "," [ OWS content-coding ] )  
Content-Language = *( "," OWS ) language-tag *( OWS "," [ OWS language-tag ] )  
Content-Location = absolute-URI / partial-URI  
Content-Type = media-type

Date = HTTP-date

Expect = "100-continue"

From = mailbox

GMT = %x47.4D.54 ; GMT

HTTP-date = IMF-fixdate / obs-date

IMF-fixdate = day-name "," SP date1 SP time-of-day SP GMT

Location = URI-reference

Max-Forwards = 1*DIGIT

OWS = <OWS，见[RFC7230]第3.2.3节>  
RWS = <RWS，见[RFC7230]第3.2.3节>  
Referer = absolute-URI / partial-URI  
Retry-After = HTTP-date / delay-seconds

Server = product *( RWS ( product / comment ) )

URI-reference = <URI引用，见[RFC7230]第2.7节>  
User-Agent = product *( RWS ( product / comment ) )

Vary = "*" / ( *( "," OWS ) field-name *( OWS "," [ OWS field-name ] ) )

absolute-URI = <绝对URI，见[RFC7230]第2.7节>  
accept-ext = OWS ";" OWS token [ "=" ( token / quoted-string ) ]  
accept-params = weight *accept-ext  
asctime-date = day-name SP date3 SP time-of-day SP year

charset = token  
codings = content-coding / "identity" / "*"  
comment = <注释，见[RFC7230]第3.2.6节>  
content-coding = token

date1 = day SP month SP year  
date2 = day "-" month "-" 2DIGIT  
date3 = month SP ( 2DIGIT / ( SP DIGIT ) )  
day = 2DIGIT  
day-name = %x4D.6F.6E ; Mon（星期一）  
/ %x54.75.65 ; Tue（星期二）  
/ %x57.65.64 ; Wed（星期三）  
/ %x54.68.75 ; Thu（星期四）  
/ %x46.72.69 ; Fri（星期五）  
/ %x53.61.74 ; Sat（星期六）  
/ %x53.75.6E ; Sun（星期日）  
day-name-l = %x4D.6F.6E.64.61.79 ; Monday（星期一）  
/ %x54.75.65.73.64.61.79 ; Tuesday（星期二）  
/ %x57.65.64.6E.65.73.64.61.79 ; Wednesday（星期三）  
/ %x54.68.75.72.73.64.61.79 ; Thursday（星期四）  
/ %x46.72.69.64.61.79 ; Friday（星期五）  
/ %x53.61.74.75.72.64.61.79 ; Saturday（星期六）  
/ %x53.75.6E.64.61.79 ; Sunday（星期日）  
delay-seconds = 1*DIGIT

field-name = <字段名，见[RFC7230]第3.2节>  
hour = 2DIGIT

language-range = <语言范围，见[RFC4647]第2.1节>  
language-tag = <语言标签，见[RFC5646]第2.1节>

mailbox = <邮箱，见[RFC5322]第3.4节>  
media-range = ( "*/*" / ( type "/*" ) / ( type "/" subtype ) ) *( OWS ";" OWS parameter )

media-type = type "/" subtype *( OWS ";" OWS parameter )  
method = token  
minute = 2DIGIT  
month = %x4A.61.6E ; Jan（一月）  
/ %x46.65.62 ; Feb（二月）  
/ %x4D.61.72 ; Mar（三月）  
/ %x41.70.72 ; Apr（四月）  
/ %x4D.61.79 ; May（五月）  
/ %x4A.75.6E ; Jun（六月）  
/ %x4A.75.6C ; Jul（七月）  
/ %x41.75.67 ; Aug（八月）  
/ %x53.65.70 ; Sep（九月）  
/ %x4F.63.74 ; Oct（十月）  
/ %x4E.6F.76 ; Nov（十一月）  
/ %x44.65.63 ; Dec（十二月）

obs-date = rfc850-date / asctime-date

parameter = token "=" ( token / quoted-string )  
partial-URI = <部分URI，见[RFC7230]第2.7节>  
product = token [ "/" product-version ]  
product-version = token  
quoted-string = <引号字符串，见[RFC7230]第3.2.6节>  
qvalue = ( "0" [ "." *3DIGIT ] ) / ( "1" [ "." *3"0" ] )

rfc850-date = day-name-l "," SP date2 SP time-of-day SP GMT

second = 2DIGIT  
subtype = token

time-of-day = hour ":" minute ":" second  
token = <标记，见[RFC7230]第3.2.6节>  
type = token

weight = OWS ";" OWS "q=" qvalue

year = 4DIGIT

以下是英文内容的中文翻译：

```
   5
      500 内部服务器错误（状态码）  63
      501 未实现（状态码）  63
      502 网关错误（状态码）  63
      503 服务不可用（状态码）  63
      504 网关超时（状态码）  63
      505 不支持的HTTP版本（状态码）  64

   A
      Accept请求头字段  38
      Accept-Charset请求头字段  40
      Accept-Encoding请求头字段  41
      Accept-Language请求头字段  42
      Allow请求头字段  72

   C
      可缓存  24
      压缩（内容编码）  11
      条件请求  36
      CONNECT方法  30
      内容编码  11
      内容协商  6
      Content-Encoding请求头字段  12
      Content-Language请求头字段  13
      Content-Location请求头字段  15
      Content-Transfer-Encoding请求头字段  89
      Content-Type请求头字段  10

   D
      Date请求头字段  67
      deflate（内容编码）  11
      DELETE方法  29

   E
      Expect请求头字段  34

   F
      From请求头字段  44

字段与Reschke  标准轨迹  [第98页]

RFC 7231             HTTP/1.1语义与内容            2014年6月

   G
      GET方法  24
      语法
         Accept  38
         Accept-Charset  40
         Accept-Encoding  41
         accept-ext  38
         Accept-Language  42
         accept-params  38
         Allow  72
         asctime-date  66
         charset  9
         codings  41
         content-coding  11
         Content-Encoding  12
         Content-Language  13
         Content-Location  15
         Content-Type  10
         Date  67
         date1  65
         day  65
         day-name  65
         day-name-l  65
         delay-seconds  69
         Expect  34
         From  44
         GMT  65
         hour  65
         HTTP-date  65
         IMF-fixdate  65
         language-range  42
         language-tag  13
         Location  68
         Max-Forwards  36
         media-range  38
         media-type  8
         method  21
         minute  65
         month  65
         obs-date  66
         parameter  8
         product  46
         product-version  46
         qvalue  38
         Referer  45
         Retry-After  69
         rfc850-date  66
         second  65

字段与Reschke  标准轨迹  [第99页]

RFC 7231             HTTP/1.1语义与内容            2014年6月

         Server  73
         subtype  8
         time-of-day  65
         type  8
         User-Agent  46
         Vary  70
         weight  38
         year  65
      gzip（内容编码）  11

   H
      HEAD方法  25

   I
      幂等  23

   L
      Location请求头字段  68

   M
      Max-Forwards请求头字段  36
      MIME-Version请求头字段  89

   O
      OPTIONS方法  31

   P
      payload（负载）  17
      POST方法  25
      PUT方法  26

   R
      Referer请求头字段  45
      表示  7
      Retry-After请求头字段  69

   S
      安全  22
      选定的表示  7, 71
      Server响应头字段  73
      状态码类别
         1xx 信息性  50
         2xx 成功  51
         3xx 重定向  54
         4xx 客户端错误  58
         5xx 服务器错误  62

字段与Reschke  标准轨迹  [第100页]

RFC 7231             HTTP/1.1语义与内容            2014年6月

   T
      TRACE方法  32

   U
      User-Agent请求头字段  46

   V
      Vary请求头字段  70

   X
      x-compress（内容编码）  11
      x-gzip（内容编码）  11

作者联系方式

   Roy T. Fielding（编辑）
   Adobe Systems Incorporated
   345 Park Ave
   San Jose, CA  95110
   美国

   电子邮箱：fielding@gbiv.com
   网址：http://roy.gbiv.com/

   Julian F. Reschke（编辑）
   greenbytes GmbH
   Hafenweg 16
   Muenster, NW  48155
   德国

   电子邮箱：julian.reschke@greenbytes.de
   网址：http://greenbytes.de/tech/webdav/
```