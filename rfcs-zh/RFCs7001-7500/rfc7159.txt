# RFC 7159 中文翻译 (stub)
# 原文文件: ../../rfcs/RFCs7001-7500/rfc7159.txt

互联网工程任务组（IETF）                      T. Bray，主编
征求意见稿：7159                                    谷歌公司
废止：4627，7158                                         2014年3月
类别：标准轨道
ISSN：2070-1721


     JavaScript对象表示法（JSON）数据交换格式

摘要

   JavaScript对象表示法（JSON）是一种轻量级、基于文本、与语言无关的数据交换格式。它源自ECMAScript编程语言标准中的对象字面量。JSON定义了一套用于结构化数据便携式表示的小型格式规则。

   本文档修正了JSON的其他规范中存在的不一致之处，纠正了规范中的错误，并提供了基于经验的互操作性指导。

本备忘录的状态

   这是一个互联网标准轨道的文档。

   本文档由互联网工程任务组（IETF）制定，代表了IETF社区的共识。它已经过公众审查，并获得互联网工程指导组（IESG）的批准发布。关于互联网标准的更多信息，请参见RFC 5741第2节。

   有关本文件当前状态、任何勘误表以及如何提供反馈的信息，可以访问：http://www.rfc-editor.org/info/rfc7159。

















布雷                         标准轨道                    [第1页]


RFC 7159                          JSON                        2014年3月


版权声明

   本文件的版权归2014年IETF信托及被列为作者的个人所有。保留所有权利。

   本文件遵循BCP 78及IETF信托关于IETF文件的法律规定（http://trustee.ietf.org/license-info），以发布之日的规定为准。请仔细阅读这些文件，它们描述了您对本文件的权利和限制。从本文件中提取的代码组件必须包含简化BSD许可证文本（详见信托法律规定第4.e节），且提供时不附带任何担保。

   本文件可能包含在2008年11月10日之前发布或公开的IETF文件或贡献的内容。部分内容的版权控制人可能未授权IETF信托对该内容进行修改。未经获得版权控制人的充分授权，不能在IETF标准流程之外修改本文件，也不能在IETF标准流程之外创建其派生作品，除非是为了将其格式化为RFC或翻译成非英语语言。

















布雷                         标准轨道                    [第2页]


RFC 7159                          JSON                        2014年3月


目录

   1. 引言 ....................................................3
      1.1. 本文使用的约定 ....................................4
      1.2. JSON的规范 .........................................4
      1.3. 本次修订介绍 .......................................4
   2. JSON语法 ..................................................4
   3. 值 ..........................................................5
   4. 对象 .......................................................6
   5. 数组 .......................................................6
   6. 数字 .......................................................6
   7. 字符串 .....................................................8
   8. 字符串与字符问题 .........................................9
      8.1. 字符编码 ............................................9
      8.2. Unicode字符 .........................................9
      8.3. 字符串比较 .........................................9
   9. 解析器 ....................................................10
   10. 生成器 ....................................................10
   11. IANA考虑事项 ............................................10
   12. 安全性考虑 ..............................................11
   13. 示例 ......................................................12
   14. 贡献者 ..................................................13
   15. 参考文献 ................................................13
      15.1. 规范性参考 .......................................13
      15.2. 信息性参考 .......................................13
   附录A. 与RFC 4627的变更 ....................................15

1. 引言

   JavaScript对象表示法（JSON）是一种用于结构化数据序列化的文本格式。它源自JavaScript的对象字面量，定义在ECMAScript第三版[ECMA-262]中。

   JSON可以表示四种基本类型（字符串、数字、布尔值和null）以及两种结构类型（对象和数组）。

   字符串是零个或多个Unicode字符的序列[UNICODE]。注意，此引用指向Unicode的最新版本，而非特定版本。未来Unicode规范的变更预计不会影响JSON的语法。

   对象是无序的零个或多个名称/值对的集合，其中名称是字符串，值可以是字符串、数字、布尔值、null、对象或数组。

   数组是有序的零个或多个值的序列。

   “对象”和“数组”这两个术语源自JavaScript的习惯用法。

   JSON的设计目标是简洁、便携、文本化，并且是JavaScript的子集。

1.1. 本文使用的约定

   本文中的关键词“必须（MUST）”、“不得（MUST NOT）”、“必需（REQUIRED）”、“应（SHALL）”、“不得（SHALL NOT）”、“建议（SHOULD）”、“不建议（SHOULD NOT）”、“推荐（RECOMMENDED）”、“可以（MAY）”和“可选（OPTIONAL）”的定义参照[RFC2119]。

   本文的语法规则的解释参照[RFC5234]。

1.2. JSON的规范

   本文档更新了[RFC4627]，该RFC描述了JSON并注册了媒体类型“application/json”。

   ECMAScript规范第5.1版[ECMA-262]第15.12节中也描述了JSON。JSON还在[ECMA-404]中有所描述。

   所有关于JSON语法的规范在语法元素上是一致的。

1.3. 本次修订介绍

   自RFC 4627发布以来，JSON得到了广泛应用。这些使用经验揭示了一些模式，虽然符合规范，但导致了互操作性问题。

   此外，已报告少量勘误（见RFC勘误ID 607[Err607]和3607[Err3607]）。

   本文档的目标是修正勘误，消除与其他JSON规范的不一致，并强调可能引发互操作性问题的实践。

2. JSON语法

   一个JSON文本是由一系列标记组成。标记集包括六个结构字符、字符串、数字和三个字面值。

   JSON文本是一个序列化的值。注意，之前的某些JSON规范限制JSON文本必须是对象或数组。只生成对象或数组的实现（在需要JSON文本的场景中）在互操作性上是兼容的，即所有实现都能接受这些符合规范的JSON文本。

      JSON文本 = 空白符 value 空白符

   这六个结构字符如下：

      begin-array     = 空白符 %x5B 空白符  ; [ 左方括号

      begin-object    = 空白符 %x7B 空白符  ; { 左大括号

      end-array       = 空白符 %x5D 空白符  ; ] 右方括号

      end-object      = 空白符 %x7D 空白符  ; } 右大括号

      name-separator  = 空白符 %x3A 空白符  ; : 冒号

      value-separator = 空白符 %x2C 空白符  ; , 逗号

   任何结构字符前后允许有无关紧要的空白符。

      空白符 = *(

              %x20 /              ; 空格

              %x09 /              ; 水平制表符

              %x0A /              ; 换行符

              %x0D )              ; 回车符

3. 值

   一个JSON值必须是对象、数组、数字或字符串，或者是以下三个字面值之一：

      false null true

   这些字面值必须全部小写。不允许其他字面值。

      value = false / null / true / object / array / number / string

      false = %x66.61.6c.73.65   ; false

      null  = %x6e.75.6c.6c      ; null

      true  = %x74.72.75.65      ; true





布雷                         标准轨道                    [第3页]


RFC 7159                          JSON                        2014年3月


4. 对象

   对象结构用一对大括号包围，内部包含零个或多个名称/值对（成员）。名称是字符串。每个名称后跟一个冒号，分隔名称和对应的值。成员之间用逗号分隔。对象中的名称应唯一。

      object = begin-object [ 成员 *( value-separator 成员 ) ]
               end-object

      成员 = 字符串 name-separator 值

   一个所有名称都唯一的对象在互操作性上是兼容的，即所有接收该对象的软件实现都能正确识别名称/值映射。当对象中的名称不唯一时，接收该对象的软件行为将不可预测。许多实现只报告最后一对名称/值，其他实现则报告错误或无法解析该对象，还有一些实现会报告所有的名称/值对，包括重复的。

   已观察到不同的JSON解析库在是否暴露对象成员的顺序方面存在差异。那些不依赖成员顺序的实现在互操作性上是兼容的，即它们不会受到这些差异的影响。

5. 数组

   数组结构用一对方括号包围，内部包含零个或多个值（元素）。元素之间用逗号分隔。

      array = begin-array [ 值 *( value-separator 值 ) ] end-array

   数组中的值类型没有要求必须相同。

6. 数字

   数字的表示类似于大多数编程语言中使用的表示方法。数字采用十进制，包含整数部分（可带有可选的负号）、小数部分和指数部分。前导零不允许。

   小数部分由小数点后跟一个或多个数字组成。

   指数部分以字母E（大小写均可）开头，后可跟正负号，再跟一个或多个数字。

   不允许表示在语法中无法表示的数字（如Infinity和NaN）。

      number = [ minus ] int [ frac ] [ exp ]

      decimal-point = %x2E       ; .

      digit1-9 = %x31-39         ; 1-9

      e = %x65 / %x45            ; e E

      exp = e [ minus / plus ] 1*DIGIT

      frac = decimal-point 1*DIGIT

      int = zero / ( digit1-9 *DIGIT )

      minus = %x2D               ; -

      plus = %x2B                ; +

      zero = %x30                ; 0

   该规范允许实现对数字范围和精度设置限制。由于IEEE 754-2008二进制64位（双精度）数字[IEEE754]的实现普遍存在且广泛使用，良好的互操作性可以通过实现者预期的精度和范围来实现，即实现会在预期的精度范围内近似JSON数字。例如，数字如1E400或3.141592653589793238462643383279可能会引发潜在的互操作性问题，因为它们暗示创建它们的软件预期接收软件具有比广泛可用的更高的数值范围和精度。

   注意，当使用此类软件时，范围在[-(2^53)+1, (2^53)-1]的整数在互操作性上是兼容的，即实现会在数值上达成一致。







布雷                         标准轨道                    [第4页]


RFC 7159                          JSON                        2014年3月


7. 字符串

   字符串的表示类似于C语言家族的编程语言中的惯例。字符串以引号开始和结束。所有Unicode字符都可以放在引号内，除了必须转义的字符：引号、反斜杠和控制字符（U+0000至U+001F）。

   任何字符都可以被转义。如果字符在基本多语言平面（U+0000至U+FFFF）内，则可以用六字符序列表示：反斜杠、字母u、后跟四个十六进制数字，编码字符的码点。十六进制字母A至F可以是大写或小写。例如，只包含单个反斜杠字符的字符串可以表示为"\u005C"。

   另外，也可以用两个字符的转义序列表示一些常用字符。例如，只包含单个反斜杠字符的字符串可以更紧凑地表示为"\\"。

   要转义不在基本多语言平面中的扩展字符，需用12字符序列表示，编码UTF-16代理对。例如，只包含G音符（U+1D11E）字符的字符串可以表示为"\uD834\uDD1E"。

      string = quotation-mark *char quotation-mark

      char = unescaped /
          escape (
              %x22 /          ; "    引号  U+0022
              %x5C /          ; \    反斜杠 U+005C
              %x2F /          ; /    斜杠   U+002F
              %x62 /          ; b    退格   U+0008
              %x66 /          ; f    换页   U+000C
              %x6E /          ; n    换行   U+000A
              %x72 /          ; r    回车   U+000D
              %x74 /          ; t    制表符 U+0009
              %x75 4HEXDIG )  ; uXXXX  U+XXXX
      )

      escape = %x5C              ; \

      quotation-mark = %x22      ; "

      unescaped = %x20-21 / %x23-5B / %x5D-10FFFF

布雷  标准轨迹  [第8页]

RFC 7159  JSON  2014年3月

8. 字符串与字符问题

8.1. 字符编码

JSON文本应采用UTF-8、UTF-16或UTF-32编码。默认编码为UTF-8，采用UTF-8编码的JSON文本具有良好的互操作性，即大多数实现都能成功读取；而许多实现无法正确读取其他编码（如UTF-16和UTF-32）编码的文本。

实现必须不得在JSON文本开头添加字节顺序标记（BOM）。为了增强互操作性，解析JSON文本的实现可以忽略BOM的存在，而不是将其视为错误。

8.2. Unicode字符

当JSON文本中所有字符串都由Unicode字符[UNICODE]（无论是否转义）组成时，该JSON文本在互操作性方面是兼容的，即所有解析它的软件实现都将对对象中的名称和字符串值的内容达成一致。

然而，本规范中的ABNF允许成员名和字符串值包含无法编码Unicode字符的比特序列；例如，"\uDEAD"（未配对的UTF-16代理项）。曾经出现过此类情况，例如，某个库在截断UTF-16字符串时未检查是否切断了代理对。包含此类值的JSON文本被接收的软件的行为是不可预测的；例如，某些实现可能会返回不同的字符串长度，甚至导致严重的运行时异常。

8.3. 字符串比较

软件实现通常需要对对象成员的名称进行相等性测试。那些将文本表示转换为Unicode代码单元序列，然后逐个代码单元进行数值比较的实现，在所有情况下都能达成一致，即对两个字符串的相等或不相等达成一致。例如，未转换转义字符的字符串比较实现可能会错误地判断" a\\b"和"a\u005Cb"不相等。

布雷  标准轨迹  [第9页]

RFC 7159  JSON  2014年3月

9. 解析器

JSON解析器将JSON文本转换为另一种表示形式。JSON解析器必须接受所有符合JSON语法的文本。解析器也可以接受非JSON形式或扩展。

实现可以对接受的文本大小设置限制。可以限制最大嵌套深度。可以限制数字的范围和精度。也可以限制字符串的长度和字符内容。

10. 生成器

JSON生成器生成JSON文本。生成的文本必须严格符合JSON语法。

11. IANA考虑事项

JSON文本的MIME媒体类型为application/json。

类型名称：application

子类型名称：json

必需参数：无

可选参数：无

编码考虑：二进制

安全考虑：参见[RFC7159]第12节。

互操作性考虑：详见[RFC7159]

已发布的规范：[RFC7159]

使用此媒体类型的应用：
JSON已被用于在用以下编程语言编写的应用之间交换数据：ActionScript、C、C#、Clojure、ColdFusion、Common Lisp、E、Erlang、Go、Java、JavaScript、Lua、Objective CAML、Perl、PHP、Python、Rebol、Ruby、Scala和Scheme。

布雷  标准轨迹  [第10页]

RFC 7159  JSON  2014年3月

附加信息：
魔数：无
文件扩展名：.json
Macintosh文件类型代码：TEXT

联系方式：
IESG
<iesg@ietf.org>

预期用途：普通

使用限制：无

作者：
道格拉斯·克罗克福德
<douglas@crockford.com>

变更控制：
IESG
<iesg@ietf.org>

注意：此注册未定义“charset”参数。添加该参数对符合规范的接收方实际上没有影响。

12. 安全考虑

通常，脚本语言存在安全问题。JSON是JavaScript的子集，但排除了赋值和调用操作。

由于JSON的语法借用了JavaScript，因此可以使用该语言的"eval()"函数来解析JSON文本。这通常构成不可接受的安全风险，因为文本中可能包含可执行代码和数据声明。对于任何符合该语言语法的其他编程语言，使用eval()类函数的情况也具有相同的风险。

布雷  标准轨迹  [第11页]

RFC 7159  JSON  2014年3月

13. 示例

这是一个JSON对象：

{
  "Image": {
      "Width":  800,
      "Height": 600,
      "Title":  "View from 15th Floor",
      "Thumbnail": {
          "Url":    "http://www.example.com/image/481989943",
          "Height": 125,
          "Width":  100
      },
      "Animated" : false,
      "IDs": [116, 943, 234, 38793]
    }
}

其Image成员是一个对象，包含一个Thumbnail对象和一个ID数组。

这是一个包含两个对象的JSON数组：

[
  {
     "precision": "zip",
     "Latitude":  37.7668,
     "Longitude": -122.3959,
     "Address":   "",
     "City":      "SAN FRANCISCO",
     "State":     "CA",
     "Zip":       "94107",
     "Country":   "US"
  },
  {
     "precision": "zip",
     "Latitude":  37.371991,
     "Longitude": -122.026020,
     "Address":   "",
     "City":      "SUNNYVALE",
     "State":     "CA",
     "Zip":       "94085",
     "Country":   "US"
  }
]

以下是三个只包含值的简短JSON文本示例：

"Hello world!"

42

true

14. 贡献者

RFC 4627由道格拉斯·克罗克福德撰写。本文件是在该文档基础上做了少量修改后形成的，因此这里的大部分内容都是他的。

15. 参考文献

15.1. 规范性参考文献

[IEEE754]  IEEE，“IEEE浮点算术标准”，IEEE标准754，2008年8月，<http://grouper.ieee.org/groups/754/>。

[RFC2119]  Bradner, S.，“在RFC中用以指示需求级别的关键词”，BCP 14，RFC 2119，1997年3月。

[RFC5234]  Crocker, D. 和 P. Overell，“语法规范的增强BNF：ABNF”，STD 68，RFC 5234，2008年1月。

[UNICODE]  Unicode联盟，“Unicode标准”，<http://www.unicode.org/versions/latest/>。

15.2. 说明性参考文献

[ECMA-262]  Ecma国际，“ECMAScript语言规范第5.1版”，标准ECMA-262，2011年6月，<http://www.ecma-international.org/publications/standards/Ecma-262.htm>。

[ECMA-404]  Ecma国际，“JSON数据交换格式”，标准ECMA-404，2013年10月，<http://www.ecma-international.org/publications/standards/Ecma-404.htm>。

[Err3607]  RFC勘误，勘误ID 3607，RFC 3607，<http://www.rfc-editor.org>。

[Err607]  RFC勘误，勘误ID 607，RFC 607，<http://www.rfc-editor.org>。

[RFC4627]  Crockford, D.，“JavaScript对象表示法（JSON）的application/json媒体类型”，RFC 4627，2006年7月。

（以下省略部分内容，保持原文结构不变）