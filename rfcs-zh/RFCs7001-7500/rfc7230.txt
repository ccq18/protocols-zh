# RFC 7230 中文翻译 (stub)
# 原文文件: ../../rfcs/RFCs7001-7500/rfc7230.txt

互联网工程任务组（IETF）                  R. Fielding，主编
意见征求稿：7230                                              Adobe
废止：2145、2616                                              J. Reschke，主编
更新：2817、2818                                              greenbytes
类别：标准轨道                                              2014年6月
ISSN：2070-1721


超文本传输协议（HTTP/1.1）：消息语法与路由

摘要

超文本传输协议（HTTP）是一种无状态的应用层协议，用于分布式、协作式超文本信息系统。本文档概述了HTTP的体系结构及相关术语，定义了“http”和“https”统一资源标识符（URI）方案，规定了HTTP/1.1消息的语法和解析要求，并描述了实现中的相关安全问题。

本备忘录的状态

这是一个互联网标准轨道的文档。

本文档由互联网工程任务组（IETF）制定，代表了IETF社区的共识。它经过公开审查，并已获互联网工程指导组（IESG）批准发布。关于互联网标准的更多信息，请参见RFC 5741第2节。

有关本文件当前状态、任何勘误以及反馈方式的信息，可在 http://www.rfc-editor.org/info/rfc7230 获取。

版权声明

版权所有（c）2014 IETF信托及本文档作者。保留所有权利。

本文件受BCP 78及IETF信托关于IETF文档的法律规定（http://trustee.ietf.org/license-info）约束，适用于本文件发布之日。请仔细阅读这些文件，它们描述了您对本文件的权利和限制。从本文件中提取的代码组件必须包括简化BSD许可证文本（详见第4.e节），并且在没有担保的情况下提供，如简化BSD许可证所述。

本文件可能包含在2008年11月10日之前发布或公开的IETF文档或贡献的内容。这些内容的版权控制人可能未授权IETF信托允许在IETF标准流程之外对其进行修改。未经获得版权控制人的充分许可，不能在IETF标准流程之外修改本文件，也不能在IETF标准流程之外创建其派生作品，除非是为了将其格式化为RFC或翻译成非英语语言。

目录

1. 引言 ....................................................5
   1.1. 需求用语 ..........................................6
   1.2. 语法用语 ..........................................6
2. 体系结构 ..................................................6
   2.1. 客户端/服务器消息 ..................................7
   2.2. 实现多样性 ........................................8
   2.3. 中介机构 ............................................9
   2.4. 缓存 ...............................................11
   2.5. 一致性与错误处理 ..................................12
   2.6. 协议版本控制 ......................................13
   2.7. 统一资源标识符（URI） ............................16
       2.7.1. http URI方案 ..................................17
       2.7.2. https URI方案 ..................................18
       2.7.3. http和https URI的规范化与比较 ..................19
3. 消息格式 ..................................................19
   3.1. 起始行 ..............................................20
       3.1.1. 请求行 ........................................21
       3.1.2. 状态行 ........................................22
   3.2. 头字段 ............................................22
       3.2.1. 字段扩展性 ....................................23
       3.2.2. 字段顺序 ......................................23
       3.2.3. 空白字符 ......................................24
       3.2.4. 字段解析 ......................................25
       3.2.5. 字段限制 ......................................26
       3.2.6. 字段值组成部分 ................................27
   3.3. 消息体 ..............................................28
       3.3.1. 传输编码 ......................................28
       3.3.2. 内容长度 ......................................30
       3.3.3. 消息体长度 ....................................32
   3.4. 处理不完整的消息 ....................................34
   3.5. 消息解析的鲁棒性 ....................................34
4. 传输编码 ..................................................35
   4.1. 分块传输编码 ........................................36
       4.1.1. 分块扩展 ......................................36
       4.1.2. 分块尾部 ......................................37
       4.1.3. 解码分块 ......................................38
   4.2. 压缩编码 ............................................38
       4.2.1. 压缩编码 ......................................38
       4.2.2. Deflate编码 ...................................38
       4.2.3. Gzip编码 ......................................39
   4.3. TE ..................................................39
   4.4. 尾部 ..................................................40
5. 消息路由 ..................................................40
   5.1. 识别目标资源 ........................................40
   5.2. 连接入站 ............................................41
   5.3. 请求目标 ............................................41
       5.3.1. 起源形式 ......................................42
       5.3.2. 绝对形式 ......................................42
       5.3.3. 权限形式 ......................................43
       5.3.4. 星号形式 ......................................43
   5.4. 主机 ................................................44
   5.5. 有效请求URI ........................................45
   5.6. 将响应关联到请求 ....................................46
   5.7. 消息转发 ............................................47
       5.7.1. 通过（Via） ....................................47
       5.7.2. 转换 ............................................49
6. 连接管理 ..................................................50
   6.1. 连接 ................................................51
   6.2. 建立 ................................................52
   6.3. 持久性 ..............................................52
       6.3.1. 重试请求 ......................................53
       6.3.2. 管道化 ........................................54
   6.4. 并发 ................................................55
   6.5. 失败与超时 ..........................................55
   6.6. 断开 ................................................56
   6.7. 升级 ................................................57
7. ABNF列表扩展：#规则 ......................................59
8. IANA考虑事项 ..............................................61
   8.1. 头字段注册 ..........................................61
   8.2. URI方案注册 ..........................................62
   8.3. Internet媒体类型注册 ..................................62
       8.3.1. Internet媒体类型 message/http ..................62
       8.3.2. Internet媒体类型 application/http ................63
   8.4. 传输编码注册 ..........................................64
       8.4.1. 流程 ............................................65
       8.4.2. 注册 ............................................65
   8.5. 内容编码注册 ..........................................66
   8.6. 升级令牌注册 ..........................................66
       8.6.1. 流程 ............................................66
       8.6.2. 升级令牌注册 ..................................67
9. 安全考虑 ..................................................67
   9.1. 建立权威 ............................................67
   9.2. 中介机构的风险 ......................................68
   9.3. 通过协议元素长度的攻击 ..............................69
   9.4. 响应拆分 ............................................69
   9.5. 请求走私 ............................................70
   9.6. 消息完整性 ..........................................70
   9.7. 消息机密性 ..........................................71
   9.8. 服务器日志信息的隐私 ................................71
10. 致谢 ......................................................72
11. 参考文献 ..................................................74
   11.1. 标准性参考 ........................................74
   11.2. 资料性参考 ........................................75
附录A. HTTP版本历史 .........................................78
   A.1. 与HTTP/1.0的变化 ....................................78
       A.1.1. 多宿主Web服务器 ................................78
       A.1.2. 保持连接 ........................................79
       A.1.3. 引入传输编码 ....................................79
   A.2. 与RFC 2616的变化 .....................................80
附录B. 收集的ABNF ...........................................82
索引 .........................................................85

1. 引言

超文本传输协议（HTTP）是一种无状态的应用层请求/响应协议，利用可扩展的语义和自描述的消息负载，实现与基于网络的超文本信息系统的灵活交互。本文档是系列文档中的第一份，合称HTTP/1.1规范：

1. “消息语法与路由”（本文件）
2. “语义与内容” [RFC7231]
3. “条件请求” [RFC7232]
4. “范围请求” [RFC7233]
5. “缓存” [RFC7234]
6. “认证” [RFC7235]

本HTTP/1.1规范废止RFC 2616和RFC 2145（关于HTTP版本控制）。同时更新了用于建立隧道的CONNECT方法（此前定义在RFC 2817），并定义了在RFC 2818中非正式描述的“https” URI方案。

HTTP是信息系统的通用接口协议，旨在隐藏服务实现的细节，通过向客户端提供统一的接口，资源类型的不同对客户端是透明的。同样，服务器无需了解每个客户端的具体用途：HTTP请求可以孤立考虑，而不必关联特定类型的客户端或预设的应用步骤序列。由此产生的协议可以在多种不同场景中有效使用，且实现可以随着时间独立演进。

HTTP还设计为一种中介协议，用于转换非HTTP信息系统的通信。HTTP代理和网关可以通过将多样的协议转换为超文本格式，为客户端提供访问替代信息服务的能力，客户端可以像操作HTTP服务一样操作这些信息。

这种灵活性带来的一个后果是，协议不能仅通过接口背后的内容来定义。我们只能定义通信的语法、接收通信的意图以及预期的接收行为。如果将通信孤立考虑，成功的操作应在服务器提供的可观察接口中反映出来。然而，由于多个客户端可能同时行动，甚至目标不同，我们不能要求这些变化在单个响应之外都能被观察到。

本文档描述了在HTTP中使用或引用的体系结构元素，定义了“http”和“https”URI方案，描述了整体网络操作和连接管理，并规定了HTTP消息的帧结构和转发要求。我们的目标是定义所有与消息语义无关的HTTP消息处理机制，从而确立消息解析器和消息转发中介的完整需求集。

1.1. 需求用语

本文档中的关键词“MUST”、“MUST NOT”、“REQUIRED”、“SHALL”、“SHALL NOT”、“SHOULD”、“SHOULD NOT”、“RECOMMENDED”、“MAY”和“OPTIONAL”均按[RFC2119]中的定义解释。

合规性标准和错误处理的考虑在第2.5节中定义。

1.2. 语法用语

本规范采用[RFC5234]中的增强巴克斯-诺尔范式（ABNF）语法，结合第7节定义的列表扩展，允许用“#”操作符紧凑定义逗号分隔的列表（类似“*”操作符表示重复）。附录B展示了所有列表操作符展开为标准ABNF的完整语法。

核心规则包括[RFC5234]附录B.1中定义的：ALPHA（字母）、CR（回车）、CRLF（回车换行）、CTL（控制字符）、DIGIT（十进制0-9）、DQUOTE（双引号）、HEXDIG（十六进制0-9/A-F/a-f）、HTAB（水平制表符）、LF（换行）、OCTET（任意8位数据序列）、SP（空格）和VCHAR（任何可见字符[USASCII]）。

作为惯例，前缀为“obs-”的ABNF规则表示“过时”的语法规则，出于历史原因而存在。

2. 体系结构

HTTP诞生于万维网（WWW）架构，随着时间推移不断演进，以支持全球超文本系统的可扩展性。许多架构特征反映在定义HTTP的术语和语法规则中。

2.1. 客户端/服务器消息

HTTP是一个无状态的请求/响应协议，通过在可靠的传输层或会话层“连接”中交换消息（第3节）实现通信（第6节）。HTTP“客户端”是一个程序，建立连接以向服务器发送一个或多个HTTP请求。HTTP“服务器”是一个程序，接受连接以通过发送HTTP响应来服务请求。

“客户端”和“服务器”仅指这些程序在特定连接中的角色。同一程序可能在某些连接中充当客户端，在其他连接中充当服务器。“用户代理”指任何发起请求的客户端程序，包括（但不限于）浏览器、爬虫（网络机器人）、命令行工具、自定义应用和移动应用。“源服务器”指能为特定目标资源发起权威响应的程序。“发送者”和“接收者”分别指任何发送或接收消息的实现。

HTTP依赖URI标准[RFC3986]指示目标资源（第5.1节）及资源间关系。消息采用类似互联网邮件[RFC5322]和多用途互联网邮件扩展（MIME）[RFC2045]的格式（详见[RFC7231]附录A，了解HTTP与MIME消息的差异）。

大部分HTTP通信是对某个URI标识的资源的表示的检索请求（GET）。最简单的情况是通过用户代理（UA）与源服务器（O）之间的单一双向连接（===）实现：

            请求   >
       UA ======================================= O
                                   <   响应

客户端以请求消息的形式向服务器发送HTTP请求，起始于请求行（包括方法、URI和协议版本（第3.1.1节）），随后是包含请求修饰符、客户端信息和表示元数据的头字段（第3.2节），空行表示头部结束，最后是包含有效载荷的消息体（如有，第3.3节）。

服务器对客户端请求的响应也是一条或多条HTTP响应消息，每条以状态行开始，包含协议版本、成功或错误代码及文本原因短语（第3.1.2节），可能跟随包含服务器信息、资源元数据和表示元数据的头字段（第3.2节），再是空行表示头部结束，最后是消息体（如有，第3.3节）。  

连接可以用于多次请求/响应交换（第6.3节定义）。

以下示例说明了在URI "http://www.example.com/hello.txt" 上进行GET请求（[RFC7231]第4.3.1节）时的典型消息交换过程：

客户端请求：

  GET /hello.txt HTTP/1.1
  User-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3
  Host: www.example.com
  Accept-Language: en, mi

服务器响应：

  HTTP/1.1 200 OK
  Date: Mon, 27 Jul 2009 12:28:53 GMT
  Server: Apache
  Last-Modified: Wed, 22 Jul 2009 19:15:56 GMT
  ETag: "34aa387-d-1568eb00"
  Accept-Ranges: bytes
  Content-Length: 51
  Vary: Accept-Encoding
  Content-Type: text/plain

  你好，世界！我的负载包括一个尾随的CRLF。

2.2. 实现多样性

在设计HTTP时，很容易陷入一种误区，认为所有用户代理都是通用浏览器，所有源服务器都是大型公共网站。实际上并非如此。常见的HTTP用户代理包括家用电器、立体声音响、秤、固件更新脚本、命令行程序、移动应用以及各种形状和大小的通信设备。同样，常见的HTTP源服务器包括家庭自动化单元、可配置的网络组件、办公设备、自主机器人、新闻源、交通摄像头、广告选择器和视频传输平台。

“用户代理”一词并不意味着在请求时有一个人类用户直接与软件代理交互。在许多情况下，用户代理被安装或配置为在后台运行，并保存其结果以供后续检查（或只保存那些可能有趣或错误的部分结果）。例如，蜘蛛通常会被赋予一个起始URI，并被配置为在爬取网页作为超文本图的过程中遵循特定行为。

HTTP的多样性意味着，并非所有用户代理都能向用户提供交互式建议或充分警示安全或隐私问题。在少数情况下，本规范要求向用户报告错误时，允许这种报告仅在错误控制台或日志文件中观察到。同样，要求在自动操作前由用户确认的情况，可以通过提前配置、运行时选项或简单避免不安全操作来满足；确认不意味着必须有特定的用户界面或中断正常处理，只要用户已做出选择。

2.3. 中介

HTTP支持通过一系列连接满足请求的中介机制。常见的HTTP中介形式有：代理、网关和隧道。在某些情况下，一个中介可以同时充当源服务器、代理、网关或隧道，根据每个请求的性质切换行为。

            >             >             >             >
       UA =========== A =========== B =========== C =========== O
                  <             <             <             <

上图显示了用户代理与源服务器之间的三个中介（A、B和C）。一条请求或响应消息在整个链路上传输时，将经过四个不同的连接。某些HTTP通信选项可能只适用于与最近的非隧道邻居的连接、链路的端点，或链路上的所有连接。虽然图中是线性的，但每个参与者可能同时进行多重通信。例如，B可能同时接收来自多个客户端的请求（除了A之外），并将请求转发到其他服务器（除了C之外），同时处理来自A的请求。同样，后续请求可能通过不同的路径传输，通常基于动态配置实现负载均衡。

“上游”和“下游”用来描述相对于消息流的方向性要求：所有消息都从上游流向下游。“入站”和“出站”用来描述相对于请求路径的方向性要求：“入站”指向源服务器，“出站”指向用户代理。

“代理”是由客户端选择的消息转发代理，通常通过本地配置规则，接收某些类型的绝对URI请求，并试图通过HTTP接口转换满足这些请求。有些转换很简单，比如代理“http” URI请求，而其他请求可能需要在不同的应用层协议之间进行转换。代理常用于将组织的HTTP请求集中到一个共同的中介，以增强安全性、提供注释服务或共享缓存。一些代理设计为在转发过程中对特定消息或负载进行变换，如第5.7.2节所述。

“网关”（又称“反向代理”）是一个中介，作为出站连接的源服务器，但会将接收到的请求转换后转发到其他服务器。网关常用于封装遗留或不可信的信息服务，通过“加速器”缓存提升服务器性能，以及实现HTTP服务在多台机器间的分区或负载均衡。

所有适用于源服务器的HTTP要求，也同样适用于网关的出站通信。网关可以使用任何协议与入站服务器通信，包括超出本规范范围的私有扩展。然而，旨在与第三方HTTP服务器互操作的HTTP-to-HTTP网关，应符合用户代理对其入站连接的要求。

“隧道”在两个连接之间充当盲目中继，不改变消息内容。一旦激活，隧道不再被视为HTTP通信的参与方，尽管隧道可能由HTTP请求发起。当两个端点都关闭时，隧道即告终止。隧道用于通过中介扩展虚拟连接，例如使用传输层安全（TLS，[RFC5246]）在共享防火墙代理中建立机密通信。

上述中介类别仅考虑作为HTTP通信参与者的情况。实际上，还存在可以在网络协议栈的更低层操作的中介，它们在未被消息发送者知晓或授权的情况下过滤或重定向HTTP流量。这些网络中介在协议层面上与中间人攻击无异，常引入安全漏洞或互操作性问题，因误违反HTTP语义。

例如，“拦截代理”[RFC3040]（也常称为“透明代理”[RFC1919]或“强制门户”）不同于普通HTTP代理，因为它不是由客户端选择的。相反，拦截代理会过滤或重定向发出的TCP端口80（偶尔也包括其他常用端口）数据包。拦截代理常见于公共网络接入点，用于在允许使用非本地互联网服务前强制订阅账户，也常在企业防火墙内执行网络使用策略。

HTTP被定义为无状态协议，意味着每个请求消息可以单独理解。许多实现依赖HTTP的无状态设计，以便重用代理连接或在多个服务器间动态负载均衡请求。因此，除非连接已加密且专属于该用户代理，否则服务器不得假设同一连接上的两个请求来自同一用户代理。一些非标准的HTTP扩展（如[RFC4559]）已被发现违反此要求，导致安全和互操作性问题。

2.4. 缓存

“缓存”是存储先前响应消息的本地存储区，以及控制其消息存储、检索和删除的子系统。缓存存储可缓存的响应，以减少未来相同请求的响应时间和网络带宽消耗。任何客户端或服务器都可以使用缓存，但在充当隧道时，服务器不能使用缓存。

缓存的作用在于，如果链路中的某一方拥有适用的缓存响应，则可以缩短请求/响应链。例如，假设B拥有来自O的早期响应的缓存副本（通过C），而该请求未被用户代理或A缓存。

               >             >
          UA =========== A =========== B - - - - - - C - - - - - - O

如果缓存允许存储响应消息的副本以用于后续请求，则该响应被视为“可缓存”。即使响应是可缓存的，客户端或源服务器可能对何时使用该缓存响应有额外限制。关于缓存行为和可缓存响应的HTTP要求详见[RFC7234]第2节。

全球范围内和大型组织内部部署的缓存架构多种多样，包括：国家级代理缓存层以节省跨洋带宽、协作系统广播或多播缓存条目、预取缓存条目的存档（用于离线或高延迟环境）等。

2.5. 合规性与错误处理

本规范针对HTTP通信中参与者的角色，定义了合规标准。因此，HTTP的要求会针对发送者、接收者、客户端、服务器、用户代理、中介、源服务器、代理、网关或缓存提出，具体取决于行为受规范限制的范围。对于超出单次通信范围的实现、资源所有者和协议元素注册，也会提出额外（社会性）要求。

“生成”一词用于区分“创建”协议元素与“仅转发”已接收元素的行为。

实现若符合其在HTTP中所扮演角色的所有要求，即视为合规。

合规性涵盖协议元素的语法和语义。发送者不得生成其已知为虚假的协议元素。也不得生成不符合对应ABNF规则的协议元素。在单个消息中，发送者不得生成仅由其他角色（即非当前角色）参与者允许生成的协议元素或语法变体。

当解析收到的协议元素时，接收者必须能够解析任何合理长度的值，只要该值适用于其角色且符合定义的ABNF规则。但也要注意，某些收到的协议元素可能不会被完全解析。例如，转发消息的中介可能会将头字段解析为通用的字段名和字段值，然后在不进一步解析字段值的情况下转发该头字段。

HTTP对许多协议元素没有具体的长度限制，因为适当的长度会因部署环境和实现目的而大不相同。因此，发送者和接收者之间的互操作性依赖于对每个协议元素合理长度的共同预期。过去二十年中，关于某些协议元素合理长度的普遍认知也在不断变化，未来仍将继续演变。

至少，接收者必须能够解析和处理长度至少与其在其他消息中生成的相同协议元素值一样长的协议元素。例如，发布非常长URI引用的源服务器，必须能够解析和处理这些引用作为请求目标。

以上内容为用户提供的英文内容的中文翻译。

接收方必须根据本规范（包括对本规范的扩展）所定义的语义来解释所接收的协议元素，除非接收方通过经验或配置确定发送方错误地实现了那些语义所暗示的内容。例如，起源服务器可能会忽略接收到的Accept-Encoding头字段的内容，如果检查User-Agent头字段后发现某个特定实现版本已知在接收某些内容编码时会失败。

除非另有说明，接收方可以尝试从无效的结构中恢复出可用的协议元素。HTTP没有定义具体的错误处理机制，除非这些机制直接影响安全性，因为不同的应用场景需要不同的错误处理策略。例如，网页浏览器可能希望在响应中的Location头字段无法按照ABNF解析时，透明地进行恢复；而系统控制客户端可能会认为任何形式的错误恢复都是危险的。

2.6 协议版本控制

HTTP使用"<主版本>.<次版本>"的编号方案来表示协议的版本。本规范定义的版本为“1.1”。整个协议版本表明发送方是否符合该版本对应的HTTP规范中的一系列要求。

HTTP消息的版本由消息第一行中的HTTP-version字段指示。HTTP-version区分大小写。

```
HTTP-version  = HTTP-name "/" DIGIT "." DIGIT
HTTP-name     = %x48.54.54.50 ; "HTTP"，区分大小写
```

HTTP版本号由两个十进制数字组成，中间用“.”（点或小数点）分隔。第一个数字（“主版本”）表示HTTP消息的语法版本，第二个数字（“次版本”）表示在该主版本内，发送方所支持的最高次版本，且能理解未来的通信内容。次版本会反映发送方的通信能力，即使只使用协议的向后兼容子集，也会通过次版本告知接收方可以使用更高级的功能（由服务器响应或由客户端在未来请求中使用）。

当向HTTP/1.0接收方[RFC1945]或未知版本的接收方发送HTTP/1.1消息时，必须确保该消息可以被解释为有效的HTTP/1.0消息（即忽略所有较新的特性）。本规范对某些新特性规定了接收方版本的要求，以确保符合规范的发送方只会使用兼容的特性，直到确认接收方支持HTTP/1.1（通过配置或消息接收）。

不同主版本之间，头字段的解释不会改变，但在没有明确说明的情况下，HTTP/1.1定义的头字段在所有HTTP/1.x版本中都应适用。特别是，Host和Connection头字段应由所有HTTP/1.x实现实现，无论它们是否声明符合HTTP/1.1。

可以在不改变协议版本的情况下引入新头字段，只要其定义的语义允许接收方安全忽略那些不认识的字段。头字段的扩展性在第3.2.1节中讨论。

处理HTTP消息的中间设备（即除作为隧道的中间设备外的所有中间设备）必须在转发的消息中发送自己的HTTP-version。换句话说，它们不能盲目转发HTTP消息的第一行，而不确保该消息中的协议版本与其支持的版本相匹配。否则，可能会导致下游接收方在根据消息中的版本决定使用哪些功能时出现通信错误。

客户端应当发送其支持的最高版本（其主版本不高于服务器支持的最高版本），如果已知的话。客户端不得发送不符合其支持的版本。

如果已知服务器错误实现了某些规范，客户端可以在尝试至少一次正常请求后，根据响应状态码或头字段（如Server）判断，选择发送较低的请求版本。

服务器应当发送其支持的最高版本（其主版本不高于请求中版本的主版本），且必须是其支持的版本。服务器可以返回505（HTTP版本不支持）状态码，拒绝服务于客户端的主协议版本。

如果服务器知道或怀疑客户端错误实现了HTTP规范，不能正确处理较新版本的响应，可能会返回HTTP/1.0响应，例如客户端未能正确解析版本号，或中间设备盲目转发HTTP版本而不符合协议的次版本要求。这种降级应避免，除非由特定客户端属性触发（如请求头字段中的特定值匹配已知错误的客户端）。

HTTP版本设计的意图是：只有在引入不兼容的消息语法时，主版本号才会增加；只有在协议的变更增加了消息语义或暗示了额外功能时，次版本号才会增加。然而，[RFC2068]到[RFC2616]之间的变更未增加次版本号，本次修订也特别避免了此类变更。

当接收方收到的HTTP消息的主版本号被支持，但次版本号高于其实现时，应将其视为在该主版本内的最高次版本进行处理。可以认为，向未支持更高次版本的接收方发送的高次版本消息，具有足够的向后兼容性，能被任何实现相同主版本的系统安全处理。

2.7 统一资源标识符（URI）

在HTTP中，统一资源标识符（URI）[RFC3986]被广泛用作资源的标识手段（参见[RFC7231]第2节）。URI引用用于定位请求、指示重定向和定义关系。

“URI-reference”、“absolute-URI”、“relative-part”、“scheme”、“authority”、“port”、“host”、“path-abempty”、“segment”、“query”和“fragment”的定义借用自URI通用语法。定义了“绝对路径”规则，用于包含非空路径部分的协议元素（此规则与RFC 3986中的path-abempty规则略有不同，后者允许空路径；也不同于不允许以“//”开头路径的path-absolute规则）。还定义了“部分URI”规则，用于包含相对URI但不含片段的协议元素。

```
URI-reference = <URI-reference, 见[RFC3986]第4.1节>
absolute-URI  = <absolute-URI, 见[RFC3986]第4.3节>
relative-part = <relative-part, 见[RFC3986]第4.2节>
scheme        = <scheme, 见[RFC3986]第3.1节>
authority     = <authority, 见[RFC3986]第3.2节>
uri-host      = <host, 见[RFC3986]第3.2.2节>
port          = <port, 见[RFC3986]第3.2.3节>
path-abempty  = <path-abempty, 见[RFC3986]第3.3节>
segment       = <segment, 见[RFC3986]第3.3节>
query         = <query, 见[RFC3986]第3.4节>
fragment      = <fragment, 见[RFC3986]第3.5节>

absolute-path = 1*( "/" segment )
partial-URI   = relative-part [ "?" query ]
```

在HTTP中，允许URI引用的每个协议元素会在其ABNF定义中指明是否允许任何形式的引用（URI-reference）、仅允许绝对URI（absolute-URI）、仅允许路径和可选查询部分，或允许上述某些组合。除非另有说明，URI引用都相对于请求的有效URI（第5.5节）进行解析。

2.7.1. HTTP URI方案

“http” URI方案被定义用于生成标识符，依据其与由潜在HTTP起源服务器管理的层次命名空间的关联，该服务器监听某个端口上的TCP连接（[RFC0793]）。

```
http-URI = "http:" "//" authority path-abempty [ "?" query ]
           [ "#" fragment ]
```

“http” URI的起源服务器由authority部分标识，包括主机标识符和可选的TCP端口（[RFC3986]第3.2.2节）。层次路径部分和可选的查询部分作为潜在目标资源在该起源服务器命名空间中的标识符。可选的片段部分允许间接标识次级资源，与URI方案无关，详见[RFC3986]第3.5节。

发送方不得生成主机标识符为空的“http” URI。处理此类URI引用的接收方必须将其视为无效并拒绝。

如果主机标识符为IP地址，则起源服务器为该IP地址上的监听（如果有）端口。若为注册名，则该注册名作为间接标识符，用于通过域名系统（DNS）等名称解析服务找到对应的起源服务器地址。端口子组件为空或未提供时，默认端口为80（WWW服务的保留端口）。

注意，URI中包含某个authority组件并不意味着一定有HTTP服务器在该主机和端口上监听。任何人都可以生成URI。authority组件决定的是谁有权对目标资源作出权威响应。注册名和IP地址的委托性质形成了一个联邦命名空间，基于对所指主机和端口的控制，无论是否存在HTTP服务器。关于建立权限的安全考虑，详见第9.1节。

在需要访问所指资源的上下文中使用“http” URI时，客户端可以尝试解析主机名为IP地址，建立TCP连接，并向服务器发送包含URI标识信息的HTTP请求（第3节，详见第5节）。如果服务器以非中间状态的HTTP响应（详见[RFC7231]第6节）响应该请求，则该响应被视为对客户端请求的权威答复。

虽然HTTP与传输协议无关，但“http”方案专用于基于TCP的服务，因为域名委托过程依赖TCP建立权限。基于其他底层连接协议的HTTP服务可能会使用不同的URI方案，例如“https”方案用于需要端到端安全连接的资源。其他协议也可能用于访问“http”标识的资源——但只有“http”方案的权威接口是特定于TCP的。

URI通用语法中的authority部分还包括一个已废弃的userinfo子组件（[RFC3986]，第3.2.1节），用于在URI中包含用户认证信息。尽管这种用法可能会暴露用户标识符或密码，但一些实现会将userinfo组件用于内部配置认证信息，例如在命令调用选项、配置文件或书签列表中。发送方在生成“http”URI引用作为请求目标或头字段值时，必须不生成userinfo子组件（以及其“@”分隔符）。在接收来自不可信来源的“http”URI引用之前，接收方应解析userinfo，并将其存在视为错误；因为它很可能被用来隐藏权限信息以进行钓鱼攻击。

2.7.2.  https URI方案

“https” URI方案特此定义，用于根据其与由潜在HTTP源服务器管理的层次命名空间的关联来生成标识符，该源服务器监听特定TCP端口以进行TLS安全连接（[RFC5246]）。

上述“http”方案的所有要求也适用于“https”方案，唯一不同的是：如果端口子组件为空或未提供，则默认端口为443；且用户代理必须确保在发送第一个HTTP请求之前，通过强加密（端到端）确保其与源服务器的连接是安全的。

https-URI = "https:" "//" authority path-abempty [ "?" query ] [ "#" fragment ]

注意，“https” URI方案依赖TLS和TCP共同建立权限。通过“https”方案提供的资源，即使其资源标识符指示相同的权限（相同的主机监听相同的TCP端口），也与“http”方案没有共享身份。它们是不同的命名空间，被视为不同的源服务器。然而，扩展到整个主机域的HTTP扩展（如Cookie协议 [RFC6265]）可以允许由一个服务设置的信息影响与匹配的主机域组内的其他服务的通信。

关于“https”标识资源的权威访问流程定义在[RFC2818]中。

2.7.3.  http和https URI的规范化与比较

由于“http”和“https”方案符合URI通用语法，这些URI应按照[RFC3986]第6节定义的算法进行规范化和比较，使用上述每个方案的默认值。

如果端口等于方案的默认端口，则正常形式应省略端口子组件。当不作为请求目标的绝对形式使用（如在OPTIONS请求中），空路径组件等同于绝对路径“/”，因此规范化形式应提供路径“/”。方案和主机名不区分大小写，通常以小写形式提供；其他组件则区分大小写。除“reserved”字符集之外的字符等价于其百分号编码的八位字节：规范化形式是不编码它们（参见[RFC3986]第2.1和2.2节）。

例如，以下三个URI是等价的：

http://example.com:80/~smith/home.html  
http://EXAMPLE.com/%7Esmith/home.html  
http://EXAMPLE.com:/%7esmith/home.html

3.  消息格式

所有HTTP/1.1消息由起始行（start-line）开始，后跟一系列类似于互联网消息格式[RFC5322]的八位字节：零个或多个头字段（统称“头部”或“头部段”）、一个空行表示头部结束，以及一个可选的消息体。

HTTP消息的正常解析流程是：读取起始行到结构中，将每个头字段按字段名存入哈希表直到遇到空行，然后根据解析的数据判断是否需要消息体。如果需要消息体，则作为流读取，直到读取的八位字节数等于消息体长度或连接关闭。

接收方必须以超集US-ASCII [USASCII]的编码解析HTTP消息的八位字节序列。以Unicode字符流解析HTTP消息（不考虑具体编码）存在安全漏洞，因为字符串处理库对包含LF（%x0A）八位字节的无效多字节字符序列的处理方式不同。字符串解析器只能在提取出协议元素（如在消息解析后提取的头字段值）后安全使用。

HTTP消息可以作为流进行逐步处理或转发下游，但不能依赖部分消息的逐步传递，因为某些实现会缓冲或延迟转发以提高网络效率、进行安全检查或进行负载变换。

发送方不得在起始行和第一个头字段之间发送空白字符。接收方若收到此类空白字符，必须拒绝该消息（视为无效）或无处理地消费掉这些空白行（即忽略整个行及其后续由空白字符前导的行，直到收到格式正确的头字段或头部结束）。在请求中出现此类空白可能试图欺骗服务器忽略该字段或将其后续行作为新请求处理，若其他实现对此处理不同，可能引发安全漏洞。同理，响应中出现此类空白也可能被某些客户端忽略或导致解析中断。

3.1.  起始行

HTTP消息可以是客户端发往服务器的请求，也可以是服务器发往客户端的响应。从语法上看，两者唯一不同在于起始行：请求行（request-line）或状态行（status-line），以及确定消息体长度的算法（第3.3节）。

理论上，客户端可以接收请求，服务器可以接收响应，通过不同的起始行格式区分，但实际上，服务器通常只期待请求（响应被视为未知或无效的请求方法），客户端只期待响应。

start-line = request-line / status-line

3.1.1.  请求行

请求行以方法标记开始，后跟一个空格（SP），请求目标，再一个空格（SP），协议版本，最后以CRLF结束。

request-line = method SP request-target SP HTTP-version CRLF

方法标记指示对目标资源执行的请求方法。请求方法区分大小写。

method = token

本规范定义的请求方法详见[RFC7231]第4节，以及HTTP方法注册表和定义新方法的考虑事项。

请求目标（request-target）标识要应用请求的目标资源，定义在第5.3节。

接收方通常通过用空白字符（见第3.5节）拆分请求行，将其拆分为各组成部分，因为这三个部分中不允许有空白字符。不幸的是，一些用户代理未能正确编码或排除超文本引用中的空白字符，导致这些不允许的字符在请求目标中被发送。

对于无效的请求行，接收方应返回400（错误请求）或301（永久重定向），请求目标应正确编码。接收方不应尝试自动更正后再处理请求（即不应在没有重定向的情况下处理），因为无效请求行可能被故意设计用以绕过安全过滤。

HTTP不对请求行长度设定预定义限制（见第2.5节）。如果服务器收到的方法长度超过其支持的最大长度，应返回501（未实现）状态码。若请求目标长度超过任何其愿意解析的URI长度，也应返回414（URI过长）状态码（见[RFC7231]第6.5.12节）。

实际中，关于请求行长度的限制多种多样。建议所有HTTP发起者和接收者支持至少8000字节的请求行长度。

3.1.2.  状态行

响应消息的第一行是状态行，由协议版本、空格（SP）、状态码、空格（SP）、描述状态码的文本短语（可能为空）以及CRLF组成。

status-line = HTTP-version SP status-code SP reason-phrase CRLF

状态码（status-code）是一个三位数字，描述服务器理解并满足客户端请求的结果。响应的其余部分应根据该状态码的语义进行解释。详见[RFC7231]第6节，包括状态码的类别（由首位数字指示）、本规范定义的状态码、定义新状态码的考虑事项以及IANA注册表。

status-code = 3DIGIT

reason-phrase（原因短语）仅用于提供与数字状态码相关联的文本描述，主要是为了向后兼容早期互联网应用协议，这些协议更常与交互式文本客户端配合使用。客户端应忽略原因短语内容。

reason-phrase = *( HTAB / SP / VCHAR / obs-text )

3.2.  头字段

每个头字段由不区分大小写的字段名、冒号（":"）、可选的前导空白、字段值以及可选的尾随空白组成。

header-field = field-name ":" OWS field-value OWS

field-name = token  
field-value = *( field-content / obs-fold )  
field-content = field-vchar [ 1*( SP / HTAB ) field-vchar ]  
field-vchar = VCHAR / obs-text

obs-fold = CRLF 1*( SP / HTAB )  
（过时的折叠行，详见第3.2.4节）

字段名（field-name）标签对应字段值，具有该头字段定义的语义。例如，Date头字段在[RFC7231]第7.1.1.2节中定义为包含消息的起始时间戳。

3.2.1.  字段扩展性

头字段完全可扩展：可以无限制地引入新字段名（每个定义可能具有新的语义），也没有限制在某个消息中使用的头字段数量。现有字段在本规范的各部分以及许多其他规范中均有定义。

可以定义新头字段，使得当被接收方理解时，可能覆盖或增强先前定义的头字段的解释，定义请求评估的前提条件，或细化响应的含义。

代理必须转发未识别的头字段，除非字段名在连接（Connection）头字段（第6.1节）中列出，或代理被特别配置为阻止或变换此类字段。其他接收方应忽略未识别的头字段。这些要求使得在不提前更新中间设备的情况下，能够增强HTTP的功能。

所有已定义的头字段应在IANA的“Message Headers”注册表中注册，详见[RFC7231]第8.3节。

3.2.2.  字段顺序

头字段中具有不同字段名的字段的接收顺序并不重要。然而，良好的做法是先发送包含控制数据的头字段，例如请求中的Host和响应中的Date，以便实现可以尽早决定何时不处理消息。服务器必须在完整接收请求头部后，才对目标资源应用请求，因为后续的头字段可能包含条件、认证凭据，或故意误导的重复头字段，这些都可能影响请求的处理。

除非整个字段值被定义为用逗号分隔的列表（即#(值)），或者该头字段是一个众所周知的例外（如下所述），否则发送方不得在消息中生成多个具有相同字段名的头字段。

接收方可以将多个具有相同字段名的头字段合并成一个“字段名：字段值”的对，方法是按顺序用逗号分隔每个后续字段值，而不改变消息的语义。因此，接收到相同字段名的头字段的顺序对合并后字段值的解释具有重要意义；代理在转发消息时不得更改这些字段值的顺序。

注意：实际上，“Set-Cookie”头字段（[RFC6265]）经常在响应消息中多次出现，并且不使用列表语法，违反了上述关于多个相同字段名的要求。由于它不能合并成单一字段值，接收方在处理头字段时应将“Set-Cookie”作为特殊情况处理。（详见[Kri2001]的附录A.2.3）

3.2.3. 空白字符

本规范使用三条规则表示线性空白字符的使用：OWS（可选空白）、RWS（必需空白）和BWS（“不良”空白）。

- OWS规则用于可能出现零个或多个线性空白八位字节的场合。对于为了提高可读性而偏好使用空白的协议元素，发送方应生成单个空格（SP）；否则，除非在消息过滤过程中需要清除无效或不需要的协议元素，否则不应生成空白字符。

- RWS规则用于至少需要一个线性空白八位字节以分隔字段标记的场合。发送方应生成单个空格（SP）。

- BWS规则用于语法允许出于历史原因而存在的可选空白。发送方不得在消息中生成BWS。接收方必须检测到此类不良空白并在解释协议元素前将其删除。

3.2.4. 字段解析

消息的解析采用通用算法，与具体的头字段名无关。在消息解释的后续阶段（通常在处理完整的头部后）才会解析字段值的内容。因此，本规范不再使用ABNF规则定义每个“字段名：字段值”对，而是使用根据每个注册字段名命名的ABNF规则，这些规则定义了该字段对应的字段值的有效语法（即在通过通用字段解析器提取字段值后）。

字段名与冒号之间不得有空白字符。过去，处理此类空白字符的差异曾导致请求路由和响应处理中的安全漏洞。服务器必须拒绝任何在字段名与冒号之间包含空白的请求消息，响应码为400（错误请求）。代理在转发响应消息前也必须删除此类空白。

字段值可能前后带有可选空白（OWS）；为了便于人类阅读，建议在字段值前加一个空格（SP）。字段值不包括任何前导或尾随空白：在从头字段中提取字段值时，解析器应排除字段值前后出现的OWS。

历史上，HTTP头字段值可以通过在每行前加空格或水平制表符（obs-fold）进行多行扩展。本规范废弃了这种换行折叠，除非在message/http媒体类型（第8.3.1节）中。除非消息用于在message/http媒体类型中封装，否则发送方不得生成包含换行折叠的消息（即，字段值中包含匹配obs-fold规则的内容）。

接收在非message/http容器中的请求消息中出现的obs-fold的服务器，必须拒绝该消息（返回400），最好附带说明不接受过时换行折叠的说明，或在解释字段值或转发前用空格替换每个obs-fold。

接收在非message/http容器中的响应消息中出现的obs-fold的代理或网关，必须丢弃该消息并返回502（网关错误），最好附带说明不接受换行折叠的说明，或用空格替换每个obs-fold后再处理。

用户代理在收到非message/http容器中的响应消息中的obs-fold时，也必须用空格替换每个obs-fold后再解释字段值。

历史上，HTTP允许字段内容使用ISO-8859-1字符集（[ISO-8859-1]），并通过[RFC2047]编码支持其他字符集。实际上，大多数HTTP头字段值仅使用US-ASCII字符集的子集[USASCII]。新定义的头字段应限制其字段值为US-ASCII八位字节。接收方应将字段内容中的其他八位字节（obs-text）视为不透明数据。

3.2.5. 字段限制

HTTP没有对每个头字段的长度或整个头部长度设定预定义限制（见第2.5节）。实际中，常见对单个头字段长度的限制多为临时性，通常依赖于具体字段的语义。

服务器在接收超出其处理能力的请求头字段或字段集时，必须返回适当的4xx（客户端错误）状态码。忽略这些头字段会增加服务器受到请求走私攻击（第9.5节）的风险。

客户端可以丢弃或截断超出其处理范围的头字段，只要这样做不会影响消息的框架或响应的语义。

3.2.6. 字段值组成部分

大多数HTTP头字段值采用由空白字符或特定分隔符分隔的通用语法组件（token、quoted-string和comment）定义。分隔符选自US-ASCII可见字符集中不允许出现在token中的字符（DQUOTE和"(),/:;<=>?@[\]{}）。

- token = 1*tchar

- tchar = "!" / "#" / "$" / "%" / "&" / "'" / "*" / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~" / DIGIT / ALPHA

- 任何VCHAR（可见字符），除分隔符外。

文本字符串如果用双引号括起来，则作为单一值解析。

- quoted-string = DQUOTE *( qdtext / quoted-pair ) DQUOTE

- qdtext = HTAB / SP / %x21 / %x23-5B / %x5D-7E / obs-text

- obs-text = %x80-FF

评论可以用括号括起来包含在某些HTTP头字段中。评论仅允许在定义为“comment”的字段值中出现。

- comment = "(" *( ctext / quoted-pair / comment ) ")"

- ctext = HTAB / SP / %x21-27 / %x2A-5B / %x5D-7E / obs-text

反斜杠八位字节（"\"）可在quoted-string和comment中用作单字节转义机制。处理quoted-string值的接收方必须将quoted-pair视为被其后八位字节替换。

- quoted-pair = "\" ( HTAB / SP / VCHAR / obs-text )

除非必要，发送方不应在quoted-string中生成quoted-pair（如为转义DQUOTE和反斜杠八位字节），在评论中也不应生成除括号和反斜杠外的quoted-pair。

3.3. 消息体

HTTP消息的消息体（如果有）用于携带请求或响应的有效载荷。除非应用过传输编码（第3.3.1节所述），否则消息体与有效载荷相同。

- message-body = *OCTET

请求和响应中允许消息体的规则不同。

请求中是否包含消息体由Content-Length或Transfer-Encoding头字段指示。请求消息的帧结构与方法语义无关，即使方法未定义消息体的用途。

响应中是否包含消息体取决于请求方法和响应状态码（第3.1.2节）。对HEAD请求（第4.3.2节[RFC7231]）的响应从不包含消息体，因为相关的响应头字段（如Transfer-Encoding、Content-Length等）仅指示如果请求方法为GET时的值（第4.3.1节[RFC7231]）。对CONNECT请求（第4.3.6节[RFC7231]）的2xx（成功）响应切换到隧道模式，不包含消息体。所有1xx（信息性）、204（无内容）和304（未修改）响应也不包含消息体。其他响应通常包含消息体，尽管可能为空。

3.3.1. 传输编码

Transfer-Encoding头字段列出为形成消息体而应用的传输编码名称序列（第4节定义）。传输编码类似于MIME的Content-Transfer-Encoding字段，旨在安全传输二进制数据（[RFC2045]第6节）。但在HTTP中，传输编码主要用于准确界定动态生成的有效载荷，以及区分仅为传输效率或安全性而应用的编码与资源本身的特性。

接收方必须能解析分块传输编码（第4.1节），因为它在未预先知道有效载荷大小时对消息的帧定界起关键作用。发送方不得对消息体多次应用分块（即，不允许对已分块的消息再次分块）。如果对请求有效载荷应用除分块外的其他传输编码，必须在最后应用分块以确保正确的帧定界；对响应有效载荷也应如此，或者通过关闭连接终止消息。

例如，

传输编码：gzip，分块

表示有效载荷主体已使用 gzip 编码进行压缩，然后在形成消息体时采用分块编码。

与内容编码（[RFC7231]第3.1.2.1节）不同，传输编码是消息的属性，而非表示的属性，链中的任何接收方（包括请求/响应链上的中间节点）都可以解码接收到的传输编码，或对消息体应用额外的传输编码，前提是相应地更改了Transfer-Encoding字段的值。关于编码参数的更多信息可以由本规范未定义的其他头字段提供。

传输编码可以在对HEAD请求的响应中，或在对GET请求的304（未修改）响应中（[RFC7232]第4.1节），这些响应都不包含消息体，用以指示如果请求是无条件的GET，源服务器本会对消息体应用传输编码。然而，这种指示并非强制，因为响应链中的任何接收方（包括源服务器）都可以在不需要传输编码时将其移除。

服务器不得在状态码为1xx（信息性）或204（无内容）的响应中发送Transfer-Encoding头字段。在对CONNECT请求的任何2xx（成功）响应中，服务器也不得发送Transfer-Encoding头字段（[RFC7231]第4.3.6节）。

传输编码是在HTTP/1.1中引入的。通常假设只支持HTTP/1.0的实现不会理解传输编码的处理方式。客户端必须在知道服务器支持HTTP/1.1（或更高版本）请求的情况下，才会在请求中包含Transfer-Encoding头字段；这种知识可能通过用户配置或记忆之前收到的响应版本获得。除非请求明确指示支持HTTP/1.1（或更高版本），否则服务器不得在响应中包含Transfer-Encoding。

如果服务器收到带有其不理解的传输编码的请求，应返回501（未实现）状态码。

3.3.2. 内容长度

当消息没有Transfer-Encoding头字段时，Content-Length头字段可以提供预期的有效载荷大小（以十进制字节数表示）。对于包含有效载荷的消息，Content-Length字段值提供了确定消息体（和消息）结束所需的边界信息。对于不包含有效载荷的消息，Content-Length指示所选表示的大小（[RFC7231]第3节）。

示例：
Content-Length: 3495

发送方不得在包含Transfer-Encoding头字段的消息中发送Content-Length头字段。

用户代理在没有传输编码的情况下，且请求方法定义了有效载荷的含义时，应在请求中发送Content-Length。例如，即使值为0（表示空载荷），POST请求通常也会包含Content-Length头字段。用户代理在请求没有载荷且方法语义不预期载荷时，不应发送Content-Length。

服务器可以在对HEAD请求的响应中发送Content-Length（[RFC7231]第4.3.2节）；除非其值等于在相同请求使用GET方法时，响应体的字节数，否则不得发送。

服务器也可以在对条件GET请求的304（未修改）响应中发送Content-Length，但前提是其值等于对相同请求返回200（成功）响应时的字节数。

服务器不得在状态码为1xx或204的响应中发送Content-Length。在对CONNECT请求的任何2xx响应中，也不得发送Content-Length。

除上述情况外，在没有传输编码的情况下，源服务器应在知道载荷大小的情况下，发送Content-Length，以便下游接收方可以测量传输进度、判断消息是否完整，以及可能重用连接。

任何大于或等于零的Content-Length值都是有效的。由于载荷长度没有预定义的限制，接收方必须能处理潜在的巨大十进制数，避免因整数溢出导致的解析错误（第9.3节）。

如果收到的消息中存在多个Content-Length头字段且字段值相同，或单个Content-Length头字段中包含多个相同的十进制值（如“Content-Length: 42, 42”），表明上游消息处理器生成或合并了重复的Content-Length字段，则接收方必须拒绝该消息（视为无效）或在确定消息体长度前，用单一有效的Content-Length字段替换重复的字段值。

注意：HTTP中使用Content-Length进行消息边界定义，与MIME中该字段的用法有显著不同，后者是可选字段，仅在“message/external-body”媒体类型中使用。

3.3.3. 消息体长度

消息体的长度由以下优先级规则确定（从高到低）：

1. 对HEAD请求的响应，以及任何状态码为1xx、204或304的响应，均以首个空行（header之后的空行）结束，不包含消息体。

2. 对CONNECT请求的任何2xx响应，意味着连接将立即成为隧道，且在结束header的空行之后。客户端必须忽略此类响应中的Content-Length或Transfer-Encoding头字段。

3. 如果存在Transfer-Encoding头字段且采用分块传输编码（第4.1节）作为最终编码，则消息体长度由读取并解码分块数据直到传输编码指示数据已完成来确定。

   如果存在Transfer-Encoding头字段且分块编码不是最终编码，则消息体长度由连接关闭前读取的数据量决定。  
   如果请求中存在Transfer-Encoding且非最终编码，则无法可靠确定消息体长度，服务器必须返回400（错误请求）并关闭连接。

   如果收到的消息同时包含Transfer-Encoding和Content-Length头字段，则传输编码优先于内容长度。  
   这类消息可能试图进行请求走私（第9.5节）或响应拆分（第9.4节），应作为错误处理。  
   发送方在转发此类消息前，必须删除已接收的Content-Length字段。

4. 如果收到的消息没有传输编码，但包含多个内容长度字段且字段值不同，或单个内容长度字段值无效，则消息边界无效，接收方必须视为不可恢复的错误。  
   若为请求消息，服务器应返回400（错误请求）并关闭连接。  
   若为代理收到的响应，代理应关闭与服务器的连接，丢弃响应，并向客户端发送502（网关错误）响应。  
   若为用户代理收到的响应，用户代理必须关闭与服务器的连接并丢弃响应。

5. 如果存在有效的Content-Length头字段（无传输编码），其十进制值定义预期的消息体长度（字节数）。  
   如果在接收完指示的字节数前，发送方关闭连接或接收方超时，则必须认为消息不完整并关闭连接。

6. 如果是请求消息，且上述情况都不成立，则消息体长度为零（无消息体）。

7. 否则，消息为未声明消息体长度的响应，消息体长度由服务器关闭连接前接收的字节数决定。

由于无法区分成功完成的、以关闭为界的消息与因网络故障中断的部分消息，服务器应尽可能生成编码或长度限定的消息。  
关闭界定主要是为了向后兼容HTTP/1.0。

服务器可以拒绝包含消息体但未带Content-Length的请求，返回411（长度必需）。

除非应用了除分块外的其他传输编码，客户端在发送包含消息体的请求时，应在已知消息体长度的情况下，使用有效的Content-Length头字段，而非分块传输编码，因为某些服务即使支持分块，也会用411状态码响应。  
这通常是因为这些服务通过网关实现，网关在调用前需要预先知道内容长度，且服务器无法或不愿在处理前缓冲整个请求。

用户代理在发送包含消息体的请求时，若不确定服务器支持HTTP/1.1（或更高版本），应使用有效的Content-Length头字段（而非分块），这可以通过用户配置或记忆之前响应的版本实现。

如果连接的最后一个请求的最终响应已完全接收，但仍有额外数据未读，用户代理可以丢弃剩余数据，或尝试判断这些数据是否属于之前响应的部分（例如，之前消息的Content-Length值不正确）。  
但不得将这些额外数据作为单独的响应处理、缓存或转发，否则可能导致缓存投毒。

3.4. 处理不完整的消息

服务器收到不完整的请求消息（通常因请求被取消或超时）时，可以在关闭连接前，先返回错误响应。

客户端收到不完整的响应消息（可能因连接提前关闭或解码分块失败）时，必须将其标记为不完整。  
关于不完整响应的缓存要求，详见[RFC7234]第3节。

如果响应在头部部分（在收到空行之前）中断，且状态码依赖头字段传达完整含义，则客户端不能假设已传达全部信息；可能需要重发请求，以确定下一步操作。

一段使用分块传输编码的消息体，如果未收到终止编码的零大小块，则视为不完整。如果一条消息使用有效的Content-Length，则当接收到的消息体大小（以字节为单位）少于Content-Length所指定的值时，也视为不完整。没有使用分块传输编码或Content-Length的响应，则通过关闭连接来终止，因此无论已接收多少消息体字节数，只要头部部分完整接收，均视为已完成。

3.5. 消息解析的鲁棒性

较旧的HTTP/1.0用户代理实现可能会在POST请求后额外发送一个CRLF，作为对一些早期服务器应用的变通措施，这些应用未能正确读取未以行尾终止的消息体内容。HTTP/1.1的用户代理不得在请求前后添加额外的CRLF。如果希望用行尾终止消息体，则用户代理必须将终止CRLF的字节数计入消息体长度。

为了增强鲁棒性，期望接收和解析请求行的服务器应忽略在请求行之前接收到的至少一个空行（CRLF）。

虽然起始行和头字段的行终止符是CRLF序列，但接收方可以识别单个LF作为行终止符，并忽略任何前置的CR。

尽管请求行和状态行的语法规则要求每个组成元素由单个空格（SP）分隔，但接收方可以改为在空白字符边界解析，除了CRLF终止符外，将任何形式的空白（包括空格、水平制表符、垂直制表符、换页符或纯CR）视为SP分隔符，并忽略前后的空白。需要注意的是，宽松的解析可能引发安全漏洞，尤其是在消息有多个接收方且每个方对鲁棒性的理解不同（详见第9.5节）。

当服务器只监听HTTP请求消息，或从起始行判断为HTTP请求消息时，若收到的字节序列不符合HTTP消息语法（除上述鲁棒性例外外），应返回400（错误请求）响应。

4. 传输编码

传输编码名称用于指示对有效载荷体进行的编码转换，以确保“安全传输”到网络中。这不同于内容编码，后者是表示的属性，而传输编码是消息的属性。

transfer-coding = "chunked"（第4.1节）/ "compress"（第4.2.1节）/ "deflate"（第4.2.2节）/ "gzip"（第4.2.3节）/ 传输扩展
传输扩展 = token *( OWS ";" OWS transfer-parameter )

参数以名称或名称=值对的形式出现。

transfer-parameter = token BWS "=" BWS ( token / 引号字符串 )

所有传输编码名称不区分大小写，应在HTTP传输编码注册表中注册（详见第8.4节）。它们在TE（第4.3节）和Transfer-Encoding（第3.3.1节）头字段中使用。

4.1. 分块传输编码

分块传输编码将消息体包装成一系列块，每个块有自己的大小指示符，后跟可选的尾部（包含头字段）。它允许传输未知大小的内容流，作为长度限定缓冲区的序列，从而实现连接的持久性，并让接收方知道何时已接收完整个消息。

chunked-body = *chunk
               last-chunk
               trailer-part
               CRLF

chunk = chunk-size [ chunk-ext ] CRLF
        chunk-data CRLF
chunk-size = 1*HEXDIG
last-chunk = 1*("0") [ chunk-ext ] CRLF

chunk-data = 1*OCTET（即一系列chunk-size字节）

chunk-size字段是十六进制数字字符串，表示块数据的大小（字节数）。当接收到大小为零的块（可能后跟尾部）并以空行终止时，分块传输编码完成。接收方必须能够解析和解码分块传输。

4.1.1. 块扩展

分块编码允许每个块在块大小后立即包含零个或多个块扩展，用于提供每块的元数据（如签名或哈希）、中间控制信息或消息体大小的随机化。

chunk-ext = *( ";" chunk-ext-name [ "=" chunk-ext-val ] )
chunk-ext-name = token
chunk-ext-val = token / 引号字符串

分块编码是每个连接特有的，可能在任何更高层应用检查扩展之前被每个接收方（包括中间代理）移除或重新编码。因此，块扩展的使用通常限于特定的HTTP服务，比如“长轮询”（客户端和服务器可以共享对块扩展的预期）或端到端安全连接中的填充。

接收方必须忽略未识别的块扩展。服务器应限制请求中接收的块扩展总长度，合理控制服务范围，类似于对消息其他部分的长度限制和超时设置，如果超出应返回4xx（客户端错误）响应。

4.1.2. 分块尾部

尾部允许发送方在分块消息末尾包含额外字段，用于提供在消息体传输过程中动态生成的元数据（如完整性校验、数字签名或后处理状态）。尾部字段与头字段相同，但在分块尾部中发送，而非在消息头部。

trailer-part = *( header-field CRLF )

发送方不得生成包含消息框架（如Transfer-Encoding和Content-Length）、路由（如Host）、请求修饰符（如[RFC7231]第5节中的控制和条件）、认证（如[RFC7235]和[RFC6265]）、响应控制数据（如[RFC7231]第7.1节）或处理载荷方式（如Content-Encoding、Content-Type、Content-Range和Trailer）所必需字段的尾部。

当接收含非空尾部的分块消息时，接收方可以将尾部字段（除上述禁止字段外）视为附加在消息头部的字段。必须忽略（或视为错误）任何禁止在尾部中发送的字段，因为将它们作为头部字段处理可能绕过外部安全过滤。

除非请求中包含表示“尾部”可接受的TE头字段（详见第4.3节），否则服务器不应生成其认为用户代理必须接收的尾部字段。没有TE字段中的“trailers”，服务器应假设尾部字段可能在传输途中被静默丢弃。这一要求允许中间代理在不缓冲整个响应的情况下，将去除分块的消息转发给HTTP/1.0接收方。

4.1.3. 分块解码

解码分块传输编码的伪代码如下：

length := 0
读取块大小、块扩展（如有）和CRLF
while (块大小 > 0) {
    读取块数据和CRLF
    将块数据附加到已解码的消息体
    length := length + 块大小
    读取下一块大小、块扩展（如有）和CRLF
}
读取尾部字段
while (尾部字段非空) {
    如果（尾部字段允许在尾部中发送） {
        将尾部字段附加到现有头字段
    }
    读取尾部字段
}
Content-Length := length
从Transfer-Encoding中移除“chunked”
从现有头字段中移除Trailer

4.2. 压缩编码

以下定义的编码可用于压缩消息的有效载荷。

4.2.1. 压缩编码

“compress”编码是自适应的Lempel-Ziv-Welch（LZW）编码[Welch]，常由UNIX文件压缩程序“compress”生成。接收方应将“x-compress”视为等同于“compress”。

4.2.2. Deflate编码

“deflate”编码是包含“deflate”压缩数据流的“zlib”数据格式[RFC1950][RFC1951]，结合了Lempel-Ziv（LZ77）压缩算法和霍夫曼编码。

注意：一些不符合规范的实现会直接发送没有zlib包装的“deflate”压缩数据。

4.2.3. Gzip编码

“gzip”编码是带有32位循环冗余校验（CRC）的LZ77编码，常由gzip文件压缩程序[RFC1952]生成。接收方应将“x-gzip”视为等同于“gzip”。

4.3. TE（传输编码接受指示）

请求中的“TE”头字段指示客户端愿意接受的除分块外的传输编码，以及是否愿意接受分块传输中的尾部字段。

TE字段值由逗号分隔的传输编码名称组成，每个允许带有可选参数（详见第4节）和/或关键词“trailers”。客户端不得在TE中发送“chunked”编码名；HTTP/1.1的接收方始终接受“chunked”。

TE = #t-codings
t-codings = "trailers" / ( transfer-coding [ t-ranking ] )
t-ranking = OWS ";" OWS "q=" rank
rank = ( "0" [ "." 0*3DIGIT ] ) / ( "1" [ "." 0*3("0") ] )

以下是TE的三个示例：

TE: deflate
TE:
TE: trailers, deflate;q=0.5

“trailers”关键词表示客户端愿意接受分块传输中的尾部字段（详见第4.1.2节），代表自己及下游客户端的意愿。对于中间代理的请求，这意味着： (a) 所有下游客户端都愿意接受转发响应中的尾部字段；或 (b) 中间代理会尝试为下游接收方缓冲响应。注意，HTTP/1.1未定义限制分块响应大小的机制，无法确保中间代理缓冲全部响应。

当接受多个传输编码时，客户端可以用不区分大小写的“q”参数（类似[RFC7231]第5.3.1节中的q值）对编码进行偏好排序。q值范围0到1，0.001为最低偏好，1为最高偏好；0表示“不可接受”。

如果TE字段为空或未出现，唯一可接受的传输编码是“chunked”。没有传输编码的消息始终可接受。

TE头字段只适用于即时连接，发送方必须在Connection头字段（第6.1节）中也发送“TE”连接选项，以防止中间设备转发TE字段而不支持其语义。

4.4. 尾部（Trailer）

当消息体采用分块传输编码，且发送方希望在消息末尾附加元数据（如完整性校验、数字签名或后处理状态）时，应在消息体之前生成Trailer头字段，指明哪些字段会出现在尾部。这样，接收方可以在开始处理消息体前准备接收尾部元数据，特别适合流式传输和需要即时验证完整性的场景。

Trailer = 1#field-name

HTTP请求消息的路由由每个客户端根据目标资源、客户端的代理配置以及入站连接的建立或重用来确定。相应的响应路由则沿着相同的连接链返回到客户端。

5.1. 确定目标资源

HTTP被广泛应用于各种场景，从通用计算机到家用电器。在某些情况下，通信选项在客户端配置中是硬编码的。然而，大多数HTTP客户端依然依赖于与通用Web浏览器相同的资源识别机制和配置技术。

HTTP通信由用户代理出于某种目的发起。这个目的由请求语义（定义在[RFC7231]中）和应用这些语义的目标资源组成。URI引用（第2.7节）通常用作“目标资源”的标识符，用户代理会将其解析为绝对形式以获取“目标URI”。目标URI不包括引用中的片段部分（如果有的话），因为片段标识符仅供客户端处理（[RFC3986]第3.5节）。

5.2. 入站连接

一旦确定了目标URI，客户端需要决定是否需要发起网络请求以实现预期的语义，以及请求应当指向哪里。

如果客户端有缓存（[RFC7234]）且请求可以由缓存满足，通常会优先向缓存发起请求。

如果缓存不能满足请求，典型的客户端会检查其配置，判断是否需要使用代理来满足请求。代理配置依赖于实现，但通常基于URI前缀匹配、选择性授权匹配或两者结合，代理本身通常由“http”或“https”URI标识。如果适用代理，客户端会通过建立（或重用）到该代理的连接进行入站连接。

如果没有适用的代理，通常客户端会调用特定于目标URI方案的处理程序，直接连接到目标资源的授权服务器。具体实现方式依赖于目标URI方案，并由相关规范定义，类似于本规范定义的“http”（第2.7.1节）和“https”（第2.7.2节）方案的访问方式。

关于连接管理的HTTP要求在第6节中定义。

5.3. 请求目标

一旦建立了入站连接，客户端会发送一条HTTP请求消息（第3节），请求目标由目标URI派生。根据请求的方法和是否请求代理，请求目标有四种不同的格式：

```
request-target = origin-form
               / absolute-form
               / authority-form
               / asterisk-form
```

5.3.1. origin-form

最常用的请求目标形式是origin-form。

```
origin-form = absolute-path [ "?" query ]
```

当直接向源服务器发起请求（除非是CONNECT或全局OPTIONS请求，详见下文）时，客户端必须只将目标URI的绝对路径和查询部分作为请求目标。如果目标URI的路径为空，客户端必须在请求目标的origin-form中发送“/”。同时，还会发送一个Host头字段（见第5.4节）。

例如，客户端希望直接从源服务器获取资源表示，资源URI为：

http://www.example.org/where?q=now

它会打开（或重用）到“www.example.org”端口80的TCP连接，并发送：

```
GET /where?q=now HTTP/1.1
Host: www.example.org
```

后续跟随请求消息的其余部分。

5.3.2. absolute-form

当向代理发起请求（除非是CONNECT或全局OPTIONS请求）时，客户端必须将目标URI以绝对形式作为请求目标。

```
absolute-form = absolute-URI
```

请求代理要么利用有效缓存提供服务，要么代表客户端向下一个入站代理服务器或直接向请求目标指示的源服务器发起相同请求。关于此类“转发”请求的要求在第5.7节中定义。

示例请求行的绝对形式为：

```
GET http://www.example.org/pub/WWW/TheProject.html HTTP/1.1
```

为了未来版本中所有请求都能过渡到绝对形式，服务器必须接受请求中的绝对形式，即使HTTP/1.1客户端通常只会向代理发送。

5.3.3. authority-form

请求目标的authority-form仅用于建立隧道的CONNECT请求（见[RFC7231]第4.3.6节）。

```
authority-form = authority
```

在发起CONNECT请求以通过一个或多个代理建立隧道时，客户端必须只将目标URI的authority部分（不包括用户信息和“@”符号）作为请求目标。例如：

```
CONNECT www.example.com:80 HTTP/1.1
```

5.3.4. asterisk-form

请求目标的asterisk-form仅用于全局OPTIONS请求（见[RFC7231]第4.3.7节）。

```
asterisk-form = "*"
```

当客户端希望对整个服务器发起OPTIONS请求，而非特定资源时，必须只发送“*”作为请求目标。例如：

```
OPTIONS * HTTP/1.1
```

如果代理收到带有绝对形式请求目标的OPTIONS请求，且URI路径为空且没有查询组件，则链中的最后一个代理必须在转发请求时将请求目标设为“*”。

例如，以下请求：

```
OPTIONS http://www.example.org:8001 HTTP/1.1
```

会被最终代理转发为：

```
OPTIONS * HTTP/1.1
Host: www.example.org:8001
```

在连接到“www.example.org”端口8001后。

5.4. Host

请求中的“Host”头字段提供目标URI中的主机和端口信息，使源服务器能够区分不同资源，尤其是在单一IP地址上服务多个主机名时。

```
Host = uri-host [ ":" port ] ; 第2.7.1节
```

所有HTTP/1.1请求消息都必须包含Host头字段。如果目标URI包含授权部分，客户端必须发送与该授权部分（除用户信息和“@”符号外）相同的Host字段值。如果目标URI缺少或未定义授权部分，则必须发送空值的Host头字段。

由于Host字段值对于请求处理至关重要，用户代理应在请求行之后立即生成Host头字段。

例如，向源服务器请求：

http://www.example.org/pub/WWW/

的GET请求应以以下内容开始：

```
GET /pub/WWW/ HTTP/1.1
Host: www.example.org
```

即使请求目标采用绝对形式，客户端也必须发送Host头字段，以确保在旧的HTTP/1.0代理中也能正确转发。

当代理收到带有绝对形式请求目标的请求时，必须忽略（如果有的话）收到的Host头字段，改用请求目标中的主机信息。转发此类请求的代理必须根据请求目标生成新的Host字段值，而不是转发原有的。

由于Host头字段作为应用层路由机制，常成为恶意软件的目标，用于污染共享缓存或将请求重定向到非预期的服务器。如果拦截代理依赖Host字段进行请求重定向或作为共享缓存的键，而未先验证连接是否指向有效的IP地址，则特别容易受到攻击。

服务器必须对缺少Host头字段的HTTP/1.1请求或包含多个Host头字段或Host字段值无效的请求返回400（错误请求）状态码。

5.5. 有效请求URI

由于请求目标通常只包含用户代理目标URI的一部分，服务器会将其重建为“有效请求URI”，以正确处理请求。重建过程涉及服务器的本地配置以及请求目标、Host头字段和连接上下文中传达的信息。

对用户代理而言，有效请求URI即目标URI。

如果请求目标采用绝对形式，有效请求URI与请求目标相同。否则，有效请求URI的构建如下：

- 如果服务器配置（或出站网关）提供固定的URI方案，则使用该方案；否则，如果连接通过TLS安全的TCP连接接收，则方案为“https”；否则为“http”。

- 如果服务器配置（或出站网关）提供固定的URI授权部分，则使用该授权部分；否则，如果请求目标为授权形式，则其授权部分与请求目标相同；否则，如果提供了非空的Host头字段，则其值作为授权部分；否则，使用服务器配置的默认名称，并且如果连接的TCP端口号不同于该方案的默认端口，则在授权部分后附加“:”和端口号。

- 如果请求目标为授权形式或星号形式，则有效请求URI的路径和查询部分为空；否则，路径和查询部分与请求目标相同。

- 一旦确定了上述组成部分，可以通过连接方案、"://"、授权部分以及路径和查询部分，组合成绝对URI形式。

示例1：在不安全的TCP连接中接收的请求

```
GET /pub/WWW/TheProject.html HTTP/1.1
Host: www.example.org:8080
```

其有效请求URI为：

```
http://www.example.org:8080/pub/WWW/TheProject.html
```

示例2：在TLS安全连接中接收的请求

```
OPTIONS * HTTP/1.1
Host: www.example.org
```

其有效请求URI为：

```
https://www.example.org
```

对于没有Host头字段的HTTP/1.0请求，可能需要使用启发式方法（如检查URI路径中是否有特定于某个主机的唯一标识）来猜测有效请求URI的授权部分。

一旦构建出有效请求URI，源服务器需要决定是否通过接收请求的连接提供服务。例如，请求可能被误导（故意或无意），使得请求目标或Host头中的信息与实际连接的主机或端口不符。如果连接来自可信网关，可能会预期到这种不一致；否则，可能意味着试图绕过安全过滤、欺骗服务器提供非公开内容或污染缓存。关于消息路由的安全考虑，请参见第9节。

5.6. 将响应关联到请求

HTTP不包含请求标识符来关联某个请求消息与其对应的响应消息。因此，它依赖响应的到达顺序与请求的发起顺序严格对应。在每个请求前可能会有一个或多个信息性响应（1xx，详见[RFC7231]第6.2节）先行响应，之后才是最终响应。

RFC 7230           HTTP/1.1 消息语法与路由         2014年6月

在一个连接上，如果客户端有多个未完成的请求，必须按照请求的发送顺序维护一份未完成请求的列表，并且必须将每个收到的响应消息与该连接上尚未收到最终（非1xx）响应的最高序请求相关联。

5.7. 消息转发

如第2.3节所述，中间人可以在处理HTTP请求和响应的过程中扮演多种角色。有些中间人用于提升性能或可用性，另一些则用于访问控制或内容过滤。由于HTTP流具有类似管道-过滤架构的特性，中间人对流的任何方向的增强（或干扰）没有固有的限制。

未作为隧道的中间人必须实现第6.1节中规定的Connection头字段，并且应排除只针对传入连接的字段不予转发。

除非受到保护以避免无限请求循环，否则中间人不得将消息转发给自己。通常，中间人应识别其自身的服务器名称，包括任何别名、本地变体或字面IP地址，并直接响应此类请求。

5.7.1. Via

"Via"头字段指示在用户代理与服务器（请求时）或源服务器与客户端（响应时）之间存在的中间协议和接收者，类似于电子邮件中的"Received"头字段（[RFC5322]第3.6.7节）。Via可用于追踪消息转发路径、避免请求循环，以及识别请求/响应链中发送者的协议能力。

Via的格式为：
```
Via = 1#( received-protocol RWS received-by [ RWS comment ] )
```
其中：
- received-protocol = [ protocol-name "/" ] protocol-version（参见第6.7节）
- received-by = ( uri-host [ ":" port ] ) / pseudonym
- pseudonym = token

多个Via字段值代表每个转发该消息的代理或网关。每个中间人会附加其关于消息接收方式的信息，最终形成按转发顺序排列的链路。

代理在转发每条消息时，必须在每个转发的消息中加入适当的Via头字段。HTTP-to-HTTP网关必须在每个入站请求中加入合适的Via头字段，也可以在转发的响应中加入。

对于每个中间人，received-protocol表示上游发送者使用的协议及版本。因此，Via字段记录了请求/响应链中声明的协议能力，以便下游接收者可以看到；这对于判断哪些向后不兼容的特性在响应或后续请求中是否安全使用非常有用（详见第2.6节）。当接收协议为HTTP时，协议名通常省略。

received-by部分通常是随后转发消息的接收服务器或客户端的主机名和可选端口号。但如果真实主机名被视为敏感信息，发件人可以用伪名代替。如果未提供端口，接收方可以理解为是在该协议的默认TCP端口上接收。

发件人可以在Via头字段中加入评论，以标识每个接收方的软件，类似于User-Agent和Server头字段。然而，所有Via中的评论都是可选的，接收方可以在转发前将其删除。

例如，一条请求可能由HTTP/1.0的用户代理发出，经过名为"fred"的内部代理（使用HTTP/1.1）转发到公共代理p.example.net，最后由该代理将请求转发到源服务器www.example.com。最终，www.example.com收到的请求可能包含如下Via头：
```
Via: 1.0 fred, 1.1 p.example.net
```

作为网络防火墙门户的中间人，除非明确启用，否则不应转发防火墙区域内主机的名称和端口。如果未启用，应该用适当的伪名替换任何防火墙后端主机的接收者信息。

中间人可以将具有相同received-protocol值的连续Via条目合并为一个条目，例如：
```
Via: 1.0 ricky, 1.1 ethel, 1.1 fred, 1.0 lucy
```
可以合并为：
```
Via: 1.0 ricky, 1.1 mertz, 1.0 lucy
```
除非这些条目属于同一组织控制，且主机已被替换为伪名，否则发件人不应合并不同的received-protocol值的条目。

5.7.2. 转换

一些中间人具有转换消息及其负载的功能。例如，代理可能会在不同图像格式之间转换，以节省缓存空间或减少慢速链路上的流量。然而，在对关键应用（如医学影像或科学数据分析）中的负载进行转换时，可能会出现操作问题，尤其是在使用完整性校验或数字签名以确保接收的负载与原始内容一致的情况下。

如果HTTP-to-HTTP代理被设计或配置为以语义上有意义的方式修改消息（即，超出正常HTTP处理所需的修改，且对原始发件人或潜在的下游接收者具有重要意义），则称其为“转换代理”。例如，转换代理可能作为共享注释服务器（修改响应以包含对本地注释数据库的引用）、恶意软件过滤器、格式转码器或隐私过滤器。此类转换被假定为由选择该代理的客户端（或客户端组织）所期望。

如果代理收到的请求目标中的主机名不是完全限定域名（FQDN），它可以在转发请求时添加自己的域名。若请求目标包含FQDN，则不得更改主机名。

代理在转发请求时，不得修改请求目标中的“绝对路径”和“查询”部分，除非为替换空路径为“/”或“*”等特殊情况。

代理可以通过应用或移除传输编码（第4节）来修改消息体。

如果消息包含“no-transform”缓存控制指令（第5.2节），代理不得转换其负载（第3.3节，[RFC7231]）。

对于未包含“no-transform”指令的消息，代理可以进行转换。转换负载时，必须在消息中加入Warning头字段，warn-code为214（“已应用转换”），如果该Warning头未存在（详见第5.5节，[RFC7234]）。对状态码为200（OK）的响应进行转换后，还可以通过将响应状态码改为203（非权威信息）来通知下游接收者已进行过转换（第6.3.4节，[RFC7231]）。

除非定义明确允许，否则代理不应修改关于通信链端点、资源状态或所选表示（除负载外）的头字段，除非出于隐私或安全考虑。

6. 连接管理

HTTP消息与底层传输或会话层的连接协议无关。HTTP仅假设存在可靠的传输，能按顺序交付请求和响应。将HTTP请求和响应结构映射到底层传输协议的数据单元超出了本规范的范围。

如第5.2节所述，HTTP交互所用的具体连接协议由客户端配置和目标URI决定。例如，“http” URI方案（第2.7.1节）表示默认使用IP上的TCP连接，端口为80，但客户端也可能配置使用其他连接、端口或协议的代理。

HTTP实现应进行连接管理，包括维护当前连接的状态、建立新连接或重用现有连接、处理连接上的消息、检测连接失败以及关闭连接。大多数客户端会同时维护多个连接，包括每个服务器端点多个连接。大多数服务器设计为能同时处理数千个连接，同时控制请求队列以实现公平使用和检测拒绝服务攻击。

6.1. 连接

“Connection”头字段允许发件人指示当前连接的控制选项。为了避免混淆下游接收者，代理或网关在转发消息前必须删除或替换任何接收到的连接选项。

当除Connection之外的头字段用于提供当前连接的控制信息时，发件人必须在Connection头字段中列出相应的字段名。代理或网关在转发消息前必须解析收到的Connection头字段，并对其中的每个连接选项，删除消息中与之同名的头字段，然后再删除Connection头字段本身（或用中间人自己的连接选项替换）。

因此，Connection头字段提供了一种声明式的方式，用于区分仅针对“跳点”接收者的头字段（“hop-by-hop”）和面向链路上所有接收者的头字段（“端到端”），使消息具有自描述性，并允许未来的连接特定扩展在不被旧中间人盲目转发的情况下部署。

Connection头字段的值符合以下语法：
```
Connection = 1#connection-option
connection-option = token
```
连接选项不区分大小写。

发件人不得为面向所有接收者的负载头字段发送对应的连接选项。例如，Cache-Control从不适合作为连接选项（第5.2节，[RFC7234]）。

连接选项不一定对应消息中的头字段，因为如果没有参数关联到连接选项，可能不需要连接特定的头字段。相反，收到的没有对应连接选项的连接特定头字段，通常表示该字段被中间人错误转发，应由接收者忽略。

定义新连接选项时，规范作者应调查现有的头字段名，确保新连接选项不与已部署的头字段重名。定义新连接选项实际上是为携带与连接相关的附加信息预留字段名，因为发件人不应将该字段名用于其他用途。

“close”连接选项用于发件人表示在响应完成后关闭连接。例如：
```
Connection: close
```
在请求或响应头中，表示发件人在当前请求/响应完成后将关闭连接（第6.6节）。

不支持持久连接的客户端必须在每个请求中加入“close”连接选项。

不支持持久连接的服务器必须在每个非1xx状态码的响应中加入“close”连接选项。

6.2. 建立连接

本规范超出了描述通过各种传输层或会话层协议建立连接方式的范围。每个连接仅适用于一个传输链路。

6.3 持久性

HTTP/1.1 默认使用“持久连接”，允许在单一连接上进行多次请求和响应。使用“close”连接选项来表示当前请求/响应后连接不会持续。HTTP实现应支持持久连接。

接收方根据最近接收的消息的协议版本和Connection头字段（如果有）判断连接是否持久：

- 如果存在“close”连接选项，连接在当前响应后不再持续；
- 如果接收的协议是HTTP/1.1（或更高版本），连接将在当前响应后持续；
- 如果接收的协议是HTTP/1.0，且存在“keep-alive”连接选项，且接收方不是代理，且希望遵循HTTP/1.0的“keep-alive”机制，连接将在当前响应后持续；
- 否则，连接将在当前响应后关闭。

客户端可以在持久连接上发送更多请求，直到发送或接收“close”连接选项，或收到没有“keep-alive”连接选项的HTTP/1.0响应。

为了保持连接的持久性，所有消息都应具有自定义的消息长度（即不由连接关闭定义的长度），如第3.3节所述。服务器必须读取完整的请求消息体或在发送响应后关闭连接，否则剩余数据可能被误解为下一次请求。同样，客户端在打算重用同一连接进行后续请求时，也必须读取完整的响应消息体。

代理服务器不得与HTTP/1.0客户端保持持久连接（详见[RFC2068]第19.7.1节关于许多HTTP/1.0客户端实现的Keep-Alive头字段问题的讨论）。

有关与HTTP/1.0客户端向后兼容的更多信息，请参见附录A.1.2。

6.3.1 重试请求

连接可能随时关闭，无论是否有意。实现应预料到异步关闭事件的恢复需求。

当入站连接提前关闭时，客户端可以开启新连接，并自动重传所有具有幂等方法（第4.2.2节）的中止请求序列（参见[RFC7231]第4.2.2节）。代理不得自动重试非幂等请求。

用户代理不得自动重试带有非幂等方法的请求，除非它有办法确认请求语义实际上是幂等的，或能检测到原始请求未被应用。例如，知道（通过设计或配置）对某资源的POST请求是安全的，用户代理可以自动重复该请求。同样，专为操作版本控制仓库设计的用户代理，可能通过在连接失败后检查目标资源的修订版本，恢复部分失败状态，回滚或修正部分已应用的更改，然后自动重试失败的请求。

客户端不应自动重试已失败的自动重试。

6.3.2 管道化

支持持久连接的客户端可以“管道化”请求（即在未等待响应的情况下连续发送多个请求）。服务器可以并行处理一系列管道请求（前提是它们都使用安全方法，第4.2.1节），但必须按请求接收的顺序发送响应。

管道化请求的客户端应在连接关闭前未收到所有响应时，重试未答复的请求。在连接失败后（非由服务器在最后完整响应中明确关闭的连接）重试管道请求时，客户端不得在连接建立后立即管道化，因为之前管道中的第一个请求可能已引发错误响应，如果在提前关闭的连接上发送多个请求，可能再次丢失响应（参见第6.6节描述的TCP重置问题）。

幂等方法（第4.2.2节）对管道化尤为重要，因为它们可以在连接失败后自动重试。用户代理在收到该方法的最终响应状态码之前，不应对非幂等请求进行管道化，除非它有办法检测和恢复涉及管道序列的部分失败。

中介（代理）在转发入站管道请求时，可以进行管道化，因为它可以依赖出站用户代理判断哪些请求可以安全管道化。如果入站连接在收到响应前失败，管道中未响应的请求（具有幂等方法）可以尝试重试，否则应转发已收到的响应并关闭相应的出站连接，以便出站用户代理能相应恢复。

6.4 并发

客户端应限制其与某一服务器维护的同时打开连接数。

早期的HTTP版本为连接数设定了上限，但这在许多应用中不切实际。因此，本规范不强制规定最大连接数，而是鼓励客户端在开启多个连接时保持保守。

多个连接通常用于避免“队头阻塞”问题，即一个请求占用大量服务器资源或负载较大，阻塞后续请求。然而，每个连接都消耗服务器资源。此外，在网络拥堵时，使用多连接可能引发不良副作用。

注意，服务器可能会拒绝被认为是滥用或拒绝服务攻击特征的流量，例如来自单一客户端的过多连接。

6.5 失败与超时

服务器通常会设定超时值，超出后会关闭非活动连接。代理服务器可能会设置更高的超时值，因为客户端可能会通过同一代理建立更多连接。持久连接对超时的长度（或存在性）没有要求。

希望超时的客户端或服务器应发出优雅关闭。实现应持续监控已打开的连接，检测关闭信号并作出响应，因为及时关闭连接有助于回收系统资源。

任何客户端、服务器或代理都可以随时关闭传输连接。例如，客户端可能在服务器决定关闭“空闲”连接时开始发送新请求。从服务器角度看，连接在空闲时被关闭；从客户端角度看，请求仍在进行中。

服务器应尽可能维持持久连接，并允许底层传输的流控机制解决临时过载，而不是终止连接，后者可能加剧网络拥堵。

客户端在传输消息体时，应监控网络连接，检测错误响应。如果看到响应表明服务器不再接受消息体并关闭连接，客户端应立即停止传输并关闭连接。

6.6 断开连接

连接头字段（第6.1节）提供了“close”选项，发送方应在当前请求/响应对后希望关闭连接时使用。

发送“close”连接选项的客户端不得在该连接上发送后续请求（在包含“close”的请求之后），并应在读取完对应的最终响应后关闭连接。

接收“close”连接选项的服务器必须在发送完包含“close”的最终响应后，主动关闭连接（见下文）。服务器应在其最终响应中包含“close”连接选项。服务器不得处理该连接上的任何后续请求。

发送“close”连接选项的服务器必须在发送包含“close”的响应后，主动关闭连接。服务器不得处理该连接上的任何后续请求。

接收“close”连接选项的客户端应停止在该连接上发送请求，并在读取包含“close”的响应后关闭连接；如果在连接上已发送其他管道请求，客户端不应假设它们会被服务器处理。

如果服务器立即关闭TCP连接，存在客户端可能无法读取最后HTTP响应的重大风险。如果服务器在完全关闭连接后从客户端接收额外数据（如客户端在收到服务器响应前已发送的请求），服务器的TCP堆栈会向客户端发送重置包；不幸的是，这可能会清除客户端未确认的输入缓冲区，导致客户端的HTTP解析器无法读取。

为避免TCP重置问题，服务器通常分阶段关闭连接。首先，执行半关闭，只关闭读写连接的写端。然后继续读取，直到收到客户端的关闭信号，或确信自己的TCP堆栈已收到客户端确认最后响应的包。最后，完全关闭连接。

尚不清楚重置问题是否仅限于TCP，或也存在于其他传输连接协议中。

6.7 升级

“Upgrade”头字段旨在提供一种简单机制，用于在同一连接上从HTTP/1.1切换到其他协议。客户端可以在请求的Upgrade头字段中列出协议，按偏好降序，邀请服务器切换到其中之一或多个协议，然后再发送最终响应。服务器可以忽略收到的Upgrade头字段，如果它希望继续使用当前协议。升级不能用来强制协议变更。

```
Upgrade          = 1#protocol

protocol         = protocol-name ["/" protocol-version]
protocol-name    = token
protocol-version = token
```

发送101（切换协议）响应的服务器必须在响应中包含Upgrade头字段，指示切换到的新协议（如果切换多个协议层，应按层级升序列出）。服务器不得切换到未在对应请求的Upgrade头字段中指明的协议。服务器也可以根据其他因素（如请求性质或当前负载）选择忽略客户端的偏好顺序，选择不同的协议。

发送426（Upgrade Required）响应的服务器必须在响应中包含Upgrade头字段，以指示可接受的协议，且按偏好顺序由高到低排列。

服务器也可以在其他响应中发送Upgrade头字段，以宣传其支持升级到列出的协议（按偏好顺序由高到低），当未来的请求适用时。

以下是客户端发出的假设示例：

```
GET /hello.txt HTTP/1.1
Host: www.example.com
Connection: upgrade
Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11
```

协议变更后，应用层通信的能力和性质完全取决于所选择的新协议。然而，在发送101（Switching Protocols）响应后，服务器应继续响应原始请求，就像它已在新协议中收到等效请求一样（即，协议变更后，服务器仍有未完成的请求需要满足，且应在不要求请求重发的情况下完成）。

例如，如果在GET请求中收到Upgrade头字段，服务器决定切换协议，它首先用HTTP/1.1的101（Switching Protocols）响应，然后立即用新协议的等效响应回应目标资源的GET请求。这允许连接升级到具有相同语义的协议，而无需额外的往返延迟。除非新协议能满足收到消息的语义，否则服务器不得切换协议；而OPTIONS请求可以被任何协议支持。

以下是对上述假设请求的示例响应：

```
HTTP/1.1 101 Switching Protocols
Connection: upgrade
Upgrade: HTTP/2.0
```

[...] 数据流切换到HTTP/2.0，并对“GET /hello.txt”请求作出适当的响应（由新协议定义）。

当发送Upgrade时，发送方还必须附带一个包含“upgrade”连接选项的Connection头字段（第6.1节），以防止中间设备误将Upgrade转发，特别是那些未实现列出协议的设备。服务器必须忽略在HTTP/1.0请求中收到的Upgrade头字段。

客户端在完全发送请求消息之前不能开始使用升级后的协议（即，不能在消息中途更改所用协议）。如果服务器在收到Upgrade和Expect（带有“100-continue”期望）头字段时，必须先发送100（Continue）响应，然后再发送101（Switching Protocols）响应。

Upgrade头字段仅适用于在现有连接基础上切换协议；不能用来切换底层连接（传输协议）或将现有通信切换到不同的连接。对于这些目的，更合适的做法是使用3xx（重定向）响应（第6.4节）。

本规范仅定义“HTTP”协议名，用于超文本传输协议族，依据第2.6节的版本规则及未来的更新。其他协议名应通过第8.6节定义的注册程序向IANA注册。

---

**7. ABNF列表扩展：#规则**

为增强某些头字段值定义的可读性，采用了对RFC5234中ABNF规则的#规则扩展。

定义了类似“*”的“#”构造，用于定义逗号分隔的元素列表。完整形式为“<n>#<m>元素”，表示至少<n>个，最多<m>个元素，每个元素由单个逗号（“,””）和可选空白（OWS）分隔。

在任何使用列表构造的规则中，发送方不得生成空元素。换句话说，列表必须满足以下语法：

```
1#元素 => 元素 *( OWS "," OWS 元素 )
```

以及：

```
#元素 => [ 1#元素 ]
```

对于n ≥ 1且m > 1的情况：

```
<n>#<m>元素 => 元素 <n-1>*<m-1> ( OWS "," OWS 元素 )
```

为了兼容旧的列表规则，接收方必须解析并忽略合理数量的空元素，以应对发送方合并值的常见错误，但不能因此成为拒绝服务的手段。换句话说，接收方必须接受满足以下语法的列表：

```
#元素 => [ ( "," / 元素 ) *( OWS "," [ OWS 元素 ] ) ]
```

以及：

```
1#元素 => *( "," OWS ) 元素 *( OWS "," [ OWS 元素 ] )
```

空元素不计入元素总数。例如，假设以下ABNF定义：

```
example-list      = 1#example-list-elmt
example-list-elmt = token  ; 见第3.2.6节
```

则以下值为有效（引号仅为界定用）：

- "foo,bar"
- "foo ,bar,"
- "foo , ,bar,charlie   "

相反，以下值无效，因为至少需要一个非空元素：

- ""
- ","
- ",   ,"

附录B展示了展开列表构造后，接收方的ABNF定义。

---

**8. IANA考虑事项**

**8.1. 头字段注册**

HTTP头字段在<http://www.iana.org/assignments/message-headers/>的“消息头字段”注册表中注册。

本文件定义了以下头字段，已相应更新“永久消息头字段名”注册表（参见[BCP90]）：

| 头字段名 | 协议 | 状态 | 参考 |
| -------- | ---- | ---- | ---- |
| Connection | http | 标准 | 第6.1节 |
| Content-Length | http | 标准 | 第3.3.2节 |
| Host | http | 标准 | 第5.4节 |
| TE | http | 标准 | 第4.3节 |
| Trailer | http | 标准 | 第4.4节 |
| Transfer-Encoding | http | 标准 | 第3.3.1节 |
| Upgrade | http | 标准 | 第6.7节 |
| Via | http | 标准 | 第5.7.1节 |

此外，“Close”头字段名已注册为“保留”，因为在HTTP头字段中使用该名称可能与Connection头字段的“close”连接选项冲突（第6.1节）。

| 头字段名 | 协议 | 状态 | 参考 |
| -------- | ---- | ---- | ---- |
| Close | http | 保留 | 第8.1节 |

变更控制者为：IETF（iesg@ietf.org）——互联网工程任务组。

---

**8.2. URI方案注册**

IANA在<http://www.iana.org/assignments/uri-schemes/>维护URI方案注册表。

本文件定义了以下URI方案，已相应更新“永久URI方案”注册表：

| URI方案 | 描述 | 参考 |
| -------- | ---- | ---- |
| http | 超文本传输协议 | 第2.7.1节 |
| https | 安全超文本传输协议 | 第2.7.2节 |

---

**8.3. 互联网媒体类型注册**

IANA在<http://www.iana.org/assignments/media-types>维护互联网媒体类型注册表。

本文件定义了“message/http”和“application/http”两种媒体类型，已注册如下：

**8.3.1. 互联网媒体类型 message/http**

该类型可用于封装单个HTTP请求或响应消息，须符合所有“message”类型关于行长和编码的MIME限制。

- 类型名：message
- 子类型名：http
- 必需参数：无
- 可选参数：version, msgtype

  - version：封装消息的HTTP版本号（如“1.1”）。若未提供，可从消息第一行推断。
  - msgtype：消息类型——“request”或“response”。若未提供，可从消息第一行推断。

- 编码考虑：仅允许“7bit”、“8bit”或“binary”。

**8.3.2. 互联网媒体类型 application/http**

该类型可封装一串（一个或多个）HTTP请求或响应消息（不混合）。

- 类型名：application
- 子类型名：http
- 必需参数：无
- 可选参数：version, msgtype

  - version：封装消息的HTTP版本号（如“1.1”）。若未提供，可从消息第一行推断。
  - msgtype：消息类型——“request”或“response”。若未提供，可从消息第一行推断。

- 编码考虑：由此类型封装的HTTP消息为“二进制”格式，传输时需使用适当的Content-Transfer-Encoding。

---

**8.4. 传输编码注册表**

“HTTP传输编码注册表”定义了传输编码名称的命名空间，维护在<http://www.iana.org/assignments/http-parameters>。

**8.4.1. 注册流程**

注册必须包括以下字段：

- 名称
- 描述
- 规范文本指针

传输编码的名称不得与内容编码（第3.1.2.1节）重名，除非编码转换完全相同（如第4.2节定义的压缩编码）。新增到此命名空间的值需经过IETF审查（见[RFC5226]第4.1节），并符合本规范定义的传输编码目的。

不建议使用程序名作为编码格式的标识，未来编码也应避免。

**8.4.2. 注册**

以下为已注册的传输编码：

| 名称 | 描述 | 参考 |
| ---- | ---- | ---- |
| chunked | 分块传输 | 第4.1节 |
| compress | UNIX“compress”数据格式 [Welch] | 第4.2.1节 |
| deflate | “deflate”压缩数据 | 第4.2.2节 |
| | （RFC1951）在“zlib”数据格式（RFC1950）内 | |
| gzip | GZIP文件格式 [RFC1952] | 第4.2.3节 |
| x-compress | 已废弃（别名为compress） | 第4.2.1节 |
| x-gzip | 已废弃（别名为gzip） | 第4.2.3节 |

---

**8.5. 内容编码注册**

IANA在<http://www.iana.org/assignments/http-parameters>维护“HTTP内容编码注册表”。

已注册的内容编码包括：

| 名称 | 描述 | 参考 |
| ---- | ---- | ---- |
| compress | UNIX“compress”数据格式 [Welch] | 第4.2.1节 |
| deflate | “deflate”压缩数据 | 第4.2.2节 |
| | （RFC1951）在“zlib”数据格式（RFC1950）内 | |
| gzip | GZIP文件格式 [RFC1952] | 第4.2.3节 |
| x-compress | 已废弃（别名为compress） | 第4.2.1节 |
| x-gzip | 已废弃（别名为gzip） | 第4.2.3节 |

---

**8.6. Upgrade Token注册表**

“超文本传输协议（HTTP）Upgrade Token注册表”定义了用于在Upgrade头字段中识别协议的protocol-name tokens的命名空间，维护在<http://www.iana.org/assignments/http-upgrade-tokens>。

**8.6.1. 注册流程**

每个已注册的协议名称都与联系信息相关联，并可选地附带一组详细说明连接升级后处理方式的规范。

注册遵循“先到先得”的原则（参见[RFC5226]第4.1节），并须遵守以下规则：

1. 一旦注册，协议名称标记（protocol-name token）将永久保持注册状态。

2. 注册必须指定负责该注册的责任方。

3. 注册必须提供一个联系方式。

4. 注册可以指定与该标记相关联的一组规范。这些规范不必公开。

5. 注册应在注册时列出一组预期的“协议版本”标记（protocol-version tokens）。

责任方可以随时更改注册信息。IANA将记录所有此类变更，并在请求时提供。

IESG（互联网工程任务组）也可能重新分配协议标记的责任。这通常仅在责任方无法联系的情况下使用。

本HTTP升级标记的注册程序取代了之前在[RFC2817]第7.2节中定义的内容。

8.6.2 升级标记注册

在升级标记注册表中，“HTTP”条目已更新，注册信息如下：

+-------+----------------------+----------------------+-------------+
| 值    | 描述                 | 预期版本标记       | 参考文献    |
|       |                      | (例如，“2.0”)       |             |
+-------+----------------------+----------------------+-------------+
| HTTP  | 超文本传输协议         | 任何数字.数字       | 第2.6节     |
|       | (Hypertext Transfer    | (e.g., “2.0”)       |             |
|       | Protocol)             |                      |             |
+-------+----------------------+----------------------+-------------+

责任方为：“IETF（iesg@ietf.org）——互联网工程任务组”。

9. 安全注意事项

本节旨在向开发者、信息提供者和用户介绍与HTTP消息语法、解析和路由相关的已知安全考虑。关于HTTP语义和负载的安全性问题，已在[RFC7231]中予以说明。

9.1 建立权威性

HTTP依赖“权威响应”的概念：由目标URI中标识的权威机构（或其指示）确定的响应，认为是针对请求在响应生成时目标资源状态下最合适的响应。从非权威源（如共享缓存）提供响应，虽有助于提升性能和可用性，但前提是该源可信或可以安全使用其响应。

然而，建立权威性可能很困难。例如，钓鱼攻击就是对用户对权威感知的攻击，可能通过在超文本中展示类似品牌的内容，甚至借助userinfo隐藏权威部分（参见第2.7.1节）来误导用户。用户代理可以通过让用户方便地检查目标URI、显著区分（或拒绝）userinfo，以及在引用文档来自不可信源时不发送存储的凭据和Cookies，来降低钓鱼攻击的影响。

当在authority部分使用注册名时，"http" URI方案（第2.7.1节）依赖用户的本地名称解析服务来查找权威响应。这意味着对用户网络主机表、缓存的名称或名称解析库的攻击，都可能成为建立权威性的攻击途径。同样，用户选择的DNS服务器及其层级也会影响地址映射的真实性；DNS安全扩展（DNSSEC，[RFC4033]）是提升真实性的一种方式。

此外，获得IP地址后，建立"HTTP" URI的权威性还可能受到互联网协议路由攻击的影响。

"HTTPS"方案（第2.7.2节）旨在防止（或至少揭示）许多建立权威性的潜在攻击，前提是协商的TLS连接安全，且客户端正确验证服务器身份与目标URI的权威部分匹配（参见[RFC2818]）。正确实现此验证可能较为困难（参见[Georgiev]）。

9.2 中间人风险

由于HTTP中间人本质上是“人中人”，因此存在中间人攻击的可能性。中间人系统的被攻破可能导致严重的安全和隐私问题。中间人可能访问安全相关信息、个人信息、用户和内容提供者的专有信息。被攻破或未考虑安全和隐私的中间人，可能被用于多种潜在攻击。

特别是含有共享缓存的中间人，更易受到缓存投毒攻击（详见[RFC7234]第8节）。

开发者应考虑其设计和编码决策以及配置选项的隐私和安全影响（尤其是默认配置）。用户应意识到，中间人可信度不高，HTTP本身无法解决此问题。

9.3 协议元素长度攻击

由于HTTP主要使用文本字符分隔字段，解析器容易受到通过发送超长（或极慢）数据流的攻击，尤其是在实现期望无预定义长度的协议元素时。

为促进互操作性，建议对请求行（第3.1.1节）和头字段（第3.2节）设定最小尺寸限制。这些建议是最低限度，旨在由资源有限的实现支持；大多数实现可能会选择更高的限制。

服务器可以拒绝请求目标过长（第6.5.12节[RFC7231]）或请求负载过大的（第6.5.11节[RFC7231]）的消息。扩展定义了与容量限制相关的状态码（如[RFC6585]）。

接收方应谨慎限制对其他协议元素的处理，包括请求方法、响应状态短语、头字段名、数值和正文块。未限制可能导致缓冲区溢出、算术溢出或拒绝服务攻击的风险。

9.4 响应拆分

响应拆分（又称CRLF注入）是一种常见技术，利用HTTP消息帧的行结构和持久连接中请求与响应的有序对应关系（参见[Klein]）。当请求经过共享缓存时，此技术尤为危险。

攻击者通过在请求参数中编码数据，利用服务器（通常是应用服务器）中的漏洞，将编码数据解码后在响应头中回显。如果解码后数据被设计成表示响应已结束，且后续响应已开始，响应就会被拆分，攻击者可控制第二个响应的内容。攻击者还可以在同一持久连接上发起其他请求，误导中间人或接收方相信第二个响应是对第二请求的权威答案。

例如，应用服务器可能在请求目标中读取参数，并在重定向（Location头）中重复使用该参数。如果参数被解码后未正确编码，攻击者可以插入编码的CRLF和其他内容，使单一响应看似变成多个响应。

防御措施之一是过滤请求中类似编码的CR和LF（如“%0D”和“%0A”）。但这假设应用服务器仅进行URI解码，而未进行更复杂的数据变换（如字符集转码、XML实体转义、Base64解码、sprintf重格式化等）。更有效的措施是限制只有服务器核心协议库能在头部中发送CR或LF，避免应用直接写入协议流。

9.5 请求走私

请求走私（[Linhart]）是一种利用不同接收方协议解析差异，将潜在被阻止或禁用的请求隐藏在看似无害请求中的技术。类似响应拆分，请求走私也可能引发多种HTTP攻击。

本规范在第3.3.3节引入了关于请求消息框架的新要求，以减少请求走私的影响。

9.6 消息完整性

HTTP未定义专门的消息完整性机制，而是依赖底层传输协议的错误检测能力，以及长度或块状帧的检测机制。可以通过扩展在消息中加入哈希或数字签名等额外完整性验证机制。

由于HTTP通信的非正式性质，缺乏单一的完整性机制，但随着HTTP作为信息访问手段的普及，其在需要验证消息完整性的环境中的使用日益增加。

建议用户代理实现可配置的检测和报告机制，以在需要时启用。例如，用于查看医疗记录或药物交互信息的浏览器，应在协议检测到信息不完整、过期或传输中损坏时通知用户。此类机制可通过用户代理扩展或响应中的完整性元数据启用。至少，用户代理应提供某种指示，让用户在需要验证时区分完整与不完整的响应（第3.4节）。

9.7  消息机密性

HTTP依赖底层传输协议提供消息机密性（如TLS）。HTTP设计为与传输协议无关，可在多种加密连接上使用，选择由URI方案或用户代理配置决定。

"HTTPS"方案（第2.7.2节）用于标识需要机密连接的资源，确保通信安全。

9.8  服务器日志信息的隐私

服务器可以存储用户请求的个人数据，可能揭示用户的阅读偏好或兴趣主题。中间人收集的日志信息常包含用户代理的交互历史，跨多个站点，可能追溯到个人用户。

HTTP日志信息具有保密性，其处理受到法律法规限制。应安全存储日志，并遵循相关指南进行分析。对个人信息进行匿名化有助于保护隐私，但不足以防止通过关联其他访问特征重新识别真实身份。因此，关联特定客户端的访问痕迹即使使用伪匿名键，也不宜公开。

为降低被盗或意外泄露的风险，应在不再需要支持安全、审计或反欺诈操作时，及时清除日志中的个人身份信息，包括用户ID、IP地址和用户查询参数。

本版本的HTTP/1.1建立在RFC 1945、RFC 2068、RFC 2145和RFC 2616的众多贡献基础之上，包括前任作者、编辑和工作组主席所做的重大贡献：蒂姆·伯纳斯-李（Tim Berners-Lee）、阿里·卢奥特宁（Ari Luotonen）、罗伊·T·菲尔丁（Roy T. Fielding）、亨里克·弗里斯蒂克·尼尔森（Henrik Frystyk Nielsen）、吉姆·盖蒂斯（Jim Gettys）、杰弗里·C·莫古尔（Jeffrey C. Mogul）、拉里·马辛特（Larry Masinter）和保罗·J·利奇（Paul J. Leach）。马克·诺丁汉（Mark Nottingham）担任工作组主席，负责监督此次工作。

自1999年以来，以下贡献者通过报告错误、提出聪明的问题、起草或审查文本以及评估未解决的问题，帮助改进了HTTP规范：

亚当·巴斯（Adam Barth）、亚当·罗奇（Adam Roach）、艾迪生·菲利普斯（Addison Phillips）、阿德里安·查德（Adrian Chadd）、阿德里安·科尔（Adrian Cole）、阿德里安·W·德克罗伊（Adrien W. de Croy）、艾伦·福特（Alan Ford）、艾伦·鲁滕贝格（Alan Ruttenberg）、艾伯特·伦德（Albert Lunde）、阿列克·斯托姆（Alek Storm）、亚历克斯·鲁斯科夫（Alex Rousskov）、亚历山大·莫尔高（Alexandre Morgaut）、阿列克谢·梅尔尼科夫（Alexey Melnikov）、艾莉莎·史密斯（Alisha Smith）、阿米海·罗斯曼（Amichai Rothman）、阿米特·克莱因（Amit Klein）、阿莫斯·杰弗里斯（Amos Jeffries）、安德烈亚斯·迈尔（Andreas Maier）、安德烈亚斯·彼得森（Andreas Petersson）、安德烈·波波夫（Andrei Popov）、阿尼尔·沙尔马（Anil Sharma）、安妮·范·凯斯特伦（Anne van Kesteren）、安东尼·布莱恩（Anthony Bryan）、阿斯比约恩·乌尔斯贝格（Asbjorn Ulsberg）、阿肖克·库马尔（Ashok Kumar）、巴拉钱德拉·克里希纳穆尔蒂（Balachander Krishnamurthy）、巴里·莱巴（Barry Leiba）、本·劳瑞（Ben Laurie）、本杰明·卡莱尔（Benjamin Carlyle）、本杰明·尼文-詹金斯（Benjamin Niven-Jenkins）、贝努瓦·克莱斯（Benoit Claise）、比尔·科里（Bil Corry）、比尔·伯克（Bill Burke）、比约恩·霍尔曼（Bjoern Hoehrmann）、鲍勃·谢弗勒（Bob Scheifler）、鲍里斯·兹巴尔斯基（Boris Zbarsky）、布雷特·斯拉特金（Brett Slatkin）、布莱恩·凯尔（Brian Kell）、布莱恩·麦克巴伦（Brian McBarron）、布莱恩·佩恩（Brian Pane）、布莱恩·雷莫尔（Brian Raymor）、布莱恩·史密斯（Brian Smith）、布鲁斯·佩伦斯（Bruce Perens）、布莱斯·内斯比特（Bryce Nesbitt）、卡梅隆·希文-琼斯（Cameron Heavon-Jones）、卡尔·库格勒（Carl Kugler）、卡斯滕·博尔马恩（Carsten Bormann）、查尔斯·弗莱（Charles Fry）、克里斯·伯迪斯（Chris Burdess）、克里斯·纽曼（Chris Newman）、克里斯蒂安·惠特玛（Christian Huitema）、赛勒斯·达布（Cyrus Daboo）、戴尔·罗伯特·安德森（Dale Robert Anderson）、丹·温（Dan Wing）、丹·温希普（Dan Winship）、丹尼尔·斯特恩贝格（Daniel Stenberg）、达雷尔·米勒（Darrel Miller）、戴夫·克里德兰（Dave Cridland）、戴夫·克罗克（Dave Crocker）、戴夫·克里斯托尔（Dave Kristol）、戴夫·泰勒（Dave Thaler）、戴维·布斯（David Booth）、戴维·辛格（David Singer）、戴维·W·莫里斯（David W. Morris）、迪瓦卡尔·谢蒂（Diwakar Shetty）、德米特里·库罗奇金（Dmitry Kurochkin）、德拉蒙德·里德（Drummond Reed）、杜安·韦塞尔斯（Duane Wessels）、爱德华·李（Edward Lee）、伊坦·阿德勒（Eitan Adler）、埃利奥特·利尔（Eliot Lear）、埃米尔·斯特凡（Emile Stephan）、埃兰·哈默-拉哈夫（Eran Hammer-Lahav）、埃里克·D·威廉姆斯（Eric D. Williams）、埃里克·J·鲍曼（Eric J. Bowman）、埃里克·劳伦斯（Eric Lawrence）、埃里克·雷斯科拉（Eric Rescorla）、埃里克·阿诺斯蒂（Erik Aronesty）、尹俊义（EungJun Yi）、埃文·普罗德罗穆（Evan Prodromou）、费利克斯·盖森多尔弗（Felix Geisendoerfer）、弗洛里安·韦默（Florian Weimer）、弗兰克·埃勒曼（Frank Ellermann）、弗雷德·阿卡林（Fred Akalin）、弗雷德·博勒（Fred Bohle）、弗雷德里克·凯瑟（Frederic Kayser）、加博尔·莫尔纳尔（Gabor Molnar）、加布里埃尔·蒙特内格罗（Gabriel Montenegro）、杰弗里·斯内登（Geoffrey Sneddon）、格瓦斯·马克汉（Gervase Markham）、吉利·扎巴里（Gili Tzabari）、格雷厄姆·格里夫（Grahame Grieve）、格雷格·斯莱帕克（Greg Slepak）、格雷格·威尔金斯（Greg Wilkins）、格热戈日·卡尔科夫斯基（Grzegorz Calkowski）、哈拉尔德·特维特·阿尔维斯特兰（Harald Tveit Alvestrand）、哈里·哈尔平（Harry Halpin）、赫尔格·赫斯（Helge Hess）、亨里克·诺德斯特伦（Henrik Nordstrom）、亨利·S·汤普森（Henry S. Thompson）、亨利·斯托里（Henry Story）、赫伯特·范德索梅尔（Herbert van de Sompel）、赫尔维·鲁埃兰（Herve Ruellan）、霍华德·梅尔曼（Howard Melman）、雨果·哈斯（Hugo Haas）、伊恩·费特（Ian Fette）、伊恩·希克森（Ian Hickson）、伊多·萨弗蒂（Ido Safruti）、伊拉里·柳瓦拉（Ilari Liusvaara）、伊利亚·格里戈里克（Ilya Grigorik）、英戈·斯特鲁克（Ingo Struck）、J·罗斯·尼科尔（J. Ross Nicoll）、詹姆斯·克洛斯（James Cloos）、詹姆斯·H·曼格（James H. Manger）、詹姆斯·莱西（James Lacey）、詹姆斯·斯内尔（James M. Snell）、杰米·洛基尔（Jamie Lokier）、简·阿尔格米森（Jan Algermissen）、贾里·阿尔科（Jari Arkko）、杰夫·霍奇斯（Jeff Hodges）（提出“有效请求URI”一词）、杰夫·平纳（Jeff Pinner）、杰夫·沃尔登（Jeff Walden）、吉姆·卢瑟（Jim Luther）、吉图·帕迪耶（Jitu Padhye）、乔·D·威廉姆斯（Joe D. Williams）、乔·格雷戈里奥（Joe Gregorio）、乔·奥尔顿（Joe Orton）、乔尔·贾格利（Joel Jaeggli）、约翰·C·克莱辛（John C. Klensin）、约翰·C·马莱里（John C. Mallery）、约翰·考恩（John Cowan）、约翰·肯普（John Kemp）、约翰·潘泽（John Panzer）、约翰·施耐德（John Schneider）、约翰·斯特拉克（John Stracke）、约翰·沙利文（John Sullivan）、乔纳斯·锡金（Jonas Sicking）、乔纳森·A·里斯（Jonathan A. Rees）、乔纳森·比林顿（Jonathan Billington）、乔纳森·摩尔（Jonathan Moore）、乔纳森·西莱拉（Jonathan Silvera）、乔迪·罗斯（Jordi Ros）、约里斯·多贝尔斯坦（Joris Dobbelsteen）、乔什·科恩（Josh Cohen）、朱利安·皮埃尔（Julien Pierre）、申重锡（Jungshik Shin）、贾斯廷·查普韦斯克（Justin Chapweske）、贾斯廷·埃伦克拉茨（Justin Erenkrantz）、贾斯廷·詹姆斯（Justin James）、卡尔文德·辛格（Kalvinder Singh）、卡尔·杜布斯特（Karl Dubost）、凯瑟琳·莫里亚蒂（Kathleen Moriarty）、基思·霍夫曼（Keith Hoffman）、基思·摩尔（Keith Moore）、肯·默奇森（Ken Murchison）、科恩·霍尔特曼（Koen Holtman）、康斯坦丁·沃龙科夫（Konstantin Voronkov）、克里斯·兹伊普（Kris Zyp）、莱夫·赫德斯特罗姆（Leif Hedstrom）、莱昂内尔·莫兰（Lionel Morand）、丽莎·杜塞罗（Lisa Dusseault）、马切伊·斯塔乔维亚克（Maciej Stachowiak）、马努·斯波尔尼（Manu Sporny）、马克·施奈德（Marc Schneider）、马克·斯莱姆科（Marc Slemko）、马克·贝克（Mark Baker）、马克·保利（Mark Pauley）、马克·沃森（Mark Watson）、马库斯·伊索马基（Markus Isomaki）、马库斯·兰萨勒（Markus Lanthaler）、马丁·J·杜尔斯特（Martin J. Duerst）、马丁·穆萨托夫（Martin Musatov）、马丁·尼尔森（Martin Nilsson）、马丁·汤姆森（Martin Thomson）、马特·林奇（Matt Lynch）、马修·考克斯（Matthew Cox）、马修·克尔温（Matthew Kerwin）、马克斯·克拉克（Max Clark）、梅纳切姆·多奇（Menachem Dodge）、梅拉尔·希拉齐普尔（Meral Shirazipour）、迈克尔·伯罗斯（Michael Burrows）、迈克尔·豪森布拉斯（Michael Hausenblas）、迈克尔·沙夫（Michael Scharf）、迈克尔·斯威特（Michael Sweet）、迈克尔·图克森（Michael Tuexen）、迈克尔·韦兹尔（Michael Welzl）、迈克·阿蒙森（Mike Amundsen）、迈克·贝尔希（Mike Belshe）、迈克·毕晓普（Mike Bishop）、迈克·凯利（Mike Kelly）、迈克·申克尔（Mike Schinkel）、迈尔斯·萨宾（Miles Sabin）、默里·S·库切拉维（Murray S. Kucherawy）、米基塔·叶夫斯蒂菲耶夫（Mykyta Yevstifeyev）、内森·里克瑟姆（Nathan Rixham）、尼古拉斯·尚克斯（Nicholas Shanks）、尼科·威廉姆斯（Nico Williams）、尼古拉斯·阿尔瓦雷斯（Nicolas Alvarez）、尼古拉斯·梅洛（Nicolas Mailhot）、诺亚·斯莱特（Noah Slater）、奥萨马·马扎希尔（Osama Mazahir）、巴布罗·卡斯特罗（Pablo Castro）、帕特·海斯（Pat Hayes）、帕特里克·R·麦克马纳斯（Patrick R. McManus）、保罗·E·琼斯（Paul E. Jones）、保罗·霍夫曼（Paul Hoffman）、保罗·马奎斯（Paul Marquess）、皮特·雷斯尼克（Pete Resnick）、彼得·莱佩斯卡（Peter Lepeska）、彼得·奥西尔（Peter Occil）、彼得·圣-安德烈（Peter Saint-Andre）、彼得·沃金斯（Peter Watkins）、菲尔·阿彻（Phil Archer）、菲尔·亨特（Phil Hunt）、菲利普·穆安-巴克（Philippe Mougin）、菲利普·霍拉姆-贝克（Phillip Hallam-Baker）、皮奥特尔·多布罗戈斯特（Piotr Dobrogost）、保尔·亨宁·坎普（Poul-Henning Kamp）、普瑞蒂·纳塔拉詹（Preethi Natarajan）、拉吉夫·贝克托（Rajeev Bector）、雷·波尔克（Ray Polk）、雷托·巴赫曼-格穆尔（Reto Bachmann-Gmuer）、理查德·巴恩斯（Richard Barnes）、理查德·奇加尼亚克（Richard Cyganiak）、罗比·特雷斯（Rob Trace）、罗比·辛普森（Robby Simpson）、罗伯特·布鲁尔（Robert Brewer）、罗伯特·柯林斯（Robert Collins）、罗伯特·马特森（Robert Mattson）、罗伯特·奥卡拉汉（Robert O'Callahan）、罗伯特·奥洛夫森（Robert Olofsson）、罗伯特·赛尔（Robert Sayre）、罗伯特·西默（Robert Siemer）、罗伯特·德·威尔德（Robert de Wilde）、罗伯托·哈维尔·戈多伊（Roberto Javier Godoy）、罗伯托·皮昂（Roberto Peon）、罗兰·津克（Roland Zink）、罗尼·维贾贾（Ronny Widjaja）、瑞安·汉密尔顿（Ryan Hamilton）、S·迈克·迪尔肯（S. Mike Dierken）、萨尔瓦多·洛雷托（Salvatore Loreto）、山姆·约翰斯顿（Sam Johnston）、山姆·普拉拉（Sam Pullara）、山姆·鲁比（Sam Ruby）、索拉布·库尔卡尔尼（Saurabh Kulkarni）、斯科特·劳伦斯（Scott Lawrence，维护原始问题列表）、肖恩·B·帕尔默（Sean B. Palmer）、肖恩·特纳（Sean Turner）、塞巴斯蒂安·巴尔努（Sebastien Barnoud）、肖恩·麦卡伦（Shane McCarron）、大筒·大辅（Shigeki Ohtsu）、西蒙·雅尔德（Simon Yarde）、斯特凡·艾辛（Stefan Eissing）、斯特凡·蒂尔科夫（Stefan Tilkov）、斯特凡诺斯·哈哈拉基斯（Stefanos Harhalakis）、斯蒂芬·博尔茨米耶（Stephane Bortzmeyer）、斯蒂芬·法雷尔（Stephen Farrell）、斯蒂芬·肯特（Stephen Kent）、斯蒂芬·卢丁（Stephen Ludin）、斯图尔特·威廉姆斯（Stuart Williams）、苏布·阿拉马拉朱（Subbu Allamaraju）、苏布拉马尼安·穆纳萨米（Subramanian Moonesamy）、苏珊·哈雷斯（Susan Hares）、西尔万·赫莱古尔（Sylvain Hellegouarch）、塔潘·迪维卡尔（Tapan Divekar）、辻垣达壹（Tatsuhiro Tsujikawa）、林林·林（Tatsuya Hayashi）、特德·哈迪（Ted Hardie）、特德·莱蒙（Ted Lemon）、托马斯·布罗耶（Thomas Broyer）、托马斯·福斯塔蒂（Thomas Fossati）、托马斯·马斯伦（Thomas Maslen）、托马斯·纳德奥（Thomas Nadeau）、托马斯·诺丁（Thomas Nordin）、托马斯·罗斯勒（Thomas Roessler）、蒂姆·布雷（Tim Bray）、蒂姆·摩根（Tim Morgan）、蒂姆·奥尔森（Tim Olsen）、汤姆·周（Tom Zhou）、特拉维斯·斯努兹（Travis Snoozy）、泰勒·克洛斯（Tyler Close）、文森特·墨菲（Vincent Murphy）、朱伟波（Wenbo Zhu）、沃尔纳·鲍曼（Werner Baumann）、威尔伯德·斯特里特（Wilbur Streett）、威尔弗雷多·桑切斯·维加（Wilfredo Sanchez Vega）、威廉·A·罗威（William A. Rowe Jr.）、威廉·陈（William Chan）、威利·塔若（Willy Tarreau）、王晓书（Xiaoshu Wang）、亚隆·戈兰（Yaron Goland）、英格维·尼萨特·彼得森（Yngve Nysaeter Pettersen）、约阿夫·尼尔（Yoav Nir）、瑜格什·班（Yogesh Bang）、程宇充（Yuchung Cheng）、大岩裕（Yutaka Oiwa）、伊夫·拉丰（Yves Lafon，长期担任编辑团队成员）、泽德·A·肖（Zed A. Shaw）、钟瑜（Zhong Yu）。

关于之前版本的补充说明，详见[RFC2616]第16节。

---

附录A. HTTP版本历史

HTTP自1990年以来一直在使用。第一个版本，后来称为HTTP/0.9，是一种用于互联网超文本数据传输的简单协议，仅支持一种请求方法（GET）且没有元数据。HTTP/1.0（定义于[RFC1945]）增加了多种请求方法和类似MIME的消息格式，允许传输元数据并对请求/响应语义进行修饰。然而，HTTP/1.0没有充分考虑层级代理、缓存、持久连接或基于名称的虚拟主机的影响。大量自称为“HTTP/1.0”的应用程序未完整实现，促使协议版本的变更，以便通信的两个应用程序能够正确识别彼此的真实能力。

HTTP/1.1通过引入更严格的要求，确保实现的可靠性，并只添加那些对HTTP/1.0接收者可以安全忽略或仅在与符合HTTP/1.1的对方通信时才会发送的功能，从而保持与HTTP/1.0的兼容性。

HTTP/1.1设计时考虑到支持旧版本的便利。一个通用的HTTP/1.1服务器应能理解任何符合HTTP/1.0格式的有效请求，并以只包含被HTTP/1.0客户端理解（或可以安全忽略）功能的HTTP/1.1消息作出适当响应。同样，HTTP/1.1客户端也应能理解任何有效的HTTP/1.0响应。

由于HTTP/0.9不支持请求头字段，因此没有机制支持基于名称的虚拟主机（通过检查Host头字段选择资源）。任何实现基于名称虚拟主机的服务器都应禁用对HTTP/0.9的支持。大多数看似HTTP/0.9的请求实际上是客户端未正确编码请求目标而导致的格式错误的HTTP/1.x请求。

A.1. HTTP/1.0的主要变更

本节总结了HTTP/1.0与HTTP/1.1之间的主要差异。

A.1.1. 多宿主Web服务器

支持Host头字段（第5.4节）、在HTTP/1.1请求中缺少时报告错误，以及接受绝对URI（第5.3节）是HTTP/1.1定义的最重要的变更之一。

以下是对上述英文内容的中文流畅翻译：

---

早期的HTTP/1.0客户端假设IP地址与服务器之间存在一对一的关系；除了请求所指向的IP地址之外，没有其他已建立的机制来区分请求的目标服务器。在HTTP/1.1的发展过程中，引入了Host头字段，尽管大多数HTTP/1.0浏览器很快实现了它，但为了确保全面采用，所有HTTP/1.1请求都被要求支持该字段。在撰写本文时，大多数基于HTTP的服务都依赖于Host头字段来定位请求目标。

A.1.2 保持连接（Keep-Alive）

在HTTP/1.0中，每个连接在请求前由客户端建立，响应后由服务器关闭。然而，一些实现支持在第19.7.1节[RFC2068]中描述的显式协商的“保持连接”版本的持久连接。

一些客户端和服务器可能希望兼容这些早期的持久连接方式，通过在请求头中明确协商“Connection: keep-alive”来实现。然而，一些HTTP/1.0的实验性实现存在缺陷，例如，如果HTTP/1.0代理服务器不理解Connection头字段，它会错误地将该头字段转发到下一个入站服务器，导致连接挂起。

一种尝试的解决方案是引入专门针对代理的Proxy-Connection头字段，但实际上也不可行，因为代理通常部署在多层结构中，带来了相同的问题。

因此，建议客户端不要在任何请求中发送Proxy-Connection头字段。

同时，建议客户端在请求中谨慎使用Connection: keep-alive；虽然它可以与HTTP/1.0服务器启用持久连接，但使用时需要监控连接是否出现“挂起”请求（即客户端应停止发送头字段），在使用代理时则不应使用此机制。

A.1.3 传输编码的引入

HTTP/1.1引入了Transfer-Encoding头字段（第3.3.1节）。在将HTTP消息转发到符合MIME标准的协议之前，必须对传输编码进行解码。

A.2 与RFC 2616的变更

- 已说明HTTP的错误处理方式（第2.5节）。
- HTTP版本的ABNF定义已明确区分大小写。此外，由于实现中多位数版本号处理不正确，版本号被限制为单个数字（第2.6节）。
- 出于安全考虑，用户信息（用户名和密码）现已禁止在HTTP和HTTPS URI中使用（第2.7.1节）。
- HTTPS URI方案由本规范定义，之前在[RFC2818]第2.4节中定义。此外，它还暗示端到端的安全性（第2.7.2节）。
- HTTP消息可以被实现缓冲，尽管有时可以作为流处理，但本质上HTTP是面向消息的协议。为提高互操作性，建议支持各种协议元素的最小尺寸（第3节）。
- 现在必须拒绝字段名周围的无效空白字符，因为接受它们存在安全漏洞。定义头字段的ABNF生产式现在只列出字段值（第3.2节）。
- 移除某些语法规则中隐式线性空白的规则；空白字符仅在ABNF中明确规定的地方允许（第3.2.3节）。
- 跨多行的头字段（“行折叠”）已被废弃（第3.2.4节）。
- NUL字节不再允许出现在注释和引号字符串中，且对反斜杠转义的处理已明确。引号对中的转义规则不再允许除HTAB之外的控制字符。头字段和原因短语中的非ASCII内容已被废弃并变为不透明（TEXT规则已删除）（第3.2.6节）。
- 无效的Content-Length头字段现在必须被接收端视为错误（第3.3.2节）。
- 现已明确所有影响消息体长度的特殊情况（如由方法或状态码驱动），并指出新协议元素不能定义此类特殊情况。CONNECT是确定消息体长度的一个新特殊情况。“multipart/byteranges”不再用作消息体长度的检测方式（第3.3.3节）。
- “identity”传输编码已被移除（第3.3和第4节）。
- 分块长度不包括块头和尾部的字节数。块扩展中的行折叠被禁止（第4.1节）。
- “deflate”内容编码的含义已被澄清（第4.2.2节）。
- RFC 3986中的段和查询部分被用来定义请求目标，而非RFC 1808中的绝对路径。仅在OPTIONS方法中允许使用星号形式的请求目标（第5.3节）。
- 引入“有效请求URI”一术语（第5.5节）。
- 网关不再需要生成Via头字段（第5.7.1节）。
- 明确了何时必须发送“close”连接选项。同时，“hop-by-hop”头字段必须出现在Connection头字段中；尽管在本规范中定义为hop-by-hop，但这并不免除其义务（第6.1节）。
- 移除了每个服务器最多两个连接的限制。不再要求幂等请求序列必须重试。也取消了在服务器提前关闭连接时必须重试请求的要求。此外，关于服务器何时可以提前关闭连接的额外要求也已删除（第6.3节）。
- 在响应中（除101状态码外）对Upgrade头字段的语义进行了定义（此内容借鉴自[RFC2817]）。此外，字段值中的顺序现在具有重要意义（第6.7节）。
- 列表生产式中的空元素（如包含“, ,”的列表头字段）已被废弃（第7节）。
- 转移编码的注册现在需要经过IETF审查（第8.4节）。
- 本规范定义了Upgrade Token注册表，此前在[RFC2817]第7.2节中定义（第8.6节）。
- 不再支持HTTP/0.9请求（附录A）。
- 指出请求中Keep-Alive和Proxy-Connection头字段的问题，并强烈建议不要使用后者（附录A.1.2）。

附录B 收集的ABNF定义

（此处为ABNF语法定义的部分内容，详细定义了各种协议元素的语法规则。）

---

如需更详细的逐句翻译或特定部分的解释，请告诉我！

收到的协议 47  
请求行 21  
请求目标 41  
RWS 25  
方案 16  
段 16  
SP 6  
起始行 21  
状态码 22  
状态行 22  
t-codings 39  
t-ranking 39  
tchar 27  
TE 39  
令牌 27  
Trailer 40  
trailer-part 37  
传输编码 35  
Transfer-Encoding 28  
传输扩展 35  
传输参数 35  
Upgrade 57  
uri-host 16  
URI引用 16  
VCHAR 6  
Via 47  
gzip（编码格式） 39  

H  
头字段 19  
头部区域 19  
头部 19  
Host头字段 44  
http URI方案 17  
https URI方案 17  

I  
入站 9  
拦截代理 11  
中介 9  

M  
媒体类型  
  application/http 63  
  message/http 62  
消息 7  
message/http媒体类型 62  
方法 21  

Fielding & Reschke           标准追踪                   [第87页]  

RFC 7230           HTTP/1.1消息语法与路由         2014年6月  

N  
非转换代理 49  

O  
源服务器 7  
源形式（请求目标） 42  
出站 10  

P  
钓鱼 67  
代理 10  

R  
接收者 7  
请求 7  
请求目标 21  
资源 16  
响应 7  
反向代理 10  

S  
发送者 7  
服务器 7  
爬虫 7  

T  
目标资源 40  
目标URI 40  
TE头字段 39  
Trailer头字段 40  
Transfer-Encoding头字段 28  
变换代理 49  
透明代理 11  
隧道 10  

U  
Upgrade头字段 57  
上游 9  
URI方案  
  http 17  
  https 17  
用户代理 7  

V  
Via头字段 47  

Fielding & Reschke           标准追踪                   [第88页]  

RFC 7230           HTTP/1.1消息语法与路由         2014年6月  

作者联系方式  

Roy T. Fielding（编辑）  
Adobe Systems Incorporated  
345 Park Ave  
San Jose, CA 95110  
美国  

电子邮件：fielding@gbiv.com  
网址：http://roy.gbiv.com/  

Julian F. Reschke（编辑）  
greenbytes GmbH  
Hafenweg 16  
明斯特，NW 48155  
德国  

电子邮件：julian.reschke@greenbytes.de  
网址：http://greenbytes.de/tech/webdav/  

Fielding & Reschke           标准追踪                   [第89页]