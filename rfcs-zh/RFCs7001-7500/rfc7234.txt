# RFC 7234 中文翻译 (stub)
# 原文文件: ../../rfcs/RFCs7001-7500/rfc7234.txt

互联网工程任务组（IETF）                  R. Fielding，主编
意见征求稿：7234                                              Adobe
废止：2616                                              M. Nottingham，主编
类别：标准轨道                                              Akamai
ISSN：2070-1721                                              J. Reschke，主编
                                                               greenbytes
                                                               2014年6月


            超文本传输协议（HTTP/1.1）：缓存

摘要

   超文本传输协议（HTTP）是一种无状态的应用层协议，用于分布式、协作式的超文本信息系统。本文件定义了HTTP缓存及相关的头字段，这些字段控制缓存行为或指示响应消息是否可缓存。

本备忘录的状态

   这是一个互联网标准轨道的文档。

   本文件由互联网工程任务组（IETF）制定，代表了IETF社区的共识。它已经过公开审查，并获得互联网工程指导组（IESG）批准发布。关于互联网标准的更多信息，请参见RFC 5741的第2节。

   有关本文件当前状态、任何勘误以及如何提供反馈的信息，可以在 http://www.rfc-editor.org/info/rfc7234 获取。



















Fielding 等人             标准轨道                     [第1页]


RFC 7234                    HTTP/1.1 缓存                   2014年6月


版权声明

   版权所有（c）2014 IETF信托及本文档作者。保留所有权利。

   本文件受BCP 78和IETF信托关于IETF文档的法律规定（http://trustee.ietf.org/license-info）约束，适用于本文件发布之日。请仔细阅读这些文件，它们描述了您对本文件的权利和限制。从本文件中提取的代码组件必须包含简化BSD许可证文本（详见信托法律规定第4.e节），且提供时不附带任何担保，具体见简化BSD许可证。

   本文件可能包含在2008年11月10日之前发布或公开的IETF文档或贡献的内容。这些内容的版权控制人可能未授予IETF信托允许在IETF标准流程之外修改此类内容的权利。在未获得版权控制人充分授权的情况下，不能在IETF标准流程之外修改本文件，也不能在IETF标准流程之外创建其派生作品，除非是为了将其格式化为RFC发布或翻译成非英语语言。

目录

   1. 引言 ....................................................4
      1.1. 合规性与错误处理 ....................................4
      1.2. 语法符号 ............................................4
           1.2.1. Delta秒 .......................................5
   2. 缓存操作概述 ............................................5
   3. 在缓存中存储响应 ........................................6
      3.1. 存储不完整的响应 ....................................7
      3.2. 存储经过认证请求的响应 ..............................7
      3.3. 合并部分内容 ..........................................8
   4. 从缓存中构建响应 ........................................8
      4.1. 使用Vary计算二级键 ..................................9
      4.2. 新鲜度 ..............................................11
           4.2.1. 计算新鲜度存活时间 ............................12
           4.2.2. 计算启发式新鲜度 ..............................13
           4.2.3. 计算年龄 ......................................13
           4.2.4. 提供陈旧响应 ..................................15
      4.3. 验证 ..................................................16
           4.3.1. 发送验证请求 ..................................16
           4.3.2. 处理收到的验证请求 ............................16
           4.3.3. 处理验证响应 ..................................18
           4.3.4. 在验证后更新存储的响应 ........................18
           4.3.5. 通过HEAD请求更新响应 ..........................19
      4.4. 失效 ..................................................20
   5. 头字段定义 ..............................................21
      5.1. Age ...................................................21
      5.2. Cache-Control .........................................21
           5.2.1. 请求中的Cache-Control指令 ......................22
           5.2.2. 响应中的Cache-Control指令 ......................24
           5.2.3. 缓存控制扩展 ..................................27
      5.3. Expires ...............................................28
      5.4. Pragma ................................................29
      5.5. Warning ...............................................29
           5.5.1. Warning: 110 - “响应陈旧” .......................31
           5.5.2. Warning: 111 - “重新验证失败” ...................31
           5.5.3. Warning: 112 - “断开连接操作” ...................31
           5.5.4. Warning: 113 - “启发式过期” .....................31
           5.5.5. Warning: 199 - “其他警告” .......................32
           5.5.6. Warning: 214 - “已应用转换” .....................32
           5.5.7. Warning: 299 - “其他持续性警告” ..................32
   6. 历史列表 .................................................32
   7. IANA考虑 .................................................32
      7.1. 缓存指令注册表 ......................................32
           7.1.1. 流程 ..........................................32
           7.1.2. 新缓存控制指令的考虑 ..........................33
           7.1.3. 注册 ..........................................33
      7.2. 警告代码注册表 ......................................34
           7.2.1. 流程 ..........................................34
           7.2.2. 注册 ..........................................34
      7.3. 头字段注册 ..........................................34
   8. 安全考虑 .................................................35
   9. 致谢 .....................................................36
   10. 参考文献 ...............................................36
      10.1. 核心参考 ..........................................36
      10.2. 资料性参考 ........................................37
   附录A. 与RFC 2616的变更 ....................................38
   附录B. 导入的ABNF ...........................................39
   附录C. 收集的ABNF ...........................................39
   索引 .........................................................41










Fielding 等人             标准轨道                     [第3页]


RFC 7234                    HTTP/1.1 缓存                   2014年6月


1. 引言

   HTTP通常用于分布式信息系统，通过使用响应缓存可以提升性能。本文件定义了与HTTP/1.1缓存和响应消息重用相关的内容。

   HTTP缓存是存储响应消息的本地存储区，以及控制存储、检索和删除消息的子系统。缓存存储可缓存的响应，以减少未来相同请求的响应时间和网络带宽消耗。任何客户端或服务器都可以使用缓存，尽管作为隧道的服务器不能使用缓存。

   共享缓存是指存储响应以供多个用户重用的缓存；共享缓存通常（但不总是）部署在中间设备中。私有缓存则专用于单一用户，通常作为用户代理的一部分部署。

   HTTP/1.1中缓存的目标是通过重用先前的响应消息显著提升性能，以满足当前请求。若响应被认为是“新鲜的”，如第4.2节所定义，则可以在不进行“验证”的情况下重用（即不向源服务器确认缓存响应是否仍然有效）。新鲜响应每次被重用时都能减少延迟和网络开销。当缓存的响应不新鲜时，仍可能通过验证（第4.3节）或在源不可用时（第4.2.4节）使其变得新鲜，从而实现重用。

1.1. 合规性与错误处理

   本文档中的关键词“必须（MUST）”、“不得（MUST NOT）”、“要求（REQUIRED）”、“应（SHALL）”、“不得（SHALL NOT）”、“建议（SHOULD）”、“不建议（SHOULD NOT）”、“推荐（RECOMMENDED）”、“可以（MAY）”和“可选（OPTIONAL）”的定义遵循[RFC2119]的描述。

   合规性标准和错误处理的考虑在[RFC7230]的第2.5节中定义。

1.2. 语法符号

   本规范采用[RFC5234]定义的增强巴克斯-诺尔范式（ABNF）符号，结合[RFC7230]第7节定义的列表扩展，允许用“#”操作符紧凑定义逗号分隔的列表（类似于“*”操作符表示重复）。附录B描述了从其他文档导入的规则，附录C显示了所有列表操作符展开为标准ABNF的完整语法。

1.2.1. Delta秒

   delta-seconds规则定义为非负整数，表示以秒为单位的时间。

     delta-seconds  = 1*DIGIT

   解析delta-seconds值并转换为二进制形式的接收方应使用至少具有31位非负整数范围的算术类型。如果缓存收到的delta-seconds值大于其能表示的最大整数，或在后续计算中溢出，则该缓存必须将该值视为2147483648（2^31）或其能方便表示的最大正整数。

      注：这里的2147483648是出于历史原因的值，实际上代表无限（超过68年），无需以二进制存储；实现可以在发生溢出时将其作为预定义字符串输出，即使计算使用的算术类型不能直接表示该数字。关键在于检测溢出，避免在后续计算中将其误判为负值。

2. 缓存操作概述

   正确的缓存操作在保持HTTP传输（[RFC7231]）语义的同时，避免传输已在缓存中的信息。虽然缓存是HTTP的可选特性，但可以假设重用缓存响应是期望的，且在没有特殊要求或本地配置阻止的情况下，默认会进行重用。因此，HTTP缓存的要求主要集中在防止缓存存储不可重用的响应或不当重用存储的响应，而不是强制缓存始终存储和重用特定响应。

   每个缓存条目由缓存键和一个或多个对应先前请求的HTTP响应组成。最常见的缓存条目是请求成功的结果：即对GET请求的200（OK）响应，包含请求目标资源的表示（[RFC7231]第4.3.1节）。但也可以缓存永久重定向、负面结果（如404（未找到））、不完整结果（如206（部分内容））以及对其他方法的响应（只要该方法定义允许缓存且定义了合适的缓存键）。

   主要缓存键由请求方法和目标URI组成。然而，由于目前常用的HTTP缓存主要缓存GET响应，许多缓存会直接拒绝其他方法，只用URI作为主要缓存键。

   如果请求目标涉及内容协商，其缓存条目可能由多个存储响应组成，每个响应由原始请求的选择性头字段值（第4.1节）作为二级键加以区分。

3.  在缓存中存储响应

   缓存不得存储任何请求的响应，除非：

   o  请求方法被缓存理解且定义为可缓存，且

   o  响应状态码被缓存理解，且

   o  请求或响应头字段中未出现“no-store”缓存指令（见第5.2节），且

   o  如果缓存是共享的，响应中未出现“private”响应指令（见第5.2.2.6节），且

   o  请求中未出现Authorization头字段（见[RFC7235]第4.2节），除非响应明确允许（见第3.2节），且

   o  响应满足以下条件之一：

      *  包含Expires头字段（见第5.3节），或

      *  包含max-age响应指令（见第5.2.2.8节），或

      *  包含s-maxage响应指令（见第5.2.2.9节）且缓存为共享，或

      *  包含允许缓存的缓存控制扩展（见第5.2.3节），或

      *  状态码被默认定义为可缓存（见第4.2.2节），或

      *  包含public响应指令（见第5.2.2.5节）。

   注意，上述任何要求都可以被缓存控制扩展覆盖；详见第5.2.3节。

   在此上下文中，缓存“理解”请求方法或响应状态码，意味着它识别并实现所有相关的缓存行为。

   需要注意的是，通常情况下，没有验证器或明确的过期时间的响应，缓存不会存储，因为此类响应通常没有存储价值。但这并不禁止缓存存储此类响应。

3.1. 存储不完整的响应

   当所有由消息框架（[RFC7230]）指示的字节都已接收，且连接未关闭时，响应消息被视为完整。如果请求方法为GET，响应状态码为200（OK），且已接收完整的响应头部，则缓存可以存储不完整的响应消息体（如果缓存条目被标记为不完整）。同样，206（部分内容）响应也可以像不完整的200（OK）缓存条目一样存储。然而，如果缓存不支持Range和Content-Range头字段，或不理解这些字段中的范围单位，则不得存储不完整或部分内容的响应。

缓存可以通过发起后续的范围请求（[RFC7233]）并将成功的响应与存储的条目结合起来（如第3.3节所定义）来完成未完成的存储响应。除非响应已被完整化，或者请求是部分请求且指定的范围完全在未完成的响应范围内，否则缓存不得使用未完成的响应来应答请求。缓存也不得在未明确使用206（部分内容）状态码标记的情况下，将部分响应返回给客户端。

3.2. 存储已认证请求的响应

共享缓存不得使用带有授权头字段（[RFC7235]第4.2节）的请求的缓存响应来满足后续请求，除非响应中包含允许存储此类响应的缓存指令。

在本规范中，以下缓存控制响应指令（第5.2.2节）具有此类效果：must-revalidate（必须重新验证）、public（公共缓存）和s-maxage（共享缓存最大年龄）。

注意，包含“must-revalidate”或“s-maxage”指令的缓存响应不得由共享缓存提供过期（第4.2.4节）。特别是，带有“max-age=0, must-revalidate”或“s-maxage=0”的响应，不能在不重新验证的情况下满足后续请求。

3.3. 组合部分内容

如果连接提前关闭或请求使用了一个或多个范围说明符（[RFC7233]），响应可能只传输了部分表示。经过多次此类传输后，缓存可能已接收了同一表示的多个范围。缓存可以将这些范围合并成一个存储的响应，并在满足以下条件时，用该响应满足后续请求：所有请求都具有相同的强验证器，并且缓存符合[RFC7233]第4.3节中的客户端要求。

在将新响应与一个或多个存储响应合并时，缓存必须：

- 删除存储响应中所有Warn头字段中warn-code为1xx的警告（见第5.5节）；
- 保留存储响应中的warn-code为2xx的Warn头字段；
- 使用新响应中的其他头字段（除Content-Range外）替换存储响应中对应的所有头字段。

4. 从缓存构建响应

当收到请求时，除非满足以下条件，否则缓存不得重用存储的响应：

- 请求的有效URI（第5.5节[RFC7230]）与存储响应的URI匹配；
- 存储响应的请求方法允许其用于当前请求；
- 存储响应中指定的请求头字段（如有）与当前请求的请求头字段匹配（见第4.1节）；
- 当前请求不包含no-cache指令（第5.4节）或no-cache缓存指令（第5.2.1节），除非存储响应已成功验证（第4.3节）；
- 存储响应不包含no-cache缓存指令（第5.2.2.2节），除非已成功验证（第4.3节）；
- 存储响应要么是：
  * 新鲜的（见第4.2节），
  * 允许过期（见第4.2.4节），
  * 已成功验证（见第4.3节）。

注意，上述任何条件都可以被缓存控制扩展覆盖；详见第5.2.3节。

当使用存储响应满足请求而不进行验证时，缓存必须生成Age头字段（第5.1节），用存储响应的current_age值替换响应中任何已有的值；详见第4.2.3节。

缓存还必须对不安全的方法（第4.2.1节[RFC7231]）的请求，将其转发到源服务器，即在转发请求并收到响应之前，不允许缓存生成此类请求的回复。

此外，不安全的请求可能会使已存储的响应失效；详见第4.4节。

当存储了多个合适的响应时，缓存必须使用最新的响应（由Date头字段确定）。也可以通过在请求中加入“Cache-Control: max-age=0”或“Cache-Control: no-cache”来区分使用哪个响应。

没有时钟的缓存不得在每次使用时都不经过验证就使用存储的响应。

4.1 使用Vary计算二级键

当缓存收到一个请求，并且该请求可以由带有Vary头字段（第7.1.4节[RFC7231]）的存储响应满足时，除非请求中所有由Vary头字段指定的请求头字段在原始请求（即与存储响应相关的请求）和当前请求中都匹配，否则不得使用该响应。

两个请求的请求头字段被定义为匹配，只有当第一个请求中的字段可以通过以下任意方式变换成第二个请求中的字段时：

- 添加或删除空白字符（在头字段语法允许的范围内）；
- 合并具有相同字段名的多个头字段（见第3.2节[RFC7230]）；
- 以已知具有相同语义的方式规范化两个头字段的值（例如：在值的顺序不重要时重新排序；大小写不敏感时进行大小写归一化）。

如果（经过任何可能的规范化后）某个头字段在请求中不存在，则只有在该字段在另一请求中也不存在时，两个请求才匹配。

Vary头字段值为“*”的响应始终不匹配。

匹配的请求头字段组成的存储响应称为“选中响应”。

如果存在多个“选中响应”（可能包括没有Vary头字段的响应），缓存需要选择一个使用。当某个请求头字段有已知的选择机制（如Accept的q值或类似机制）时，可以用该机制选择偏好响应；否则，使用最新的响应（由Date头字段确定），如第4节所述。

如果没有任何“选中响应”，缓存无法满足当前请求，通常会将请求转发到源服务器（可能是条件请求，详见第4.3节）。

4.2. 新鲜度

新鲜响应是指其年龄尚未超过其新鲜期的响应。相反，过期响应的年龄已超过其新鲜期。

响应的“新鲜期”是指从源服务器生成到其过期时间的时间长度。显式过期时间是源服务器希望存储响应在未经过验证的情况下不能再使用的时间点，而启发式过期时间是在没有显式过期时间时由缓存赋予的估算值。

响应的“年龄”是指自其由源服务器生成或成功验证以来经过的时间。

当缓存中的响应“新鲜”时，可以在不联系源服务器的情况下满足后续请求，从而提高效率。

判断响应是否新鲜的主要机制是：源服务器提供未来的显式过期时间，使用Expires头字段（第5.3节）或max-age响应指令（第5.2.2.8节）。通常，源服务器会在响应中设置未来的显式过期时间，认为在此时间之前，表示内容不会发生语义上的重大变化。

如果源服务器希望强制缓存每次验证，可以将响应的显式过期时间设置为过去的时间，表示响应已过期。符合规范的缓存通常会在重用过期缓存响应前进行验证（第4.2.4节）。

由于源服务器不总是提供显式过期时间，缓存也可以在特定情况下使用启发式方法估算过期时间（第4.2.2节）。

判断响应是否新鲜的计算公式为：

    response_is_fresh = (freshness_lifetime > current_age)

其中，freshness_lifetime在第4.2.1节定义，current_age在第4.2.3节定义。

客户端可以在请求中加入max-age或min-fresh指令，以限制或放宽对应响应的新鲜度计算（第5.2.1节）。

在计算新鲜度时，为避免日期解析中的常见问题，应注意：

- 虽然所有日期格式都区分大小写，但缓存接收方应不区分大小写地匹配星期、周和时区名称；
- 如果缓存的时间实现分辨率低于HTTP日期值，必须将解析的Expires日期内部表示为不晚于接收值的最近时间；
- 不允许本地时区影响年龄或过期时间的计算或比较；
- 不应将非GMT或UTC的时区缩写视为有效的过期时间计算依据。

注意，新鲜度仅适用于缓存操作，不能用来强制用户代理刷新显示或重新加载资源。关于缓存与历史机制的区别，请参见第6节。

4.2.1 计算新鲜期

缓存可以通过以下第一个匹配的方式计算响应的“新鲜期”（freshness_lifetime）：

- 如果是共享缓存且存在s-maxage响应指令（第5.2.2.9节），使用其值；
- 否则，如果存在max-age响应指令（第5.2.2.8节），使用其值；
- 否则，如果存在Expires响应头字段（第5.3节），用其值减去Date响应头字段的值；
- 否则，响应中没有显式过期时间，可能适用启发式新鲜期；详见第4.2.2节。

请注意，此计算不受时钟偏差影响，因为所有信息都来自源服务器。

当某个指令有多个值（如两个Expires头字段或多个Cache-Control: max-age指令）时，视为无效。建议缓存将具有无效新鲜度信息的响应视为过期。

4.2.2 计算启发式新鲜度

由于源服务器不总是提供显式过期时间，缓存可以在没有明确时间的情况下，采用启发式算法估算过期时间，利用其他头字段（如Last-Modified）估算合理的过期时间。此规范未提供具体算法，但对其结果设有限制。

当存储响应中存在显式过期时间时，缓存不得使用启发式方法。根据第3节的要求，实际上启发式只能用于没有显式新鲜度信息且状态码默认可缓存的响应（见第6.1节[RFC7231]），以及那些被明确标记为可缓存的响应（如带“public”指令）。

如果响应中有Last-Modified头字段（第2.2节[RFC7232]），建议使用不超过该时间间隔某一比例的启发式过期值，通常为10%。

使用启发式计算新鲜期时，如果当前年龄超过24小时，且未出现相关警告，缓存应在响应中加入Warning头字段，warn-code为113（第5.5.4节）。

注意，[RFC2616]第13.9节禁止缓存对带有查询组件（即包含“?”）的URI进行启发式新鲜度计算。实际上，这一限制未被广泛实现。因此，源服务器鼓励在需要时发出明确指令（如Cache-Control: no-cache）以防止缓存。

4.2.3.  计算年龄

   Age 头字段用于在从缓存中获取响应消息时传达估算的响应年龄。Age 字段的值是缓存对自响应被生成或由源服务器验证以来经过的秒数的估算值。本质上，Age 值是沿着从源服务器到当前缓存路径上每个缓存中响应驻留时间的总和，加上沿网络路径传输的时间。

   用于年龄计算的以下数据：

   age_value

      “age_value” 一词表示 Age 头字段（第5.1节）中的值，采用适合算术运算的形式；如果不可用，则为0。

   date_value

      “date_value” 一词表示 Date 头字段的值，采用适合算术运算的形式。关于 Date 头字段的定义及无此字段的响应的要求，请参见 [RFC7231]第7.1.1.2节。

   now

      “now” 指“执行计算的主机上当前的时钟值”。主机应使用 NTP（[RFC5905]）或类似协议将其时钟同步到协调世界时（UTC）。

   request_time

      产生存储响应的请求时主机上的当前时钟值。

   response_time

      接收响应时主机上的当前时钟值。

   响应的年龄可以通过两种完全独立的方法计算：

   1.  “表观年龄” (apparent_age)：response_time 减去 date_value，如果本地主机的时钟与源服务器的时钟同步良好。如果结果为负，则将其替换为零。

   2.  “校正年龄值” (corrected_age_value)，前提是路径上的所有缓存都实现了 HTTP/1.1。缓存必须相对于请求发起的时间来解释此值，而非响应接收的时间。

     apparent_age = max(0, response_time - date_value)

     response_delay = response_time - request_time

     corrected_age_value = age_value + response_delay

   这些值合并为：

     corrected_initial_age = max(apparent_age, corrected_age_value)

   除非缓存对 Age 头字段的值非常有信心（例如，因为 Via 头字段中没有 HTTP/1.0 跳点），在这种情况下，可以使用 corrected_age_value 作为 corrected_initial_age。

   然后，可以通过将自上次由源服务器验证存储响应以来经过的时间（秒）加到 corrected_initial_age 上，计算存储响应的当前年龄：

     resident_time = now - response_time

     current_age = corrected_initial_age + resident_time

4.2.4.  提供过期响应

   “过期”响应是指具有明确过期信息或允许通过启发式方法计算过期时间，但根据第4.2节的计算方式不新鲜的响应。

   缓存不得生成过期响应，除非被明确的协议指令禁止（例如，“no-store”或“no-cache”缓存指令，“must-revalidate”缓存响应指令，或适用的“s-maxage”或“proxy-revalidate”缓存响应指令；参见第5.2.2节）。

   除非断开连接（即无法联系源服务器或以其他方式找到转发路径）或明确允许（例如，通过 max-stale 请求指令；参见第5.2.1节），否则缓存不得发送过期响应。

   缓存应在过期响应中生成带有 110 警告码（见第5.5.1节）的 Warning 头字段。同样，如果缓存处于断开状态，也应生成带有 112 警告码（见第5.5.3节）的 Warning 头字段。

   即使响应已过期，缓存也不应在转发没有 Age 头字段的响应时生成新的 Warning 头字段。对于仅在传输途中变得过期的响应，缓存无需验证。

4.3.  验证

   当缓存拥有一个或多个存储的响应用于请求的 URI，但无法提供任何响应（例如，因为它们不新鲜，或无法选择其中一个；参见第4.1节）时，可以在转发请求中使用条件请求机制 [RFC7232]，让下一个入站服务器有机会选择一个有效的存储响应以使用，或用新响应替换存储的响应。这一过程称为“验证”或“重新验证”存储的响应。

4.3.1.  发送验证请求

   当发送用于缓存验证的条件请求时，缓存会在请求中加入一个或多个包含其存储响应的验证元数据的预条件头字段，接收方会将其与当前资源的表示进行比较，以判断存储的响应是否等同于资源的当前表示。

   其中一种验证器是 Last-Modified 头字段（[RFC7232]第2.2节）中的时间戳，可用于在 If-Modified-Since 头字段中进行响应验证，或在 If-Unmodified-Since 或 If-Range 头字段中用于表示选择（即，客户端特别指向之前获得的带有该时间戳的表示）。

   另一种验证器是 ETag 头字段（[RFC7232]第2.3节）中的实体标签（entity-tag）。可以在 If-None-Match 头字段中使用一个或多个实体标签，以验证响应，或在 If-Match 或 If-Range 头字段中使用，用于表示选择（即，客户端特别指向之前获得的带有列出实体标签的表示）。

4.3.2.  处理收到的验证请求

   请求链中的每个客户端可能都有自己的缓存，因此中间缓存经常会收到来自其他（出站）缓存的条件请求。同样，一些用户代理也会使用条件请求，以限制数据传输到最近修改的表示，或完成部分检索表示的传输。

   如果缓存收到的请求可以通过重用其存储的 200（OK）或 206（部分内容）响应满足，缓存应评估请求中任何适用的条件头字段预条件，与所选响应中的验证器进行比较。缓存不得评估仅适用于源服务器的条件头字段（如 If-Match 和 If-Unmodified-Since），也不得应用于没有存储响应的目标资源；这些预条件很可能是为其他（入站）服务器设计的。

   缓存正确评估条件请求依赖于收到的预条件头字段及其优先级，详见 [RFC7232]第6节。If-Match 和 If-Unmodified-Since 条件头字段不适用于缓存。

   包含 If-None-Match 头字段（[RFC7232]第3.2节）的请求，表示客户端希望验证其一个或多个存储响应，与缓存选择的响应进行比较。如果该字段值为“*”，或字段值为实体标签列表且至少有一个匹配所选存储响应的实体标签，缓存应生成 304（未修改）响应（使用所选存储响应的元数据），而不是发送存储响应。

   当缓存决定重新验证包含实体标签列表的请求中的存储响应时，可以将收到的实体标签列表与其存储的响应集合中的实体标签列表合并，作为替代的 If-None-Match 头字段值，转发请求时发送两个列表的并集。如果存储响应只包含部分内容，除非请求范围完全由该部分存储响应满足，否则不得在并集中包含其实体标签。如果对转发请求的响应为 304（未修改）且其 ETag 头字段中的实体标签不在客户端列表中，缓存必须通过重用其对应的存储响应（由 304 响应元数据更新）为客户端生成 200（OK）响应（参见第4.3.4节）。

   如果没有包含 If-None-Match 头字段的请求，包含 If-Modified-Since 头字段（[RFC7232]第3.3节）的请求，表示客户端希望通过修改日期验证其一个或多个存储响应。如果满足以下任一情况，缓存应生成 304（未修改）响应（使用所选存储响应的元数据）：
   1）所选存储响应的 Last-Modified 字段值早于或等于条件时间戳；
   2）所选存储响应没有 Last-Modified 字段，但其 Date 字段值早于或等于条件时间戳；
   3）所选存储响应既没有 Last-Modified 也没有 Date 字段，但缓存记录其接收时间早于或等于条件时间戳。

   实现范围请求部分响应（[RFC7233]定义）的缓存，还需要评估收到的 If-Range 头字段（[RFC7233]第3.2节）与其所选存储响应的关系。

4.3.3.  处理验证响应

   缓存对条件请求响应的处理取决于其状态码：

   o  304（未修改）响应状态码表示存储的响应可以更新并重用；详见第4.3.4节。

   o  完整响应（即带有负载体的响应）表示条件请求中提名的存储响应都不合适。缓存必须使用完整响应满足请求，并可以替换存储的响应。

   o  如果缓存在验证响应时收到 5xx（服务器错误）响应，可以将此响应转发给请求的客户端，或视为服务器未响应。在后者情况下，缓存可以发送之前存储的响应（参见第4.2.4节）。

4.3.4.  验证后更新存储响应

   当缓存收到 304（未修改）响应且已存有一个或多个对应的 200（OK）响应时，必须识别哪些存储响应被此新响应更新，然后用 304 响应中的新信息更新存储响应。

   更新的存储响应由以下第一个匹配项确定（如果有）：

   o  如果新响应包含强验证器（[RFC7232]第2.1节），则该强验证器标识要更新的表示。所有具有相同强验证器的存储响应都被选中。如果没有存储响应包含相同的强验证器，则不得用新响应更新任何存储响应。

   o  如果新响应包含弱验证器，并且该验证器对应于存储的响应之一，则选择最新的匹配存储响应进行更新。

   o  如果新响应不包含任何验证器（例如，客户端从非 Last-Modified 响应头字段的源生成 If-Modified-Since 请求），且只有一个存储响应，且该响应也没有验证器，则选择该存储响应进行更新。

   如果选择了存储响应进行更新，缓存必须：

   o  删除存储响应中所有带 warn-code 1xx 的 Warning 头字段（参见第5.5节）；

   o  保留存储响应中所有带 warn-code 2xx 的 Warning 头字段；

   o  使用在 304（未修改）响应中提供的其他头字段，替换存储响应中对应的所有头字段。

4.3.5.  通过 HEAD 进行响应新鲜度更新

HEAD方法的响应与对应的GET请求的响应内容相同，唯一的区别在于没有实体主体。HEAD响应的这一特性可以用来使缓存的GET响应失效或更新，尤其在无法使用更高效的条件GET请求机制（因为存储的响应中没有验证器）或即使内容已更改也不希望传输实体主体的情况下。

当缓存对某个请求目标发起入站HEAD请求并收到一个200（OK）响应时，应该更新或使其存储的所有可能对应该请求的GET响应失效（详见第4.1节）。

对于每个可能被选中的存储响应，如果存储的响应与HEAD响应中的验证器字段（ETag和Last-Modified）值匹配，并且HEAD响应中有Content-Length头字段且其值与存储响应中的相符，缓存应按照以下方式更新存储的响应；否则，缓存应将该存储响应视为过期。

如果缓存用HEAD响应中提供的元数据更新了存储的响应，必须：

- 删除存储响应中所有带有warn-code 1xx的Warning头字段（详见第5.5节）；
- 保留存储响应中所有带有warn-code 2xx的Warning头字段；
- 使用HEAD响应中提供的其他头字段替换存储响应中对应的所有头字段，并将新的头字段附加到存储响应的头部，除非由Cache-Control头字段另有限制。

4.4. 失效

由于PUT、POST或DELETE等不安全的请求方法（详见[RFC7231]第4.2.1节）可能会改变源服务器的状态，中间缓存可以利用它们保持内容的最新。

当对某个非错误状态码的请求收到响应时，缓存必须使有效请求URI（详见[RFC7230]第5.5节）以及响应头中的Location和Content-Location（如果存在）中的URI失效。

但如果Location或Content-Location头中的URI的主机部分与有效请求URI的主机部分不同，缓存不得使其失效，以防止拒绝服务攻击。

当缓存收到对某个方法安全性未知的请求的非错误响应时，也必须使该请求的有效URI失效。

这里，“非错误响应”指状态码为2xx（成功）或3xx（重定向）的响应。“失效”意味着缓存要么删除所有与该有效请求URI相关的存储响应，要么将其标记为“无效”，并在后续请求中强制进行验证。

注意，这并不保证所有相关响应都被失效。例如，状态变更请求可能会使其经过的缓存中的响应失效，但其他缓存中可能仍然存有相关响应。

5. 头字段定义

本节定义与缓存相关的HTTP/1.1头字段的语法和语义。

5.1. Age

“Age”头字段传达发件人对自响应生成或成功验证以来经过时间的估算值。Age值按第4.2.3节的规定计算。

Age = delta-seconds

Age字段值为非负整数，表示以秒为单位的时间（详见第1.2.1节）。

存在Age头字段意味着该响应不是由源服务器为此请求生成或验证的。然而，缺少Age头字段并不意味着没有联系源服务器，因为响应可能来自未实现Age的HTTP/1.0缓存。

5.2. Cache-Control

“Cache-Control”头字段用于指定请求/响应链中缓存的指令。这些指令是单向的，即请求中存在某指令并不意味着响应中也必须包含相同的指令。

缓存必须遵守本节定义的Cache-Control指令。关于其他地方定义的Cache-Control指令的处理方式，请参见第5.2.3节。

注意：一些HTTP/1.0缓存可能不支持Cache-Control。

代理（无论是否实现缓存）必须在转发的消息中传递Cache-Control指令，无论其对应用程序的重要性如何，因为这些指令可能适用于请求/响应链中的所有接收者。不能将指令定向到特定缓存。

Cache-Control指令由一个标记（token）组成，比较时不区分大小写，并可带有可选参数，参数可以使用标记或引号字符串语法。对于定义了参数的指令，接收方应接受两种形式，即使其中一种被建议使用。对于未在本规范中定义的指令，接收方必须接受两种形式。

Cache-Control = 1#cache-directive

cache-directive = token [ "=" ( token / quoted-string ) ]

除非另有说明，否则以下定义的指令没有参数。

5.2.1. 请求端的Cache-Control指令

5.2.1.1. max-age

参数语法：delta-seconds（详见第1.2.1节）

“max-age”请求指令表示客户端不愿接受年龄大于指定秒数的响应。除非同时存在“max-stale”指令，否则客户端不愿接受过期的响应。

该指令使用标记形式的参数：如“max-age=5”，而非“max-age="5"”。发送方不应生成带引号的字符串形式。

5.2.1.2. max-stale

参数语法：delta-seconds（详见第1.2.1节）

“max-stale”请求指令表示客户端愿意接受超出新鲜度期限的响应。如果赋值，则客户端愿意接受超出期限不超过指定秒数的响应；如果未赋值，则接受任何过期响应。

该指令使用标记形式：如“max-stale=10”，不应生成带引号的字符串。

5.2.1.3. min-fresh

参数语法：delta-seconds（详见第1.2.1节）

“min-fresh”请求指令表示客户端希望响应的剩余新鲜时间不少于当前年龄加上指定秒数，即希望响应在未来至少还保持指定秒数的新鲜度。

使用标记形式：如“min-fresh=20”，不应生成带引号的字符串。

5.2.1.4. no-cache

表示请求端不希望使用缓存的响应直接满足请求，必须在源服务器验证后才能使用。

5.2.1.5. no-store

表示缓存不得存储请求或响应的任何部分。适用于私有和共享缓存。“不得存储”意味着缓存不得有意将信息存入非易失性存储，也应尽力从易失性存储中尽快删除。

此指令不能保证隐私安全，恶意或被攻破的缓存可能不遵守，网络通信也可能被窃听。

如果请求中包含此指令，已存储的响应不受影响。

5.2.1.6. no-transform

表示中间体（无论是否实现缓存）不得变换负载内容（详见[RFC7230]第5.7.2节）。

5.2.1.7. only-if-cached

表示客户端只希望获取缓存中的响应。收到此指令后，缓存应返回符合请求其他约束的存储响应，或返回504（网关超时）状态码。若多个缓存作为统一系统运行，成员缓存可在内部转发此请求。

5.2.2. 响应端的Cache-Control指令

5.2.2.1. must-revalidate

表示一旦响应变得过期，缓存不得在未成功验证的情况下使用它满足后续请求。此指令支持可靠操作，尤其在无法联系源服务器时，必须返回504。

服务器应在验证失败可能导致错误操作（如财务交易未执行）时使用此指令。

5.2.2.2. no-cache

参数语法：#field-name

表示响应不得在未验证的情况下用于满足后续请求。允许服务器在响应中列出一个或多个字段名，缓存可以在满足其他缓存限制的前提下使用此响应，但列出的字段名在后续请求中不得被无验证地使用，必须重新验证。

字段名不局限于本规范定义的头字段，且不区分大小写。

此指令使用引号字符串形式，建议不要用标记形式（即使引号不必要）。

注意：虽然已在许多实现中支持，但某些HTTP/1.0缓存可能不识别或遵守此指令。带字段名的no-cache响应指令常被缓存视为未限定的no-cache。

5.2.2.3. no-store

表示缓存不得存储请求或响应的任何部分。适用于私有和共享缓存。定义同上，不能保证隐私安全。

5.2.2.4. no-transform

表示中间体不得变换负载内容（详见[RFC7230]第5.7.2节）。

5.2.2.5. public

“public”响应指令表示任何缓存都可以存储该响应，即使该响应通常是不可缓存的或仅在私有缓存中缓存的。（有关在响应中使用public的更多细节，特别是在请求中包含Authorization的情况下，参见第3.2节；以及第3节详细说明public如何影响通常因状态码未定义为可缓存而不能存储的响应；参见第4.2.2节。）

5.2.2.6. private

参数语法：

      #字段名

Fielding 等人             标准轨道                   [第25页]

RFC 7234                    HTTP/1.1 缓存                   2014年6月

“private”响应指令表示该响应消息是为单一用户设计的，必须不得由共享缓存存储。私有缓存可以存储该响应并在后续请求中重用，即使该响应通常是不可缓存的。

如果private响应指令指定了一个或多个字段名，则此要求仅限于与列出的响应头字段相关联的字段值。也就是说，共享缓存不得存储指定的字段名，但可以存储响应消息的其余部分。

所给出的字段名不限于本规范定义的头字段集。字段名不区分大小写。

该指令使用引号字符串形式的参数语法。发送方不应生成标记（token）形式（即使引号在单条列表中似乎不需要）。

注意：此处“private”一词的用法仅控制响应可以存储的位置；不能确保消息内容的隐私。此外，带有字段名的private响应指令通常会被缓存视为未限定的private指令，即，针对限定形式的特殊处理并未广泛实现。

5.2.2.7. proxy-revalidate

“proxy-revalidate”响应指令的含义与must-revalidate响应指令相同，但不适用于私有缓存。

5.2.2.8. max-age

参数语法：

      delta-seconds（参见第1.2.1节）

“max-age”响应指令表示，响应在其年龄超过指定秒数后将被视为过期。

该指令使用标记（token）形式的参数语法，例如：‘max-age=5’，而非‘max-age="5"’。发送方不应生成引号字符串形式。

5.2.2.9. s-maxage

参数语法：

      delta-seconds（参见第1.2.1节）

“s-maxage”响应指令表示，在共享缓存中，此指令指定的最大年龄优先于max-age指令或Expires头字段中定义的最大年龄。s-maxage还暗示了proxy-revalidate响应指令的语义。

该指令使用标记（token）形式的参数语法，例如：‘s-maxage=10’，而非‘s-maxage="10"’。发送方不应生成引号字符串形式。

5.2.3. 缓存控制扩展

Cache-Control头字段可以通过使用一个或多个cache-extension标记（每个可带有可选值）进行扩展。缓存必须忽略未识别的缓存指令。

信息性扩展（不需要改变缓存行为的扩展）可以在不改变其他指令语义的情况下添加。

行为扩展旨在作为对现有缓存指令的修饰符工作。既提供新指令，也提供旧指令，以便不理解新指令的应用程序会默认遵循旧指令的行为，而理解新指令的应用程序会将其视为对旧指令相关要求的修正。这样，扩展现有缓存控制指令可以在不破坏已部署缓存的情况下实现。

例如，假设有一个名为“community”的新响应指令，它作为private指令的修饰符：除了私有缓存外，任何由指定社区成员共享的缓存也允许缓存响应。希望允许UCI社区在其共享缓存中使用本应私有的响应的源服务器，可以通过包含以下内容实现：

     Cache-Control: private, community="UCI"

识别此类社区缓存扩展的缓存可以根据扩展内容调整其行为。不识别该社区扩展的缓存将忽略它，并遵循private指令。

5.3. 过期（Expires）

“Expires”头字段给出响应被视为过期的日期/时间。关于新鲜度模型的详细讨论请参见第4.2节。

存在Expires字段并不意味着原始资源会在该时间点之前、之后或之时发生变化或不存在。

Expires值是一个HTTP-date时间戳，定义见[RFC7231]第7.1.1.1节。

例如：

     Expires: Thu, 01 Dec 1994 16:00:00 GMT

接收缓存必须将无效的日期格式（尤其是值“0”）解释为过去的时间（即“已过期”）。

如果响应中包含带有max-age指令（第5.2.2.8节）的Cache-Control字段，接收方必须忽略Expires字段。同样，如果响应中包含s-maxage指令（第5.2.2.9节），共享缓存接收方也必须忽略Expires字段。在这两种情况下，Expires中的值仅适用于尚未实现Cache-Control字段的接收方。

没有时钟的源服务器不得生成Expires字段，除非其值代表一个固定的过去时间（始终过期）或其值已由具有可靠时钟的系统或用户与资源相关联。

历史上，HTTP要求Expires字段值最多为一年后。虽然不再禁止更长的有效期，但已证明极大的值可能引发问题（例如，因使用32位整数存储时间值导致的时钟溢出），许多缓存会比此更早地驱逐响应。

5.4. Pragma

“Pragma”头字段允许向后兼容HTTP/1.0缓存，使客户端可以指定“no-cache”请求，确保其被理解（因为直到HTTP/1.1才定义了Cache-Control）。当请求中同时存在且被理解的Cache-Control头字段时，Pragma将被忽略。

在HTTP/1.0中，Pragma被定义为一个可扩展字段，用于实现者指定的指令。为提高互操作性，本规范废弃了此类扩展。

     Pragma           = 1#pragma-directive
     pragma-directive = "no-cache" / extension-pragma
     extension-pragma = token [ "=" ( token / quoted-string ) ]

当请求中未包含Cache-Control头字段时，缓存必须将no-cache请求Pragma指令视为等同于“Cache-Control: no-cache”的效果（参见第5.2.1节）。

发出no-cache请求时，客户端应同时包含Pragma和Cache-Control指令，除非有意省略Cache-Control: no-cache，以针对HTTP/1.1缓存的其他Cache-Control响应指令。例如：

     GET / HTTP/1.1
     Host: www.example.com
     Cache-Control: max-age=30
     Pragma: no-cache

这将限制HTTP/1.1缓存响应不超过30秒，同时阻止不理解Cache-Control的实现从缓存中提供响应。

注意：由于“Pragma: no-cache”在响应中的含义未被明确规定，它不能可靠地替代“Cache-Control: no-cache”。

5.5. 警告（Warning）

“Warning”头字段用于携带关于消息状态或变换的附加信息，这些信息可能未在状态码中反映。此信息通常用于警告缓存操作或对消息负载应用的变换可能引入的错误。

Warning可以用于其他目的，包括缓存相关和非缓存相关。使用Warning而非错误状态码，可以将这些响应与真正的失败区分开。

Warning头字段通常可以应用于任何消息，但某些warn-code仅适用于响应消息，且特定于缓存。

     Warning       = 1#warning-value

     warning-value = warn-code SP warn-agent SP warn-text
                                           [ SP warn-date ]

     warn-code  = 3DIGIT
     warn-agent = ( uri-host [ ":" port ] ) / pseudonym
                     ; 添加Warning头字段的服务器名称或假名，用于调试
                     ; 建议在未知代理时使用“-”
     warn-text  = quoted-string
     warn-date  = DQUOTE HTTP-date DQUOTE

响应中可以生成多个警告（由源服务器或缓存），包括多个相同warn-code但warn-text不同的警告。

接收一个或多个Warning头字段的用户代理应尽可能按响应中出现的顺序通知用户所有警告。生成多个Warning头字段的发件人应考虑此行为，将它们按此顺序排列。新生成的Warning头字段必须附加在现有Warning头字段之后。

Warning代码为三位数字。首位数字指示在验证后是否必须从存储响应中删除该警告：

- 1xx warn-code描述响应的最新性或验证状态，验证后必须由缓存删除。仅在验证缓存条目时生成，其他情况下不得生成。

- 2xx warn-code描述表示某些表示方面（如有损压缩）未通过验证得到修正，验证后不得由缓存删除，除非发送完整响应，此时必须删除。

如果发件人在向只实现HTTP/1.0的接收方发送消息时生成一个或多个1xx warn-code，必须在每个相应的warn-value中包含与消息中的Date头字段匹配的warn-date。例如：

     HTTP/1.1 200 OK
     Date: Sat, 25 Aug 2012 23:34:45 GMT
     Warning: 112 - "network down" "Sat, 25 Aug 2012 23:34:45 GMT"

警告还应附带描述错误的warn-text（例如，用于日志记录）。此内容仅为建议，其内容不影响warn-code的解释。

如果接收方在评估或显示Warning头字段时，收到的warn-date与消息中的Date值不同，必须在存储、转发或使用消息前排除包含该warn-date的警告值。这允许接收方排除在缓存验证后被错误保留的警告值。如果所有警告值都被排除，接收方也必须排除Warning头字段。

本规范定义的warn-code如下，每个都附有建议的英文warn-text及其含义说明。定义其他warn-code的程序请参见第7.2.1节。

5.5.1. 警告：110 - “响应已过期”

缓存应在响应过期时生成此警告。

5.5.2. 警告：111 - “重新验证失败”

当因无法联系服务器而尝试验证响应失败时，缓存应生成此警告。

5.5.3. 警告：112 - “断开连接操作”

如果缓存故意在一段时间内与网络断开，应生成此警告。

5.5.4. 警告：113 - “启发式过期”

如果缓存启发式选择的新鲜度超过24小时，且响应的年龄也超过24小时，应生成此警告。

5.5.5. 警告：199 - “其他警告”

警告文本可以包含任意信息，用于呈现给用户或记录。接收系统不得对该警告采取任何自动行动，除非向用户显示。

5.5.6. 警告：214 - “应用变换”

如果代理对表示进行了任何变换（如更改内容编码、媒体类型或修改表示数据），必须添加此警告码，除非该警告码已出现在响应中。

5.5.7. 警告：299 - “其他持久性警告”

   警告文本可以包含任意信息，旨在向人类用户展示或记录。接收此警告的系统不得采取任何自动化行动。

6. 历史列表

   用户代理通常具有历史机制，例如“后退”按钮和历史列表，可以用来重新显示在会话中早期检索到的表示。

   新鲜度模型（第4.2节）不一定适用于历史机制。也就是说，历史机制可以显示已过期的先前表示。

   这并不禁止历史机制告知用户某个视图可能已过时，或遵守缓存指令（例如，Cache-Control: no-store）。

7. IANA注意事项

7.1. 缓存指令注册表

   “超文本传输协议（HTTP）缓存指令注册表”定义了缓存指令的命名空间。该注册表已创建，并由以下网址维护：
   <http://www.iana.org/assignments/http-cache-directives>。

7.1.1. 过程

   注册必须包括以下字段：

   - 缓存指令名称

   - 指向规范文本的指针

   添加到此命名空间的值需要经过IETF审查（参见 [RFC5226]，第4.1节）。

7.1.2. 新缓存控制指令的考虑事项

   新的扩展指令应考虑定义：

   - 指令多次指定的含义，

   - 当指令不带参数时，参数存在的含义，

   - 当指令需要参数但缺失时的含义，

   - 指令是特定于请求、响应，还是可以在两者中使用。

   另请参见第5.2.3节。

7.1.3. 注册情况

   注册表已填充以下注册信息：

   +------------------------+----------------------------------+
   | 缓存指令               | 参考                            |
   +------------------------+----------------------------------+
   | max-age                | 第5.2.1.1节，第5.2.2.8节          |
   | max-stale              | 第5.2.1.2节                      |
   | min-fresh              | 第5.2.1.3节                      |
   | must-revalidate        | 第5.2.2.1节                      |
   | no-cache               | 第5.2.1.4节，第5.2.2.2节          |
   | no-store               | 第5.2.1.5节，第5.2.2.3节          |
   | no-transform           | 第5.2.1.6节，第5.2.2.4节          |
   | only-if-cached         | 第5.2.1.7节                      |
   | private                | 第5.2.2.6节                      |
   | proxy-revalidate       | 第5.2.2.7节                      |
   | public                 | 第5.2.2.5节                      |
   | s-maxage               | 第5.2.2.9节                      |
   | stale-if-error         | [RFC5861]，第4节                 |
   | stale-while-revalidate| [RFC5861]，第3节                 |
   +------------------------+----------------------------------+

7.2. 警告代码注册表

   “超文本传输协议（HTTP）警告代码”注册表定义了警告代码的命名空间。该注册表已创建，并由以下网址维护：
   <http://www.iana.org/assignments/http-warn-codes>。

7.2.1. 过程

   注册必须包括以下字段：

   - 警告代码（3位数字）

   - 简短描述

   - 指向规范文本的指针

   添加到此命名空间的值需要经过IETF审查（参见 [RFC5226]，第4.1节）。

7.2.2. 注册情况

   注册表已填充以下注册信息：

   +-----------+------------------------------+--------------+
   | 警告代码  | 简短描述                     | 参考         |
   +-----------+------------------------------+--------------+
   | 110       | 响应已过期                   | 第5.5.1节    |
   | 111       | 重新验证失败                 | 第5.5.2节    |
   | 112       | 断开操作                     | 第5.5.3节    |
   | 113       | 启发式过期                   | 第5.5.4节    |
   | 199       | 其他持久性警告               | 第5.5.5节    |
   | 214       | 已应用转换                   | 第5.5.6节    |
   | 299       | 其他持久性警告               | 第5.5.7节    |
   +-----------+------------------------------+--------------+

7.3. 头字段注册

   HTTP头字段在“消息头”注册表中注册，该注册表由以下网址维护：
   <http://www.iana.org/assignments/message-headers/>。

   本文档定义了以下HTTP头字段，因此“永久消息头字段名”注册表已相应更新（参见 [BCP90]）：

   +-------------------+----------+----------+--------------+
   | 头字段名           | 协议     | 状态     | 参考         |
   +-------------------+----------+----------+--------------+
   | Age               | http     | 标准     | 第5.1节      |
   | Cache-Control     | http     | 标准     | 第5.2节      |
   | Expires           | http     | 标准     | 第5.3节      |
   | Pragma            | http     | 标准     | 第5.4节      |
   | Warning           | http     | 标准     | 第5.5节      |
   +-------------------+----------+----------+--------------+

   变更控制者为：“IETF (iesg@ietf.org) - 互联网工程任务组”。

8. 安全注意事项

   本节旨在告知开发者、信息提供者和用户关于HTTP缓存的已知安全问题。更一般的安全考虑在HTTP消息 [RFC7230] 和语义 [RFC7231] 中已有说明。

   缓存可能带来额外的潜在漏洞，因为缓存内容是恶意利用的潜在目标。由于缓存内容在HTTP请求完成后仍会保留，攻击者可以在用户认为信息已从网络中删除后，仍能通过攻击缓存获取信息。因此，缓存内容应被视为敏感信息加以保护。

   特别是，某些攻击可能通过存储在共享缓存中而被放大；此类“缓存中毒”攻击利用缓存向多个客户端分发恶意负载，尤其当攻击者能利用实现缺陷、提升权限或其他技术将响应插入缓存时。一种常见的缓存中毒攻击方式是利用代理和用户代理在消息解析上的差异；详见 [RFC7230] 第3.3.3节的相关要求。

   同样，实施缺陷（以及对缓存操作的误解）可能导致敏感信息（如认证凭据）被缓存，暴露给未授权方。

   此外，使用缓存本身也可能引发隐私问题。例如，如果两个用户共享一个缓存，第一个用户浏览某个站点，第二个用户可能会检测到前者访问过该站点，因为资源加载更快，得益于缓存。

   注意，Set-Cookie响应头字段 [RFC6265] 不会阻止缓存；带有Set-Cookie头的可缓存响应可以（且常常会）用于满足后续的请求。希望控制这些响应缓存的服务器应发出适当的Cache-Control响应头。

9. 致谢

   详见 [RFC7230] 第10节。

10. 参考文献

10.1. 规范性参考文献

   [RFC2119]  Bradner, S.，“用于指示RFC中需求级别的关键词”，BCP 14，RFC 2119，1997年3月。

   [RFC5234]  Crocker, D.（编辑）和 P. Overell，“语法规范的增强BNF：ABNF”，STD 68，RFC 5234，2008年1月。

   [RFC7230]  Fielding, R.（编辑）和 J. Reschke（编辑），“超文本传输协议（HTTP/1.1）：消息语法和路由”，RFC 7230，2014年6月。

   [RFC7231]  Fielding, R.（编辑）和 J. Reschke（编辑），“超文本传输协议（HTTP/1.1）：语义和内容”，RFC 7231，2014年6月。

   [RFC7232]  Fielding, R.（编辑）和 J. Reschke（编辑），“超文本传输协议（HTTP/1.1）：条件请求”，RFC 7232，2014年6月。

   [RFC7233]  Fielding, R.（编辑），Lafon, Y.（编辑）和 J. Reschke（编辑），“超文本传输协议（HTTP/1.1）：范围请求”，RFC 7233，2014年6月。

   [RFC7235]  Fielding, R.（编辑）和 J. Reschke（编辑），“超文本传输协议（HTTP/1.1）：认证”，RFC 7235，2014年6月。

10.2. 说明性参考文献

   [BCP90]  Klyne, G.，Nottingham, M.，和 J. Mogul，“消息头字段的注册程序”，BCP 90，RFC 3864，2004年9月。

   [RFC2616]  Fielding, R.，Gettys, J.，Mogul, J.，Frystyk, H.，Masinter, L.，Leach, P.，和 T. Berners-Lee，“超文本传输协议——HTTP/1.1”，RFC 2616，1999年6月。

   [RFC5226]  Narten, T. 和 H. Alvestrand，“编写IANA考虑事项节的指南”，BCP 26，RFC 5226，2008年5月。

   [RFC5861]  Nottingham, M.，“HTTP缓存控制扩展以支持过期内容”，RFC 5861，2010年4月。

   [RFC5905]  Mills, D.，Martin, J.（编辑），Burbank, J.，和 W. Kasch，“网络时间协议第4版：协议和算法规范”，RFC 5905，2010年6月。

   [RFC6265]  Barth, A.，“HTTP状态管理机制”，RFC 6265，2011年4月。

附录A.  与RFC 2616的变更

   规范已大幅重写以提高清晰度。

   关于已认证响应何时可以被缓存的条件已被澄清（第3.2节）。

   新的状态码现在可以定义允许缓存使用启发式新鲜度。缓存现在可以对带查询组件的URI计算启发式新鲜度（第4.2.2节）。

   计算年龄的算法变得不那么保守。缓存现在必须将带时区的日期视为无效，因为无法准确猜测（第4.2.3节）。

   Content-Location响应头字段不再用于确定验证时应使用的响应（第4.3节）。

   选择已缓存协商响应的算法已被多方面澄清。特别是，它现在明确允许在处理选择头字段时进行头特定的规范化（第4.1节）。

   关于执行失效时的拒绝服务攻击规避的要求已被澄清（第4.4节）。

   仅在收到成功响应时才进行缓存失效（第4.4节）。

   明确规定缓存指令不区分大小写。定义了在只期望一个实例时如何处理多个实例的缓存指令（第5.2节）。

   “no-store”请求指令不适用于响应；即，缓存可以满足带有no-store的请求，但不会使其失效（第5.2.1.5节）。

   私有和no-cache缓存指令的限定形式被指出未被广泛实现，例如，“private=foo”在许多缓存中被解释为仅为“private”。此外，已澄清no-cache的限定形式的含义（第5.2.2节）。

   已澄清“no-cache”响应指令的含义（第5.2.2.2节）。

   取消了Expires头字段值的一年限制；相反，给出了使用合理值的理由（第5.3节）。

   Pragma头字段现在仅为向后兼容而定义；未来的Pragma将被弃用（第5.4节）。

   关于生成和处理Warning头字段的某些要求已放宽，因为其实现尚不普遍。此外，Warning头字段不再使用RFC 2047编码，也不支持多语言，因为这些方面未被实现（第5.5节）。

   本规范引入了缓存指令和警告代码注册表，并定义了新缓存指令的考虑事项（第7.1节和第7.2节）。

附录B. 导入的ABNF

   以下核心规则通过引用包含，定义在 [RFC5234] 的附录B.1中：ALPHA（字母）、CR（回车）、CRLF（回车换行）、CTL（控制字符）、DIGIT（十进制0-9）、DQUOTE（双引号）、HEXDIG（十六进制0-9/A-F/a-f）、LF（换行）、OCTET（任何8位数据序列）、SP（空格）和VCHAR（任何可见US-ASCII字符）。

   以下规则在 [RFC7230] 中定义：

     OWS           = <OWS，参见 [RFC7230] 第3.2.3节>
     field-name    = <字段名，参见 [RFC7230] 第3.2节>
     quoted-string = <带引号字符串，参见 [RFC7230] 第3.2.6节>
     token         = <标记，参见 [RFC7230] 第3.2.6节>

     port          = <端口，参见 [RFC7230] 第2.7节>
     pseudonym     = <假名，参见 [RFC7230] 第5.7.1节>
     uri-host      = <URI主机，参见 [RFC7230] 第2.7节>

   以下规则在其他部分定义：

     HTTP-date     = <HTTP日期，参见 [RFC7231] 第7.1.1.1节>

附录C. 收集的ABNF

   在下方的收集ABNF中，列表规则按照 [RFC7230] 第1.2节展开。

   Age = delta-seconds

   Cache-Control = *( "," OWS ) cache-directive *( OWS "," [ OWS cache-directive ] )

   Expires = HTTP-date

   HTTP-date = <HTTP日期，参见 [RFC7231] 第7.1.1.1节>

   OWS = <OWS，参见 [RFC7230] 第3.2.3节>

   Pragma = *( "," OWS ) pragma-directive *( OWS "," [ OWS pragma-directive ] )

   Warning = *( "," OWS ) warning-value *( OWS "," [ OWS warning-value ] )

   cache-directive = token [ "=" ( token / quoted-string ) ]

   delta-seconds = 1*DIGIT

   extension-pragma = token [ "=" ( token / quoted-string ) ]

   field-name = <字段名，参见 [RFC7230] 第3.2节>

   port = <端口，参见 [RFC7230] 第2.7节>
   pragma-directive = "no-cache" / extension-pragma
   pseudonym = <假名，参见 [RFC7230] 第5.7.1节>

   quoted-string = <带引号字符串，参见 [RFC7230] 第3.2.6节>

   token = <标记，参见 [RFC7230] 第3.2.6节>

   uri-host = <URI主机，参见 [RFC7230] 第2.7节>

警告代理 = （uri-host [ ":" 端口 ] ）/ 假名  
警告代码 = 3位数字  
警告日期 = 用引号括起的HTTP日期  
警告文本 = 引号字符串  
警告值 = 警告代码 SP 警告代理 SP 警告文本 [ SP 警告日期 ]



Fielding 等人  规范追踪  [第40页]

RFC 7234  HTTP/1.1 缓存  2014年6月


索引

   1
      110（警告代码）  31
      111（警告代码）  31
      112（警告代码）  31
      113（警告代码）  31
      199（警告代码）  32

   2
      214（警告代码）  32
      299（警告代码）  32

   A
      age  11
      Age 头字段  21

   C
      缓存  4
      缓存条目  5
      缓存键  5-6
      Cache-Control 头字段  21

   D
      断开连接操作（警告文本）  31

   E
      Expires 头字段  28
      明确的过期时间  11

   F
      新鲜  11
      新鲜度存续期  11

   G
      语法
         Age  21
         Cache-Control  22
         缓存指令  22
         delta秒  5
         Expires  28
         扩展-pragma  29
         Pragma  29
         pragma指令  29
         warn-agent  29
         warn-code  29
         warn-date  29
         warn-text  29
         Warning  29
         warning-value  29

   H
      启发式过期（警告文本）  31
      启发式过期时间  11

   M
      max-age（缓存指令）  22, 26
      max-stale（缓存指令）  22
      min-fresh（缓存指令）  22
      其他持久性警告（警告文本）  32
      其他警告（警告文本）  32
      must-revalidate（缓存指令）  24

   N
      no-cache（缓存指令）  23, 25
      no-store（缓存指令）  23, 24
      no-transform（缓存指令）  23, 25

   O
      only-if-cached（缓存指令）  23

   P
      Pragma 头字段  29
      private（缓存指令）  25
      私有缓存  4
      proxy-revalidate（缓存指令）  26
      public（缓存指令）  25

   R
      响应已过期（警告文本）  30
      重新验证失败（警告文本）  31

   S
      s-maxage（缓存指令）  27
      共享缓存  4
      过期  11
      强验证器  18

   T
      应用的转换（警告文本）  32

   V
      验证器  16

   W
      Warning 头字段  29




Fielding 等人  规范追踪  [第42页]

RFC 7234  HTTP/1.1 缓存  2014年6月


作者联系方式

Roy T. Fielding（编辑）  
Adobe Systems Incorporated  
345 Park Ave  
San Jose, CA  95110  
美国

电子邮箱：fielding@gbiv.com  
网址：http://roy.gbiv.com/


Mark Nottingham（编辑）  
Akamai

电子邮箱：mnot@mnot.net  
网址：http://www.mnot.net/


Julian F. Reschke（编辑）  
greenbytes GmbH  
Hafenweg 16  
明斯特，NW  48155  
德国

电子邮箱：julian.reschke@greenbytes.de  
网址：http://greenbytes.de/tech/webdav/
























Fielding 等人  规范追踪  [第43页]