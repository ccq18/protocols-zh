# RFC 8446 中文翻译 (stub)
# 原文文件: ../../rfcs/RFCs8001-8500/rfc8446.txt

互联网工程任务组（IETF）                       E. Rescorla
评论请求：8446                                       Mozilla
废止：5077、5246、6961                                  2018年8月
更新：5705、6066
类别：标准轨道
ISSN：2070-1721


        传输层安全（TLS）协议版本1.3

摘要

   本文档规定了传输层安全（TLS）协议的第1.3版。TLS允许客户端/服务器应用程序在互联网上进行通信，旨在防止窃听、篡改和消息伪造。

   本文档更新了RFC 5705和6066，并废止了RFC 5077、5246和6961。本文档还对TLS 1.2的实现提出了新的要求。

本备忘录的状态

   这是一个互联网标准轨道的文档。

   本文档由互联网工程任务组（IETF）制定，代表了IETF社区的共识。它已经过公开审查，并获得互联网工程指导组（IESG）的批准发布。关于互联网标准的更多信息，请参见RFC 7841第2节。

   有关本文件当前状态、任何勘误以及如何提供反馈的信息，可以在https://www.rfc-editor.org/info/rfc8446获取。

版权所有声明

   本文件的版权归2018年IETF信托及被列为作者的个人所有。保留所有权利。

   本文件受BCP 78和IETF信托关于IETF文件的法律规定（https://trustee.ietf.org/license-info）约束，适用于本文件发布之日。请仔细阅读这些文件，它们描述了您对本文件的权利和限制。从本文件中提取的代码组件必须包括简化BSD许可证文本（详见信托法律规定第4.e节），并且在没有担保的情况下提供，如简化BSD许可证所述。

   本文件可能包含在2008年11月10日之前发布或公开的IETF文件或贡献的内容。这些内容的版权控制人可能未授权IETF信托允许在IETF标准流程之外对其进行修改。未经获得版权控制人的充分许可，不得在IETF标准流程之外修改本文件，也不得在IETF标准流程之外创建其衍生作品，除非是为了将其格式化为RFC或翻译成非英语语言。

目录

1. 引言 ....................................................6
   1.1. 约定和术语 ...........................................7
   1.2. 与TLS 1.2的主要差异 .................................8
   1.3. 对TLS 1.2的更新 ......................................9
2. 协议概述 ..............................................10
   2.1. 不正确的DHE共享 ....................................14
   2.2. 会话恢复与预共享密钥（PSK） .......................15
   2.3. 0-RTT数据 ...........................................17
3. 表示语言 ..............................................19
   3.1. 基本块大小 ..........................................19
   3.2. 其他 ................................................20
   3.3. 数字 ................................................20
   3.4. 向量 ................................................20
   3.5. 枚举 ................................................21
   3.6. 构造类型 ............................................22
   3.7. 常量 ................................................23
   3.8. 变体 ................................................23
4. 握手协议 ..............................................24
   4.1. 密钥交换消息 ........................................25
       4.1.1. 密码协商 ......................................26
       4.1.2. 客户端Hello ..................................27
       4.1.3. 服务器Hello ..................................31
       4.1.4. Hello重试请求 ................................33
   4.2. 扩展 ................................................35
       4.2.1. 支持的版本 ....................................39
       4.2.2. Cookie ........................................40
       4.2.3. 签名算法 ....................................41
       4.2.4. 证书颁发机构 ................................45
       4.2.5. OID过滤器 ....................................45
       4.2.6. 握手后客户端认证 ..............................47
       4.2.7. 支持的组 ......................................47
       4.2.8. 密钥共享 ......................................48
       4.2.9. 预共享密钥交换模式 ............................51
       4.2.10. 早期数据指示 ................................52
       4.2.11. 预共享密钥扩展 ...............................55
   4.3. 服务器参数 ..........................................59
       4.3.1. 加密扩展 ......................................60
       4.3.2. 证书请求 ......................................60
   4.4. 认证消息 ............................................61
       4.4.1. 传输哈希 ......................................63
       4.4.2. 证书 ..........................................64
       4.4.3. 证书验证 ......................................69
       4.4.4. 完成 ..........................................71
   4.5. 早期数据结束 ........................................72
   4.6. 握手后消息 ..........................................73
       4.6.1. 新会话票据消息 ................................73
       4.6.2. 握手后认证 ....................................75
       4.6.3. 密钥和初始化向量更新 ..........................76
5. 记录协议 ..............................................77
   5.1. 记录层 ..............................................78
   5.2. 记录负载保护 ........................................80
   5.3. 每记录的随机数 ......................................82
   5.4. 记录填充 ............................................83
   5.5. 密钥使用限制 ........................................84
6. 警报协议 ..............................................85
   6.1. 关闭警报 ............................................87
   6.2. 错误警报 ............................................88
7. 密码学计算 ............................................90
   7.1. 密钥调度 ............................................91
   7.2. 更新流量秘密 ........................................94
   7.3. 流量密钥计算 ........................................95
   7.4. (EC)DHE共享秘密计算 ................................95
       7.4.1. 有限域Diffie-Hellman ............................95
       7.4.2. 椭圆曲线Diffie-Hellman ..........................96
   7.5. 导出器 ..............................................97
8. 0-RTT与抗重放 .........................................98
   8.1. 单次使用票据 ........................................99
   8.2. 客户端Hello记录 ....................................99
   8.3. 新鲜度检查 .........................................101
9. 合规性要求 ...........................................102
   9.1. 必须实现的密码套件 .................................102
   9.2. 必须实现的扩展 .....................................103
   9.3. 协议不变量 .........................................104
10. 安全考虑 ............................................106
11. IANA考虑 ............................................106
12. 参考文献 ............................................109
   12.1. 规范性参考 .......................................109
   12.2. 资料性参考 .......................................112
附录A. 状态机 ...........................................120
   A.1. 客户端 ...........................................120
   A.2. 服务器 ...........................................121
附录B. 协议数据结构与常量值 ............................122
   B.1. 记录层 ...........................................122
   B.2. 警报消息 .........................................123
   B.3. 握手协议 .........................................124
       B.3.1. 密钥交换消息 ................................125
       B.3.2. 服务器参数消息 ................................131
       B.3.3. 认证消息 ......................................132
       B.3.4. 票据建立 ......................................132
       B.3.5. 密钥更新 ......................................133
   B.4. 密码套件 .........................................133
附录C. 实现说明 ........................................134
   C.1. 随机数生成与种子 ................................134
   C.2. 证书与认证 ........................................135
   C.3. 实现陷阱 ..........................................135
   C.4. 客户端追踪预防 ....................................137
   C.5. 非认证操作 ........................................137
附录D. 向后兼容性 ......................................138
   D.1. 与旧服务器协商 ....................................139
   D.2. 与旧客户端协商 ....................................139
   D.3. 0-RTT向后兼容 .....................................140
   D.4. 中间设备兼容模式 ..................................140
   D.5. 与向后兼容相关的安全限制 ..........................141
附录E. 安全属性概述 ....................................142
   E.1. 握手 ..............................................142
       E.1.1. 密钥派生与HKDF ................................145
       E.1.2. 客户端认证 ....................................146
       E.1.3. 0-RTT ...........................................146
       E.1.4. 导出器独立性 ..................................146
       E.1.5. 后妥协安全 ....................................146
       E.1.6. 外部引用 ......................................147
   E.2. 记录层 ............................................147
       E.2.1. 外部引用 ......................................148
   E.3. 流量分析 ............................................148
   E.4. 侧信道攻击 ..........................................149
   E.5. 0-RTT的重放攻击 ....................................150
       E.5.1. 重放与导出器 ..................................151
   E.6. PSK身份暴露 ........................................152
   E.7. 共享PSK ............................................152
   E.8. 静态RSA攻击 ........................................152
贡献者 .................................................153
作者联系方式 ...........................................160

-  参考文献已更新为指向相应的RFC最新版本（例如，使用RFC 5280而非RFC 3280）。

1.3. 影响TLS 1.2的更新内容

   本文定义了若干可选的变更，这些变更会影响TLS 1.2的实现，包括那些不同时支持TLS 1.3的实现：

   -  在第4.1.3节中描述了一种版本降级保护机制。

   -  在第4.2.3节中定义了RSASSA-PSS签名方案。

   -  "supported_versions"客户端问候扩展可以用来协商使用的TLS版本，优先于legacy_version字段。

   -  "signature_algorithms_cert"扩展允许客户端指示其能验证的X.509证书中的签名算法。

此外，本文还澄清了对早期TLS版本的某些合规性要求；详见第9.3节。

---

Rescorla  规范追踪  [第9页]

RFC 8446  TLS  August 2018

2.  协议概述

   安全通道所用的加密参数由TLS握手协议生成。TLS的子协议——握手协议——在客户端和服务器首次通信时使用。握手协议允许双方协商协议版本、选择加密算法、可选地进行相互认证，并建立共享的密钥材料。一旦握手完成，双方便使用已建立的密钥来保护应用层的通信。

   握手失败或出现其他协议错误时，会终止连接，必要时会发送警报消息（见第6节）。

   TLS支持三种基本的密钥交换模式：

   -  (EC)DHE（基于有限域或椭圆曲线的Diffie-Hellman）

   -  仅使用PSK（预共享密钥）

   -  PSK结合(EC)DHE

---

下图（图1）展示了完整的TLS握手流程：

```
客户端                                           服务器

密钥交换 ^ ClientHello
        | + key_share*
        | + signature_algorithms*
        | + psk_key_exchange_modes*
        v + pre_shared_key*       -------->
                                               ServerHello  ^ 密钥
                                              + key_share*  | 交换
                                         + pre_shared_key*  v
                                     {EncryptedExtensions}  ^  服务器
                                     {CertificateRequest*}  v  参数
                                            {Certificate*}  ^
                                      {CertificateVerify*}  | 认证
                                                {Finished}  v
                        <--------  [应用数据*]
  ^ {Certificate*}
认证 | {CertificateVerify*}
  v {Finished}              -------->
    [应用数据]            <------->  [应用数据]
```

-  图中“+”表示在之前提到的消息中发送的值得注意的扩展。

-  “*”表示可选或依赖情境的消息/扩展，并非每次都发送。

-  {}表示使用从[sender]_handshake_traffic_secret派生的密钥保护的消息。

-  []表示使用从[sender]_application_traffic_secret_N派生的密钥保护的消息。

（图1：完整TLS握手的消息流程）

握手可以分为三个阶段（如上图所示）：

-  密钥交换：建立共享密钥材料并选择加密参数。此阶段之后的所有通信都将被加密。

-  服务器参数：建立其他握手参数（如客户端是否认证、应用层协议支持等）。

-  认证：验证服务器（以及可选的客户端）身份，并提供密钥确认和握手完整性。

在密钥交换阶段，客户端会发送ClientHello（第4.1.2节），其中包含随机数（ClientHello.random）、提议的协议版本、对称密码/ HKDF哈希对列表、Diffie-Hellman密钥共享（在"key_share"扩展中）、预共享密钥标签（在"pre_shared_key"扩展中）或两者，以及可能的其他扩展。为了中间设备的兼容性，还可能包含额外字段或消息。

服务器处理ClientHello后，确定适合的加密参数，并回复ServerHello（第4.1.3节），指示协商的连接参数。ClientHello和ServerHello的组合决定了共享密钥。如果使用(EC)DHE密钥交换，ServerHello会包含一个"key_share"扩展，里面是服务器的临时Diffie-Hellman共享；该共享必须与客户端的某个组相匹配。如果使用PSK，ServerHello会包含一个"pre_shared_key"扩展，指示选择了哪个客户端提议的PSK。注意，实现可以同时使用(EC)DHE和PSK，此时两个扩展都将被提供。

随后，服务器会发送两条消息以建立服务器参数：

-  EncryptedExtensions：对ClientHello扩展的响应，除了那些特定于单个证书的内容外，用于补充协商参数。

-  CertificateRequest：如果需要基于证书的客户端认证，则指定所需的证书参数；如果不需要，则省略。

最后，客户端和服务器交换认证消息。TLS每次需要基于证书的认证时，都会使用相同的消息集（PSK认证作为密钥交换的副产品发生）。具体包括：

-  Certificate：端点的证书及相关扩展。如果不进行证书认证，服务器会省略此消息；客户端如果服务器未请求证书，也会省略。注意，如果使用原始公钥（RFC7250）或缓存信息扩展（RFC7924），此消息不会包含证书，而是包含对应服务器长期密钥的其他值。

-  CertificateVerify：用对应私钥对整个握手的签名，用以验证证书的真实性。若端点不进行证书认证，则省略。

-  Finished：对整个握手的消息认证码（MAC），提供密钥确认，绑定端点身份，并在PSK模式下验证握手完整性。

收到服务器消息后，客户端会回复认证消息（如Certificate和CertificateVerify（如果请求））以及Finished。

至此，握手完成，客户端和服务器会派生出记录层所需的密钥材料，用于保护应用层数据的传输（通过认证加密）。在发送Finished消息之前，不得发送应用数据。注意，虽然服务器可能在收到客户端认证消息之前就发送应用数据，但此时传输的数据未经过认证。

---

2.1.  关于DHE共享不正确的情况

如果客户端未提供足够的"key_share"扩展（例如，只包含服务器不支持或不可接受的DHE或ECDHE组），服务器会通过HelloRetryRequest纠正此不匹配，客户端需用合适的"key_share"扩展重新开始握手（见图2）。如果无法协商出共同的加密参数，服务器必须中止握手并发出相应的警报。

（图2：参数不匹配的完整握手消息流程）

注意：握手的会话记录包含最初的ClientHello/HelloRetryRequest交换；不会因新的ClientHello而重置。

TLS还支持多种优化的握手变体，详见后续章节。

---

2.2.  会话恢复与预共享密钥（PSK）

虽然TLS的PSK可以通过带外方式建立，但也可以在之前的连接中建立，然后用于新连接（“会话恢复”或“使用PSK恢复”）。握手完成后，服务器可以向客户端发送一个PSK身份标识，代表从初始握手派生的唯一密钥（见第4.6.1节）。客户端可以在未来的握手中使用该PSK身份，协商使用对应的PSK。如果服务器接受该PSK，则新连接的安全上下文会与原始连接绑定，且会用从初始握手派生的密钥来启动加密状态，而无需完整的握手。在TLS 1.2及以下版本中，这一功能由“会话ID”和“会话票据”[RFC5077]提供，但在TLS 1.3中已废弃。

PSK可以与(EC)DHE密钥交换结合使用，以提供前向保密性（通过共享密钥），也可以单独使用，但会牺牲应用数据的前向保密性。

（图3）展示了两个握手过程：第一个建立PSK，第二个使用它。

```
首次握手：
  客户端
    ClientHello
    + key_share               -------->
                                服务器
                                + key_share
                      {EncryptedExtensions}
                      {CertificateRequest*}
                             {Certificate*}
                       {CertificateVerify*}
                                 {Finished}
                  <--------     [应用数据*]
    {Certificate*}
    {CertificateVerify*}
    {Finished}                -------->
                                [应用数据]
  
后续握手：
  客户端
    ClientHello
    + key_share*
    + pre_shared_key          -------->
                                服务器
                               + pre_shared_key
                               + key_share*
                      {EncryptedExtensions}
                         {Finished}
                  <--------     [应用数据*]
    {Finished}                -------->
                                [应用数据]
```

-  由于服务器通过PSK进行认证，不会发送Certificate或CertificateVerify消息。

-  客户端提供PSK恢复时，应同时提供"key_share"扩展，以便服务器在必要时拒绝恢复并回退到完整握手。

-  服务器响应"pre_shared_key"扩展，协商使用PSK；也可以响应"key_share"扩展，进行(EC)DHE密钥交换，从而提供前向保密。

当PSK是带外预置时，还必须提供PSK身份和KDF哈希算法。

注意：使用带外预置的预共享密钥时，关键在于在密钥生成过程中使用足够的熵（参见RFC4086）。用密码或低熵源派生共享密钥是不安全的。低熵秘密或密码容易受到字典攻击。即使结合Diffie-Hellman，指定的PSK认证也不是强密码基础的密钥交换，不能防止观察握手的攻击者对密码或预共享密钥进行暴力破解。

---

2.3.  0-RTT数据

当客户端和服务器共享一个PSK（无论是外部获得还是通过前一次握手获得）时，TLS 1.3允许客户端在第一轮（“早期数据”）中发送数据。客户端使用PSK验证服务器，并加密早期数据。

如图4所示，0-RTT数据直接附加在第一轮的1-RTT握手中。其余握手流程与使用PSK恢复的1-RTT握手相同。

（图4：0-RTT握手的消息流程）

---

重要提示：0-RTT数据的安全属性比其他TLS数据弱，具体包括：

1.  该数据不具有前向保密性，因为它仅用提议的PSK派生的密钥加密。

2.  连接之间没有重放保护。普通TLS 1.3 1-RTT数据通过服务器的随机值提供抗重放保护，但0-RTT数据不依赖ServerHello，因此安全性较弱。特别是在数据通过TLS客户端认证或应用协议内部认证时更为明显。相同的警告也适用于任何使用early_exporter_master_secret的场景。

0-RTT数据在一个连接中不能被重复使用（即，服务器不会对同一连接中的相同数据进行两次处理），攻击者也无法使0-RTT数据看起来像1-RTT数据（因为它们使用不同的密钥进行保护）。附录E.5描述了潜在的攻击方式，第8节则介绍了服务器可以采用的机制以限制重放攻击的影响。

3. 表示语言

本文档涉及外部表示中数据的格式化。将使用以下非常基础且略显随意定义的表示语法。

3.1. 基本块大小

所有数据项的表示都明确规定。基本数据块的大小为一个字节（即8位）。多字节数据项是由字节按从左到右、从上到下的顺序连接而成的。对于字节流中的多字节项（以下示例中的数字），其形成方式（采用C语言表示法）为：

```
value = (byte[0] << 8*(n-1)) | (byte[1] << 8*(n-2)) | ... | byte[n-1];
```

这种多字节值的字节顺序是常见的网络字节序（大端格式）。

3.2. 其他说明

注释以“/*”开始，以“*/”结束。

可选组件用双括号“[[ ]]”括起来。

包含未解释数据的单字节实体类型为opaque（不透明）。

类型别名T'定义为已存在类型T的别名，格式为：

```
T T';
```

3.3. 数字

基本的数字数据类型是无符号字节（uint8）。所有更大的数字类型由一系列固定长度的字节连接而成（如第3.1节所述），同样为无符号类型。预定义的数字类型包括：

- uint8
- uint16[2]
- uint24[3]
- uint32[4]
- uint64[8]

所有值（在本规范中以及其他地方）都以网络字节序（大端）传输；例如，十六进制字节01 02 03 04表示的uint32值等同于十进制的16909060。

3.4. 向量

向量（单维数组）是同质数据元素的流。向量的大小可以在文档中指定，也可以在运行时未指定。在任何情况下，长度表示字节数，而非元素数。定义固定长度向量T'（元素类型为T，长度为n）的方法为：

```
T T'[n];
```

这里，T'在数据流中占用n个字节，n是T的大小的倍数。向量的长度不包含在编码的流中。

例如，定义Datum为三个未被协议解释的连续字节，Data为三个连续的Datum，共占用九个字节：

```
opaque Datum[3];      /* 三个未解释的字节 */
Datum Data[9];        /* 三个连续的3字节向量 */
```

可变长度向量通过指定合法长度范围（包括端点）来定义，使用符号<floor..ceiling>。编码时，实际长度在向量内容之前，占用一个或多个字节，表示向量的实际长度，长度字段的值最多占用足够的字节以存储最大长度（ceiling）。长度为零的可变向量称为空向量。

例如：

```
T T'<floor..ceiling>;
```

在以下示例中，“mandatory”是一个长度在300到400字节之间的不可为空的opaque向量，其实际长度字段占用两个字节（uint16），足以表示最大值400（见第3.3节）。类似地，“longer”可以表示最多800字节（或400个uint16元素），且可以为空。编码时，实际长度字段会在向量前面加上两个字节。

```
opaque mandatory<300..400>; /* 长度字段为两字节，不可为空 */
uint16 longer<0..800>;      /* 0到800的uint16元素 */
```

3.5. 枚举类型

还提供一种稀疏的数据类型，称为“enum”或“枚举”。每个定义代表一种不同的类型。只有相同类型的枚举值才能相互赋值或比较。枚举的每个元素都必须被赋值，如示例所示。由于枚举元素无序，它们可以被赋予任何唯一值，顺序不限。

定义格式为：

```
enum { e1(v1), e2(v2), ... , en(vn) [[, (n)]] } Te;
```

未来协议的扩展或新增可能会定义新的值。实现者应能解析并忽略未知值，除非字段定义另有说明。

枚举在字节流中占用空间等于其最大定义的序数值所需的字节数。例如，定义Color为：

```
enum { red(3), blue(5), white(7) } Color;
```

可以选择不带标签的值，强制定义宽度而不引入多余元素。例如，Taste在当前协议版本中只能取值1、2或4，且会占用两个字节（一个uint16）：

```
enum { sweet(1), sour(2), bitter(4), (32000) } Taste;
```

枚举元素的名称在定义类型的作用域内有效。例如，完全限定名为Color.blue。若目标已明确类型，限定名可省略。

```
Color color = Color.blue;  /* 过度限定，但合法 */
Color color = blue;        /* 正确，类型隐式 */
```

枚举的名称不必唯一，数值范围内的不同值可以对应相同的名称。数值范围用两个点“..”分隔，包含端点，主要用于预留空间。

```
enum { sad(0), meh(1..254), happy(255) } Mood;
```

3.6. 构造类型

结构类型可以由基本类型构造而成，方便使用。每个定义声明一个唯一的新类型。定义语法类似C语言。

```
struct {
    T1 f1;
    T2 f2;
    ...
    Tn fn;
} T;
```

允许使用标准向量语法定义固定或可变长度的向量字段。示例中的V1和V2结构（第3.8节）演示了这一点。

结构中的字段可以用类型名限定，语法类似枚举。例如，T.f2表示前述声明中的第二个字段。

3.7. 常量

字段和变量可以用“=”赋予固定值，例如：

```
struct {
    T1 f1 = 8;  /* T.f1始终为8 */
    T2 f2;
} T;
```

3.8. 变体

定义的结构可以根据环境中的某些已知信息具有不同的变体。选择器必须是定义了可能变体的枚举类型。每个“select”分支（如下）指定该变体字段的类型和可选的字段标签。变体的运行时选择机制未由表示语言规定。

```
struct {
    T1 f1;
    T2 f2;
    ...
    Tn fn;
    select (E) {
        case e1: Te1 [[fe1]];
        case e2: Te2 [[fe2]];
        ...
        case en: Ten [[fen]];
    };
} Tv;
```

示例：

```
enum { apple(0), orange(1) } VariantTag;

struct {
    uint16 number;
    opaque string<0..10>; /* 可变长度 */
} V1;

struct {
    uint32 number;
    opaque string[10];    /* 固定长度 */
} V2;

struct {
    VariantTag type;
    select (VariantRecord.type) {
        case apple:  V1;
        case orange: V2;
    };
} VariantRecord;
```

4. 握手协议

握手协议用于协商连接的安全参数。握手消息由TLS记录层提供，封装在一个或多个TLSPlaintext或TLSCiphertext结构中，按照当前激活的连接状态进行处理和传输。

协议消息必须按照第4.4.1节定义的顺序以及第2节图示的流程进行发送。若接收方在意料之外的顺序收到握手消息，必须中止握手并发出“unexpected_message”警报。

新类型的握手消息由IANA根据第11节的规定分配。

4.1. 密钥交换消息

密钥交换消息用于确定客户端和服务器的安全能力，建立共享秘密，包括用于保护后续握手和数据的流量密钥。

4.1.1. 密码协商

在TLS中，密码协商由客户端在ClientHello中提供以下四组选项开始：

- 支持的密码套件列表，指示客户端支持的AEAD算法和HKDF哈希对。

- “supported_groups”扩展（第4.2.7节），指示客户端支持的（EC）DHE组，以及包含（EC）DHE共享的“key_share”扩展（第4.2.8节），用于部分或全部组。

- “signature_algorithms”扩展（第4.2.3节），指示客户端可接受的签名算法。还可以添加“signature_algorithms_cert”扩展（第4.2.3节），以指示证书相关的签名算法。

- “pre_shared_key”扩展（第4.2.11节），包含客户端已知的对称密钥标识符列表，以及“psk_key_exchange_modes”扩展（第4.2.9节），指示可用的PSK密钥交换模式。

如果服务器不选择PSK，则前三个选项完全独立：服务器会自主选择密码套件、（EC）DHE组和密钥共享，以及用于身份验证的签名算法/证书对。如果收到的“supported_groups”与服务器支持的组没有交集，服务器必须以“handshake_failure”或“insufficient_security”警报中止握手。

如果服务器选择了PSK，则必须从客户端“psk_key_exchange_modes”扩展指示的集合中选择一种密钥建立模式（目前为仅PSK或PSK结合（EC）DHE）。注意，如果PSK可以在没有（EC）DHE的情况下使用，则“supported_groups”参数的非重叠不一定是致命的（与前述非PSK情况不同）。

若服务器选择了（EC）DHE组，但客户端在最初的ClientHello中未提供兼容的“key_share”扩展，必须响应一个HelloRetryRequest（第4.1.4节）消息。

若服务器成功选择参数且不需要HelloRetryRequest，则在ServerHello中指示所选参数：

- 若使用PSK，服务器会发送“pre_shared_key”扩展，指示所选密钥。

- 若使用（EC）DHE，服务器还会提供“key_share”扩展。如果未使用PSK，则始终采用（EC）DHE和基于证书的身份验证。

- 若通过证书进行身份验证，服务器会发送Certificate（第4.4.2节）和CertificateVerify（第4.4.3节）消息。在本协议定义的TLS 1.3中，始终使用PSK或证书，但不同时使用两者。未来的文档可能会定义它们的结合方式。

如果服务器无法协商出一组支持的参数（即客户端和服务器的参数没有重叠），它必须中止握手，并发出“handshake_failure”或“insufficient_security”致命警报（详见第6节）。

4.1.2 客户端问候（Client Hello）

当客户端首次连接到服务器时，必须将ClientHello作为其第一个TLS消息进行发送。当服务器用HelloRetryRequest响应客户端的ClientHello时，客户端也会再次发送ClientHello。在这种情况下，客户端必须不加修改地重复发送相同的ClientHello，除非有以下情况：

- 如果在HelloRetryRequest中提供了“key_share”扩展，则用包含指示组中的单个KeyShareEntry的列表替换原有的密钥共享列表。

- 如果存在“early_data”扩展（第4.2.10节），则将其删除。HelloRetryRequest之后不允许使用早期数据。

- 如果HelloRetryRequest中提供了“cookie”扩展，则必须包含该扩展。

- 如果存在“pre_shared_key”扩展，则需要重新计算“obfuscated_ticket_age”和绑定值（binder），并（可选）删除与服务器指示的密码套件不兼容的PSK。

- 可选地，添加、删除或更改“padding”扩展（RFC7685）中的长度。

- 以及未来定义的扩展中可能允许的其他修改。

由于TLS 1.3禁止重新协商，如果服务器已协商TLS 1.3，并在任何其他时间收到ClientHello，必须用“unexpected_message”警报终止连接。

如果服务器之前使用较早版本的TLS建立了连接，并在重新协商中收到TLS 1.3的ClientHello，则必须保持之前的协议版本，不得协商TLS 1.3。

此消息的结构如下：

```
uint16 ProtocolVersion;
opaque Random[32];

uint8 CipherSuite[2];    /* 密码套件选择器 */

struct {
    ProtocolVersion legacy_version = 0x0303;    /* TLS v1.2 */
    Random random;
    opaque legacy_session_id<0..32>;
    CipherSuite cipher_suites<2..2^16-2>;
    opaque legacy_compression_methods<1..2^8-1>;
    Extension extensions<8..2^16-1>;
} ClientHello;
```

- legacy_version：在早期TLS版本中，此字段用于版本协商，表示客户端支持的最高版本。经验表明，许多服务器未正确实现版本协商，导致“版本不兼容”问题，即服务器拒绝支持的高版本ClientHello。在TLS 1.3中，客户端在“supported_versions”扩展中指示其偏好版本（第4.2.1节），而legacy_version字段必须设置为0x0303，即TLS 1.2的版本号。TLS 1.3的ClientHello被识别为legacy_version为0x0303且存在supported_versions扩展，且该扩展中最高版本为0x0304（详见附录D，关于向后兼容性）。

- random：由安全随机数生成器产生的32字节。详见附录C。

- legacy_session_id：在TLS 1.3之前的版本中支持“会话恢复”功能（已与预共享密钥合并，见第2.2节）。具有缓存会话ID的客户端应将此字段设置为该值。在兼容模式（见附录D.4）下，此字段必须非空，因此未提供TLS 1.3之前会话的客户端应生成新的32字节值。该值不必随机，但应不可预测，以避免实现对特定值的固化（ossification）。否则，应将其设置为空（即长度字段为零的单字节值）。

- cipher_suites：客户端支持的对称密码选项列表，具体包括记录保护算法（包括密钥长度）和用于HKDF的哈希函数，按客户端偏好降序排列。值定义见附录B.4。如果列表中包含服务器不识别、不支持或不愿使用的密码套件，服务器必须忽略这些套件，照常处理剩余的套件。如果客户端试图进行PSK密钥协商，应至少广告一个指示与PSK相关的哈希的密码套件。

- legacy_compression_methods：在TLS 1.3之前的版本中，支持压缩的版本，支持的压缩方法列表在此字段中。对于每个TLS 1.3 ClientHello，此向量必须恰好包含一个字节，值为零，对应之前版本TLS中的“null”压缩方法。如果收到的TLS 1.3 ClientHello中此字段值不同，服务器必须以“illegal_parameter”警报中止握手。注意，TLS 1.3服务器可能会收到包含其他压缩方法的TLS 1.2或更早版本的ClientHello（如果协商了早期版本），应遵循相应版本的处理程序。

- extensions：客户端通过在扩展字段中发送数据，请求服务器提供扩展功能。实际的“Extension”格式定义在第4.2节。在TLS 1.3中，某些扩展的使用是强制的，因为功能已迁移到扩展中，以保持ClientHello与早期TLS版本的兼容性。服务器必须忽略未识别的扩展。

所有TLS版本都允许扩展字段可选地跟在compression_methods字段之后。TLS 1.3的ClientHello始终包含扩展（至少包括“supported_versions”扩展，否则会被视为TLS 1.2的ClientHello）。但TLS 1.3服务器可能会收到没有扩展字段的早期版本ClientHello。可以通过检查ClientHello末尾compression_methods后是否有字节来检测扩展的存在。注意，这种检测方法不同于常规TLS中可变长度字段的方式，但为了兼容早期未定义扩展的TLS版本而采用。TLS 1.3服务器需要先进行此检测，仅在“supported_versions”扩展存在时才尝试协商TLS 1.3。如果协商早期版本，必须确保消息中在legacy_compression_methods之后没有数据，或者有有效的扩展块且无数据跟随，否则必须以“decode_error”警报中止。

如果客户端请求扩展中的额外功能，但服务器未提供，客户端可以中止握手。

客户端在发送ClientHello后，等待ServerHello或HelloRetryRequest消息。如果启用了早期数据，客户端可以在等待下一次握手消息时，传输早期应用数据（第2.3节）。

4.1.3 服务器问候（Server Hello）

服务器会在收到ClientHello后，若能协商出一组可接受的参数，则会发送此消息以继续握手。

此消息的结构如下：

```
struct {
    ProtocolVersion legacy_version = 0x0303;    /* TLS v1.2 */
    Random random;
    opaque legacy_session_id_echo<0..32>;
    CipherSuite cipher_suite;
    uint8 legacy_compression_method = 0;
    Extension extensions<6..2^16-1>;
} ServerHello;
```

- legacy_version：在早期TLS版本中，此字段用于版本协商，表示为连接选择的版本号。不幸的是，一些中间设备在遇到新值时会出现故障。在TLS 1.3中，服务器通过“supported_versions”扩展指示其版本，legacy_version必须设置为0x0303（TLS 1.2的版本号）（详见附录D，关于向后兼容性）。

- random：由安全随机数生成器产生的32字节。详见附录C。若协商TLS 1.2或TLS 1.1，最后8字节必须按如下方式覆盖，其余字节必须随机。此结构由服务器生成，且必须独立于ClientHello.random。

- legacy_session_id_echo：客户端的legacy_session_id字段内容。即使客户端的值对应于服务器未选择恢复的缓存会话，此字段也会回显。若客户端收到的legacy_session_id_echo与其发送的不符，必须以“illegal_parameter”警报中止握手。

- cipher_suite：由服务器从ClientHello.cipher_suites中选择的单一密码套件。若客户端收到未曾提供的密码套件，必须以“illegal_parameter”警报中止。

- legacy_compression_method：单字节，值必须为0。

- extensions：扩展列表。ServerHello只应包含建立加密上下文和协商协议版本所需的扩展。所有TLS 1.3的ServerHello都必须包含“supported_versions”扩展。当前的ServerHello还会包含“pre_shared_key”或“key_share”扩展，或两者（在使用PSK结合(EC)DHE密钥协商时）。其他扩展（见第4.2节）在加密的扩展消息中单独发送。

出于向后兼容中间设备的考虑（详见附录D.4），HelloRetryRequest消息采用与ServerHello相同的结构，但随机值设置为“HelloRetryRequest”的SHA-256的特殊值：

```
CF 21 AD 74 E5 9A 61 11 BE 1D 8C 02 1E 65 B8 91
C2 A2 11 16 7A BB 8C 5E 07 9E 09 E2 C8 A8 33 9C
```

收到类型为server_hello的消息后，实现必须先检查随机值，如果匹配此特殊值，则按第4.1.4节的描述处理。

TLS 1.3在服务器随机值中嵌入了向下兼容保护机制。协商TLS 1.2或以下的TLS 1.3服务器，必须在ServerHello中将随机值的最后8字节设置为特殊值：

```
44 4F 57 4E 47 52 44 01
```

协商TLS 1.1或以下时，TLS 1.3服务器必须（TLS 1.2服务器建议）将随机值的最后8字节设置为：

```
44 4F 57 4E 47 52 44 00
```

客户端在收到指示TLS 1.2或以下的ServerHello时，必须检查最后8字节不等于上述值。TLS 1.2客户端也应检查是否不等于第二个值（TLS 1.1或以下）。若匹配，必须以“illegal_parameter”警报中止握手。此机制提供了有限的向下攻击保护，超出Finished交换提供的保护：因为在TLS 1.2及以下版本中存在的ServerKeyExchange消息会对两个随机值签名，使用临时密码套件时，攻击者无法在未被检测的情况下修改随机值。静态RSA不受此保护。

注意：这是对[RFC5246]的变更，实际上许多TLS 1.2的客户端和服务器可能不会完全符合上述行为。

使用TLS 1.2或更早版本进行重新协商的遗留TLS客户端，在重新协商中收到TLS 1.3的ServerHello时，必须以“protocol_version”警报中止握手。注意，TLS 1.3一旦协商成功，重新协商即不再可能。

4.1.4 重新尝试请求（Hello Retry Request）

如果服务器能找到一组可接受的参数，但ClientHello中信息不足以继续握手，它会以此消息响应。正如第4.1.3节所述，HelloRetryRequest的格式与ServerHello相同，legacy_version、legacy_session_id_echo、cipher_suite和legacy_compression_method字段含义相同。但为了方便起见，本文中“HelloRetryRequest”将被视作一种不同的消息。

服务器的扩展必须包含“supported_versions”。此外，它应当包含客户端生成正确的ClientHello对所必需的最小扩展集。与ServerHello一样，HelloRetryRequest不得包含任何未在客户端的ClientHello中首次提供的扩展，除了可选的“cookie”扩展（见第4.2.2节）。

收到HelloRetryRequest后，客户端必须检查第4.1.3节中规定的legacy_version、legacy_session_id_echo、cipher_suite和legacy_compression_method，然后处理扩展，从使用“supported_versions”确定版本开始。如果HelloRetryRequest不会导致ClientHello的任何变化，客户端必须中止握手并发出“illegal_parameter”警报。如果在同一连接中（即ClientHello本身是对HelloRetryRequest的响应）收到第二个HelloRetryRequest，客户端必须中止握手并发出“unexpected_message”警报。

否则，客户端必须处理HelloRetryRequest中的所有扩展，并发送第二个更新的ClientHello。本规范定义的HelloRetryRequest扩展包括：

- supported_versions（见第4.2.1节）
- cookie（见第4.2.2节）
- key_share（见第4.2.8节）

如果客户端收到未在其提供的扩展中提出的密码套件，必须中止握手。服务器必须确保在接收符合规范的更新ClientHello时协商相同的密码套件（如果服务器在协商的第一步中选择密码套件，则会自动实现）。收到ServerHello后，客户端必须检查ServerHello中提供的密码套件是否与HelloRetryRequest中的相同，否则中止握手并发出“illegal_parameter”警报。

此外，在其更新的ClientHello中，客户端不应提供与所选密码套件的哈希不同的预共享密钥。这使得客户端避免在第二个ClientHello中为多个哈希计算部分哈希转录。

HelloRetryRequest中的selected_version值（在“supported_versions”扩展中）必须在ServerHello中保留，如果该值发生变化，客户端必须中止握手并发出“illegal_parameter”警报。

---

4.2. 扩展

许多TLS消息包含标签-长度-值编码的扩展结构。

结构定义如下：
```
struct {
    ExtensionType extension_type;
    opaque extension_data<0..2^16-1>;
} Extension;
```

扩展类型枚举包括（部分列出）：
- server_name（RFC 6066）
- max_fragment_length（RFC 6066）
- status_request（RFC 6066）
- supported_groups（RFC 8422, 7919）
- signature_algorithms（RFC 8446）
- use_srtp（RFC 5764）
- heartbeat（RFC 6520）
- application_layer_protocol_negotiation（RFC 7301）
- signed_certificate_timestamp（RFC 6962）
- client_certificate_type（RFC 7250）
- server_certificate_type（RFC 7250）
- padding（RFC 7685）
- pre_shared_key（RFC 8446）
- early_data（RFC 8446）
- supported_versions（RFC 8446）
- cookie（RFC 8446）
- psk_key_exchange_modes（RFC 8446）
- certificate_authorities（RFC 8446）
- oid_filters（RFC 8446）
- post_handshake_auth（RFC 8446）
- signature_algorithms_cert（RFC 8446）
- key_share（RFC 8446）

其中：
- “extension_type”标识特定扩展类型。
- “extension_data”包含特定扩展类型的相关信息。

扩展类型列表由IANA维护（详见第11节）。扩展通常以请求/响应的方式结构化，部分扩展仅为指示，无对应响应。客户端在ClientHello中发送扩展请求，服务器在ServerHello、EncryptedExtensions、HelloRetryRequest和Certificate消息中响应扩展。服务器在CertificateRequest消息中也可以请求扩展，客户端可以用Certificate消息响应。服务器也可以在NewSessionTicket中主动发送未请求的扩展，但客户端不会直接响应。

实现必须确保未收到对应扩展请求的情况下不发送扩展响应，除了HelloRetryRequest中的“cookie”扩展。收到未请求的扩展时，必须中止握手并发出“unsupported_extension”警报。

下表列出扩展可能出现的消息类型（用缩写表示：CH（ClientHello）、SH（ServerHello）、EE（EncryptedExtensions）、CT（Certificate）、CR（CertificateRequest）、NST（NewSessionTicket）、HRR（HelloRetryRequest））。如果收到的扩展在对应消息中未被定义，必须中止握手并发出“illegal_parameter”警报。

（此处为扩展在不同消息中的出现情况示意表，略。）

当存在多种不同类型的扩展时，它们可以以任何顺序出现，但“pre_shared_key”扩展（第4.2.11节）必须是ClientHello中的最后一个扩展（但可以在ServerHello扩展块中任何位置出现）。在一个扩展块中不得有多个相同类型的扩展。

在TLS 1.3中，与TLS 1.2不同，即使在会话恢复（resumption-PSK）模式下，也会为每次握手协商扩展。然而，0-RTT参数是上一次握手中协商的参数；不匹配可能导致拒绝0-RTT（见第4.2.10节）。

协议中可能出现一些微妙（甚至不那么微妙）的交互，可能会导致整体安全性显著降低。设计新扩展时应考虑以下事项：

- 服务器不同意某个扩展的情况，有些是错误条件（如握手无法继续），有些只是拒绝支持某些功能。一般而言，错误应使用警报（alert）通知，支持拒绝则在服务器扩展响应中用字段表示。
- 扩展应尽可能设计成防止通过操纵握手消息强制使用或不使用某个功能的攻击。无论是否认为某功能存在安全问题，都应遵循此原则。通常，将扩展字段包含在Finished消息的哈希输入中已足够，但当扩展改变握手消息的含义时，必须格外小心。设计者和实现者应意识到，在握手未被认证之前，主动攻击者可以修改消息、插入、删除或替换扩展。

---

4.2.1. 支持的版本

结构定义：
```
struct {
    select (Handshake.msg_type) {
        case client_hello:
            ProtocolVersion versions<2..254>;
        case server_hello: /* 和 HelloRetryRequest */
            ProtocolVersion selected_version;
    };
} SupportedVersions;
```

“supported_versions”扩展由客户端用以指示支持的TLS版本，由服务器用以指示所用版本。扩展包含按偏好顺序排列的支持版本列表，最偏好的版本排在前面。实现必须在包含所有准备协商的TLS版本的ClientHello中发送此扩展（对于本规范，至少包括0x0304，但如果允许协商早期版本，也必须包含它们）。

如果未提供此扩展，符合本规范且支持TLS 1.2的服务器必须协商TLS 1.2或更早版本，即使ClientHello中的legacy_version为0x0304或更晚。服务器可以在收到legacy_version为0x0304或更晚的ClientHello时中止握手。

如果ClientHello中包含此扩展，服务器不得使用ClientHello.legacy_version值进行版本协商，而应仅使用“supported_versions”扩展来确定客户端偏好。服务器只能选择该扩展中列出的TLS版本，忽略任何未知版本。此机制允许在一方支持稀疏范围时协商TLS 1.2之前的版本。支持早期版本的TLS 1.3实现应支持TLS 1.2。服务器必须准备好接收包含此扩展但未在版本列表中包括0x0304的ClientHello。

协商TLS 1.2之前版本的服务器必须设置ServerHello.version，并且不得发送“supported_versions”扩展。协商TLS 1.3的服务器必须响应一个包含所选版本（0x0304）的“supported_versions”扩展，并将ServerHello.legacy_version字段设置为0x0303（TLS 1.2）。客户端在处理ServerHello之前必须检查此扩展（尽管需要解析ServerHello以读取扩展）。如果此扩展存在，客户端必须忽略ServerHello.legacy_version值，只用“supported_versions”扩展来确定版本。如果ServerHello中的“supported_versions”包含客户端未提供的版本或早于TLS 1.3的版本，客户端必须中止握手并发出“illegal_parameter”警报。

---

4.2.2. Cookie

结构定义：
```
struct {
    opaque cookie<1..2^16-1>;
} Cookie;
```

Cookie主要有两个用途：

- 让服务器强制客户端证明其在表面网络地址上的可达性（提供一定的拒绝服务保护措施）。这对于非连接导向的传输尤其有用（参见[RFC6347]示例）。
- 让服务器将状态转移到客户端，从而在不存储任何状态的情况下发送HelloRetryRequest。服务器可以在HelloRetryRequest的cookie中存储ClientHello的哈希（用某种合适的完整性保护算法保护）。

在发送HelloRetryRequest时，服务器可以向客户端提供“cookie”扩展（这是对通常只允许在ClientHello中发送扩展的规则的例外）。在发送新的ClientHello时，客户端必须将从HelloRetryRequest中收到的扩展内容复制到新ClientHello中的“cookie”扩展中。后续连接中，客户端不得在初始ClientHello中使用cookie。

当服务器以无状态方式操作时，可能会在第一和第二个ClientHello之间收到未受保护的change_cipher_spec记录（见第5节）。由于服务器不存储任何状态，这些记录看起来就像是第一个收到的消息。无状态服务器必须忽略这些记录。

---

4.2.3. 签名算法

TLS 1.3 提供了两个扩展，用于指示可以在数字签名中使用的签名算法。“signature_algorithms_cert”扩展适用于证书中的签名，而“signature_algorithms”扩展（最早出现在TLS 1.2中）则适用于CertificateVerify消息中的签名。在证书中找到的密钥必须与所用签名算法的类型相匹配。特别是在RSA密钥和PSS签名方面，如下所述。如果没有“signature_algorithms_cert”扩展，则“signature_algorithms”扩展也适用于证书中的签名。希望服务器通过证书进行身份验证的客户端必须发送“signature_algorithms”扩展。如果服务器通过证书进行身份验证，而客户端未发送“signature_algorithms”扩展，则服务器必须以“missing_extension”警报中止握手（参见第9.2节）。

“signature_algorithms_cert”扩展的添加，旨在支持那些在证书和TLS本身支持不同算法集的实现，能够明确表达其能力。TLS 1.2的实现也应处理此扩展。对于在两者中具有相同策略的实现，可以省略“signature_algorithms_cert”扩展。

这些扩展的“extension_data”字段包含一个SignatureSchemeList值：

```c
enum {
    /* RSA PKCS#1 v1.5 算法 */
    rsa_pkcs1_sha256(0x0401),
    rsa_pkcs1_sha384(0x0501),
    rsa_pkcs1_sha512(0x0601),

    /* ECDSA 算法 */
    ecdsa_secp256r1_sha256(0x0403),
    ecdsa_secp384r1_sha384(0x0503),
    ecdsa_secp521r1_sha512(0x0603),

    /* 使用RSA加密OID的RSASSA-PSS算法 */
    rsa_pss_rsae_sha256(0x0804),
    rsa_pss_rsae_sha384(0x0805),
    rsa_pss_rsae_sha512(0x0806),

    /* EdDSA算法 */
    ed25519(0x0807),
    ed448(0x0808),

    /* 使用RSASSA-PSS的签名算法，公钥OID为rsaEncryption */
    rsa_pss_pss_sha256(0x0809),
    rsa_pss_pss_sha384(0x080a),
    rsa_pss_pss_sha512(0x080b),

    /* 传统算法 */
    rsa_pkcs1_sha1(0x0201),
    ecdsa_sha1(0x0203),

    /* 保留代码点 */
    private_use(0xFE00..0xFFFF),
    (0xFFFF)
} SignatureScheme;
```

SignatureSchemeList结构定义为：

```c
struct {
    SignatureScheme supported_signature_algorithms<2..2^16-2>;
} SignatureSchemeList;
```

注意：此枚举被命名为“SignatureScheme”，是因为TLS 1.2中已有“SignatureAlgorithm”类型，本标准用“SignatureScheme”来替代。全文中使用“签名算法”一词。

每个SignatureScheme值列出客户端愿意验证的单一签名算法，按偏好程度递减排序。签名算法的输入是任意长度的消息，而非摘要。传统上作用于摘要的算法应在TLS中定义为先对输入进行哈希（使用指定的哈希算法），再进行签名。上述代码点组的含义如下：

- RSA PKCS#1 v1.5算法：表示使用RSASSA-PKCS1-v1_5 [RFC8017]，配合[SHS]中定义的相应哈希算法。这些值仅指在证书中出现的签名（参见第4.4.2.2节），不用于签名的TLS握手消息，但为了向后兼容TLS 1.2，可能在“signature_algorithms”和“signature_algorithms_cert”中出现。

- ECDSA算法：表示使用ECDSA [ECDSA]，对应的曲线在ANSI X9.62 [ECDSA]和FIPS 186-4 [DSS]中定义，哈希算法在[SHS]中定义。签名以DER编码的[ X690 ]格式的ECDSA-Sig-Value结构表示。

- RSASSA-PSS RSAE算法：表示使用RSASSA-PSS [RFC8017]，掩码生成函数为1。生成函数中的摘要和签名的摘要都为[SHS]中定义的相应哈希算法。盐的长度必须等于哈希输出长度。如果公钥在X.509证书中，则必须使用rsaEncryption OID [RFC5280]。

- EdDSA算法：表示使用[RFC8032]定义的EdDSA或其后续版本。注意，这些对应“PureEdDSA”算法，而非“prehash”变体。

- RSASSA-PSS PSS算法：表示使用RSASSA-PSS [RFC8017]，掩码生成函数为1。生成函数中的摘要和签名的摘要都为[SHS]中定义的相应哈希算法。盐的长度必须等于哈希算法的输出长度。如果公钥在X.509证书中，则必须使用RSASSA-PSS OID [RFC5756]。在证书签名中，算法参数必须采用DER编码。如果公钥参数存在，则签名中的参数必须与公钥中的参数一致。

- 传统算法：指那些因存在已知弱点而被弃用的算法，特别是SHA-1（在此上下文中，SHA-1在RSA（RSASSA-PKCS1-v1_5或ECDSA中使用）中使用）。这些值仅指在证书中出现的签名（参见第4.4.2.2节），不用于签名的TLS握手消息，但为了向后兼容TLS 1.2，可能在“signature_algorithms”和“signature_algorithms_cert”中出现。端点不应协商这些算法，但出于向后兼容的目的可以。提供这些值的客户端必须将它们列为最低优先级（在SignatureSchemeList中列在所有其他算法之后）。TLS 1.3的服务器不得提供SHA-1签名的证书，除非无法在没有它的情况下生成有效的证书链（参见第4.4.2.2节）。

对自签名证书或信任锚点证书的签名不进行验证，因为它们开始了认证路径（参见[RFC5280]第3.2节）。开始认证路径的证书可以使用未在“signature_algorithms”扩展中声明支持的签名算法。

注意：TLS 1.2定义了不同的扩展。愿意协商TLS 1.2的TLS 1.3实现必须按照[RFC5246]的要求进行，特别是：

- TLS 1.2的ClientHellos可以省略此扩展。

- 在TLS 1.2中，此扩展包含哈希/签名对。对以两个八位字节编码的对进行编码，因此为SignatureScheme值分配了与TLS 1.2编码相符的值。一些遗留对未分配值。这些算法在TLS 1.3中已弃用，不能由任何实现提供或协商。特别是，MD5 [SLOTH]、SHA-224和DSA不得使用。

- ECDSA签名方案与TLS 1.2中的ECDSA哈希/签名对一致。然而，旧的语义未限制签名曲线。如果协商TLS 1.2，必须准备接受使用“supported_groups”扩展中声明的任何曲线的签名。

- 支持RSASSA-PSS（TLS 1.3中强制要求）的实现必须准备接受使用该方案的签名，即使在协商TLS 1.2时也是如此。在TLS 1.2中，RSASSA-PSS用于RSA密码套件。

4.2.4 证书授权机构

“certificate_authorities”扩展用于指示端点支持的证书授权机构（CAs），以及接收端应使用它们来指导证书选择。

“certificate_authorities”扩展的主体由CertificateAuthoritiesExtension结构组成：

```c
opaque DistinguishedName<1..2^16-1>;

struct {
    DistinguishedName authorities<3..2^16-1>;
} CertificateAuthoritiesExtension;
```

authorities：接受的证书授权机构的区分名（Distinguished Names）[X501]列表，采用DER编码的[X690]格式。这些区分名指定信任锚或下级CA的期望区分名，因此此消息既可描述已知的信任锚，也可描述期望的授权空间。

客户端可以在ClientHello消息中发送“certificate_authorities”扩展，服务器也可以在CertificateRequest消息中发送。

“trusted_ca_keys”扩展[RFC6066]功能类似，但更复杂，在TLS 1.3中未使用（但在提供早期TLS版本的客户端的ClientHello中可能出现）。

4.2.5 OID过滤器

“oid_filters”扩展允许服务器提供一组OID/值对，期望客户端证书匹配。这一扩展（如果由服务器提供）必须仅在CertificateRequest消息中发送。

```c
struct {
    opaque certificate_extension_oid<1..2^8-1>;
    opaque certificate_extension_values<0..2^16-1>;
} OIDFilter;

struct {
    OIDFilter filters<0..2^16-1>;
} OIDFilterExtension;
```

filters：一份证书扩展OID [RFC5280]及其允许值的列表，采用DER编码的[X690]格式。一些扩展OID允许多个值（如扩展密钥用法）。如果服务器包含非空的过滤器列表，响应中的客户端证书必须包含所有被客户端识别的指定扩展OID。对于每个被识别的扩展OID，客户端证书中必须包含所有指定的值（但证书也可以有其他值）。客户端必须忽略并跳过任何未识别的扩展OID。如果客户端忽略了某些必需的扩展OID，且提供的证书不满足请求，服务器可以自行决定继续不进行客户端验证或以“unsupported_certificate”警报中止握手。每个OID在过滤器列表中不得出现多次。

PKIX RFC定义了多种证书扩展OID及其对应的值类型。根据类型，匹配的证书扩展值不一定是位比特相等。TLS实现应依赖其PKI库进行证书选择，依据扩展OID。

本文定义了两个标准证书扩展的匹配规则，均在[RFC5280]中定义：

- 证书中的Key Usage扩展：当请求中所有声明的密钥用途位在证书的Key Usage扩展中也被声明时，匹配成功。

- 证书中的Extended Key Usage扩展：当请求中所有的密钥用途OID也出现在证书的Extended Key Usage扩展中时，匹配成功。请求中不得使用特殊的anyExtendedKeyUsage OID。

其他证书扩展的匹配规则可由单独的规范定义。

4.2.6 后握手客户端认证

“post_handshake_auth”扩展用于指示客户端愿意进行后续握手认证（第4.6.2节）。服务器不得向未提供此扩展的客户端发送后续握手的CertificateRequest，也不得发送此扩展。

```c
struct {} PostHandshakeAuth;
```

“post_handshake_auth”扩展的“extension_data”字段为空。

4.2.7 支持的组

客户端发送时，“supported_groups”扩展指示客户端支持的命名组（用于密钥交换），按偏好顺序排列，从最偏好到最不偏好。

注意：在TLS 1.3之前的版本中，此扩展名为“elliptic_curves”，仅包含椭圆曲线组。[RFC8422]和[RFC7919]中有详细定义。此扩展也用于协商ECDSA曲线。签名算法现已单独协商（见第4.2.3节）。

“supported_groups”扩展的“extension_data”字段包含一个NamedGroupList值：

```c
enum {
    /* 椭圆曲线组（ECDHE） */
    secp256r1(0x0017), secp384r1(0x0018), secp521r1(0x0019),
    x25519(0x001D), x448(0x001E),

    /* 有限域组（DHE） */
    ffdhe2048(0x0100), ffdhe3072(0x0101), ffdhe4096(0x0102),
    ffdhe6144(0x0103), ffdhe8192(0x0104),

    /* 保留代码点 */
    ffdhe_private_use(0x01FC..0x01FF),
    ecdhe_private_use(0xFE00..0xFEFF),
    (0xFFFF)
} NamedGroup;
```

结构定义为：

```c
struct {
    NamedGroup named_group_list<2..2^16-1>;
} NamedGroupList;
```

椭圆曲线组（ECDHE）：支持对应的命名曲线，定义在FIPS 186-4 [DSS]或[RFC7748]中。值0xFE00至0xFEFF为私用保留。

有限域组（DHE）：支持对应的有限域组，定义在[RFC7919]中。值0x01FC至0x01FF为私用。

“named_group_list”中的项按发送方偏好排序（最偏好优先）。

从TLS 1.3起，服务器可以向客户端发送“supported_groups”扩展。客户端在握手成功完成前不得依据此信息行动，但可以在后续连接中利用握手成功获得的信息调整“key_share”扩展中的组。如果服务器偏好某个组而又愿意接受ClientHello中的组，应发送“supported_groups”以更新客户端的偏好视图；此扩展应包含所有支持的组，无论它们当前是否被客户端支持。

4.2.8 密钥共享

“key_share”扩展包含端点的加密参数。

客户端可以发送空的client_shares向量，以请求服务器选择组，但这会增加一次往返（参见第4.1.4节）。

结构体 {
    NamedGroup group; // 被交换密钥的命名组
    opaque key_exchange<1..2^16-1>; // 密钥交换信息，其内容由指定的组及其对应定义决定。有限域Diffie-Hellman [DH76]参数在第4.2.8.1节描述；椭圆曲线Diffie-Hellman参数在第4.2.8.2节描述。
} KeyShareEntry;

group：被交换密钥的命名组。

key_exchange：密钥交换信息。该字段的内容由所指定的组及其定义决定。有限域Diffie-Hellman参数在第4.2.8.1节描述；椭圆曲线Diffie-Hellman参数在第4.2.8.2节描述。

在ClientHello消息中，此扩展的“extension_data”字段包含一个“KeyShareClientHello”值：

结构体 {
    KeyShareEntry client_shares<0..2^16-1>; // 按客户端偏好顺序降序排列的提供的密钥分享列表
} KeyShareClientHello;

client_shares：按客户端偏好顺序降序排列的提供的KeyShareEntry值列表。

如果客户端请求HelloRetryRequest，此向量可以为空。每个KeyShareEntry值必须对应在“supported_groups”扩展中提供的组，并且必须按相同顺序出现。然而，这些值可以是“supported_groups”扩展中非连续的子集，且可能省略最偏好的组。如果最偏好的组是新组，且不太可能在足够多的地方支持，从而使预生成密钥分享变得低效，可能会出现这种情况。

客户端可以提供与支持的组数相等的多个KeyShareEntry值，每个代表一组密钥交换参数。例如，客户端可能会提供多个椭圆曲线或多个FFDHE组的密钥分享。每个KeyShareEntry的key_exchange值必须独立生成。客户端不得为同一组提供多个KeyShareEntry值，也不得为未在“supported_groups”扩展中列出的组提供任何KeyShareEntry值。服务器可以检查这些规则的违反情况，并在违反时中止握手并发出“illegal_parameter”警报。

在HelloRetryRequest消息中，此扩展的“extension_data”字段包含一个KeyShareHelloRetryRequest值：

结构体 {
    NamedGroup selected_group; // 服务器打算协商的、双方支持的组，且请求客户端重试的密钥分享
} KeyShareHelloRetryRequest;

selected_group：服务器打算协商的、双方支持的组，且请求客户端重试的密钥分享。

当在HelloRetryRequest中收到此扩展时，客户端必须验证：(1) selected_group字段对应的组在原始ClientHello的“supported_groups”扩展中提供，(2) selected_group字段不对应在原始ClientHello的“key_share”扩展中提供的组。如果任一验证失败，客户端必须中止握手并发出“illegal_parameter”警报。否则，在发送新的ClientHello时，客户端必须用仅包含指示在触发HelloRetryRequest的selected_group字段中的组的新KeyShareEntry的扩展，替换原有的“key_share”扩展。

在ServerHello消息中，此扩展的“extension_data”字段包含一个KeyShareServerHello值：

结构体 {
    KeyShareEntry server_share; // 服务器的密钥分享，必须与客户端的某个分享在同一组
} KeyShareServerHello;

server_share：一个KeyShareEntry值，且与客户端的某个分享在同一组。

如果使用（EC）DHE密钥协商，服务器在ServerHello中只提供一个KeyShareEntry。该值必须与客户端提供的、为协商的密钥交换选择的KeyShareEntry值在同一组中。服务器不得为未在客户端“supported_groups”扩展中列出的组发送KeyShareEntry，也不得在使用“psk_ke” PskKeyExchangeMode时发送。当客户端收到包含“key_share”扩展的HelloRetryRequest时，必须验证ServerHello中选择的NamedGroup是否与HelloRetryRequest中的相同。如果验证失败，客户端必须中止握手并发出“illegal_parameter”警报。

4.2.8.1. Diffie-Hellman参数

Diffie-Hellman [DH76]参数（用于客户端和服务器）编码在KeyShare结构中的KeyShareEntry的不透明字段key_exchange中。该不透明值包含指定组的Diffie-Hellman公钥值（Y = g^X mod p），以大端整数编码，并在左侧用零填充至p的字节大小。

注意：对于给定的Diffie-Hellman组，填充会使所有公钥具有相同长度。

对等方必须验证彼此的公钥Y，确保1 < Y < p-1。这一验证确保远端对等方行为正确，不会强制本地系统进入小子群。

4.2.8.2. ECDHE参数

ECDHE参数（用于客户端和服务器）编码在KeyShare结构中的KeyShareEntry的不透明字段key_exchange中。

对于secp256r1、secp384r1和secp521r1，内容是以下结构的序列化值：

结构体 {
    uint8 legacy_form = 4; // 表示未压缩点格式
    opaque X[coordinate_length]; // x坐标的二进制表示
    opaque Y[coordinate_length]; // y坐标的二进制表示
} UncompressedPointRepresentation;

X和Y分别是x和y值的二进制表示，采用网络字节序。没有内部长度标记，每个数字表示占用的字节数由曲线参数决定。例如，P-256的X和Y各占用32个字节，必要时左侧用零填充；P-384各占用48个字节；P-521各占用66个字节。

对于secp256r1、secp384r1和secp521r1曲线，双方必须验证彼此的公钥Q，确保Q是椭圆曲线上的有效点。验证程序在[ECDSA]第4.3.7节和[KEYAGREEMENT]第5.6.2.3节中定义。验证包括三步：(1) 确认Q不是无穷远点（O），(2) 确认Q = (x, y)中的x和y是正确区间内的整数，(3) 确认(x, y)是椭圆曲线方程的正确解。对于这些曲线，实施者无需验证成员资格是否属于正确的子群。

对于X25519和X448，公钥值的内容是[RFC7748]中定义的相应函数的字节串输入和输出：X25519为32字节，X448为56字节。

注意：TLS 1.3之前的版本允许点格式协商；TLS 1.3取消了此功能，采用每条曲线的单一点格式。

4.2.9. 预共享密钥交换模式

为了使用PSK，客户端必须也发送“psk_key_exchange_modes”扩展。该扩展的语义是客户端仅支持使用这些模式的PSK，这限制了在ClientHello中提供的PSK以及服务器可能通过NewSessionTicket提供的PSK。

如果客户端提供“pre_shared_key”扩展，则必须提供“psk_key_exchange_modes”扩展。若客户端提供“pre_shared_key”但未提供“psk_key_exchange_modes”，服务器必须中止握手。服务器不得选择未在客户端列出的密钥交换模式。该扩展还限制了用于PSK恢复的模式。服务器不应发送与广告模式不兼容的NewSessionTicket，但如果这样做，影响仅在于客户端的恢复尝试失败。

服务器不得发送“psk_key_exchange_modes”扩展。

枚举类型 {
    psk_ke(0), // 仅PSK的密钥交换
    psk_dhe_ke(1), // 使用（EC）DHE的PSK密钥交换
    (255) // 保留
} PskKeyExchangeMode;

结构体 {
    PskKeyExchangeMode ke_modes<1..255>; // 支持的密钥交换模式列表
} PskKeyExchangeModes;

psk_ke：仅使用PSK的密钥交换。在此模式下，服务器不得提供“key_share”。

psk_dhe_ke：使用（EC）DHE的PSK密钥交换。在此模式下，客户端和服务器必须按照第4.2.8节的描述提供“key_share”值。

未来分配的任何值都必须确保传输的协议消息能明确识别服务器选择的模式；目前，这通过ServerHello中是否存在“key_share”来指示。

4.2.10. 早期数据指示

当使用PSK且允许早期数据时，客户端可以在首次消息中发送应用数据。如果客户端选择这样做，必须同时提供“pre_shared_key”和“early_data”扩展。

此扩展的“extension_data”字段包含一个“EarlyDataIndication”值。

结构体 {} 空结构

结构体 {
    select (Handshake.msg_type) {
        case new_session_ticket:   uint32 max_early_data_size; // 早期数据最大大小
        case client_hello:         空
        case encrypted_extensions: 空
    };
} EarlyDataIndication;

有关max_early_data_size字段的使用细节，请参见第4.6.1节。

0-RTT数据的参数（版本、对称密码套件、应用层协议协商（ALPN）[RFC7301]协议等）与所用的PSK相关。对于外部提供的PSK，相关值与密钥一同提供；对于通过NewSessionTicket消息建立的PSK，相关值是在建立PSK的连接中协商的。用于加密早期数据的PSK必须是客户端“pre_shared_key”扩展中列出的第一个PSK。

对于通过NewSessionTicket提供的PSK，服务器必须验证所选PSK身份的票据年龄（通过从PskIdentity.obfuscated_ticket_age中减去ticket_age_add后取模2^32）是否在票据发出时间的一个小容差范围内。如果不在范围内，服务器应继续握手但拒绝0-RTT，并且不应采取其他假设此ClientHello是新鲜的措施。

在第一个消息中发送的0-RTT消息内容类型与其他消息（握手和应用数据）相同（已加密），但受不同密钥保护。收到服务器的Finished消息后，如果服务器接受早期数据，将发送EndOfEarlyData消息以指示密钥变更。该消息将用0-RTT流量密钥加密。

服务器收到“early_data”扩展后，必须采取以下三种行为之一：

- 忽略扩展，返回普通的1-RTT响应。然后，服务器通过尝试用握手流量密钥解密接收的记录，跳过早期数据，丢弃解密失败的记录（最多到max_early_data_size配置值）。一旦成功解密一条记录，即视为客户端第二次发出的消息，继续正常的1-RTT握手。

- 通过响应HelloRetryRequest请求客户端发送另一个ClientHello。客户端不得在后续ClientHello中包含“early_data”扩展。服务器随后通过跳过所有内容类型为“application_data”的记录（表示已加密）来忽略早期数据，最多到max_early_data_size。

- 在EncryptedExtensions中返回自己的“early_data”扩展，表示其打算处理早期数据。服务器不可能只接受部分早期数据消息。即使服务器发送接受早期数据的消息，实际的早期数据可能在生成此消息时已在传输中。

为了接受早期数据，服务器必须已接受PSK密码套件，并选择客户端“pre_shared_key”扩展中提供的第一个密钥。此外，必须验证以下值与所选PSK相关的值相同：

- TLS版本号
- 选择的密码套件
- 选择的ALPN [RFC7301]协议（如果有）

这些要求是使用相关PSK进行1-RTT握手所需条件的超集。对于外部建立的PSK，相关值与密钥一同提供；对于通过NewSessionTicket建立的PSK，相关值是在建立PSK的连接中协商的。

未来的扩展必须定义其与0-RTT的交互方式。

如果任何验证失败，服务器不得响应扩展，并且必须使用上述前两种机制之一（回退到1-RTT或2-RTT）丢弃所有第一轮消息。如果客户端尝试进行0-RTT握手但被服务器拒绝，服务器通常没有0-RTT记录保护密钥，必须使用试解密（使用1-RTT握手密钥或在HelloRetryRequest中查找明文ClientHello）来找到第一个非0-RTT消息。

如果服务器选择接受“early_data”扩展，则它必须遵守处理早期数据记录时所有记录的错误处理要求。具体而言，如果服务器未能解密在接受“early_data”扩展后发送的0-RTT记录，它必须根据第5.2节的规定，使用“bad_record_mac”警报终止连接。

如果服务器拒绝“early_data”扩展，客户端应用可以在握手完成后选择重新传输之前在早期数据中发送的应用数据。请注意，自动重新传输早期数据可能会导致对连接状态的错误假设。例如，当协商的连接使用的ALPN协议与早期数据所用的协议不同，应用可能需要构造不同的消息。同样，如果早期数据假设了连接状态的某些内容，可能在握手完成后错误地发送。

TLS实现不应自动重新发送早期数据；应用程序更适合决定何时进行重传。除非协商的连接使用相同的ALPN协议，否则TLS实现不得自动重新发送早期数据。

4.2.11. 预共享密钥扩展

“pre_shared_key”扩展用于协商在特定握手中使用的预共享密钥的身份，结合PSK密钥建立。

该扩展的“extension_data”字段包含一个“PreSharedKeyExtension”值：

```c
struct {
    opaque identity<1..2^16-1>;
    uint32 obfuscated_ticket_age;
} PskIdentity;

opaque PskBinderEntry<32..255>;

struct {
    PskIdentity identities<7..2^16-1>;
    PskBinderEntry binders<33..2^16-1>;
} OfferedPsks;

struct {
    select (Handshake.msg_type) {
        case client_hello: OfferedPsks;
        case server_hello: uint16 selected_identity;
    };
} PreSharedKeyExtension;
```

- identity：密钥的标签。例如，票据（见附录B.3.4）或外部建立的预共享密钥的标签。

- obfuscated_ticket_age：密钥年龄的模糊版本。第4.2.11.1节描述了如何为通过NewSessionTicket消息建立的身份形成此值。对于外部建立的身份，应使用值为0的obfuscated_ticket_age，且服务器必须忽略该值。

- identities：客户端愿意与服务器协商的身份列表。如果与“early_data”扩展（见第4.2.10节）一同发送，第一个身份用于0-RTT数据。

- binders：一系列HMAC值，每个值对应身份列表中的一个，按相同顺序计算，具体方法如下。

- selected_identity：服务器选择的身份，表示为客户端身份列表中的（0-based）索引。

每个PSK都关联一个哈希算法。对于通过票据机制（第4.6.1节）建立的PSK，此算法为建立票据的连接上的KDF哈希算法。对于外部建立的PSK，哈希算法必须在建立时设置，或如果未定义，则默认为SHA-256。服务器必须确保选择了兼容的PSK（如果有）和密码套件。

在TLS 1.3之前的版本中，服务器名称标识（SNI）值应与会话相关联（第3节，[RFC6066]），服务器必须确保会话中的SNI值与恢复握手中指定的值匹配。然而，实际上实现对使用的两个SNI值的选择不一致，导致客户端在实际中强制执行一致性要求。在TLS 1.3中，SNI值始终在恢复握手中明确指定，服务器无需将SNI值与票据关联。然而，客户端应将SNI与PSK一起存储，以满足第4.6.1节的要求。

实现者注意事项：当会话恢复是PSK的主要用途时，最简单的实现方式是先协商密码套件，然后排除任何不兼容的PSK。任何未知的PSK（例如，不在PSK数据库中或用未知密钥加密的）应被忽略。如果未找到任何可接受的PSK，服务器应尽可能执行非PSK握手。如果需要向后兼容，客户端提供的外部建立的PSK应影响密码套件的选择。

在接受PSK密钥建立之前，服务器必须验证相应的binder值（见第4.2.11.2节）。如果该值不存在或验证失败，服务器必须中止握手。服务器不应尝试验证多个binder，而应只选择一个PSK并验证对应的binder。关于此要求的安全理由，请参见第8.2节和附录E.6。为了接受PSK密钥建立，服务器会发送一个“pre_shared_key”扩展，指示所选的身份。

客户端必须验证服务器的selected_identity在客户端提供的范围内，且服务器选择的密码套件指示了与PSK相关的哈希算法，并且如果ClientHello的“psk_key_exchange_modes”扩展要求，必须存在服务器的“key_share”扩展。如果这些值不一致，客户端必须以“illegal_parameter”警报中止握手。

如果服务器提供了“early_data”扩展，客户端必须验证服务器的selected_identity为0。如果返回其他值，客户端必须以“illegal_parameter”警报中止握手。

“pre_shared_key”扩展必须是ClientHello中的最后一个扩展（这样便于实现，如下所述）。服务器必须检查它是否为最后一个扩展，否则应以“illegal_parameter”警报中止握手。

4.2.11.1. 票据年龄

客户端对票据年龄的看法是自收到NewSessionTicket消息起的时间。客户端不得尝试使用年龄大于票据提供的“ticket_lifetime”值的票据。每个PskIdentity的“obfuscated_ticket_age”字段包含一个模糊版本的票据年龄，通过将以毫秒为单位的年龄加上票据中包含的“ticket_age_add”值（见第4.6.1节），再对2^32取模形成。此加法防止被动观察者关联连接，除非票据被重复使用。注意，NewSessionTicket消息中的“ticket_lifetime”以秒为单位，而“obfuscated_ticket_age”以毫秒为单位。由于票据的有效期限制为一周，32位足以表示任何合理的年龄，即使以毫秒为单位。

4.2.11.2.  PSK绑定器

PSK绑定器值在PSK与当前握手之间形成绑定，以及在生成PSK的握手（如果通过NewSessionTicket消息）与当前握手之间形成绑定。每个绑定器条目是对包含部分ClientHello（直到并包括PreSharedKeyExtension.identities字段）的转录哈希（见第4.4.1节）进行的HMAC计算。也就是说，它包括所有ClientHello内容，但不包括绑定器列表本身。消息的长度字段（包括整体长度、扩展块长度和“pre_shared_key”扩展的长度）都设置为假设存在正确长度的绑定器。

PskBinderEntry的计算方式与Finished消息（第4.4.4节）相同，但基础密钥为通过密钥调度从对应的PSK派生的binder_key（见第7.1节）。

如果握手中包含HelloRetryRequest，则初始ClientHello和HelloRetryRequest都包含在转录中，以及新的ClientHello。例如，客户端发送ClientHello1时，其绑定器将基于：

```
Transcript-Hash(截断(ClientHello1))
```

其中，截断()会从ClientHello中移除绑定器列表。

如果服务器响应HelloRetryRequest，客户端随后发送ClientHello2，其绑定器将基于：

```
Transcript-Hash(ClientHello1,
                HelloRetryRequest,
                截断(ClientHello2))
```

所有其他握手哈希计算中都包含完整的ClientHello1/ClientHello2。注意，在第一轮中，直接对截断的ClientHello1进行哈希，而在第二轮中，先对ClientHello1进行哈希，然后作为“message_hash”消息重新注入，如第4.4.1节所述。

4.2.11.3. 处理顺序

允许客户端在收到服务器的Finished之前“流式”传输0-RTT数据，只有在收到Finished后，才发送EndOfEarlyData消息，然后继续剩余的握手。为了避免死锁，在接受“early_data”时，服务器必须先处理客户端的ClientHello，然后立即发送其消息组，而不是等待客户端的EndOfEarlyData消息后再发送ServerHello。

4.3. 服务器参数

服务器的接下来的两个消息，EncryptedExtensions和CertificateRequest，包含由服务器提供的决定握手其余部分的信息。这些消息用从server_handshake_traffic_secret派生的密钥加密。

4.3.1.  Encrypted Extensions

在所有握手中，服务器必须在ServerHello消息之后立即发送EncryptedExtensions消息。这是第一个用从server_handshake_traffic_secret派生的密钥加密的消息。

EncryptedExtensions消息包含可以保护的扩展，即那些不需要建立加密上下文但不与单个证书相关的扩展。客户端必须检查EncryptedExtensions中是否存在任何禁止的扩展，如果发现任何，应以“illegal_parameter”警报中止握手。

消息结构：

```c
struct {
    Extension extensions<0..2^16-1>;
} EncryptedExtensions;
```

extensions：扩展列表。更多信息请参见第4.2节的表。

4.3.2.  证书请求

进行证书验证的服务器可以选择请求客户端提供证书。如果发送此消息，必须在EncryptedExtensions之后。

消息结构：

```c
struct {
    opaque certificate_request_context<0..2^8-1>;
    Extension extensions<2..2^16-1>;
} CertificateRequest;
```

- certificate_request_context：标识证书请求的不透明字符串，将在客户端的Certificate消息中回显。该字段在此连接范围内必须唯一（以防止重放客户端CertificateVerify消息）。除非用于第4.6.2节描述的握手后身份验证交换，否则此字段应为空（长度为零）。在请求握手后身份验证时，服务器应使上下文不可预测（例如，随机生成），以防止具有临时访问客户端私钥的攻击者预先计算有效的CertificateVerify消息。

- extensions：描述被请求证书参数的扩展集。必须指定“signature_algorithms”扩展，其他扩展可根据定义选择性包含。客户端应忽略未识别的扩展。

在TLS的早期版本中，CertificateRequest消息携带一份签名算法和证书颁发机构列表，服务器接受这些列表。在TLS 1.3中，前者通过发送“signature_algorithms”和可选的“signature_algorithms_cert”扩展表达，后者通过发送“certificate_authorities”扩展（见第4.2.4节）表达。

使用PSK进行验证的服务器不得在主握手中发送CertificateRequest消息，但可以在握手后身份验证中（第4.6.2节）发送，前提是客户端已发送“post_handshake_auth”扩展（第4.2.6节）。

4.4. 认证消息

如第2节所述，TLS通常使用一组通用消息进行认证、密钥确认和握手完整性：Certificate、CertificateVerify和Finished。（PSK绑定器也执行密钥确认，方式类似。）这三条消息总是在握手飞行的最后发送。Certificate和CertificateVerify消息仅在特定情况下发送，具体如下。Finished消息始终作为认证块的一部分发送。这些消息用从[sender]_handshake_traffic_secret派生的密钥加密。

认证消息的计算都统一采用以下输入：

- 用于认证的证书和签名密钥。

- 包含将被加入转录哈希的消息集的握手上下文。

- 用于计算MAC密钥的基础密钥。

基于这些输入，消息内容包括：

- Certificate：用于认证的证书，以及链中的支持证书。注意，基于证书的客户端认证在PSK握手流程（包括0-RTT）中不可用。

证书验证：对握手上下文中包含的所有握手消息的哈希值进行签名。

完成：使用从基础密钥派生的MAC密钥，对值Transcript-Hash(握手上下文、证书、证书验证)进行消息认证码（MAC）计算。

以下表格定义了每种场景下的握手上下文和MAC基础密钥：

| 模式      | 握手上下文                         | 基础密钥                         |
|-----------|-----------------------------------|----------------------------------|
| 服务器    | 客户端Hello之后的所有消息（包括加密扩展/证书请求） | 服务器握手流量秘密               |
| 客户端    | 客户端Hello之后的所有消息（包括服务器的Finished/EndOfEarlyData） | 客户端握手流量秘密               |
| 后握手    | 客户端Hello之后的所有消息（包括客户端的Finished和证书请求） | 客户端应用流量秘密_N             |

4.4.1. 传输哈希（Transcript Hash）

TLS中的许多密码学计算都使用传输哈希值。该值通过对所有包含的握手消息（包括握手消息头中的类型和长度字段，但不包括记录层头）进行哈希计算得出。例如：

Transcript-Hash(M1, M2, ... Mn) = Hash(M1 || M2 || ... || Mn)

在某些特殊情况下，例如服务器用HelloRetryRequest响应ClientHello时，ClientHello1的值会被一个特殊的合成握手消息（类型为“message_hash”）替代，该消息包含Hash(ClientHello1)。即：

Transcript-Hash(ClientHello1, HelloRetryRequest, ... Mn) =
    Hash(message_hash ||
         00 00 Hash.length ||
         Hash(ClientHello1) ||
         HelloRetryRequest || ... || Mn)

这样设计的原因是为了让服务器可以在无状态的情况下发出HelloRetryRequest，只需在cookie中存储ClientHello1的哈希值，而不必导出整个中间哈希状态（详见第4.2.2节）。

具体而言，传输哈希值始终从以下握手消息序列中取出，从第一个ClientHello开始，包括所有已发送的消息：ClientHello、HelloRetryRequest、ClientHello、ServerHello、EncryptedExtensions、服务器的CertificateRequest、服务器的Certificate、服务器的CertificateVerify、服务器的Finished、EndOfEarlyData、客户端的Certificate、客户端的CertificateVerify和客户端的Finished。

通常，实现可以通过维护一个基于协商哈希的连续传输哈希值来实现。注意，后续的后握手认证不包括彼此，只包括到主握手结束的消息。

4.4.2. 证书（Certificate）

该消息向对端传递端点的证书链。

当协商的密钥交换方法使用证书进行认证时（包括本文件定义的所有密钥交换方法，除PSK外），服务器必须发送Certificate消息。

客户端只有在服务器请求客户端认证（通过CertificateRequest消息，详见4.3.2节）时，才必须发送Certificate消息。如果服务器请求客户端认证但没有合适的证书可用，客户端必须发送一个空的Certificate消息（即“certificate_list”字段长度为0）。无论Certificate消息是否为空，Finished消息都必须发送。

消息结构如下：

```c
enum {
    X509(0),
    RawPublicKey(2),
    (255)
} CertificateType;

struct {
    select (certificate_type) {
        case RawPublicKey:
            /* 来自RFC 7250 ASN.1_subjectPublicKeyInfo */
            opaque ASN1_subjectPublicKeyInfo<1..2^24-1>;

        case X509:
            opaque cert_data<1..2^24-1>;
    };
    Extension extensions<0..2^16-1>;
} CertificateEntry;

struct {
    opaque certificate_request_context<0..2^8-1>;
    CertificateEntry certificate_list<0..2^24-1>;
} Certificate;
```

- certificate_request_context：如果此消息是对CertificateRequest的响应，则为该请求中的值；否则（如服务器认证场景）应为空。

- certificate_list：一组（链式）CertificateEntry结构，每个包含一个证书及其扩展。

- extensions：一组用于CertificateEntry的扩展值。扩展格式定义在第4.2节。目前，服务器证书的有效扩展包括OCSP状态扩展[RFC6066]和SignedCertificateTimestamp扩展[RFC6962]；未来可能会定义其他扩展。来自服务器的Certificate消息中的扩展必须与ClientHello中的扩展一致；来自客户端的Certificate消息中的扩展必须与CertificateRequest中的扩展一致。如果某个扩展适用于整个链，应在第一个CertificateEntry中包含。

如果在加密扩展（EncryptedExtensions）中未协商“server_certificate_type”或“client_certificate_type”扩展，或协商了X.509证书类型，则每个CertificateEntry包含一个DER编码的X.509证书。发件人的证书必须出现在列表的第一个CertificateEntry中。后续的每个证书应直接证实前一个证书。由于证书验证需要独立分发信任锚，指定信任锚的证书可以省略在链中，只要已知支持的对端拥有任何省略的证书。

注意：在TLS 1.3之前，"certificate_list"的顺序要求每个证书都证实前一个证书；但一些实现允许一定的灵活性。服务器有时会同时发送当前和已弃用的中间证书以实现过渡，或配置不当，但这些情况仍可正确验证。为最大兼容性，所有实现应准备处理任何TLS版本可能出现的多余证书和任意顺序，除了必须放在第一位的终端实体证书。

如果协商了RawPublicKey证书类型，则certificate_list中最多应包含一个CertificateEntry，且其中包含RFC 7250第3节定义的ASN1_subjectPublicKeyInfo值。

RFC 6091定义的OpenPGP证书类型[MUST NOT]与TLS 1.3一起使用。

服务器的certificate_list必须始终非空。如果客户端没有合适的证书响应服务器的认证请求，则会发送空的certificate_list。

4.4.2.1. OCSP状态和SCT扩展

[RFC6066]和[RFC6961]定义了协商服务器向客户端发送OCSP响应的扩展。在TLS 1.2及以下版本中，服务器通过空扩展响应来表示协商了此扩展，OCSP信息包含在CertificateStatus消息中。在TLS 1.3中，OCSP信息包含在包含相关证书的CertificateEntry中的扩展中。具体来说，来自服务器的"status_request"扩展的主体必须是[RFC6066]定义的CertificateStatus结构，并按[RFC6960]的定义进行解释。

注意：status_request_v2扩展[RFC6961]已被弃用。TLS 1.3服务器在处理ClientHello时不得基于其存在或信息作出反应；特别是，它们不得在EncryptedExtensions、CertificateRequest或Certificate消息中发送status_request_v2扩展。TLS 1.3服务器应能处理包含该扩展的ClientHello，因为早期协议版本的客户端可能会发送。

服务器可以在CertificateRequest消息中通过空的"status_request"扩展请求客户端提供OCSP响应。如果客户端选择发送OCSP响应，其"status_request"扩展的主体必须是[RFC6066]定义的CertificateStatus结构。

类似地，[RFC6962]定义了在TLS 1.2及以下版本中，服务器可以在ServerHello中通过扩展发送签名的证书时间戳（SCT）。在TLS 1.3中，SCT信息包含在CertificateEntry中的扩展中。

4.4.2.2. 服务器证书选择

以下规则适用于服务器发送的证书：

- 证书类型必须是X.509v3 [RFC5280]，除非明确协商另行规定（如[RFC7250]）。

- 服务器的终端实体证书的公钥（及相关限制）必须与客户端的"signature_algorithms"扩展中选择的认证算法兼容（目前为RSA、ECDSA或EdDSA）。

- 证书必须允许用其密钥进行签名（即，如果存在Key Usage扩展，则digitalSignature位必须被设置），且签名方案应在客户端的"signature_algorithms"/"signature_algorithms_cert"扩展中声明（详见4.2.3节）。

- "server_name" [RFC6066]和"certificate_authorities"扩展用于引导证书选择。由于服务器可能要求存在"server_name"扩展，客户端应在适用时发送此扩展。

- 由服务器提供的所有证书必须由客户端支持的签名算法签名（如果客户端能提供相应链）。自签名证书或预期为信任锚的证书不在链验证范围内，因此可以用任何算法签名。

- 如果服务器无法生成仅由支持的算法签名的证书链，则应继续握手，向客户端发送其选择的证书链，可能包含客户端未支持的算法。此备用链通常不应使用已弃用的SHA-1哈希算法，但如果客户端允许，则可以使用。

- 如果客户端无法用提供的证书构建可接受的链，并决定中止握手，则必须以适当的证书相关警报（默认为"unsupported_certificate"）中止。

- 如果服务器有多个证书，将根据上述标准（以及其他因素如传输层端点、本地配置和偏好）选择其中之一。

4.4.2.3. 客户端证书选择

客户端发送的证书应遵循以下规则：

- 证书类型必须是X.509v3 [RFC5280]，除非明确协商另行规定（如[RFC7250]）。

- 如果CertificateRequest消息中包含"certificate_authorities"扩展，则链中的至少一个证书应由列出的CA之一签发。

- 证书必须使用可接受的签名算法签名（详见4.3.2节），这放宽了之前版本TLS中对签名算法的限制。

- 如果CertificateRequest中包含非空的"oid_filters"扩展，则终端实体证书必须匹配客户端识别的OID（详见4.2.5节）。

4.4.2.4. 接收Certificate消息

一般而言，详细的证书验证过程超出TLS范围（参见[RFC5280]）。本节提供TLS特定的要求。

- 如果服务器提供空的Certificate消息，客户端必须以"decode_error"警报中止握手。

- 如果客户端不发送任何证书（即发送空的Certificate消息），服务器可以自行决定继续握手（不进行客户端认证）或以"certificate_required"警报中止。

- 如果证书链中的某个证书在验证时需要用MD5哈希的签名算法，则必须以"bad_certificate"警报中止握手。SHA-1已被弃用，建议任何端点在验证证书时避免使用SHA-1，否则也应中止。

- 所有端点应尽快过渡到使用SHA-256或更强的算法，以保持与逐步淘汰SHA-1支持的实现的互操作性。

- 证书中使用的签名算法可以不同于签名密钥的算法（例如，用ECDSA签名的RSA密钥）。

4.4.3. 证书验证（Certificate Verify）

此消息用于明确证明端点拥有与其证书对应的私钥。CertificateVerify消息还为到目前为止的握手过程提供完整性保障。当服务器通过证书进行身份验证时，必须发送此消息；当客户端通过证书进行身份验证（即Certificate消息非空）时，必须发送此消息。发送时，此消息必须紧接在Certificate消息之后，且在Finished消息之前。

此消息的结构如下：

```c
struct {
    SignatureScheme algorithm;
    opaque signature<0..2^16-1>;
} CertificateVerify;
```

其中，algorithm字段指定所用的签名算法（详见第4.2.3节的定义）。签名是使用该算法的数字签名。签名覆盖的内容是第4.4.1节描述的哈希输出，即：

```
Transcript-Hash(Handshake Context, Certificate)
```

数字签名是对以下内容的串联进行计算的：

- 一个由64个字节0x20（空格）组成的字符串
- 上下文字符串
- 一个单一的0字节，作为分隔符
- 要签名的内容

此结构旨在防止对TLS早期版本的攻击，在早期版本中，ServerKeyExchange格式可能导致攻击者能够用特定的32字节前缀（ClientHello.random）签名消息。64字节的填充清除了该前缀以及由服务器控制的ServerHello.random。

服务器签名的上下文字符串为：
"TLS 1.3, server CertificateVerify"  
客户端签名的上下文字符串为：
"TLS 1.3, client CertificateVerify"  
该字符串用于区分不同上下文中的签名，帮助防范潜在的跨协议攻击。

例如，假设转录哈希为32字节的01（适用于SHA-256），则服务器CertificateVerify的签名内容为：

```
2020202020202020202020202020202020202020202020202020202020202020
2020202020202020202020202020202020202020202020202020202020202020
544c5320312e332c207365727665722043657274696669636174655665726966
79
00
0101010101010101010101010101010101010101010101010101010101010101
```

在发送端，计算CertificateVerify消息的签名字段的过程如下：

- 输入：
  - 被签名的内容
  - 与前一消息中发送的证书对应的私钥

- 若由服务器发送，签名算法必须是客户端"signature_algorithms"扩展中提供的算法之一，除非没有支持的算法能生成有效证书链（详见第4.2.3节）。

- 若由客户端发送，签名算法必须是"signature_algorithms"扩展中的supported_signature_algorithms字段所列的算法之一。

- 签名算法还必须与发送端实体证书中的密钥兼容。RSA签名必须使用RSASSA-PSS算法，无论"signature_algorithms"中是否出现RSASSA-PKCS1-v1_5算法。SHA-1算法绝不应在CertificateVerify消息中使用。

所有在本规范中定义的SHA-1签名算法仅用于遗留证书，不适用于CertificateVerify签名。

接收方必须验证签名字段。验证过程包括：

- 被签名的内容
- 证书中的公钥（在相关Certificate消息中）
- 从CertificateVerify消息中接收的数字签名

验证失败时，必须以"decrypt_error"警报终止握手。

4.4.4. 完成（Finished）

Finished消息是认证块中的最后一条消息。它对于提供握手的身份验证和已计算密钥的验证至关重要。

接收方必须验证Finished消息的内容是否正确，若不正确，则以"decrypt_error"警报终止连接。

一旦一方发送了Finished消息并验证了对方的Finished消息后，即可开始在连接上发送和接收应用数据。在以下两种情况下，可以在收到对方Finished之前发送数据：

1. 客户端使用第4.2.10节描述的0-RTT数据。
2. 服务器可以在发送第一轮数据后立即发送数据，但由于握手尚未完成，不能保证对方的身份或其存活（即ClientHello可能被重放）。

用于计算Finished消息的密钥来自第4.4节定义的基础密钥，使用HKDF（详见第7.1节）：

```
finished_key = HKDF-Expand-Label(BaseKey, "finished", "", Hash.length)
```

消息结构如下：

```c
struct {
    opaque verify_data[Hash.length];
} Finished;
```

verify_data的计算方式为：

```
verify_data = HMAC(finished_key, Transcript-Hash(Handshake Context, Certificate*, CertificateVerify*))
```

（*表示仅在存在时包括）

HMAC [RFC2104]使用握手的哈希算法。如上所述，HMAC的输入通常可以通过运行中的哈希（即此时的握手哈希）实现。

在早期版本的TLS中，verify_data总是12个字节长。在TLS 1.3中，它的大小等于用于握手的哈希算法的HMAC输出长度。

注意：警报和任何非握手记录类型都不是握手消息，不包括在哈希计算中。

任何在Finished消息之后的记录必须使用第7.2节描述的应用流量密钥进行加密。特别是，这包括服务器对客户端Certificate和CertificateVerify消息的响应中发送的任何警报。

4.5. 早期数据结束（End of Early Data）

```c
struct {} EndOfEarlyData;
```

如果服务器在EncryptedExtensions中发送了"early_data"扩展，客户端必须在收到服务器的Finished后发送EndOfEarlyData消息；如果服务器未在EncryptedExtensions中发送"early_data"扩展，则客户端不得发送EndOfEarlyData消息。此消息表示所有的0-RTT应用数据（如果有）已传输完毕，后续记录由握手流量密钥保护。服务器不得发送此消息，接收方必须在收到此消息后以"unexpected_message"警报终止连接。此消息在客户端早期流量密钥派生的密钥下加密。

4.6. 握手后消息（Post-Handshake Messages）

TLS还允许在主握手完成后发送其他消息。这些消息使用握手内容类型，并由相应的应用流量密钥加密。

4.6.1. 新会话票据（New Session Ticket）

在服务器收到客户端的Finished消息后，可以随时发送NewSessionTicket消息。该消息在票据值与由恢复主密钥派生的秘密PSK之间建立唯一关联（详见第7节）。

客户端可以在未来的握手中使用此PSK，只需在ClientHello的"pre_shared_key"扩展中包含票据值（第4.2.11节）。服务器可以在单一连接中多次发送票据，可能在每次握手后或特定事件后（详见附录C.4）。例如，服务器可能在后握手认证后发送新票据，以封装额外的客户端认证状态。多票据对客户端有多种用途，包括：

- 开启多个并行的HTTP连接
- 通过（例如）Happy Eyeballs [RFC8305]或相关技术进行接口和地址族的连接竞速

每个票据只能与使用相同KDF哈希算法的密码套件一起恢复。

客户端只有在新SNI值对所提供的证书有效且与原始会话中的SNI值匹配时，才会尝试恢复。后者是性能优化：通常，不同服务器由单一证书覆盖，彼此接受对方的票据的可能性很低；因此，在这种情况下尝试恢复会浪费一次性票据。如果提供了此类指示（外部或其他方式），客户端可以使用不同的SNI值进行恢复。

在恢复时，如果向调用应用报告SNI值，必须使用恢复的ClientHello中发送的值，而非之前会话中的值。注意，如果服务器拒绝所有带不同SNI值的PSK身份，则这两个值始终相同。

注意：尽管恢复主密钥依赖于客户端的第二轮发出，但未请求客户端认证的服务器可以独立计算剩余的转录内容，并在发送Finished后立即发送NewSessionTicket，而无需等待客户端的Finished。这在客户端预期同时开启多个TLS连接并希望减少恢复握手开销的场景中可能适用。

```c
struct {
    uint32 ticket_lifetime;
    uint32 ticket_age_add;
    opaque ticket_nonce<0..255>;
    opaque ticket<1..2^16-1>;
    Extension extensions<0..2^16-2>;
} NewSessionTicket;
```

- ticket_lifetime：表示票据的有效期（秒），为网络字节序的32位无符号整数，值不得超过604800秒（7天）。值为零表示应立即丢弃票据。客户端不得缓存超过7天的票据，无论ticket_lifetime如何，也可根据本地策略提前删除。服务器可能将票据视为有效期短于ticket_lifetime所示。

- ticket_age_add：由安全随机生成的32位值，用于隐藏票据的实际年龄。客户端在"pre_shared_key"扩展中包含的票据年龄会加上此值（模2^32）以得到传输值。服务器必须为每个票据生成新的此值。

- ticket_nonce：每个票据唯一的值，用于区分不同票据。

- ticket：用作PSK身份的票据值。票据是一个不透明标签，可以是数据库查找键，也可以是自加密和自验证的值。

- extensions：票据的扩展值集合。扩展格式定义在第4.2节。客户端必须忽略未知扩展。

目前唯一定义的扩展是"early_data"，表示该票据可用于发送0-RTT数据（第4.2.10节）。它的值如下：

```c
max_early_data_size：客户端允许使用此票据发送的最大0-RTT数据量（字节数）。仅计算应用数据负载（即明文，不包括填充或内部内容类型字节）。如果接收的0-RTT数据超过此值，服务器应以"unexpected_message"警报终止连接。注意，由于缺乏加密材料，拒绝早期数据的服务器无法区分填充和内容，因此客户端不应依赖在早期记录中发送大量填充。

PSK的计算方式为：

HKDF-Expand-Label(resumption_master_secret, "resumption", ticket_nonce, Hash.length)

由于每个NewSessionTicket的ticket_nonce值不同，故每个票据会派生出不同的PSK。

原则上，可以持续发放新票据，无限期延长从非PSK握手（很可能与对端证书相关）中派生的密钥材料的有效期。建议实现对密钥材料总有效期设置限制，这些限制应考虑对端证书的有效期、可能的吊销以及对端的在线CertificateVerify签名的时间。

4.6.2. 握手后认证（Post-Handshake Authentication）

当客户端发送了"post_handshake_auth"扩展（第4.2.6节）后，服务器可以在任何时候通过发送CertificateRequest消息请求客户端认证。客户端必须用相应的认证消息（第4.4节）响应。如果客户端选择认证，必须发送Certificate、CertificateVerify等消息。

完成了。如果客户端拒绝，必须发送一个不包含证书的Certificate消息，随后发送Finished消息。客户端在收到某个响应的所有消息必须连续出现，不能夹杂其他类型的消息。

如果客户端收到CertificateRequest消息时没有发送“post_handshake_auth”扩展，则必须以“unexpected_message”致命警报终止连接。

注意：由于客户端认证可能涉及提示用户，服务器必须为此做好延迟准备，包括在发送CertificateRequest和收到响应之间可能接收任意数量的其他消息。此外，收到多个CertificateRequest消息的客户端可以以不同于接收顺序的方式响应（certificate_request_context值帮助服务器区分响应）。

4.6.3 密钥与初始化向量更新

KeyUpdate握手消息用于指示发送方正在更新其加密密钥。任何一方在发送Finished消息后都可以发送此消息。若在收到Finished消息之前收到KeyUpdate消息，必须以“unexpected_message”警报终止连接。发送KeyUpdate消息后，发送方应使用下一代密钥（如第7.2节所述）进行所有通信。收到KeyUpdate后，接收方必须更新其接收密钥。

enum {
    update_not_requested(0), update_requested(1), (255)
} KeyUpdateRequest;

结构体：
struct {
    KeyUpdateRequest request_update;
} KeyUpdate;

request_update：指示接收方是否应回应自己的KeyUpdate。若接收到其他值，必须以“illegal_parameter”警报终止连接。

如果request_update字段设置为“update_requested”，则接收方在发送下一次应用数据之前，必须用request_update设置为“update_not_requested”来回应自己的KeyUpdate。这一机制允许任一方强制更新整个连接，但在静默状态下多次接收KeyUpdate时，可能只响应一次更新。注意：由于请求更新和收到对方的KeyUpdate之间可能存在多个消息在飞行中，接收方可能会收到任意数量的中间消息。然而，由于发送和接收密钥是由不同的流量秘密派生的，保留接收流量秘密不会威胁到之前发送数据的前向安全。

如果一方独立地以“update_requested”发出自己的KeyUpdate，并且两者交叉飞行，则每一方也会响应，导致双方各自增加两个世代。

双方必须用旧密钥加密KeyUpdate消息。此外，双方必须确保在接受用新密钥加密的消息之前，已收到用旧密钥加密的KeyUpdate，否则可能导致消息截断攻击。

5 记录协议

TLS记录协议将待传输的消息进行碎片化，保护记录内容，并传输结果。接收端验证、解密、重组后，将数据交付给更高层的客户端。

TLS记录有类型，允许多种高层协议复用同一记录层。本文件定义了四种内容类型：握手（handshake）、应用数据（application_data）、警报（alert）和变更密码规范（change_cipher_spec）。变更密码规范记录仅用于兼容（详见附录D.4）。

实现可以在任何时间在已发送或接收第一个ClientHello消息后、在收到对端Finished消息之前，接收未加密的变更密码规范（类型为0x01的单字节记录），并应直接丢弃，无需进一步处理。注意：此记录可能出现在实现预期保护记录的握手阶段，因此必须在尝试解密前检测此情况。若收到其他值的变更密码规范或已保护的变更密码规范记录，必须以“unexpected_message”警报中止握手。如果在收到第一个ClientHello之前或在对端Finished消息之后检测到变更密码规范记录，也应视为意外记录类型（尽管无状态服务器可能无法区分这些情况）。

除非通过某些扩展协商，否则实现不得发送未定义的记录类型。如果收到意外的记录类型，必须以“unexpected_message”警报终止连接。新的内容类型由IANA在TLS ContentType注册表中分配（详见第11节）。

5.1 记录层

记录层将信息块碎片化为TLSPlaintext记录，每个记录携带不超过2^14字节的数据。消息边界的处理依赖于底层的ContentType。未来的内容类型必须定义相应规则。注意：这些规则比TLS 1.2中更严格。

握手消息可以合并成一个TLSPlaintext记录，或分散在多个记录中，但必须遵守：
- 握手消息不得与其他类型的记录交错。如果一个握手消息被拆分成多个记录，它们之间不能夹杂其他记录。
- 握手消息不得跨越密钥变更。实现必须验证所有密钥变更前的消息都与记录边界对齐，否则必须以“unexpected_message”警报终止连接。由于ClientHello、EndOfEarlyData、ServerHello、Finished和KeyUpdate消息可以紧接着密钥变更，必须确保这些消息与记录边界对齐。

实现不得发送空长度的握手类型碎片，即使这些碎片包含填充。

警报消息（第6节）不得跨记录分片，多个警报消息也不得合并成一个TLSPlaintext记录。换句话说，带有警报类型的记录必须恰好包含一条消息。

应用数据消息包含TLS不可见的应用层数据。应用数据始终受到保护。可以发送零长度的应用数据碎片，作为流量分析的对策。应用数据碎片可以分散在多个记录中，也可以合并成一个记录。

内容类型定义：
enum {
    invalid(0),
    change_cipher_spec(20),
    alert(21),
    handshake(22),
    application_data(23),
    (255)
} ContentType;

结构体：
struct {
    ContentType type;
    ProtocolVersion legacy_record_version;
    uint16 length;
    opaque fragment[TLSPlaintext.length];
} TLSPlaintext;

type：用于处理封装内容的上层协议。

legacy_record_version：除非是初始ClientHello（非HelloRetryRequest后生成的），否则必须设为0x0303，也可为0x0301以兼容。此字段已废弃，必须忽略。TLS早期版本在某些情况下会使用其他值。

length：后续TLSPlaintext.fragment的长度（字节数），不得超过2^14。若接收的记录超出此长度，必须以“record_overflow”警报终止连接。

fragment：传输的数据，透明处理，作为由type字段指定的上层协议的独立块。

本文件描述TLS 1.3，版本号为0x0304。此版本号源自历史，TLS 1.0用0x0301，SSL 3.0用0x0300。为了最大程度兼容，包含初始ClientHello的记录应使用0x0301（TLS 1.0），包含第二个ClientHello或ServerHello的记录必须使用0x0303（TLS 1.2）。在协商早期版本TLS时，端点应遵循附录D中的流程和要求。

在未启用记录保护前，TLSPlaintext结构直接写入网络。一旦启用记录保护，TLSPlaintext记录将按后续节描述进行保护和传输。注意：应用数据记录不得未保护直接写入网络（详见第2节）。

5.2 记录负载保护

记录保护函数将TLSPlaintext结构转换为TLSCiphertext结构，解保护函数逆转此过程。在TLS 1.3中，所有密码算法都采用“带关联数据的认证加密” (AEAD) [RFC5116]模型。AEAD提供统一的加密和认证操作，将明文转为带认证的密文，反之亦然。每个加密记录由明文头和加密体组成，后者包含类型和可选填充。

结构体：
struct {
    opaque content[TLSPlaintext.length];
    ContentType type;
    uint8 zeros[length_of_padding];
} TLSInnerPlaintext;

结构体：
struct {
    ContentType opaque_type = application_data; /* 23 */
    ProtocolVersion legacy_record_version = 0x0303; /* TLS v1.2 */
    uint16 length;
    opaque encrypted_record[TLSCiphertext.length];
} TLSCiphertext;

内容：TLSPlaintext.fragment的值，包含握手或警报消息的字节编码，或应用层数据的原始字节。

类型：TLSPlaintext.type的值，指示记录内容类型。

零：类型字段后可以出现任意长度的零值字节，用于填充，允许发送者按需填充记录以控制总大小，详见第5.4节。

外层不透明类型：TLSCiphertext的外层opaque_type字段始终设为23（application_data），以兼容习惯解析旧版本TLS的中间设备。解密后，实际内容类型在TLSInnerPlaintext.type中。

legacy_record_version：始终为0x0303。TLS 1.3的TLSCiphertext在协商完成后生成，不存在接收其他值的历史兼容问题。握手协议（包括ClientHello和ServerHello）会验证协议版本，此值为冗余。

长度：后续TLSCiphertext.encrypted_record的长度（字节），为内容和填充长度之和，加上类型字段（1字节）和AEAD算法可能添加的扩展。不得超过2^14 + 256字节。若接收的记录超出此长度，必须以“record_overflow”警报终止连接。

encrypted_record：AEAD加密的TLSInnerPlaintext结构。

AEAD算法以密钥、随机数（nonce）、明文和“附加数据”作为输入（详见[RFC5116]第2.1节）。密钥为client_write_key或server_write_key，随机数由序列号和client_write_iv或server_write_iv派生（见第5.3节），附加数据为记录头。

即：
additional_data = TLSCiphertext.opaque_type ||
                  TLSCiphertext.legacy_record_version ||
                  TLSCiphertext.length

AEAD算法的明文输入为编码后的TLSInnerPlaintext结构。流量密钥的派生定义在第7.3节。

AEAD输出为加密操作的密文。由于包含TLSInnerPlaintext.type和可能的填充，密文长度通常大于对应的TLSPlaintext.length，具体大小取决于AEAD算法。

由于密码可能包含填充，开销可能随明文长度变化。符号表示：
AEADEncrypted = AEAD-Encrypt(write_key, nonce, additional_data, plaintext)

TLSCiphertext的encrypted_record字段即为AEADEncrypted。

解密和验证时，密码算法以密钥、随机数、附加数据和AEADEncrypted为输入，输出为明文或错误（解密失败）。没有单独的完整性校验。符号表示：
plaintext of encrypted_record = AEAD-Decrypt(peer_write_key, nonce, additional_data, AEADEncrypted)

若解密失败，接收端必须以“bad_record_mac”警报终止连接。

在TLS 1.3中使用的AEAD算法不得产生超过255个八位字节的扩展。若接收端收到的TLSCiphertext长度大于2^14 + 256个八位字节的记录，必须以“record_overflow”警报终止连接。该限制源自最大TLS内部明文长度为2^14个八位字节，加上1个八位字节的内容类型，以及最大255个八位字节的AEAD扩展。

5.3. 每个记录的随机数

每个连接会为读取和写入的记录分别维护一个64位的序列号。在读取或写入每个记录后，相应的序列号会增加1。每个序列号在连接开始时以及每次更换密钥时被重置为零；在特定流量密钥下传输的第一个记录必须使用序列号0。

由于序列号为64位，不应发生溢出。如果TLS实现需要溢出序列号，必须重新密钥（参见第4.6.3节）或终止连接。

每个AEAD算法会定义每个记录随机数（nonce）的可能长度范围，从N_MIN字节到N_MAX字节[RFC5116]。TLS每个记录的随机数（iv_length）应设置为8字节与N_MIN的较大值（参见[RFC5116]第4节）。若某AEAD算法的N_MAX小于8字节，则不得在TLS中使用。每个记录的随机数构造如下：

1. 将64位的记录序列号以网络字节序编码，并在左侧用零填充至iv_length。

2. 将填充后的序列号与静态的client_write_iv或server_write_iv（取决于角色）进行异或。

所得长度为iv_length的值即为每个记录的随机数。

注意：这与TLS 1.2中部分显式随机数的构造不同。

5.4. 记录填充

所有加密的TLS记录都可以填充以增加TLSCiphertext的大小，从而隐藏流量大小，防止被观察者检测。

在生成TLSCiphertext记录时，实现可以选择填充。未填充的记录即为填充长度为零的记录。填充是一个由零值字节组成的字符串，附加在ContentType字段后，在加密前必须全部设置为零。

应用数据记录可以包含零长度的TLSInnerPlaintext.content（如果发送方愿意），以生成大小合理的伪装流量，尤其在活动的存在或缺失可能敏感的场景中。实现不得发送TLS握手或警报记录，其TLSInnerPlaintext.content为零长度；若收到此类消息，接收端必须以“unexpected_message”警报终止连接。

记录保护机制会自动验证填充：成功解密TLSCiphertext.encrypted_record后，接收端会从尾部向前扫描，直到找到第一个非零字节。该字节即为消息的内容类型。此填充方案允许对任何加密TLS记录进行任意大小（从零到最大记录长度）的填充，而不引入新的内容类型。设计还强制所有填充字节为零，以便快速检测填充错误。

实现必须限制扫描范围为解密后明文内容。如果未找到非零字节，必须以“unexpected_message”警报终止连接。

填充不会改变记录的整体大小限制：完整编码的TLSInnerPlaintext不得超过2^14 + 1个八位字节。如果最大片段长度因[RFC8449]的record_size_limit扩展等被减小，则缩减的限制适用于包括内容类型和填充在内的全部明文。

选择填充策略（何时以及填充多少）是一个复杂话题，超出本规范范围。如果应用层协议在TLS之上有自己的填充机制，建议在应用层对应用数据TLS记录进行填充。加密的握手或警报记录的填充仍须在TLS层处理。后续文档可能会定义填充算法或通过TLS扩展或其他机制请求填充策略。

5.5. 密钥使用限制

对一组密钥安全加密的明文数据量存在密码学上的限制。[AEAD-LIMITS]分析了在基础原语（AES或ChaCha20）无弱点的假设下的限制。实现应在达到这些限制前根据第4.6.3节的建议进行密钥更新。

对于AES-GCM，在保持大约2^-57的安全裕度下，最多可以在单一连接上加密2^24.5个完整记录（约2,400万条）。对于ChaCha20/Poly1305，序列号会在达到安全极限前溢出。

6. 警报协议

TLS提供警报内容类型，用于指示连接关闭信息和错误。与其他消息一样，警报消息按照当前连接状态进行加密。

警报传达警报描述和一个遗留字段（在TLS早期版本中用于指示严重级别）。警报分为两类：关闭警报和错误警报。在TLS 1.3中，严重级别隐含在警报类型中，“level”字段可以忽略。使用“close_notify”警报表示有序关闭连接的单向操作。收到此警报后，TLS实现应向应用层指示结束数据。

错误警报表示连接的中断（见第6.2节）。收到错误警报后，TLS实现应向应用层指示错误，并且不得再发送或接收任何数据。服务器和客户端必须忘记在失败连接中建立的秘密值和密钥，PSK（预共享密钥）关联的会话票据除外，应尽可能丢弃。

所有在第6.2节列出的警报必须以AlertLevel=fatal发送，无论消息中的“level”字段为何值，收到时都应视为错误警报。未知的警报类型也必须视为错误警报。

注意：TLS定义了两个通用警报（见第6节）用于消息解析失败时使用。若对方收到的消息无法按语法解析（如长度超出边界或内容长度不正确），必须以“decode_error”警报终止连接。若消息语法正确但语义无效（如p-1的DHE共享或无效的枚举值），必须以“illegal_parameter”警报终止连接。

枚举定义如下：

```plaintext
enum { warning(1), fatal(2), (255) } AlertLevel;

enum {
    close_notify(0),
    unexpected_message(10),
    bad_record_mac(20),
    record_overflow(22),
    handshake_failure(40),
    bad_certificate(42),
    unsupported_certificate(43),
    certificate_revoked(44),
    certificate_expired(45),
    certificate_unknown(46),
    illegal_parameter(47),
    unknown_ca(48),
    access_denied(49),
    decode_error(50),
    decrypt_error(51),
    protocol_version(70),
    insufficient_security(71),
    internal_error(80),
    inappropriate_fallback(86),
    user_canceled(90),
    missing_extension(109),
    unsupported_extension(110),
    unrecognized_name(112),
    bad_certificate_status_response(113),
    unknown_psk_identity(115),
    certificate_required(116),
    no_application_protocol(120),
    (255)
} AlertDescription;

struct {
    AlertLevel level;
    AlertDescription description;
} Alert;
```

6.1 关闭警报

客户端和服务器必须共享连接即将结束的知识，以防止截断攻击。

- close_notify：通知接收方，发送方不会再发送任何消息。收到此警报后，任何后续数据必须忽略。

- user_canceled：通知接收方，发送方因非协议故障的原因取消握手。若用户在握手完成后取消操作，直接关闭连接（发送“close_notify”）更为合适。此警报应跟随“close_notify”。通常为警告级别。

任一方可以通过发送“close_notify”主动关闭其写端。收到关闭警报后，任何后续数据都应忽略。如果在收到“close_notify”之前收到传输层关闭，则无法确认所有已发送数据是否已被接收。

每方在关闭写端前必须发送“close_notify”警报，除非已发送某个错误警报。此操作不影响读端。注意：这与TLS 1.2及以前版本不同，后者要求在收到“close_notify”后立即丢弃待发数据并发出自己的“close_notify”。前者可能导致读端截断。两端不必等待对方的“close_notify”再关闭读端，但这样可能引发截断。

如果应用协议允许在TLS连接关闭后继续传输数据，TLS实现必须在通知应用层“end-of-data”前接收“close_notify”。本标准不规定TLS数据传输的具体管理方式，包括连接何时开启或关闭。

注意：关闭写端应确保待发数据可靠送达后再关闭传输。

6.2 错误警报

TLS中的错误处理非常简单：检测到错误时，检测方应向对端发送相应的错误消息。发送或接收致命警报后，双方必须立即关闭连接。

当实现遇到致命错误时，应发送适当的致命警报，并必须关闭连接，不再发送或接收任何数据。在本规范的其他部分，提到“终止连接”或“中止握手”时，若未指明具体警报，意味着应发送下述相应的警报。若要“用X警报终止连接”或“用X警报中止握手”，则必须发送警报X。所有在本节定义的警报以及所有未知警报，均在TLS 1.3中被视为致命（见第6节）。实现应提供日志记录警报发送和接收的机制。

定义的错误警报包括：

- unexpected_message：收到不适当的消息（如错误的握手消息、过早的应用数据等）。在正常实现间不应出现。

- bad_record_mac：收到无法解保护的记录时返回。由于AEAD算法结合了解密和验证，为避免侧信道攻击，此警报用于所有解保护失败。正常实现中不应出现，除非消息在网络中被篡改。

- record_overflow：收到长度超过2^14 + 256字节的TLSCiphertext记录，或解密后得到超过2^14字节（或协商的其他限制）的TLSPlaintext记录。正常实现中不应出现，除非消息在网络中被篡改。

- handshake_failure：收到“handshake_failure”警报表示无法协商出可接受的安全参数。

- bad_certificate：证书损坏、签名验证失败等。

- unsupported_certificate：证书类型不支持。

- certificate_revoked：证书被签发者吊销。

- certificate_expired：证书已过期或当前无效。

- certificate_unknown：处理证书时出现其他（未指明）问题，导致其不可接受。

非法参数：握手中的某个字段不正确或与其他字段不一致。此警报用于符合正式协议语法但在其他方面不正确的错误。

未知的证书授权中心（CA）：收到了有效的证书链或部分链，但由于无法找到CA证书或无法与已知的信任锚匹配，导致证书未被接受。

访问被拒绝：收到了有效的证书或预共享密钥（PSK），但在应用访问控制时，发送方决定不继续协商。

解码错误：由于某个字段超出规定范围或消息长度不正确，导致无法解码消息。此警报用于消息不符合正式协议语法的错误。除非消息在网络中被破坏，否则在正常实现之间的通信中不应出现此警报。

解密错误：握手（非记录层）中的加密操作失败，包括无法正确验证签名、验证Finished消息或PSK绑定。

协议版本：对等方试图协商的协议版本被识别但不被支持（详见附录D）。

安全性不足：在协商失败时返回，特别是因为服务器要求的参数比客户端支持的更安全。

内部错误：与对等方或协议正确性无关的内部错误（如内存分配失败）导致无法继续。

不适当的回退：服务器对客户端的无效重试连接请求的响应（详见[RFC7507]）。

缺少扩展：端点在接收未包含强制为所提供TLS版本或其他协商参数所必需的扩展的握手消息时发出。

不支持的扩展：端点在接收包含已知禁止在特定握手消息中包含的扩展，或在ServerHello或Certificate中包含未在相应的ClientHello或CertificateRequest中首次提供的扩展时发出。

未识别的名称：服务器在没有由客户端通过“server_name”扩展提供的名称对应的服务器存在时发出（详见[RFC6066]）。

不良的证书状态响应：客户端在收到由服务器通过“status_request”扩展提供的无效或不可接受的OCSP响应时发出（详见[RFC6066]）。

未知的PSK身份：服务器希望建立PSK，但客户端未提供可接受的PSK身份。发送此警报是可选的；服务器也可以选择发送“解密错误”警报，仅表示PSK身份无效。

需要证书：服务器希望客户端提供证书，但未收到。

没有应用协议：当客户端的“application_layer_protocol_negotiation”扩展仅广告不被服务器支持的协议时发出（详见[RFC7301]）。

新警报值由IANA根据第11节的描述进行分配。

7. 密码学计算

TLS握手会建立一个或多个输入秘密，这些秘密被结合起来生成实际的工作密钥材料，具体如下。密钥派生过程结合了输入秘密和握手转录（握手消息的完整记录）。注意，由于握手转录包括Hello消息中的随机值，即使使用相同的输入秘密，任何特定握手的流量秘密也会不同，比如在多次连接中使用相同的PSK时。

7.1 密钥调度

密钥派生过程使用HKDF-Extract和HKDF-Expand函数（定义在[RFC5869]中），以及以下定义的函数：

- HKDF-Expand-Label(Secret, Label, Context, Length) = HKDF-Expand(Secret, HkdfLabel, Length)

其中HkdfLabel定义为：

```结构体 {
    uint16 length = Length;
    透明标签<7..255> = "tls13 " + Label;
    透明上下文<0..255> = Context;
} HkdfLabel;```

- Derive-Secret(Secret, Label, Messages) = HKDF-Expand-Label(Secret, Label, Transcript-Hash(Messages), Hash.length)

这里，Transcript-Hash是所有握手消息（包括消息类型和长度字段，但不包括记录层头部）的拼接的哈希值。Hash函数为密码套件的哈希算法，Hash.length为其输出长度（字节）。如果传入空字符串（""）作为上下文，表示长度为零的上下文。所有标签均为ASCII字符串，不包括尾随的NUL字节。

注意：使用常见哈希函数时，标签长度超过12字符时，需要额外一轮哈希计算。本规范中的标签都已设计在此限制内。

密钥由两个输入秘密通过HKDF-Extract和Derive-Secret函数生成。添加新秘密的通用模式是用当前秘密状态作为Salt，待加入的秘密作为IKM，调用HKDF-Extract。在TLS 1.3中，两个输入秘密为：

- 预共享密钥（PSK），即外部建立或从先前连接的resumption_master_secret派生的密钥
- (EC)DHE共享秘密（详见第7.4节）

这产生一个完整的密钥调度流程图。流程图中的格式约定如下：

- HKDF-Extract的输入Salt在顶部，输入IKM在左侧，输出在底部，输出名称在右侧。
- Derive-Secret的Secret参数由箭头指示。例如，Early Secret是生成client_early_traffic_secret的秘密。
- “0”表示一个Hash.length字节全为零的字符串。

流程图示意（简化）如下：

```
0
|
v
PSK -> HKDF-Extract = Early Secret
      |
      +--> Derive-Secret(., "ext binder" | "res binder", "")
      |            = binder_key
      |
      +--> Derive-Secret(., "c e traffic", ClientHello)
      |            = client_early_traffic_secret
      |
      +--> Derive-Secret(., "e exp master", ClientHello)
                   = early_exporter_master_secret
      |
      v
   Derive-Secret(., "derived", "")
      |
      v
(EC)DHE -> HKDF-Extract = Handshake Secret
      |
      +--> Derive-Secret(., "c hs traffic", ClientHello...ServerHello)
      |            = client_handshake_traffic_secret
      |
      +--> Derive-Secret(., "s hs traffic", ClientHello...ServerHello)
                   = server_handshake_traffic_secret
      |
      v
   Derive-Secret(., "derived", "")
      |
      v
0 -> HKDF-Extract = Master Secret
      |
      +--> Derive-Secret(., "c ap traffic", ClientHello...server Finished)
      |            = client_application_traffic_secret_0
      |
      +--> Derive-Secret(., "s ap traffic", ClientHello...server Finished)
      |            = server_application_traffic_secret_0
      |
      +--> Derive-Secret(., "exp master", ClientHello...server Finished)
                   = exporter_master_secret
      |
      +--> Derive-Secret(., "res master", ClientHello...client Finished)
                   = resumption_master_secret
```

左侧的秘密（如PSK和DHE）是纯粹的熵源，没有上下文；右侧的秘密包含握手上下文，可用来直接派生工作密钥。不同的Derive-Secret调用可以使用不同的Messages参数，即使秘密相同。在0-RTT中，调用四次不同的转录；在1-RTT中，调用三次。

如果某个秘密不可用，则用全零（Hash.length字节全为零的字符串）代替。注意，这不意味着跳过轮次，例如未使用PSK时，Early Secret仍为HKDF-Extract(0,0)。在计算binder_key时，标签为“ext binder”用于外部PSK，“res binder”用于恢复PSK（即作为前一次握手的resumption_master_secret）。不同标签防止不同类型的PSK被互换。

根据最终选择的PSK，可能存在多个Early Secret值。客户端需要为每个潜在的PSK计算对应的Early Secret；如果未选择任何PSK，则计算对应零PSK的Early Secret。

所有由某个秘密派生的值计算完毕后，应立即将该秘密抹除。

7.2 交通秘密的更新

握手完成后，任一端都可以使用Section 4.6.3定义的KeyUpdate握手消息更新其发送的流量密钥。新一代流量密钥通过从前一代traffic secret（client_/server_application_traffic_secret_N）派生出client_/server_application_traffic_secret_N+1，然后再重新计算流量密钥（详见7.3节）。

新一代应用流量秘密的计算为：

```
application_traffic_secret_N+1 =
    HKDF-Expand-Label(application_traffic_secret_N, "traffic upd", "", Hash.length)
```

一旦计算出client_/server_application_traffic_secret_N+1及其相关的流量密钥，建议删除之前的秘密和密钥。

7.3 流量密钥的计算

流量密钥材料由以下输入值生成：

- 一个秘密值
- 一个用途值，指示生成的具体值
- 生成密钥的长度

流量密钥材料由输入的traffic secret值通过以下方式生成：

```
[sender]_write_key = HKDF-Expand-Label(Secret, "key", "", key_length)
[sender]_write_iv  = HKDF-Expand-Label(Secret, "iv", "", iv_length)
```

其中，[sender]代表发送方。每个记录类型对应的Secret值如下表：

| 记录类型             | Secret                                    |
|---------------------|-------------------------------------------|
| 0-RTT应用数据       | client_early_traffic_secret             |
| 握手                | [sender]_handshake_traffic_secret       |
| 应用数据            | [sender]_application_traffic_secret_N |

每当基础Secret变化（如从握手密钥切换到应用数据密钥或密钥更新时），所有流量密钥材料都应重新计算。

7.4 (EC)DHE共享秘密的计算

7.4.1 有限域Diffie-Hellman

对于有限域群，执行传统的Diffie-Hellman [DH76]计算。协商的密钥（Z）通过大端编码转换为字节串，并在前面补零至素数的大小。该字节串作为共享秘密输入到密钥调度中。

注意：此构造不同于之前版本的TLS，后者会去除前导零。

7.4.2 椭圆曲线Diffie-Hellman

对于secp256r1、secp384r1和secp521r1，ECDH计算（包括参数和密钥生成以及共享秘密计算）按照[IEEE1363]中的ECKAS-DH1方案进行，使用恒等映射作为密钥派生函数（KDF），共享秘密为ECDH共享点的x坐标（以八位字节串表示）。FE2OSP（域元素到八位字节串转换原语）输出的八位字节串长度在任何给定域中是恒定的，不能截断前导零。

（注意：此处使用恒等KDF是技术细节。实际上，ECDH配合非平凡的KDF使用，是因为TLS不直接用此秘密做其他用途。）

对于X25519和X448，ECDH计算如下：

- 用于KeyShareEntry.key_exchange的公钥为对适当长度的私钥（标量）应用ECDH标量乘法后得到的点（u-坐标点），与标准基点相乘。
- 共享秘密为对私钥（标量）和对方公钥（u-坐标点）应用ECDH标量乘法的结果，直接使用，无需处理。

这些曲线的实现应遵循[RFC7748]中的方法，计算出的Diffie-Hellman共享秘密若为全零值，应立即中止（详见[RFC7748]第6节）。如果使用其他实现，应进行相应的额外检查。

7.5 导出器（Exporters）

[RFC5705]定义了基于TLS伪随机函数（PRF）的密钥导出器。本规范用HKDF替代PRF，因此需要新的构造，但导出器接口保持不变。

导出值的计算为：

```
TLS-Exporter(label, context_value, key_length) =
    HKDF-Expand-Label(Derive-Secret(Secret, label, ""), "exporter", Hash(context_value), key_length)
```

秘密（Secret）可以是 early_exporter_master_secret 或 exporter_master_secret。实现必须使用 exporter_master_secret，除非应用程序明确规定使用其他的。early_exporter_master_secret 主要用于需要导出器（exporter）以处理0-RTT数据的场景。建议为早期导出器（early exporter）设计单独的接口，以避免用户在需要普通导出器时误用早期导出器，反之亦然。

如果没有提供上下文（context），则 context_value 的长度为零。因此，不提供上下文与提供空上下文会得到相同的值。这与之前版本的TLS不同，之前空上下文会产生不同的输出。自本文发布之日起，未分配的导出标签（exporter label）在有无上下文的情况下都未被使用。未来的规范不得定义允许同时使用空上下文和无上下文的导出器（exporter）标签。新的导出器用法应在所有导出器计算中提供上下文，尽管该值可以为空。

关于导出器标签（exporter labels）格式的要求，详见[RFC5705]第4节。

---

8. 0-RTT与防重放（Anti-Replay）

如第2.3节和附录E.5所述，TLS本身不提供0-RTT数据的重放保护。需要关注的潜在威胁有两类：

- 网络攻击者通过简单复制一批0-RTT数据进行重放攻击。

- 网络攻击者利用客户端重试行为，使服务器收到多份应用消息。虽然客户端在遇到网络错误时会尝试重试，但0-RTT为那些不维护全局一致状态的服务器系统带来了额外风险。例如，如果一个服务器系统在不同区域（zone）中，来自区域A的票据（ticket）在区域B不被接受，攻击者可以复制ClientHello和早期数据，向A和B两个区域发送。A区域会接受0-RTT数据，但B区域会拒绝0-RTT，强制进行完整的握手。如果攻击者阻止A区域的ServerHello，客户端会在B区域完成握手并可能重试请求，从而导致整个系统的重复。

第一类攻击可以通过共享状态来防止，确保0-RTT数据最多只被接受一次。服务器应通过实现本节描述的方法或等效手段，提供相应的重放安全保障。然而，出于操作考虑，并非所有部署都能维护此级别的状态。因此，在正常操作中，客户端只能发送其认为安全的、可能被重放的早期数据。

除了直接的重放影响外，还存在一种攻击方式，即大量重放可能利用一些本应幂等的操作（如定时攻击、资源耗尽等，详见附录E.5）。可以通过限制每个0-RTT载荷的重放次数来缓解。服务器必须确保其任何实例（无论是机器、线程或其他实体）最多只接受同一0-RTT握手一次，从而将重放次数限制在部署中的服务器实例数。这可以通过本地记录近期收到的ClientHello信息并拒绝重复，或采用其他提供相同或更强保障的方法实现。“每个服务器实例最多一次”的保证是最低要求，服务器应在可行时进一步限制0-RTT重放。

第二类攻击无法在TLS层防范，必须由应用程序应对。任何实现重试机制的客户端都应实现某种反重放措施。

8.1. 单次使用票据（Single-Use Tickets）

最简单的反重放措施是让服务器每个会话票据（ticket）只使用一次。例如，服务器可以维护所有有效票据的数据库，在使用后删除对应票据。若提供未知票据，服务器则回退到完整握手。

如果票据不是自包含的，而是数据库中的密钥（key），且在使用后删除对应的预共享密钥（PSK），那么基于PSK建立的连接具有前向保密性。这增强了所有0-RTT数据和在不使用（EC)DHE的情况下的PSK的安全性。

由于此机制需要在多节点环境中共享会话数据库，可能难以实现高成功率的PSK 0-RTT连接（相较于自加密票据）。不同于会话数据库，票据可以在没有一致存储的情况下成功建立PSK会话，但在允许0-RTT的情况下，仍需一致存储以防止0-RTT数据被重放，详见下一节。

8.2. 客户端Hello记录（Client Hello Recording）

另一种反重放方法是记录由ClientHello派生的唯一值（通常是随机值或PSK绑定器），并拒绝重复的ClientHello。全部记录会导致状态无限增长，但可以在一定时间窗口内记录ClientHello，并利用“obfuscated_ticket_age”确保票据不会在窗口外被重用。

实现时，收到ClientHello后，服务器首先验证PSK绑定器（详见第4.2.11节）。然后计算预期到达时间（expected_arrival_time），如果超出记录窗口则拒绝0-RTT，转而使用1-RTT握手。

如果预期到达时间在窗口内，服务器会检查是否已记录匹配的ClientHello。若找到，则中止握手（发出“illegal_parameter”警告）或接受PSK但拒绝0-RTT；若未找到，则接受0-RTT，并在预期到达时间内将该ClientHello存储。服务器也可以使用误报的存储方案（如布隆过滤器），在出现重放时拒绝0-RTT，但不终止握手。

存储密钥必须仅由经过验证的ClientHello部分派生。如果ClientHello包含多个PSK身份，攻击者可以伪造多个ClientHello，使用不同绑定器值（binder），假设服务器不会验证（如第4.2.11节建议）。例如，客户端发送PSK A和B，但服务器偏好A，攻击者可以修改B的绑定器而不影响A的绑定器，从而使该ClientHello不被视为重复，可能导致重放缓存污染，尽管任何0-RTT数据都无法解密（因为密钥不同）。如果用验证过的绑定器或ClientHello.random作为存储密钥，则此攻击不可行。

此机制不需要存储所有未完成的票据，适合高频恢复和0-RTT的分布式系统，便于实现，但反重放能力可能较弱，因为难以可靠存储和检索所有收到的ClientHello。在这种情况下，最优方案是由单一存储区域对某个票据具有权威性，其他区域拒绝该票据的0-RTT，从而防止简单重放（只有唯一区域接受0-RTT数据）。另一种较弱的方案是为每个区域单独存储，但允许任何区域使用0-RTT，这样重放次数限制为每个区域一次。无论哪种方案，应用消息的重复仍可能发生。

新启动的实现应拒绝0-RTT，只要其记录窗口与启动时间有重叠，否则可能接受在启动期间发出的重放。

注意：如果客户端时钟快于服务器很多，可能会收到超出窗口的ClientHello（未来时间），此时可能被接受为1-RTT，导致客户端重试，再次接受为0-RTT。这是第二类攻击的变体之一。

8.3. 新鲜度检查（Freshness Checks）

由于ClientHello包含其发送时间，可以高效判断是否近期发送，只接受符合条件的ClientHello的0-RTT，否则退回到1-RTT握手。这对于第8.2节描述的ClientHello存储机制尤为重要，否则服务器需无限存储ClientHello，且对自包含单次票据的优化也有帮助，因为可以快速拒绝不可用于0-RTT的ClientHello。

实现时，服务器应存储生成会话票据的时间（creation_time），加上估算的往返时间（RTT）偏差，即：

    adjusted_creation_time = creation_time + estimated_RTT

此值可编码在票据中，避免存储每个未完成票据的状态。服务器通过从“obfuscated_ticket_age”中减去“ticket_age_add”值，计算客户端对票据的“年龄”。预期到达时间（expected_arrival_time）为：

    expected_arrival_time = adjusted_creation_time + 客户端的票据年龄

收到新ClientHello后，将预期到达时间与服务器当前时间比较，如果差异超过某个阈值，则拒绝0-RTT，但允许1-RTT完成。

潜在误差源包括客户端和服务器的时钟偏差、网络延迟等。网络延迟可能导致误差达十秒左右，具体取决于部署环境。时钟偏差分布非对称，最优的容差范围也应考虑非对称性。

仅进行新鲜度检查不足以完全防止重放，因为在误差窗口内可能仍有大量重放（视带宽和系统容量而定）。此外，新鲜度检查只在收到ClientHello时进行，后续早期应用数据的接收不再验证。早期数据一旦接受，后续可能持续传输。

---

9. 合规性要求

9.1. 必须实现的密码套件（Mandatory-to-Implement Cipher Suites）

除非有其他应用配置标准，否则：

符合TLS规范的应用必须实现 TLS_AES_128_GCM_SHA256（详见[GCM]），并建议实现 TLS_AES_256_GCM_SHA384 和 TLS_CHACHA20_POLY1305_SHA256（详见RFC8439，见附录B.4）。

符合TLS标准的应用程序必须支持使用rsa_pkcs1_sha256（用于证书）、rsa_pss_rsae_sha256（用于CertificateVerify和证书）以及ecdsa_secp256r1_sha256的数字签名。应用程序还必须支持secp256r1（NIST P-256）进行密钥交换，并应支持X25519 [RFC7748]进行密钥交换。

[RFC7919] Gillmor, D.，“传输层安全（TLS）协商的有限域临时参数”，RFC 7919，DOI 10.17487/RFC7919，2016年8月，<https://www.rfc-editor.org/info/rfc7919>。

[RFC8017] Moriarty, K.（主编），Kaliski, B.、Jonsson, J. 和 A. Rusch，“PKCS #1：RSA密码学规范第2.2版”，RFC 8017，DOI 10.17487/RFC8017，2016年11月，<https://www.rfc-editor.org/info/rfc8017>。

[RFC8032] Josefsson, S. 和 I. Liusvaara，“爱德华曲线数字签名算法（EdDSA）”，RFC 8032，DOI 10.17487/RFC8032，2017年1月，<https://www.rfc-editor.org/info/rfc8032>。

[RFC8126] Cotton, M.、Leiba, B. 和 T. Narten，“在RFC中撰写IANA考虑事项部分的指南”，BCP 26，RFC 8126，DOI 10.17487/RFC8126，2017年6月，<https://www.rfc-editor.org/info/rfc8126>。

[RFC8174] Leiba, B.，“RFC 2119关键词中大写与小写的歧义”，BCP 14，RFC 8174，DOI 10.17487/RFC8174，2017年5月，<https://www.rfc-editor.org/info/rfc8174>。

[RFC8439] Nir, Y. 和 A. Langley，“IETF协议中的ChaCha20和Poly1305”，RFC 8439，DOI 10.17487/RFC8439，2018年6月，<https://www.rfc-editor.org/info/rfc8439>。

[SHS] Dang, Q.，“安全哈希标准（SHS）”，国家标准与技术研究院报告，DOI 10.6028/NIST.FIPS.180-4，2015年8月。

[X690] ITU-T，“信息技术——ASN.1编码规则：基本编码规则（BER）、规范编码规则（CER）和区别编码规则（DER）规范”，ISO/IEC 8825-1:2015，2015年11月。












Rescorla  规范轨迹  [第111页]

RFC 8446  TLS  2018年8月


12.2.  资料性参考文献

[AEAD-LIMITS] Luykx, A. 和 K. Paterson，“TLS中认证加密使用的限制”，2017年8月，<http://www.isg.rhul.ac.uk/~kp/TLS-AEbounds.pdf>。

[BBFGKZ16] Bhargavan, K.、Brzuska, C.、Fournet, C.、Green, M.、Kohlweiss, M. 和 S. Zanella-Beguelin，“密钥交换协议中的降级弹性”，IEEE安全与隐私研讨会（圣何塞）论文集，DOI 10.1109/SP.2016.37，2016年5月。

[BBK17] Bhargavan, K.、Blanchet, B. 和 N. Kobeissi，“TLS 1.3标准候选的验证模型和参考实现”，IEEE安全与隐私研讨会（圣何塞）论文集，DOI 10.1109/SP.2017.26，2017年5月。

[BDFKPPRSZZ16] Bhargavan, K.、Delignat-Lavaud, A.、Fournet, C.、Kohlweiss, M.、Pan, J.、Protzenko, J.、Rastogi, A.、Swamy, N.、Zanella-Beguelin, S. 和 J. Zinzindohoue，“TLS 1.3记录层的实现与证明”，IEEE安全与隐私研讨会（圣何塞）论文集，2017年5月，<https://eprint.iacr.org/2016/1178>。

[Ben17a] Benjamin, D.，“在IETF 100的TLS工作组前的陈述”，2017年11月，<https://datatracker.ietf.org/meeting/100/materials/slides-100-tls-sessa-tls13/>。

[Ben17b] Benjamin, D.，“Chrome中TLS 1.3的额外结果”，发给TLS邮件列表的消息，2017年12月18日，<https://www.ietf.org/mail-archive/web/tls/current/msg25168.html>。

[Blei98] Bleichenbacher, D.，“针对基于RSA加密标准PKCS #1的协议的选择密文攻击”，CRYPTO '98会议论文集，1998年。

[BMMRT15] Badertscher, C.、Matt, C.、Maurer, U.、Rogaway, P. 和 B. Tackmann，“增强型安全通道与TLS 1.3记录层的目标”，ProvSec 2015，2015年9月，<https://eprint.iacr.org/2015/394>。

[BT16] Bellare, M. 和 B. Tackmann，“TLS 1.3中的多用户安全性：AES-GCM”，CRYPTO 2016会议论文集，2016年7月，<https://eprint.iacr.org/2016/564>。

[CCG16] Cohn-Gordon, K.、Cremers, C. 和 L. Garratt，“后被攻破的安全性”，IEEE计算机安全基础研讨会，DOI 10.1109/CSF.2016.19，2015年7月。

[CHECKOWAY] Checkoway, S.、Maskiewicz, J.、Garman, C.、Fried, J.、Cohney, S.、Green, M.、Heninger, N.、Weinmann, R.、Rescorla, E. 和 H. Shacham，“Juniper双EC事件的系统分析”，2016年ACM计算机与通信安全会议论文集 - CCS '16，DOI 10.1145/2976749.2978395，2016年10月。

[CHHSV17] Cremers, C.、Horvat, M.、Hoyland, J.、Scott, S. 和 T. van der Merwe，“尴尬的握手：在第18版中客户端/服务器对客户端认证的可能不匹配”，发给TLS邮件列表的消息，2017年2月10日，<https://www.ietf.org/mail-archive/web/tls/current/msg22382.html>。

[CHSV16] Cremers, C.、Horvat, M.、Scott, S. 和 T. van der Merwe，“TLS 1.3的自动化分析与验证：0-RTT、会话恢复与延迟认证”，IEEE安全与隐私研讨会（圣何塞）论文集，DOI 10.1109/SP.2016.35，2016年5月，<https://ieeexplore.ieee.org/document/7546518/>。

[CK01] Canetti, R. 和 H. Krawczyk，“密钥交换协议的分析及其用于构建安全通道”，Eurocrypt 2001会议论文集，DOI 10.1007/3-540-44987-6_28，2001年4月。

[CLINIC] Miller, B.、Huang, L.、Joseph, A. 和 J. Tygar，“我知道你为什么去诊所：HTTPS流量分析的风险与实现”，隐私增强技术，页143-163，DOI 10.1007/978-3-319-08506-7_8，2014年。

[DFGS15] Dowling, B.、Fischlin, M.、Guenther, F. 和 D. Stebila，“TLS 1.3握手协议候选方案的密码学分析”，ACM CCS 2015会议论文集，2015年10月，<https://eprint.iacr.org/2015/914>。

[DFGS16] Dowling, B.、Fischlin, M.、Guenther, F. 和 D. Stebila，“TLS 1.3完整和预共享密钥握手协议的密码学分析”，TRON 2016，2016年2月，<https://eprint.iacr.org/2016/081>。

[DOW92] Diffie, W.、van Oorschot, P. 和 M. Wiener，“认证与认证密钥交换”，设计、编码与密码学，DOI 10.1007/BF00124891，1992年6月。

[DSS] 美国国家标准与技术研究院（NIST）、美国商务部，“数字签名标准（DSS）”，NIST FIPS PUB 186-4，DOI 10.6028/NIST.FIPS.186-4，2013年7月。

[FG17] Fischlin, M. 和 F. Guenther，“对TLS 1.3握手候选方案的重放攻击”，EuroS&P 2017会议论文集，2017年4月，<https://eprint.iacr.org/2017/082>。

[FGSW16] Fischlin, M.、Guenther, F.、Schmidt, B. 和 B. Warinschi，“密钥确认在密钥交换中的作用：形式化处理及对TLS 1.3的影响”，IEEE安全与隐私研讨会（圣何塞）论文集，DOI 10.1109/SP.2016.34，2016年5月，<https://ieeexplore.ieee.org/document/7546517/>。

[FW15] Weimer, F.，“利用TLS完美前向保密性进行RSA密钥分解”，2015年9月。

[HCJC16] Husak, M.、Cermak, M.、Jirsik, T. 和 P. Celeda，“被动SSL/TLS指纹识别的HTTPS流量分析与客户端识别”，《信息安全》EURASIP期刊，2016年第，DOI 10.1186/s13635-016-0030-7，2016年2月。

[HGFS15] Hlauschek, C.、Gruber, M.、Fankhauser, F. 和 C. Schanes，“撬开潘多拉的盒子：针对TLS的KCI攻击”，USENIX攻击技术研讨会，2015年8月。

[IEEE1363] IEEE，“公开密钥密码学的IEEE标准规范”，IEEE Std. 1363-2000，DOI 10.1109/IEEESTD.2000.92292。







Rescorla  规范轨迹  [第114页]

RFC 8446  TLS  2018年8月


[JSS15] Jager, T.、Schwenk, J. 和 J. Somorovsky，“TLS 1.3和QUIC在PKCS#1 v1.5加密弱点方面的安全性”，ACM CCS 2015会议论文集，DOI 10.1145/2810103.2813657，2015年10月，<https://www.nds.rub.de/media/nds/veroeffentlichungen/2015/08/21/Tls13QuicAttacks.pdf>。

[KEYAGREEMENT] Barker, E.、Chen, L.、Roginsky, A.、Vassilev, A. 和 R. Davis，“使用离散对数密码学的成对密钥建立方案建议”，国家标准与技术研究院，DOI 10.6028/NIST.SP.800-56Ar3，2018年4月。

[Kraw10] Krawczyk, H.，“密码提取与密钥派生：HKDF方案”，CRYPTO 2010会议论文集，2010年8月，<https://eprint.iacr.org/2010/264>。

[Kraw16] Krawczyk, H.，“单边到互认的密钥交换验证器（应用于TLS 1.3中的客户端认证）”，ACM CCS 2016会议论文集，2016年10月，<https://eprint.iacr.org/2016/711>。

[KW16] Krawczyk, H. 和 H. Wee，“OPTLS协议与TLS 1.3”，EuroS&P 2016会议论文集，2016年3月，<https://eprint.iacr.org/2015/978>。

[LXZFH16] Li, X.、Xu, J.、Zhang, Z.、Feng, D. 和 H. Hu，“TLS 1.3候选方案的多次握手安全性”，IEEE安全与隐私研讨会（圣何塞）论文集，DOI 10.1109/SP.2016.36，2016年5月，<https://ieeexplore.ieee.org/document/7546519/>。

[Mac17] MacCarthaigh, C.，“TLS 1.3 0-RTT安全性审查”，2017年3月，<https://github.com/tlswg/tls13-spec/issues/1001>。

[PS18] Patton, C. 和 T. Shrimpton，“部分规范的通道：TLS 1.3记录层无省略”，2018年，<https://eprint.iacr.org/2018/634>。

[PSK-FINISHED] Scott, S.、Cremers, C.、Horvat, M. 和 T. van der Merwe，“修订版10：如果在预共享密钥期间允许客户端认证，可能存在攻击”，发给TLS邮件列表的消息，2015年10月31日，<https://www.ietf.org/mail-archive/web/tls/current/msg18215.html>。




Rescorla  规范轨迹  [第115页]

RFC 8446  TLS  2018年8月


[REKEY] Abdalla, M. 和 M. Bellare，“增加密钥寿命：重钥技术的安全性比较分析”，ASIACRYPT 2000，DOI 10.1007/3-540-44448-3_42，2000年10月。

[Res17a] Rescorla, E.，“Firefox TLS 1.3中间盒实验的初步数据”，发给TLS邮件列表的消息，2017年12月5日，<https://www.ietf.org/mail-archive/web/tls/current/msg25091.html>。

[Res17b] Rescorla, E.，“更多兼容性测量结果”，发给TLS邮件列表的消息，2017年12月22日，<https://www.ietf.org/mail-archive/web/tls/current/msg25179.html>。

[RFC3552] Rescorla, E. 和 B. Korver，“撰写安全考虑事项的RFC文本指南”，BCP 72，RFC 3552，2003年7月，<https://www.rfc-editor.org/info/rfc3552>。

[RFC4086] Eastlake 3rd, D.、Schiller, J. 和 S. Crocker，“安全性随机性要求”，BCP 106，RFC 4086，2005年6月，<https://www.rfc-editor.org/info/rfc4086>。

[RFC4346] Dierks, T. 和 E. Rescorla，“传输层安全（TLS）协议第1.1版”，RFC 4346，2006年4月，<https://www.rfc-editor.org/info/rfc4346>。

[RFC4366] Blake-Wilson, S.、Nystrom, M.、Hopwood, D.、Mikkelsen, J. 和 T. Wright，“传输层安全（TLS）扩展”，RFC 4366，2006年4月，<https://www.rfc-editor.org/info/rfc4366>。

[RFC4492] Blake-Wilson, S.、Bolyard, N.、Gupta, V.、Hawk, C. 和 B. Moeller，“用于传输层安全（TLS）的椭圆曲线密码套件（ECC）”，RFC 4492，2006年5月，<https://www.rfc-editor.org/info/rfc4492>。

[RFC5077] Salowey, J.、Zhou, H.、Eronen, P. 和 H. Tschofenig，“无服务器端状态的传输层安全（TLS）会话恢复”，RFC 5077，DOI 10.17487/RFC5077，2008年1月，<https://www.rfc-editor.org/info/rfc5077>。





Rescorla  规范轨迹  [第116页]

RFC 8446  TLS  2018年8月


[RFC5246] Dierks, T. 和 E. Rescorla，“传输层安全（TLS）协议第1.2版”，RFC 5246，DOI 10.17487/RFC5246，2008年8月，<https://www.rfc-editor.org/info/rfc5246>。

[RFC5764] McGrew, D. 和 E. Rescorla，“数据报传输层安全（DTLS）扩展，用于建立安全实时传输协议（SRTP）密钥”，RFC 5764，DOI 10.17487/RFC5764，2010年5月，<https://www.rfc-editor.org/info/rfc5764>。

[RFC5929] Altman, J.、Williams, N. 和 L. Zhu，“TLS的通道绑定”，RFC 5929，DOI 10.17487/RFC5929，2010年7月，<https://www.rfc-editor.org/info/rfc5929>。

[RFC6091] Mavrogiannopoulos, N. 和 D. Gillmor，“使用OpenPGP密钥进行传输层安全（TLS）认证”，RFC 6091，DOI 10.17487/RFC6091，2011年2月，<https://www.rfc-editor.org/info/rfc6091>。

[RFC6101] Freier, A.、Karlton, P. 和 P. Kocher，“安全套接字层（SSL）协议第3.0版”，RFC 6101，DOI 10.17487/RFC6101，2011年8月，<https://www.rfc-editor.org/info/rfc6101>。

[RFC6176] Turner, S. 和 T. Polk，“禁止使用安全套接字层（SSL）第2.0版”，RFC 6176，DOI 10.17487/RFC6176，2011年3月，<https://www.rfc-editor.org/info/rfc6176>。

[RFC6347] Rescorla, E. 和 N. Modadugu，“数据报传输层安全（DTLS）第1.2版”，RFC 6347，DOI 10.17487/RFC6347，2012年1月，<https://www.rfc-editor.org/info/rfc6347>。

[RFC6520] Seggelmann, R.、Tuexen, M. 和 M. Williams，“传输层安全（TLS）和数据报传输层安全（DTLS）心跳扩展”，RFC 6520，DOI 10.17487/RFC6520，2012年2月，<https://www.rfc-editor.org/info/rfc6520>。

[RFC7230] Fielding, R.（主编）和 J. Reschke（主编），“超文本传输协议（HTTP/1.1）：消息语法与路由”，RFC 7230，DOI 10.17487/RFC7230，2014年6月，<https://www.rfc-editor.org/info/rfc7230>。








Rescorla  规范轨迹  [第117页]

RFC 8446  TLS  2018年8月


[RFC7250] Wouters, P.（主编）、Tschofenig, H.（主编）、Gilmore, J.、Weiler, S. 和 T. Kivinen，“在传输层安全（TLS）和数据报传输层安全（DTLS）中使用原始公钥”，RFC 7250，DOI 10.17487/RFC7250，2014年6月，<https://www.rfc-editor.org/info/rfc7250>。

[RFC7465] Popov, A.，“禁止RC4密码套件”，RFC 7465，DOI 10.17487/RFC7465，2015年2月，<https://www.rfc-editor.org/info/rfc7465>。

[RFC7568] Barnes, R.、Thomson, M.、Pironti, A. 和 A. Langley，“废弃安全套接字层（SSL）第3.0版”，RFC 7568，DOI 10.17487/RFC7568，2015年6月，<https://www.rfc-editor.org/info/rfc7568>。

[RFC7627] Bhargavan, K.（主编）、Delignat-Lavaud, A.、Pironti, A.、Langley, A. 和 M. Ray，“传输层安全（TLS）会话哈希与扩展主密钥扩展”，RFC 7627，DOI 10.17487/RFC7627，2015年9月，<https://www.rfc-editor.org/info/rfc7627>。

[RFC7685] Langley, A.，“TLS客户端Hello填充扩展”，RFC 7685，DOI 10.17487/RFC7685，2015年10月，<https://www.rfc-editor.org/info/rfc7685>。

[RFC7924] Santesson, S. 和 H. Tschofenig，“TLS缓存信息扩展”，RFC 7924，DOI 10.17487/RFC7924，2016年7月，<https://www.rfc-editor.org/info/rfc7924>。

[RFC8305] Schinazi, D. 和 T. Pauly，“Happy Eyeballs第2版：通过并发实现更好的连接性”，RFC 8305，DOI 10.17487/RFC8305，2017年12月，<https://www.rfc-editor.org/info/rfc8305>。

[RFC8422] Nir, Y.、Josefsson, S. 和 M. Pegourie-Gonnard，“用于TLS版本1.2及更早版本的椭圆曲线密码套件（ECC）”，RFC 8422，2018年8月，<https://www.rfc-editor.org/info/rfc8422>。

[RFC8447] Salowey, J. 和 S. Turner，“TLS和DTLS的IANA注册表更新”，RFC 8447，DOI 10.17487/RFC8447，2018年8月，<https://www.rfc-editor.org/info/rfc8447>。

[RFC8449] Thomson, M.，“TLS的记录大小限制扩展”，RFC 8449，DOI 10.17487/RFC8449，2018年8月，<https://www.rfc-editor.org/info/rfc8449>。












Rivest, R.、Shamir, A. 和 L. Adleman，“获得数字签名和公钥密码系统的方法”，《ACM通讯》，第21卷第2期，页120-126，DOI 10.1145/359340.359342，1978年2月。

[Krawczyk, H.] “SIGMA：‘签名-和-消息认证’方法，用于认证Diffie-Hellman及其在IKE协议中的应用”，CRYPTO 2003会议论文集，DOI 10.1007/978-3-540-45146-4_24，2003年8月。

[ SLOTH ] Bhargavan, K. 和 G. Leurent，“转录碰撞攻击：破解TLS、IKE和SSH中的认证”，网络与分布式系统安全研讨会（NDSS 2016），DOI 10.14722/ndss.2016.23418，2016年2月。

[SSL2] Hickman, K.，“SSL协议”，1995年2月。

[TIMING] Boneh, D. 和 D. Brumley，“远程时间攻击的实用性”，USENIX安全研讨会，2003年8月。

[TLS13-TRACES] Thomson, M.，“TLS 1.3示例握手轨迹”，工作进展稿，draft-ietf-tls-tls13-vectors-06，2018年7月。

[X501] ITU-T，“信息技术——开放系统互联——目录：模型”，ITU-T X.501，2016年10月，<https://www.itu.int/rec/T-REC-X.501/en>。











Rescorla  规范轨迹  [第119页]

本附录提供了客户端和服务器握手过程中的状态转换概要。状态名称（全部大写，例如START）没有正式定义，仅为便于理解而设。仅在特定情况下采取的操作用“[]”标示。符号“K_{send,recv} = foo”表示“将发送/接收密钥设置为foo”。

A.1. 客户端

                              START <----+
               发送ClientHello |        | 接收HelloRetryRequest
          [K_send = 早期数据] |        |
                                v        |
           /                 WAIT_SH ----+
           |                    | 接收ServerHello
           |                    | K_recv = 握手
       可以 |                    V
      发送 |                 WAIT_EE
     早期 |                    | 接收加密扩展
      数据 |           +--------+--------+
           |     使用 |                 | 使用证书
           |       PSK |                 v
           |           |            WAIT_CERT_CR
           |           |        接收 |       | 接收CertificateRequest
           |           | 证书       v
           |           |             |    WAIT_CERT
           |           |             |       | 接收证书
           |           |             v       v
           |           |              WAIT_CV
           |           |                 | 接收CertificateVerify
           |           +> WAIT_FINISHED <+
           |                  | 接收Finished
           \                  | [发送EndOfEarlyData]
                              | K_send = 握手
                              | [发送证书（+ CertificateVerify）]
    可以发送                  | 发送Finished
    应用数据   -->            | K_send = K_recv = application
    在此之后                v
                          已连接

注意，上述状态转换允许客户端在明文或使用早期数据密钥的情况下，发送源自ServerHello之后的警报。如果客户端需要发送此类警报，应首先尽可能重新用握手密钥进行密钥更新。

A.2. 服务器

                              START <-----+
               接收ClientHello |         | 发送HelloRetryRequest
                                v         |
                             RECVD_CH ----+
                                | 选择参数
                                v
                             NEGOTIATED
                                | 发送ServerHello
                                | K_send = 握手
                                | 发送EncryptedExtensions
                                | [发送CertificateRequest]
 可以发送                       | [发送Certificate + CertificateVerify]
 应用数据                       | 发送Finished
 在此 -->                     | K_send = application
                          +--------+--------+
              无0-RTT |                 | 0-RTT
                       |                 |
   K_recv = 握手   |                 |  K_recv = 早期数据
 [跳过解密错误]     |    +------> WAIT_EOED -+
                       |    |       接收 |      | 接收EndOfEarlyData
                       |    | 早期数据   |      | K_recv = 握手
                       |    +------------+      |
                       |                        |
                       +> WAIT_FLIGHT2 <--------+
                                |
                       +--------+--------+
               无认证 |                 | 客户端认证
                       |                 |
                       |                 v
                       |             WAIT_CERT
                       |        接收 |       | 接收Certificate
                       |       空       |       v
                       | 证书         |    WAIT_CV
                       |             |       | 接收CertificateVerify
                       |             v       | 
                       +-> WAIT_FINISHED <---+
                                | 接收Finished
                                | K_recv = application
                                v
                            已连接

A.3. 协议数据结构和常量值

本附录定义了协议的类型和常量值。列为“_RESERVED”的值曾在TLS的早期版本中使用，为完整性列出。TLS 1.3的实现不得发送这些值，但可能会接收来自旧版本TLS的实现。

B.1. 记录层

enum {
    invalid(0),
    change_cipher_spec(20),
    alert(21),
    handshake(22),
    application_data(23),
    heartbeat(24),  /* RFC 6520 */
    (255)
} ContentType;

struct {
    ContentType type;
    ProtocolVersion legacy_record_version;
    uint16 length;
    opaque fragment[TLSPlaintext.length];
} TLSPlaintext;

struct {
    opaque content[TLSPlaintext.length];
    ContentType type;
    uint8 zeros[length_of_padding];
} TLSInnerPlaintext;

struct {
    ContentType opaque_type = application_data; /* 23 */
    ProtocolVersion legacy_record_version = 0x0303; /* TLS v1.2 */
    uint16 length;
    opaque encrypted_record[TLSCiphertext.length];
} TLSCiphertext;

B.2. 警报消息

enum { warning(1), fatal(2), (255) } AlertLevel;

enum {
    close_notify(0),
    unexpected_message(10),
    bad_record_mac(20),
    decryption_failed_RESERVED(21),
    record_overflow(22),
    decompression_failure_RESERVED(30),
    handshake_failure(40),
    no_certificate_RESERVED(41),
    bad_certificate(42),
    unsupported_certificate(43),
    certificate_revoked(44),
    certificate_expired(45),
    certificate_unknown(46),
    illegal_parameter(47),
    unknown_ca(48),
    access_denied(49),
    decode_error(50),
    decrypt_error(51),
    export_restriction_RESERVED(60),
    protocol_version(70),
    insufficient_security(71),
    internal_error(80),
    inappropriate_fallback(86),
    user_canceled(90),
    no_renegotiation_RESERVED(100),
    missing_extension(109),
    unsupported_extension(110),
    certificate_unobtainable_RESERVED(111),
    unrecognized_name(112),
    bad_certificate_status_response(113),
    bad_certificate_hash_value_RESERVED(114),
    unknown_psk_identity(115),
    certificate_required(116),
    no_application_protocol(120),
    (255)
} AlertDescription;

struct {
    AlertLevel level;
    AlertDescription description;
} Alert;

B.3. 握手协议

enum {
    hello_request_RESERVED(0),
    client_hello(1),
    server_hello(2),
    hello_verify_request_RESERVED(3),
    new_session_ticket(4),
    end_of_early_data(5),
    hello_retry_request_RESERVED(6),
    encrypted_extensions(8),
    certificate(11),
    server_key_exchange_RESERVED(12),
    certificate_request(13),
    server_hello_done_RESERVED(14),
    certificate_verify(15),
    client_key_exchange_RESERVED(16),
    finished(20),
    certificate_url_RESERVED(21),
    certificate_status_RESERVED(22),
    supplemental_data_RESERVED(23),
    key_update(24),
    message_hash(254),
    (255)
} HandshakeType;

struct {
    HandshakeType msg_type;    /* 握手类型 */
    uint24 length;             /* 消息字节数 */
    select (Handshake.msg_type) {
        case client_hello:          ClientHello;
        case server_hello:          ServerHello;
        case end_of_early_data:     EndOfEarlyData;
        case encrypted_extensions:  EncryptedExtensions;
        case certificate_request:   CertificateRequest;
        case certificate:           Certificate;
        case certificate_verify:    CertificateVerify;
        case finished:              Finished;
        case new_session_ticket:    NewSessionTicket;
        case key_update:            KeyUpdate;
    };
} Handshake;

B.3.1. 密钥交换消息

uint16 ProtocolVersion;
opaque Random[32];

uint8 CipherSuite[2];    /* 密码套件选择器 */

struct {
    ProtocolVersion legacy_version = 0x0303;    /* TLS v1.2 */
    Random random;
    opaque legacy_session_id<0..32>;
    CipherSuite cipher_suites<2..2^16-2>;
    opaque legacy_compression_methods<1..2^8-1>;
    Extension extensions<8..2^16-1>;
} ClientHello;

struct {
    ProtocolVersion legacy_version = 0x0303;    /* TLS v1.2 */
    Random random;
    opaque legacy_session_id_echo<0..32>;
    CipherSuite cipher_suite;
    uint8 legacy_compression_method = 0;
    Extension extensions<6..2^16-1>;
} ServerHello;

struct {
    ExtensionType extension_type;
    opaque extension_data<0..2^16-1>;
} Extension;

enum {
    server_name(0),                             /* RFC 6066 */
    max_fragment_length(1),                     /* RFC 6066 */
    status_request(5),                          /* RFC 6066 */
    supported_groups(10),                       /* RFC 8422, 7919 */
    signature_algorithms(13),                   /* RFC 8446 */
    use_srtp(14),                               /* RFC 5764 */
    heartbeat(15),                              /* RFC 6520 */
    application_layer_protocol_negotiation(16), /* RFC 7301 */
    signed_certificate_timestamp(18),           /* RFC 6962 */
    client_certificate_type(19),                /* RFC 7250 */
    server_certificate_type(20),                /* RFC 7250 */
    padding(21),                                /* RFC 7685 */
    RESERVED(40),                               /* 已使用但未分配 */
    pre_shared_key(41),                         /* RFC 8446 */
    early_data(42),                             /* RFC 8446 */
    supported_versions(43),                     /* RFC 8446 */
    cookie(44),                                 /* RFC 8446 */
    psk_key_exchange_modes(45),                 /* RFC 8446 */
    RESERVED(46),                               /* 已使用但未分配 */
    certificate_authorities(47),                /* RFC 8446 */
    oid_filters(48),                            /* RFC 8446 */
    post_handshake_auth(49),                    /* RFC 8446 */
    signature_algorithms_cert(50),              /* RFC 8446 */
    key_share(51),                              /* RFC 8446 */
    (65535)
} ExtensionType;

struct {
    NamedGroup group;
    opaque key_exchange<1..2^16-1>;
} KeyShareEntry;

struct {
    KeyShareEntry client_shares<0..2^16-1>;
} KeyShareClientHello;

struct {
    NamedGroup selected_group;
} KeyShareHelloRetryRequest;

struct {
    KeyShareEntry server_share;
} KeyShareServerHello;

struct {
    uint8 legacy_form = 4;
    opaque X[coordinate_length];
    opaque Y[coordinate_length];
} UncompressedPointRepresentation;

enum { psk_ke(0), psk_dhe_ke(1), (255) } PskKeyExchangeMode;

struct {
    PskKeyExchangeMode ke_modes<1..255>;
} PskKeyExchangeModes;

struct {} Empty;

struct {
    select (Handshake.msg_type) {
        case new_session_ticket:   uint32 max_early_data_size;
        case client_hello:         Empty;
        case encrypted_extensions: Empty;
    };
} EarlyDataIndication;

struct {
    opaque identity<1..2^16-1>;
    uint32 obfuscated_ticket_age;
} PskIdentity;

opaque PskBinderEntry<32..255>;

struct {
    PskIdentity identities<7..2^16-1>;
    PskBinderEntry binders<33..2^16-1>;
} OfferedPsks;

struct {
    select (Handshake.msg_type) {
        case client_hello: OfferedPsks;
        case server_hello: uint16 selected_identity;
    };
} PreSharedKeyExtension;

B.3.1.1.  版本扩展

struct {
    select (Handshake.msg_type) {
        case client_hello:
            ProtocolVersion versions<2..254>;

        case server_hello: /* 和HelloRetryRequest */
            ProtocolVersion selected_version;
    };
} SupportedVersions;

B.3.1.2.  Cookie扩展

struct {
    opaque cookie<1..2^16-1>;
} Cookie;

B.3.1.3.  签名算法扩展

enum {
    /* RSASSA-PKCS1-v1_5算法 */
    rsa_pkcs1_sha256(0x0401),
    rsa_pkcs1_sha384(0x0501),
    rsa_pkcs1_sha512(0x0601),

    /* ECDSA算法 */
    ecdsa_secp256r1_sha256(0x0403),
    ecdsa_secp384r1_sha384(0x0503),
    ecdsa_secp521r1_sha512(0x0603),

    /* 使用RSA加密的RSASSA-PSS算法，公钥OID rsaEncryption */
    rsa_pss_rsae_sha256(0x0804),
    rsa_pss_rsae_sha384(0x0805),
    rsa_pss_rsae_sha512(0x0806),

    /* EdDSA算法 */
    ed25519(0x0807),
    ed448(0x0808),

    /* 使用RSA PSS的算法，公钥OID为RSASSA-PSS */
    rsa_pss_pss_sha256(0x0809),
    rsa_pss_pss_sha384(0x080a),
    rsa_pss_pss_sha512(0x080b),

    /* 传统算法 */
    rsa_pkcs1_sha1(0x0201),
    ecdsa_sha1(0x0203),

    /* 保留代码点 */
    obsolete_RESERVED(0x0000..0x0200),
    dsa_sha1_RESERVED(0x0202),
    obsolete_RESERVED(0x0204..0x0400),
    dsa_sha256_RESERVED(0x0402),
    obsolete_RESERVED(0x0404..0x0500),
    dsa_sha384_RESERVED(0x0502),
    obsolete_RESERVED(0x0504..0x0600),
    dsa_sha512_RESERVED(0x0602),
    obsolete_RESERVED(0x0604..0x06FF),
    private_use(0xFE00..0xFFFF),
    (0xFFFF)
} SignatureScheme;

struct {
    SignatureScheme supported_signature_algorithms<2..2^16-2>;
} SignatureSchemeList;

B.3.1.4.  支持的组扩展

enum {
    unallocated_RESERVED(0x0000),

    /* 椭圆曲线组（ECDHE） */
    obsolete_RESERVED(0x0001..0x0016),
    secp256r1(0x0017), secp384r1(0x0018), secp521r1(0x0019),
    obsolete_RESERVED(0x001A..0x001C),
    x25519(0x001D), x448(0x001E),

    /* 有限域组（DHE） */
    ffdhe2048(0x0100), ffdhe3072(0x0101), ffdhe4096(0x0102),
    ffdhe6144(0x0103), ffdhe8192(0x0104),

    /* 保留代码点 */
    ffdhe_private_use(0x01FC..0x01FF),
    ecdhe_private_use(0xFE00..0xFEFF),
    obsolete_RESERVED(0xFF01..0xFF02),
    (0xFFFF)
} NamedGroup;

struct {
    NamedGroup named_group_list<2..2^16-1>;
} NamedGroupList;

“obsolete_RESERVED”范围内的值曾在TLS早期版本中使用，TLS 1.3实现不得提供或协商这些值。旧曲线可能存在已知或潜在的弱点，或使用极少，部分仅因服务器配置问题。它们不再被认为适合一般用途，应视为潜在不安全。此处定义的曲线集足以确保与所有已部署且配置正确的TLS实现的互操作性。

B.3.2. 服务器参数消息

opaque DistinguishedName<1..2^16-1>;

struct {
    DistinguishedName authorities<3..2^16-1>;
} CertificateAuthoritiesExtension;

struct {
    opaque certificate_extension_oid<1..2^8-1>;
    opaque certificate_extension_values<0..2^16-1>;
} OIDFilter;

struct {
    OIDFilter filters<0..2^16-1>;
} OIDFilterExtension;

struct {} PostHandshakeAuth;

struct {
    Extension extensions<0..2^16-1>;
} EncryptedExtensions;

struct {
    opaque certificate_request_context<0..2^8-1>;
    Extension extensions<2..2^16-1>;
} CertificateRequest;

B.3.3. 认证消息

enum {
    X509(0),
    OpenPGP_RESERVED(1),
    RawPublicKey(2),
    (255)
} CertificateType;

struct {
    select (certificate_type) {
        case RawPublicKey:
            /* RFC 7250 ASN.1_subjectPublicKeyInfo */
            opaque ASN1_subjectPublicKeyInfo<1..2^24-1>;

        case X509:
            opaque cert_data<1..2^24-1>;
    };
    Extension extensions<0..2^16-1>;
} CertificateEntry;

struct {
    opaque certificate_request_context<0..2^8-1>;
    CertificateEntry certificate_list<0..2^24-1>;
} Certificate;

struct {
    SignatureScheme algorithm;
    opaque signature<0..2^16-1>;
} CertificateVerify;

struct {
    opaque verify_data[Hash.length];
} Finished;

B.3.4.  Ticket建立

struct {
    uint32 ticket_lifetime;
    uint32 ticket_age_add;
    opaque ticket_nonce<0..255>;
    opaque ticket<1..2^16-1>;
    Extension extensions<0..2^16-2>;
} NewSessionTicket;

B.3.5. 密钥更新

struct {} EndOfEarlyData;

enum {
    update_not_requested(0), update_requested(1), (255)
} KeyUpdateRequest;

struct {
    KeyUpdateRequest request_update;
} KeyUpdate;

B.4. 密码套件

对称密码套件定义了用于HKDF的AEAD算法和哈希算法的组合。密码套件名称遵循命名规则：

      CipherSuite TLS_AEAD_HASH = VALUE;

+-----------+------------------------------------------------+
| 组成部分  | 内容                                           |
+-----------+------------------------------------------------+
| TLS       | 字符串“TLS”                                    |
|           |                                                 |
| AEAD      | 用于记录保护的AEAD算法                          |
|           |                                                 |
| HASH      | 用于HKDF的哈希算法                              |
|           |                                                 |
| VALUE     | 为该密码套件分配的两字节ID                        |
+-----------+------------------------------------------------+

本规范定义了TLS 1.3使用的以下密码套件。

              +------------------------------+-------------+
              | 描述                         | 值          |
              +------------------------------+-------------+
              | TLS_AES_128_GCM_SHA256       | {0x13,0x01} |
              |                              |             |
              | TLS_AES_256_GCM_SHA384       | {0x13,0x02} |
              |                              |             |
              | TLS_CHACHA20_POLY1305_SHA256 | {0x13,0x03} |
              |                              |             |
              | TLS_AES_128_CCM_SHA256       | {0x13,0x04} |
              |                              |             |
              | TLS_AES_128_CCM_8_SHA256     | {0x13,0x05} |
              +------------------------------+-------------+

对应的AEAD算法包括AEAD_AES_128_GCM、AEAD_AES_256_GCM和AEAD_AES_128_CCM，定义在[RFC5116]中。AEAD_CHACHA20_POLY1305定义在[RFC8439]中。AEAD_AES_128_CCM_8定义在[RFC6655]中。对应的哈希算法定义在[SHS]中。

虽然TLS 1.3使用与早期TLS版本相同的密码套件空间，但TLS 1.3的密码套件定义不同，仅指定对称密码，不能用于TLS 1.2。同样，TLS 1.2及以下版本的密码套件也不能用于TLS 1.3。

新密码套件值由IANA分配，详见第11节。

附录C. 实现注意事项

TLS协议无法防止许多常见的安全错误。本附录提供若干建议以协助实现者。 [TLS13-TRACES]提供TLS 1.3握手的测试向量。

C.1. 随机数生成与种子

TLS要求使用密码学安全的伪随机数生成器（CSPRNG）。大多数情况下，操作系统提供合适的设施，如/dev/urandom，应优先使用，除非有其他（如性能）考虑。建议优先使用现有的CSPRNG实现，而非自行设计。许多可靠的加密库已在合理的许可条款下提供。如果这些不令人满意，[RFC4086]提供了随机值生成的指导。

TLS在公共协议字段（如ClientHello和ServerHello中的随机值）以及密钥材料生成中使用随机值。只要CSPRNG正常工作，这不会带来安全问题，因为从输出难以推断CSPRNG状态。然而，若CSPRNG存在缺陷，攻击者可能利用公开输出推断内部状态，从而预测密钥材料（详见[CHECKOWAY]）。实现者可以通过使用不同的CSPRNG生成公开和私有值，增强安全性。

C.2. 证书与认证

实现应负责验证证书的完整性，并且通常应支持证书吊销消息。除非应用配置文件中有具体指示，否则应始终验证证书以确保其由受信任的证书授权机构（CA）正确签署。信任锚点的选择和添加应非常谨慎。用户应能够查看有关证书和信任锚点的信息。应用程序还应强制执行最小和最大密钥长度。例如，包含弱于2048位RSA或224位ECDSA的密钥或签名的认证路径，不适用于安全应用。

C.3. 实现陷阱

实践经验表明，早期TLS规范的某些部分难以理解，且成为互操作性和安全性问题的源头。许多这些问题已在本文档中澄清，但本附录列出一些需要实现者特别注意的关键事项。

TLS协议相关问题：

- 你是否正确处理被分片到多个TLS记录的握手消息（见第5.1节）？是否正确处理诸如ClientHello被拆分成多个小片段的极端情况？是否对超出最大片段大小的握手消息进行分片？特别是，Certificate和CertificateRequest握手消息可能大到需要分片。

- 你是否忽略所有未加密TLS记录中的TLS记录层版本号（见附录D）？

- 你是否确保所有支持SSL、RC4、导出密码套件和MD5（通过“signature_algorithms”扩展）在支持TLS 1.3或更高版本的配置中已完全移除，并且尝试使用这些过时功能时能正确失败（见附录D）？

- 你是否正确处理ClientHellos中的TLS扩展，包括未知扩展？

- 当服务器请求客户端证书但没有合适证书时，你是否正确发送空的Certificate消息，而不是省略整个消息（见第4.4.2节）？

- 在处理由AEAD-Decrypt产生的明文片段并从末尾扫描ContentType时，你是否避免在对端发送格式错误的全零明文时扫描越过明文起始位置？

- 你是否正确忽略未识别的密码套件（第4.1.2节）、hello扩展（第4.2节）、命名组（第4.2.7节）、密钥共享（第4.2.8节）、支持的版本（第4.2.1节）和签名算法（第4.2.3节）？

- 作为服务器，你是否在支持兼容（EC）DHE组但未在“key_share”扩展中预测到的情况下，向客户端发送HelloRetryRequest？作为客户端，你是否正确处理来自服务器的HelloRetryRequest？

加密细节：

- 你采用了哪些措施防止计时攻击[TIMING]？

- 使用Diffie-Hellman密钥交换时，你是否正确保留了协商密钥中的前导零字节（见第7.4.1节）？

- 你的TLS客户端是否检查服务器发送的Diffie-Hellman参数是否可接受（见第4.2.8.1节）？

- 你是否在生成Diffie-Hellman私钥、ECDSA“k”参数及其他安全关键值时使用强大且正确种子化的随机数生成器（见附录C.1）？建议实现采用[RFC6979]中规定的“确定性ECDSA”。

- 你是否对Diffie-Hellman公钥值和共享秘密进行零填充至组大小（见第4.2.8.1节和第7.4.1节）？

- 你在签名后是否验证签名，以防止RSA-CRT密钥泄露[FW15]？

C.4. 客户端追踪预防

客户端不应重复使用票据进行多次连接。重复使用票据会让被动观察者关联不同连接。发放票据的服务器应提供的票据数量至少等于客户端可能使用的连接数，例如，使用HTTP/1.1的网页浏览器可能会开启六个连接。服务器应在每次连接时发放新票据，以确保客户端在建立新连接时总能使用新票据。

C.5. 未认证操作

TLS的早期版本提供了基于匿名Diffie-Hellman的显式未认证密码套件。这些模式在TLS 1.3中已被废弃。然而，仍可通过多种方法协商不提供可验证服务器认证的参数，包括：

- 原始公钥[RFC7250]。

- 使用证书中的公钥但不验证证书链或其内容。

单独使用任何一种技术都易受中间人攻击，因此不安全。也可以通过带外验证服务器公钥、首次信任机制或信道绑定（尽管[RFC5929]中描述的信道绑定未定义于TLS 1.3）将此类连接绑定到外部认证机制。如果不使用此类机制，连接就没有主动中间人攻击的保护；应用程序不得在没有明确配置或特定应用配置文件的情况下使用TLS。

附录D. 向后兼容性

TLS协议内置了端点之间版本协商的机制，支持不同版本的TLS。

TLS 1.x和SSL 3.0使用兼容的ClientHello消息。只要ClientHello格式保持兼容，且客户端和服务器至少支持一个共同的协议版本，服务器也能处理尝试使用未来版本TLS的客户端。

早期TLS版本使用记录层版本号（TLSPlaintext.legacy_record_version和TLSCiphertext.legacy_record_version）用于多种目的。从TLS 1.3起，该字段已被废弃。所有实现必须忽略TLSPlaintext.legacy_record_version的值。TLSCiphertext.legacy_record_version的值包含在解保护的附加数据中，但可以忽略或验证其是否匹配固定常量值。版本协商仅通过握手版本（ClientHello.legacy_version和ServerHello.legacy_version）以及ClientHello、HelloRetryRequest和ServerHello中的“supported_versions”扩展进行。为了最大程度兼容旧端点，支持TLS 1.0-1.2的实现应在ServerHello及之后的所有记录中设置记录层版本号为协商版本。

为了最大程度兼容以前的非标准行为和配置错误的部署，所有实现应支持基于本文档预期的证书路径验证，即使在处理早期TLS版本的握手时（见第4.4.2.2节）。

TLS 1.2及以前版本支持“扩展主秘密”[RFC7627]扩展，将握手转录的部分内容摘要到主秘密中。由于TLS 1.3始终在服务器Finished之前哈希转录内容，支持TLS 1.3及早期版本的实现应在API中指示使用了扩展主秘密。

D.1. 与旧服务器协商

希望与不支持TLS 1.3的服务器协商的TLS 1.3客户端应发送普通的TLS 1.3 ClientHello，包含0x0303（TLS 1.2）在ClientHello.legacy_version中，但在“supported_versions”扩展中使用正确的版本。如果服务器不支持TLS 1.3，它将以包含较旧版本号的ServerHello响应。如果客户端同意使用该版本，协商将按协议进行。使用票据恢复的客户端应使用之前协商的版本发起连接。

注意，0-RTT数据不兼容旧服务器，且不应在不确认服务器支持TLS 1.3的情况下发送（见附录D.3）。

如果服务器选择的版本不被客户端支持（或不可接受），客户端必须以“protocol_version”警报中止握手。

一些遗留服务器实现未正确实现TLS规范，可能在遇到未知的TLS扩展或版本时中止连接。与存在缺陷的服务器的互操作性是一个复杂话题，超出本文范围。可能需要多次连接尝试以协商向后兼容的连接，但此做法易受降级攻击，不推荐使用。

D.2. 与旧客户端协商

TLS服务器也可能收到指示版本低于其最高支持版本的ClientHello。如果存在“supported_versions”扩展，服务器必须按第4.2.1节所述协商；如果没有，必须在ClientHello.legacy_version和TLS 1.2中取最小值。例如，服务器支持TLS 1.0、1.1和1.2，且legacy_version为TLS 1.0，则会使用TLS 1.0的ServerHello。如果没有“supported_versions”扩展，且服务器只支持比legacy_version更高的版本，必须以“protocol_version”警报中止握手。

注意，早期TLS版本未在所有情况下明确指定记录层版本号（TLSPlaintext.legacy_record_version），服务器会收到各种TLS 1.x版本，但其值必须始终忽略。

D.3.  0-RTT向后兼容性

0-RTT数据不兼容旧服务器。旧服务器会用较旧的ServerHello响应ClientHello，但不会正确跳过0-RTT数据，导致握手失败。在多服务器部署中，客户端尝试使用0-RTT可能会遇到问题。例如，部署可能逐步引入TLS 1.3，部分服务器实现TLS 1.3，部分仍用TLS 1.2，或者TLS 1.3部署被降级到TLS 1.2。

尝试发送0-RTT数据的客户端如果收到TLS 1.2或更早版本的ServerHello，必须失败连接，并可重试但禁用0-RTT。为避免降级攻击，客户端应只禁用0-RTT，不禁用TLS 1.3。

为避免此类错误，多服务器部署应确保在启用0-RTT前，TLS 1.3的部署是统一且稳定的。

D.4. 中间盒兼容模式

实测[Ben17a][Ben17b][Res17a][Res17b]发现，许多中间盒在TLS 1.3协商时表现异常。实现可通过让TLS 1.3握手更像TLS 1.2握手，增加通过中间盒的成功率：

- 客户端在ClientHello中始终提供非空的会话ID（见第4.1.2节的legacy_session_id部分）。

- 若不提供早期数据，客户端在第二次发飞行前立即发送一个虚拟的change_cipher_spec记录（见第5节第三段），可能在第二个ClientHello之前或在加密握手飞行之前。若提供早期数据，则在第一个ClientHello之后立即放置此记录。

- 服务器在第一个握手消息后立即发送虚拟的change_cipher_spec记录，可能在ServerHello或HelloRetryRequest之后。

这些变化使TLS 1.3握手更像TLS 1.2会话恢复，从而提高穿越中间盒的成功率。此“兼容模式”部分协商：客户端可以选择提供或不提供会话ID，服务器必须回显。任何一方在握手过程中都可以随时发送change_cipher_spec，尽管应被对端忽略，但如果客户端提供非空会话ID，服务器必须按附录中的描述发送change_cipher_spec。

D.5. 与向后兼容相关的安全限制

支持较旧TLS版本的实现应优先采用前向安全和AEAD密码套件（当可用时）。

RC4密码套件的安全性被认为不足（见[RFC7465]），实现不得出于任何原因提供或协商RC4密码套件。

旧版本的TLS允许使用安全等级非常低的密码套件。
安全强度低于112位的密码套件不得在任何版本的TLS中出于任何原因被提供或协商。

SSL 3.0 [RFC6101]的安全性被认为不足，原因详见[RFC7568]，因此不得出于任何原因进行协商。

SSL 2.0 [SSL2]的安全性被认为不足，原因详见[RFC6176]，因此不得出于任何原因进行协商。

实现必须不得发送兼容SSL 2.0的CLIENT-HELLO。实现不得使用兼容SSL 2.0的CLIENT-HELLO协商TLS 1.3或更高版本。不建议接受兼容SSL 2.0的CLIENT-HELLO以协商较旧版本的TLS。

实现不得发送ClientHello.legacy_version或ServerHello.legacy_version字段设置为0x0300或更低的消息。任何接收到ClientHello.legacy_version或ServerHello.legacy_version设置为0x0300的Hello消息的端点，必须中止握手并发出“protocol_version”警报。

实现不得发送版本低于0x0300的记录。实现应避免接受版本低于0x0300的记录（但如果完全忽略记录版本号，可能会无意中接受）。

实现不得使用[RFC6066]第7节定义的截断HMAC扩展，因为它不适用于AEAD算法，并且在某些场景中已被证明不安全。

附录E. 安全属性概述

对TLS的完整安全性分析超出本文范围。在本附录中，我们提供对所需安全属性的非正式描述，以及指向研究文献中更详细、形式化定义的参考。

我们将握手的属性与记录层的属性分开讨论。

E.1. 握手

TLS握手是一种认证密钥交换（AKE）协议，旨在提供单向认证（仅服务器）和双向认证（客户端和服务器）功能。在握手完成后，双方会输出以下内容的视图：

- 一组“会话密钥”（由主密钥派生的各种秘密），可由其派生出一组工作密钥。
- 一组密码参数（算法等）。
- 通信双方的身份。

我们假设攻击者是主动的网络攻击者，意味着其对通信双方之间的网络具有完全控制权 [RFC3552]。即使在这种情况下，握手仍应提供以下属性。注意，这些属性不一定相互独立，但反映了协议用户的需求。

- 生成相同的会话密钥：握手应在双方成功完成的情况下输出相同的会话密钥集（参见[CK01]第1部分第1点）。
- 会话密钥的机密性：共享的会话密钥应仅为通信双方所知，攻击者不得得知（参见[CK01]第1部分第2点）。注意，在单向认证的连接中，攻击者可以与服务器建立自己的会话密钥，但这些密钥与客户端建立的不同。
- 对等方认证：客户端对对方身份的认知应反映服务器的身份。如果客户端已认证，服务器对对方身份的认知也应与客户端的身份一致。
- 会话密钥的唯一性：任何两个不同的握手应产生不同且无关的会话密钥。由一次握手产生的单个会话密钥也应彼此不同且独立。
- 降级保护：双方的密码参数应一致，且应与在无攻击情况下通信时的参数相同（参见[BBFGKZ16]第8和第9定义）。
- 长期密钥的前向安全性：如果在握手完成后，长期密钥（如证书中的签名密钥或PSK中的外部/恢复密钥）被攻破，不应影响会话密钥的安全（参见[DOW92]），前提是会话密钥已被擦除。在使用“psk_ke”模式的PSK时，不满足前向安全性。
- 密钥泄露抵抗（KCI）：在相互认证的证书连接中，攻破一方的长期秘密不应破坏该方对其对等方的认证（参见[HGFS15]）。例如，如果客户端的签名密钥被攻破，不应能冒充任意服务器与客户端建立后续握手。
- 端点身份保护：服务器的身份（证书）应免受被动攻击者的影响。客户端的身份应同时受到被动和主动攻击的保护。

非正式地说，TLS 1.3的基于签名的模式通过（EC）DHE密钥交换建立唯一的、机密的共享密钥，并由服务器对握手转录的签名进行认证，同时通过MAC绑定到服务器身份。如果客户端通过证书进行认证，它也会对握手转录签名，并提供绑定两个身份的MAC。[SIGMA]描述了此类密钥交换协议的设计与分析。如果每次连接都使用新的（EC）DHE密钥，则输出的密钥具有前向安全性。

外部PSK和恢复PSK通过从长期共享秘密出发，建立每个连接唯一的短期会话密钥集。该秘密可能在之前的握手中已建立。如果使用带（EC）DHE的PSK进行密钥协商，这些会话密钥也将具有前向安全性。恢复PSK的设计确保由连接N计算的恢复主秘密（用于形成连接N+1）与连接N使用的流量密钥分离，从而提供连接间的前向安全性。此外，如果在同一连接上建立多个票据，它们关联的密钥不同，因此一个票据的PSK泄露不会影响用其他票据的PSK建立的连接。这一特性在票据存储在数据库中（可以删除）时尤为重要，而非自我加密的存储方式。

PSK绑定值在某种程度上绑定了PSK与当前握手，以及PSK建立的会话与当前会话之间的关系。这一绑定包括了原始握手转录，因为该转录被摘要到生成恢复主秘密的值中。这要求用于生成恢复主秘密的密钥派生函数（KDF）和用于计算绑定的MAC都具有抗碰撞性。详见附录E.1.1。注意：绑定值不覆盖其他PSK的绑定值，尽管它们包含在Finished MAC中。

目前，TLS不允许服务器在非证书基础的握手（如PSK）中发送certificate_request消息。如果未来放宽此限制，客户端的签名将不会直接覆盖服务器的证书。然而，如果PSK是通过NewSessionTicket建立的，客户端的签名将通过PSK绑定间接覆盖服务器的证书。[PSK-FINISHED]描述了对未绑定到服务器证书的构造的具体攻击（另见[Kraw16]）。当客户端可能与两个不同端点共享相同的PSK/密钥ID时，使用基于证书的客户端认证是不安全的。除非通过某些扩展协商，否则实现不得将外部PSK与客户端或服务器的证书认证结合使用。

如果使用导出器，则其生成的值是唯一且机密的（因为它们由唯一的会话密钥生成）。用不同标签和上下文计算的导出值在计算上是独立的，因此无法从一个导出值推算出另一个或会话秘密。注意：导出器可以生成任意长度的值；如果导出器用作信道绑定，则导出值必须足够大以提供抗碰撞性。TLS 1.3中的导出器与早期流量密钥和应用流量密钥来自相同的握手上下文，因此具有类似的安全属性。注意：它们不包括客户端证书；未来可能需要定义新的导出器以绑定到客户端证书。

所有握手模式中，Finished MAC（以及存在时的签名）都能防止降级攻击。此外，随机数中的某些字节（详见4.1.3节）允许检测到降级到早期TLS版本的情况。详见[BBFGKZ16]关于TLS 1.3和降级的更多细节。

一旦客户端和服务器交换足够的信息以建立共享密钥，剩余的握手部分将被加密，从而即使共享密钥未经过认证，也能防止被动攻击。由于服务器在客户端之前进行认证，客户端可以确保在向服务器认证的情况下，只向已认证的服务器披露身份信息。注意，协议实现必须在握手期间使用提供的记录填充机制，以避免因长度泄露身份信息。客户端提出的PSK身份未加密，服务器选择的身份也未加密。

E.1.1. 密钥派生与HKDF

TLS 1.3中的密钥派生使用[RFC5869]定义的HKDF及其两个组成部分：HKDF-Extract和HKDF-Expand。HKDF的完整原理详见[Kraw10]，在TLS 1.3中的应用原理详见[KW16]。在本文中，每次应用HKDF-Extract后，通常会跟随一次或多次HKDF-Expand。应始终遵循此顺序（包括未来的修订）；特别是，不应在没有HKDF-Expand的情况下，将HKDF-Extract的输出作为另一次HKDF-Extract的输入。多次应用HKDF-Expand到相同输入是允许的，只要通过密钥和/或标签进行区分。

注意，HKDF-Expand实现了一个伪随机函数（PRF），其输入和输出长度可变。在本文某些用途中（如生成导出值和恢复主秘密），必须确保HKDF-Expand的应用具有抗碰撞性，即找到两个不同输入产生相同输出应是不可行的。这要求基础哈希函数具有抗碰撞性，且HKDF-Expand的输出长度至少为256位（或满足哈希函数防碰撞的需求）。

E.1.2. 客户端认证

已向服务器发送认证数据（在握手中或在后握手认证中）的客户端，不能保证之后服务器是否仍视其为已认证。如果客户端需要确认服务器是否认为连接是单向或双向认证的，这应由应用层提供。详见[CHHSV17]。此外，[Kraw16]对后握手认证的分析表明，客户端在后握手阶段由证书识别的身份持有流量密钥。因此，该方是参与原始握手的客户端，或是被原始客户端委托持有流量密钥的实体（前提是密钥未被攻破）。

E.1.3. 0-RTT

0-RTT模式通常提供与1-RTT数据类似的安全属性，唯一的区别在于：0-RTT的加密密钥不提供完全的前向安全性，且服务器不能在不存储潜在过多状态的情况下保证握手的唯一性（不可重放性）。详见第8节关于限制重放攻击的机制。

E.1.4. 导出器的独立性

导出主秘密（exporter_master_secret）和早期导出主秘密（early_exporter_master_secret）是为了与交通密钥（traffic keys）相互独立而派生的，因此它们不构成对使用这些密钥加密的交通的安全威胁。然而，由于这些秘密可以用来计算任何导出器（exporter）值，建议尽快将其擦除。如果已知所有导出标签（exporter labels），实现应预先计算所有标签对应的导出器计算的内部派生阶段（Derive-Secret），然后在确认不再需要时立即擦除[early_]exporter_master_secret，以及在知道不再需要时擦除每个内部值。

E.1.5. 事后妥协安全性（Post-Compromise Security）

TLS不为在对等方的长期秘密（签名密钥或外部预共享密钥PSK）被攻破之后进行的握手提供安全保障。因此，TLS不提供事后妥协安全性（[CCG16]），有时也称为向后或未来安全性。这与抗密钥-compromise-impersonation（KCI）攻击的安全性不同，后者描述的是在自身长期秘密被攻破后，某一方仍能获得的安全保障。

E.1.6. 外部参考资料

读者应参考以下文献，以分析TLS握手过程：[DFGS15]、[CHSV16]、[DFGS16]、[KW16]、[Kraw16]、[FGSW16]、[LXZFH16]、[FG17] 和 [BBK17]。

E.2. 记录层（Record Layer）

记录层依赖于握手产生强大的交通秘密（traffic secrets），这些秘密可用于派生双向加密密钥和随机数（nonces）。假设这一点成立，且密钥仅用于第5.5节所述的有限数据范围内，则记录层应提供以下保证：

- 保密性：攻击者不应能确定某一记录的明文内容。
- 完整性：攻击者不应能伪造不同于现有记录且会被接收方接受的新记录。
- 顺序保护/防重放：攻击者不应能使接收方接受已接受过的记录，或在未处理完前一条记录的情况下接受第N+1条记录。
- 长度隐藏：给定某一记录的外部长度，攻击者不应能判断内容部分与填充部分的比例。
- 密钥变更后的前向安全性：如果已使用第4.6.3节描述的交通密钥更新机制，并且删除了前一代密钥，则攻破端点的攻击者不应能解密用旧密钥加密的流量。

非正式地说，TLS 1.3通过AEAD（Authenticated Encryption with Associated Data）保护明文，提供这些特性。AEAD加密（[RFC5116]）确保数据的保密性和完整性。非重放性由为每个记录使用不同的随机数（nonce）实现，该随机数由记录序列号（第5.3节）派生，且序列号在双方独立维护；因此，乱序传输的记录会导致AEAD解密失败。为了防止在不同用户用相同密钥反复加密相同明文时发生大规模密码分析（如HTTP场景），随机数由序列号与连接特定的初始化向量（IV）混合生成，IV与流量密钥一同派生。详见[BT16]对该结构的分析。

TLS 1.3中的重新密钥（rekey）技术（见第7.2节）遵循[REKEY]中讨论的串行生成器（serial generator）结构，表明重新密钥可以使密钥在比不重新密钥时更大量的加密操作中使用。这依赖于HKDF-Expand-Label函数作为伪随机函数（PRF）的安全性。此外，只要该函数是真正的单向函数，就不可能从之前的密钥计算出流量密钥（实现前向安全性）。

TLS不为连接中在某一交通秘密被攻破后传输的数据提供安全保障。也就是说，TLS不提供事后安全性、未来安全性或向后安全性（相对于交通秘密而言）。实际上，攻破某一交通秘密的攻击者可以计算出该连接的所有未来交通秘密。希望获得此类保证的系统应重新进行握手，并通过（EC）DHE交换建立新连接。

E.2.1. 外部参考资料

读者应参考以下文献，以分析TLS记录层：[BMMRT15]、[BT16]、[BDFKPPRSZZ16]、[BBK17] 和 [PS18]。

E.3. 流量分析（Traffic Analysis）

TLS容易受到基于观察加密包的长度和时间间隔的多种流量分析攻击（[CLINIC]、[HCJC16]）。在消息集合较少、易于区分的场景（如托管固定内容的视频服务器）中，这类攻击尤为容易，但即使在更复杂的场景中，也能提供有用信息。

TLS没有提供针对这类攻击的特定防护措施，但包含了应用层的填充机制：由AEAD保护的明文包括内容和变长填充，允许应用生成任意长度的加密记录，以及仅用于掩盖传输与静默时期差异的填充流量。由于填充与内容一同加密，攻击者无法直接判断填充长度，但可能通过记录处理中的时间信道间接测量（如处理一条记录所需时间或通过请求响应时间判断请求是否指向相同资源）。通常，完全消除这些信道非常困难，因为即使采用恒定时间的填充移除函数，也可能在数据依赖的函数中泄露信息。最低限度，完全恒定时间的服务器或客户端需要与应用层协议紧密配合，包括使高层协议也实现恒定时间。

注意：强健的流量分析防护可能会导致性能下降，表现为传输延迟增加和流量增多。

E.4. 侧信道攻击（Side-Channel Attacks）

一般而言，TLS没有针对侧信道攻击（如通过时间等次级通道攻击通信内容）的专门防护措施，相关防护由底层密码原语的实现负责。然而，TLS的某些特性旨在简化抗侧信道代码的编写：

- 不同于早期版本TLS采用的复合MAC-后加密结构，TLS 1.3仅使用AEAD算法，允许实现使用自包含的恒定时间实现。
- TLS对所有解密错误使用统一的“bad_record_mac”警报，旨在防止攻击者逐步获取消息部分信息。遇到此类错误时终止连接；新连接将使用不同的加密材料，防止多次尝试的密码攻击。

信息泄露通过侧信道在TLS之上层的应用协议和应用程序中也可能发生。抗侧信道攻击的能力依赖于应用和协议的单独设计，确保敏感信息不会无意中泄露。

E.5. 0-RTT重放攻击（Replay Attacks on 0-RTT）

可重放的0-RTT数据对TLS应用带来多种安全威胁，除非应用特别设计为在重放下安全（至少应是幂等的，但在许多情况下还需更强条件，如恒定时间响应）。潜在攻击包括：

- 重复执行引发副作用的操作（如购买商品或转账），危害网站或用户。
- 攻击者存储并重放0-RTT消息，以改变消息顺序（如将删除操作放在创建之后）。
- 利用缓存时间行为，通过重放0-RTT消息到不同缓存节点，再用不同连接测量请求延迟，判断请求是否指向相同资源。

如果数据被大量重放，还可能引发其他攻击，比如反复测量加密操作的速度，或超载速率限制系统。详见[Mac17]。

最终，服务器有责任保护自己免受0-RTT数据重放攻击。第8节描述的机制旨在防止TLS层的重放，但不能完全防止多次接收客户端数据。TLS 1.3在服务器没有客户端信息（如不同集群不共享状态或票据被删除）时，会回退到1-RTT握手。如果应用层协议在此情况下重传数据，攻击者可能通过向原始集群（立即处理数据）和备用集群（在应用层重放后处理）发送ClientHello，诱导消息重复。此类攻击的规模受客户端重试意愿限制，每次复制仅表现为新连接。

如果正确实现，第8.1和8.2节中的机制可以防止在状态一致的集群中多次接受重放的ClientHello及其相关的0-RTT数据；对于限制0-RTT只在单一集群使用的场景，某一ClientHello及其0-RTT数据只会被接受一次。然而，如果状态不完全一致，攻击者可能在复制窗口期间接受多份数据。由于客户端无法掌握服务器的具体行为，必须确保在早期数据中不发送不安全重放的消息，也不愿在多个1-RTT连接中重试。

应用协议不得在未定义使用场景的情况下使用0-RTT数据。该场景应明确哪些消息或交互可以安全使用0-RTT，以及服务器拒绝0-RTT后如何处理。

此外，为避免误用，TLS实现不得启用0-RTT（无论是发送还是接受），除非应用明确请求，并且不得在被服务器拒绝后自动重发0-RTT数据，除非应用指示。服务器端应用可能希望对某些应用流量的0-RTT数据进行特殊处理（如中止连接、请求在应用层重发数据或延迟处理直到握手完成）。为支持此类处理，TLS实现必须提供机制，让应用判断握手是否已完成。

E.5.1. 重放与导出器（Exporters）

ClientHello的重放会产生相同的早期导出器（early exporter），因此使用这些导出器的应用需格外小心。特别是，如果将导出器用作身份验证的绑定（如签名导出器输出），攻破PSK的攻击者可以在不同连接间转移认证信息，而不破坏认证密钥。

此外，早期导出器不应用于生成服务器到客户端的加密密钥，因为这会导致密钥重复使用。这类似于早期应用流量密钥仅在客户端到服务器方向使用的情况。

E.6. PSK身份暴露（PSK Identity Exposure）

因为实现会通过中止握手来响应无效的PSK绑定者，所以攻击者可能能够验证某个给定的PSK身份是否有效。具体来说，如果服务器同时接受外部PSK握手和基于证书的握手，那么有效的PSK身份会导致握手失败，而无效的身份则会被跳过，最终导致证书握手成功。仅支持PSK握手的服务器可能通过对没有有效PSK身份和存在身份但绑定者无效的情况采取相同的处理方式，从而抵抗此类攻击。

E.7. 共享PSK

TLS 1.3对PSK采取了保守的做法，将其绑定到特定的密钥派生函数（KDF）上。相比之下，TLS 1.2允许PSK与任何哈希函数和TLS 1.2的伪随机函数（PRF）一起使用。因此，任何在TLS 1.2和TLS 1.3中都使用的PSK，必须在TLS 1.3中仅用一种哈希函数，否则如果用户希望使用单一的PSK进行配置，效果就不理想。TLS 1.2和TLS 1.3中的构造不同，尽管它们都基于HMAC。虽然目前没有已知的方法表明相同的PSK在两个版本中可能产生相关的输出，但相关分析仍然有限。实现可以通过不在TLS 1.3和TLS 1.2之间重复使用PSK，来确保跨协议的输出安全。

E.8. 静态RSA攻击

虽然TLS 1.3不使用RSA密钥传输，因此不直接受到Bleichenbacher类型攻击的影响[Blei98]，但如果TLS 1.3服务器在支持早期版本TLS的情况下也支持静态RSA，那么可能存在伪装成TLS 1.3服务器的风险[JSS15]。TLS 1.3的实现可以通过禁用所有版本TLS中的静态RSA支持来防止此类攻击。原则上，实施还可以通过区分具有不同keyUsage位的证书，用于静态RSA解密和RSA签名，但这种技术依赖于客户端拒绝接受未设置digitalSignature位的密钥签名的证书，而许多客户端未强制执行此限制。