# RFC 5246 中文翻译 (stub)
# 原文文件: ../../rfcs/RFCs5001-5500/rfc5246.txt

网络工作组                                          T. Dierks
意见请求编号：5246                                   独立作者
废止：3268, 4346, 4366                                   E. Rescorla
更新：4492                                              RTFM公司
类别：标准轨道                                    2008年8月

              传输层安全（TLS）协议
                              版本1.2

本备忘录的状态

   本文件为互联网社区制定的互联网标准轨道协议，旨在征求讨论和改进建议。请参阅最新版本的《互联网官方协议标准》（STD 1）以了解该协议的标准化状态和现行情况。本备忘录的分发不受限制。

摘要

   本文件定义了传输层安全（TLS）协议的1.2版本。TLS协议为互联网通信提供安全保障。该协议允许客户端/服务器应用程序以一种旨在防止窃听、篡改或消息伪造的方式进行通信。

目录

   1. 引言 ....................................................4
      1.1. 术语定义 ...........................................5
      1.2. 与TLS 1.1的主要差异 ...............................5
   2. 目标 .....................................................6
   3. 本文档目标 ...............................................7
   4. 表示语言 .................................................7
      4.1. 基本块大小 .........................................7
      4.2. 其他 ...............................................8
      4.3. 向量 ...............................................8
      4.4. 数字 ...............................................9
      4.5. 枚举 ..............................................9
      4.6. 结构类型 .........................................10
           4.6.1. 变体 .......................................10
      4.7. 密码学属性 .......................................12
      4.8. 常量 .............................................14
   5. HMAC与伪随机函数 .......................................14
   6. TLS记录协议 .............................................15
      6.1. 连接状态 .........................................16
      6.2. 记录层 ...........................................19
           6.2.1. 分片 ......................................19
           6.2.2. 记录压缩与解压缩 ..........................20
           6.2.3. 记录载荷保护 ..............................21
                  6.2.3.1. 空或标准流密码 ....................22
                  6.2.3.2. CBC块密码 ..........................22
                  6.2.3.3. AEAD密码 ..........................24
      6.3. 密钥计算 .........................................25
   7. TLS握手协议 ............................................26
      7.1. 改变密码规范协议 ................................27
      7.2. 警报协议 .........................................28
           7.2.1. 关闭警报 ..................................29
           7.2.2. 错误警报 ..................................30
      7.3. 握手协议概述 ....................................33
      7.4. 握手协议 .........................................37
           7.4.1. 握手消息 ..................................38
                  7.4.1.1. 握手请求 ..........................38
                  7.4.1.2. 客户端问候 ..........................39
                  7.4.1.3. 服务器问候 ..........................42
                  7.4.1.4. 握手扩展 ..........................44
                           7.4.1.4.1. 签名算法 .................45
           7.4.2. 服务器证书 ................................47
           7.4.3. 服务器密钥交换消息 ........................50
           7.4.4. 证书请求 ..................................53
           7.4.5. 服务器问候完成 ............................55
           7.4.6. 客户端证书 ................................55
           7.4.7. 客户端密钥交换消息 ........................57
                  7.4.7.1. RSA加密的预主密钥消息 ............58
                  7.4.7.2. 客户端Diffie-Hellman公钥值 ..........61
           7.4.8. 证书验证 ..................................62
           7.4.9. 完成 ......................................63
   8. 密码学计算 .............................................64
      8.1. 计算主密钥 .......................................64
           8.1.1. RSA ........................................65
           8.1.2. Diffie-Hellman ...............................65
   9. 强制使用的密码套件 ....................................65
   10. 应用数据协议 ..........................................65
   11. 安全考虑 ..............................................65
   12. IANA考虑 ..............................................65
   附录A. 协议数据结构与常量值 ............................68
      A.1. 记录层 ............................................68
      A.2. 改变密码规范消息 ................................69
      A.3. 警报消息 ..........................................69
      A.4. 握手协议 ..........................................70
           A.4.1. 握手消息 ..................................71
           A.4.2. 服务器认证与密钥交换消息 ..................72
           A.4.3. 客户端认证与密钥交换消息 ..................74
           A.4.4. 握手完成消息 ................................74
      A.5. 密码套件 ..........................................75
      A.6. 安全参数 ..........................................77
      A.7. RFC 4492的变更 ....................................78
   附录B. 术语表 ............................................78
   附录C. 密码套件定义 ......................................83
   附录D. 实现注意事项 ......................................85
      D.1. 随机数生成与种子 ................................85
      D.2. 证书与认证 ......................................85
      D.3. 密码套件 ........................................85
      D.4. 实现陷阱 ........................................85
   附录E. 向后兼容性 ......................................87
      E.1. 与TLS 1.0/1.1及SSL 3.0的兼容性 ..................87
      E.2. 与SSL 2.0的兼容性 .................................88
      E.3. 避免中间人攻击导致的版本回退 ....................90
   附录F. 安全性分析 ........................................91
      F.1. 握手协议 ..........................................91
           F.1.1. 认证与密钥交换 ..............................91
                  F.1.1.1. 匿名密钥交换 ........................91
                  F.1.1.2. RSA密钥交换与认证 ..................92
                  F.1.1.3. 带认证的Diffie-Hellman密钥交换 ........92
           F.1.2. 版本回退攻击 ................................93
           F.1.3. 检测握手协议攻击 ............................94
           F.1.4. 会话恢复 ....................................94
      F.2. 保护应用数据 ......................................94
      F.3. 明确初始化向量（IVs） ............................95
      F.4. 复合密码模式的安全性 ..............................95
      F.5. 拒绝服务攻击 ......................................96
      F.6. 结语 ..............................................96
   规范性参考文献 ............................................97
   资料性参考文献 ............................................98
   工作组信息 ..............................................101
   贡献者 .................................................101

1. 引言

   TLS协议的主要目标是为两个通信应用之间提供隐私和数据完整性。该协议由两个层次组成：TLS记录协议和TLS握手协议。在最低层，TLS记录协议在某个可靠传输协议（如TCP [TCP]）之上。TLS记录协议提供连接安全，具有两个基本特性：

   - 连接是私密的。使用对称加密（如AES [AES]、RC4 [SCH]等）进行数据加密。对称密钥由每个连接唯一生成，基于由其他协议（如TLS握手协议）协商的秘密。记录协议也可以在无加密的情况下使用。

   - 连接是可靠的。消息传输包括使用带密钥的消息认证码（MAC）进行的完整性检查。MAC计算使用安全哈希函数（如SHA-1等）。记录协议可以在无MAC的情况下操作，但通常仅在另一协议使用记录协议作为传输安全参数协商的媒介时采用此模式。

   TLS记录协议用于封装各种高级协议。其中之一是TLS握手协议，它允许服务器和客户端在应用协议传输第一个字节之前相互认证并协商加密算法和密钥。TLS握手协议提供的连接安全具有三个基本特性：

   - 可以使用非对称（公钥）密码学（如RSA [RSA]、DSA [DSS]等）验证对方身份。这种认证可以是可选的，但通常至少需要一方进行。

   - 共享秘密的协商是安全的：协商的秘密对窃听者不可用，对于已认证的连接，即使攻击者在中间，也无法获得秘密。

   - 协商过程是可靠的：没有攻击者可以在不被检测的情况下篡改协商通信。

   TLS的一个优势在于它是应用协议无关的。更高层的协议可以透明地在TLS之上层叠。尽管如此，TLS标准并未规定协议如何在TLS之上增加安全性；关于如何发起TLS握手以及如何解释交换的认证证书的决策，留给运行在TLS之上的协议的设计者和实现者自行判断。

1.1. 术语定义

   本文档中的“必须”（MUST）、“不得”（MUST NOT）、“需要”（REQUIRED）、“应”（SHALL）、“不得”（SHALL NOT）、“建议”（SHOULD）、“不建议”（SHOULD NOT）、“推荐”（RECOMMENDED）、“可以”（MAY）和“可选”（OPTIONAL）等关键词，均按RFC 2119 [REQ]中的定义解释。

1.2. 与TLS 1.1的主要差异

   本文档是对TLS 1.1 [TLS1.1]协议的修订版本，增强了灵活性，特别是在协商密码算法方面。主要变化包括：

   - 在伪随机函数（PRF）中，MD5/SHA-1组合被替换为密码套件指定的PRF。本文件中的所有密码套件均使用P_SHA256。

   - 数字签名元素中的MD5/SHA-1组合被替换为单一哈希。签名元素现在包含一个明确指定所用哈希算法的字段。

   - 大幅清理了客户端和服务器指定接受的哈希和签名算法的能力。注意，这也放宽了之前版本中对签名和哈希算法的某些限制。

   - 增加了对带附加数据的认证加密模式的支持。

   - 将TLS扩展定义和AES密码套件从外部（[TLSEXT]和[TLSAES]）合并。

   - 更严格地检查加密预主密钥（EncryptedPreMasterSecret）版本号。

   - 加强了若干要求。

   - verify_data的长度现在依赖于密码套件（默认仍为12字节）。

   - 清理了对Bleichenbacher/Klima攻击防御的描述。

   - 在许多情况下必须发送警报。

   - 在证书请求后，如果没有可用证书，客户端必须发送空的证书列表。

   - TLS_RSA_WITH_AES_128_CBC_SHA成为必须实现的密码套件。

   - 增加了HMAC-SHA256密码套件。

   - 移除了IDEA和DES密码套件。它们现已弃用，将在单独的文档中说明。

   - 支持SSLv2向后兼容的问候（hello）现在为“可选”（MAY），而非“建议”（SHOULD），并建议不支持（SHOULD NOT）。未来可能变为“建议不支持”。

   - 增加了有限的“穿透”表示语言，以允许多个条件分支具有相同编码。

   - 添加了实现陷阱部分。

   - 进行了常规的澄清和编辑工作。

2. 目标

   TLS协议的目标，按优先级排序如下：

   1. 密码学安全：TLS应用于建立两个方之间的安全连接。

   2. 互操作性：不同程序员应能开发出能成功交换密码参数的应用，无需了解彼此的代码。

   3. 可扩展性：TLS旨在提供一个框架，以便在必要时加入新的公钥和批量加密方法。这也实现了两个子目标：避免创建新协议（及其可能引入的新弱点）以及避免实现全新的安全库。

   4. 相对效率：密码操作通常计算密集，尤其是公钥操作。为此，TLS引入了可选的会话缓存机制，以减少从零开始建立连接的次数。此外，还努力减少网络活动。

3. 本文档目标

   本文档及TLS协议本身基于Netscape发布的SSL 3.0协议规范。两者之间的差异不大，但足够重要，导致不同版本的TLS和SSL 3.0不能互操作（尽管每个协议都包含向后兼容的机制）。本文件主要面向将实现该协议的开发者和进行密码分析的研究人员。规范的撰写考虑了这一点，旨在满足这两类用户的需求。因此，许多依赖算法的数据结构和规则直接包含在正文中（而非附录），以便更易查阅。

   本文档不打算提供服务定义或接口定义的详细信息，但会涉及一些策略方面的内容，以维护良好的安全性。

4. 表示语言

   本文档涉及外部表示的数据格式。将采用一种非常基础且略显随意定义的表示语法。该语法借鉴了多种来源，虽然在语法上类似于“C”语言，且在结构和意图上类似于XDR [XDR]，但不宜过多类比。此表示语言的目的是专门用于记录TLS协议；它没有超出此特定目标的通用应用。

4.1. 基本块大小

   所有数据项的表示都明确规定。基本数据块大小为一个字节（即8位）。多字节数据项由字节串连接而成，从左到右、从上到下。例如，形成一个多字节数值（示例中为数字）的方法为：

      value = (byte[0] << 8*(n-1)) | (byte[1] << 8*(n-2)) | ... | byte[n-1];

   这种多字节值的字节顺序为常见的网络字节序（大端格式）。

4.2. 其他

   注释以“/*”开始，以“*/”结束。

   可选组件用双括号“[[ ]]”括起来。

   单字节实体（包含未解释数据）类型为opaque。

4.3. 向量

向量（单维数组）是由同质数据元素组成的连续数据流。向量的大小可以在文档中指定，也可以在运行时未指定。在任何情况下，长度声明的是字节数，而非元素个数。指定新类型T'（固定长度向量，元素类型为T）的语法为：

```
T T'[n];
```

这里，T'在数据流中占用n个字节，其中n是T的大小的倍数。向量的长度不包含在编码的字节流中。

在以下示例中，Datum被定义为协议不解释的连续三个字节，而Data是由三个连续的Datum组成，总共占用九个字节。

```
opaque Datum[3];      /* 三个未解释的字节 */
Datum Data[9];        /* 3个连续的3字节向量 */
```

可变长度向量通过指定合法长度的子范围（包括端点）来定义，使用符号<floor..ceiling>。在编码时，实际长度会在向量内容之前以字节流的形式出现。长度以数字形式表示，占用尽可能多的字节以容纳向量的最大长度（ceiling）。长度字段为零的可变长度向量称为空向量。

```
T T'<floor..ceiling>;
```

在以下示例中，mandatory是一个必须包含300到400字节的opaque类型向量，且永不为空。实际长度字段占用两个字节（uint16），足以表示最大值400（参见第4.4节）。另一方面，longer可以表示最多800字节（即400个uint16元素），且可以为空。其编码会在向量前加上两个字节的实际长度字段。

```
opaque mandatory<300..400>;
      /* 长度字段为2字节，不能为空 */
uint16 longer<0..800>;
      /* 0到800个16位无符号整数 */
```

4.4 数字

基本的数字数据类型是无符号字节（uint8）。所有较大的数字类型由固定长度的字节序列组成（详见第4.1节），也是无符号的。预定义的数字类型包括：

```
uint8 uint16[2];
uint8 uint24[3];
uint8 uint32[4];
uint8 uint64[8];
```

所有值（在本规范中及其他地方）都以网络字节序（大端序）存储。例如，十六进制字节01 02 03 04表示的uint32值等同于十进制的16909060。

注意，在某些情况下（如DH参数），整数需要用不透明向量表示。在这种情况下，它们作为无符号整数表示（即使最高位被置位，也不需要前导零字节）。

4.5 枚举类型

还提供一种稀疏数据类型，称为enum。enum类型的字段只能取定义中声明的值。每个定义都是不同的类型。只有相同类型的枚举值才能相互赋值或比较。每个枚举元素都必须赋值，如示例所示。由于枚举元素无序，它们可以被赋予任何唯一值，顺序不限。

```
enum { e1(v1), e2(v2), ... , en(vn) [[, (n)]] } Te;
```

枚举在字节流中占用的空间等于其最大定义的序数值。例如，以下定义会用一字节存储Color类型的字段。

```
enum { red(3), blue(5), white(7) } Color;
```

可以选择性地为枚举元素指定没有关联标签的值，以强制定义宽度而不定义多余的元素。

示例：Taste会占用两个字节，但只能取值1、2或4。

```
enum { sweet(1), sour(2), bitter(4), (32000) } Taste;
```

枚举元素的名称在定义的类型范围内具有作用域。例如，完全限定的引用第二个元素应为Color.blue。如果目标已明确，则不需要限定。

```
Color color = Color.blue;     /* 过度限定，合法 */
Color color = blue;           /* 正确，类型隐式 */
```

对于从不转换为外部表示的枚举，可以省略数值信息。

```
enum { low, medium, high } Amount;
```

4.6 构造类型

结构类型可以由原始类型构造而成，方便使用。每个定义声明一个新的唯一类型。定义的语法类似于C语言。

```
struct {
    T1 f1;
    T2 f2;
    ...
    Tn fn;
} [[T]];
```

结构中的字段可以用类型名进行限定，语法类似于枚举。例如，T.f2指向前述声明中的第二个字段。结构定义可以嵌套。

4.6.1 变体（Variants）

定义的结构可以根据环境中的某些已知信息具有变体。选择器必须是定义了所有可能变体的枚举类型。每个枚举元素都必须有对应的case分支。case分支的穿透有限制：如果两个case紧接在一起且中间没有字段，则它们包含相同的字段。因此，在下面的示例中，“orange”和“banana”都包含V2。注意，这是TLS 1.2中新引入的语法。

变体结构的主体可以用标签标记以供引用。运行时选择变体的机制未由表现语言规定。

示例：

```
struct {
    T1 f1;
    T2 f2;
    ...
    Tn fn;
    select (E) {
        case e1: Te1;
        case e2: Te2;
        case e3: case e4: Te3;
        ...
        case en: Ten;
    } [[fv]];
} [[Tv]];
```

具体示例：

```
enum { apple, orange, banana } VariantTag;

struct {
    uint16 number;
    opaque string<0..10>; /* 可变长度 */
} V1;

struct {
    uint32 number;
    opaque string[10];    /* 固定长度 */
} V2;

struct {
    select (VariantTag) { /* 选择器值为隐式 */
        case apple:
            V1;   /* 变体内容，标签为apple */
        case orange:
        case banana:
            V2;   /* 变体内容，标签为orange或banana */
    } variant_body;       /* 变体的可选标签 */
} VariantRecord;
```

4.7 密码学属性

五种密码操作——数字签名、流密码加密、块密码加密、带附加数据的认证加密（AEAD）以及公钥加密——分别被标记为数字签名、流密码、块密码、aead密码和公钥加密。字段的密码处理通过在类型说明前加上相应的关键词实现。密码密钥由当前会话状态隐含（参见第6.1节）。

数字签名元素以结构DigitallySigned编码：

```
struct {
    SignatureAndHashAlgorithm algorithm;
    opaque signature<0..2^16-1>;
} DigitallySigned;
```

algorithm字段指定所用算法（详见第7.4.1.4.1节）。注意，引入algorithm字段是与之前版本的变化。签名是使用相应算法对元素内容的数字签名。内容本身不在传输中出现，只进行计算。签名长度由签名算法和密钥决定。

RSA签名中，opaque向量包含用RSASSA-PKCS1-v1_5签名方案生成的签名（详见[PKCS1]）。如[PKCS1]所述，DigestInfo必须采用DER编码（[X680][X690]）。对于无参数的哈希算法（包括SHA-1），DigestInfo.AlgorithmIdentifier.parameters字段必须为NULL，但实现应接受无参数和NULL参数两种情况。注意，早期TLS版本使用的RSA签名方案不同，不包含DigestInfo编码。

在DSA中，SHA-1哈希的20字节直接用于数字签名算法，无需额外哈希。产生两个值r和s。DSA签名是一个不透明向量，其内容为DER编码的：

```
Dss-Sig-Value ::= SEQUENCE {
    r INTEGER,
    s INTEGER
}
```

注意：在当前术语中，DSS指的是数字签名算法（Digital Signature Algorithm），而DSS标准由NIST制定。在最初的SSL和TLS规范中，“DSS”一词被普遍使用。本文用“DSA”指算法，用“DSS”指标准，为了历史连续性，也在代码点定义中沿用“DSS”。

在流密码加密中，明文与由密码学安全的伪随机数生成器产生的输出进行异或（XOR）操作。

在块密码加密中，每个明文块加密成对应的密文块。所有块密码加密都在CBC（密码块链接）模式下进行，且所有块都必须是块长度的整数倍。

在AEAD加密中，明文同时进行加密和完整性保护。输入可以任意长度，输出通常比输入大，以容纳完整性校验值。

在公钥加密中，使用公钥算法对数据进行加密，只有对应的私钥才能解密。公钥加密元素以不透明向量<0..2^16-1>编码，长度由加密算法和密钥决定。

RSA加密采用[PKCS1]定义的RSAES-PKCS1-v1_5方案。

示例：

```
stream-ciphered struct {
    uint8 field1;
    uint8 field2;
    digitally-signed opaque {
        uint8 field3<0..255>;
        uint8 field4;
    };
} UserType;
```

内部结构（field3和field4）的内容用作签名/哈希算法的输入，然后整个结构用流密码加密。该结构的字节长度等于field1和field2的两个字节，加上签名和哈希算法的两个字节，加上签名长度的两个字节，以及签名输出的长度。签名长度已知，因为签名所用的算法和密钥在编码或解码前已知。

4.8 常量

可以通过声明符号并赋值，定义类型常量，用于规范说明。未充分定义的类型（不透明、可变长向量和包含不透明的结构）不能赋值。多元素结构或向量的字段不能省略。

示例：

```
struct {
    uint8 f1;
    uint8 f2;
} Example1;

Example1 ex1 = {1, 4};  /* f1=1, f2=4 */
```

首先，我们定义了一个数据扩展函数 P_hash(secret, data)，它使用单一的哈希函数将一个秘密和种子扩展成任意数量的输出：

P_hash(secret, seed) = HMAC_hash(secret, A(1) + seed) + HMAC_hash(secret, A(2) + seed) + HMAC_hash(secret, A(3) + seed) + ...

其中“+”表示连接。

A()的定义如下：

A(0) = seed  
A(i) = HMAC_hash(secret, A(i-1))

可以多次迭代P_hash，以生成所需数量的数据。例如，如果使用P_SHA256生成80字节的数据，则需要迭代三次（到A(3)），产生96字节的输出数据；最后一轮的16字节将被丢弃，剩下80字节作为输出。

TLS的伪随机函数（PRF）是通过对秘密应用P_hash实现的，定义为：

PRF(secret, label, seed) = P_<hash>(secret, label + seed)

其中标签是一个ASCII字符串，应按原样包含，不带长度字节或尾随空字符。例如，标签“slithy toves”会通过哈希以下字节进行处理：

73 6C 69 74 68 79 20 74 6F 76 65 73

---

6. TLS记录协议

TLS记录协议是一个分层协议。在每一层，消息可能包含长度、描述和内容字段。记录协议将待传输的消息进行碎片化成可管理的块，选择性地压缩数据，应用消息认证码（MAC），加密后传输。接收端则进行解密、验证、解压、重组，最后交付给更高层的客户端。

本文描述了四种使用记录协议的协议：握手协议、警报协议、变更密码规范协议和应用数据协议。为了支持TLS协议的扩展，记录协议还可以支持其他内容类型。新的内容类型由IANA在TLS内容类型注册表中分配（详见第12节）。

实现者不得发送未在本文定义的记录类型，除非通过某些扩展协商。如果TLS实现收到意外的记录类型，必须发送“意外消息”警报。

任何设计在TLS上使用的协议都必须谨慎设计，以应对所有可能的攻击。实际上，这意味着协议设计者必须了解TLS提供了哪些安全属性，以及哪些不能安全依赖。

特别注意的是，记录的类型和长度信息未被加密保护。如果这些信息本身敏感，应用设计者可能需要采取措施（如填充、伪装流量）以减少信息泄露。

---

6. 连接状态

TLS连接状态是TLS记录协议的操作环境。它定义了压缩算法、加密算法和MAC算法。此外，还知道这些算法的参数：MAC密钥和在读写方向上的大块加密密钥。从逻辑上讲，始终存在四个连接状态：当前的读写状态和待定的读写状态。所有记录都在当前的读写状态下处理。待定状态的安全参数可以由TLS握手协议设置，ChangeCipherSpec可以选择性地将待定状态变为当前状态，此时相应的旧状态被废弃，待定状态被重置为空状态。未初始化安全参数的状态不能成为当前状态。初始的当前状态表示不使用加密、压缩或MAC。

TLS连接的读写状态的安全参数由以下值设置：

- 连接端：指示该实体是“客户端”还是“服务器”。
- PRF算法：用于从主秘密生成密钥的算法（详见第5节和第6.3节）。
- 大块加密算法：用于大块加密的算法，包括密钥长度、块类型（块、流或AEAD）、块大小（如适用）以及显式和隐式初始化向量（或随机数）的长度。
- MAC算法：用于消息认证的算法，包括MAC值的长度。
- 压缩算法：用于数据压缩的算法，必须包含实现该算法所需的所有信息。
- 主秘密：在连接双方之间共享的48字节秘密。
- 客户端随机数：由客户端提供的32字节值。
- 服务器随机数：由服务器提供的32字节值。

这些参数在表现语言中定义为：

```c
enum { server, client } ConnectionEnd;

enum { tls_prf_sha256 } PRFAlgorithm;

enum { null, rc4, 3des, aes } BulkCipherAlgorithm;

enum { stream, block, aead } CipherType;

enum { null, hmac_md5, hmac_sha1, hmac_sha256, hmac_sha384, hmac_sha512 } MACAlgorithm;

enum { null(0), (255) } CompressionMethod;

/* 以上枚举值可以添加更多内容 */

struct {
    ConnectionEnd entity;
    PRFAlgorithm prf_algorithm;
    BulkCipherAlgorithm bulk_cipher_algorithm;
    CipherType cipher_type;
    uint8 enc_key_length;
    uint8 block_length;
    uint8 fixed_iv_length;
    uint8 record_iv_length;
    MACAlgorithm mac_algorithm;
    uint8 mac_length;
    uint8 mac_key_length;
    CompressionMethod compression_algorithm;
    opaque master_secret[48];
    opaque client_random[32];
    opaque server_random[32];
} SecurityParameters;
```

记录层将使用这些安全参数生成以下六个项目（部分内容类型可能不需要某些项，因此为空）：

- 客户端写MAC密钥
- 服务器写MAC密钥
- 客户端写加密密钥
- 服务器写加密密钥
- 客户端写IV
- 服务器写IV

客户端写参数由服务器在接收和处理记录时使用，反之亦然。生成这些项的算法在第6.3节中描述。

一旦安全参数被设置并且密钥被生成，连接状态可以通过将其设为当前状态来实例化。每处理一条记录，必须更新这些当前状态。每个连接状态包括以下元素：

- 压缩状态：当前的压缩算法状态。
- 密码状态：当前的加密算法状态，包括调度的密钥。对于流密码，还应包含继续加密或解密所需的状态信息。
- MAC密钥：如上所述生成的MAC密钥。
- 序列号：每个连接状态都维护一个序列号，分别用于读和写。每次将状态设为活动状态时，序列号必须重置为零。序列号类型为uint64，不能超过2^64-1，不会环绕。如果TLS实现需要环绕序列号，必须重新协商。每条记录传输后，序列号递增，且在特定连接状态下的第一条记录必须使用序列号0。

---

6.2. 记录层

TLS记录层接收来自上层的未解释数据，以任意大小的非空块形式。

6.2.1. 碎片化

记录层将信息块碎片化为TLSPlaintext记录，每个块的大小不超过2^14字节。客户端消息边界在记录层中不被保留（即，多个相同ContentType的客户端消息可以合并成一个TLSPlaintext记录，或一个消息可以被碎片化到多个记录中）。

结构定义如下：

```c
struct {
    uint8 major;
    uint8 minor;
} ProtocolVersion;

enum {
    change_cipher_spec(20), alert(21), handshake(22),
    application_data(23), (255)
} ContentType;

struct {
    ContentType type;
    ProtocolVersion version;
    uint16 length;
    opaque fragment[TLSPlaintext.length];
} TLSPlaintext;
```

- type：用于处理封装片段的上层协议。
- version：所用协议版本。本文件描述TLS 1.2，版本号为{3, 3}。版本值3.3是历史遗留，源自TLS 1.0使用的{3, 1}（详见附录A.1）。注意，支持多版本TLS的客户端在收到ServerHello之前可能不知道将使用哪个版本。关于ClientHello应使用的记录层版本号，详见附录E。
- length：后续TLSPlaintext.fragment的长度（字节数），不得超过2^14。
- fragment：应用数据，透明处理，作为独立块由上层协议处理。

实现者不得发送零长度的握手、警报或变更密码规范内容的碎片。应用数据的零长度碎片可以发送，作为流量分析的对策。

注意：不同TLS记录层内容类型的数据可以交错传输。应用数据通常优先级较低，但记录必须按保护顺序传递到网络。接收端必须在握手后处理交错的应用层流量。

---

6.2.2. 记录压缩与解压

所有记录都使用当前会话状态定义的压缩算法进行压缩。始终存在一个活动的压缩算法，但初始时为CompressionMethod.null。压缩函数将TLSPlaintext结构转换为TLSCompressed结构。每次连接状态激活时，压缩算法会用默认状态初始化。RFC3749描述了TLS的压缩算法。

压缩必须是无损的，且不能使内容长度增加超过1024字节。如果解压函数遇到会解压出超过2^14字节的TLSCompressed.fragment，必须报告致命的解压失败错误。

结构定义如下：

```c
struct {
    ContentType type;       /* 同TLSPlaintext.type */
    ProtocolVersion version;/* 同TLSPlaintext.version */
    uint16 length;
    opaque fragment[TLSCompressed.length];
} TLSCompressed;
```

- length：后续TLSCompressed.fragment的长度（字节数），不得超过2^14 + 1024。

- fragment：TLSPlaintext.fragment的压缩形式。

注意：CompressionMethod.null操作是身份操作，不改变任何字段。

实现提示：解压函数负责确保消息不会引起内部缓冲区溢出。

---

6.2.3. 记录载荷保护

加密和MAC函数将TLSCompressed结构转换为TLSCiphertext。解密函数则逆转此过程。记录的MAC还包含序列号，以检测丢失、重复或多余的消息。

结构定义如下：

```c
struct {
    ContentType type;
    ProtocolVersion version;
    uint16 length;
    select (SecurityParameters.cipher_type) {
        case stream: GenericStreamCipher;
        case block:  GenericBlockCipher;
        case aead:   GenericAEADCipher;
    } fragment;
} TLSCiphertext;
```

- type：与TLSCompressed.type相同。
- version：与TLSCompressed.version相同。
- length：后续TLSCiphertext.fragment的长度（字节数），不得超过2^14 + 2048。
- fragment：TLSCompressed.fragment的加密形式，包含MAC。

---

6.2.3.1. 空或标准流密码

流密码（包括BulkCipherAlgorithm.null）将TLSCompressed.fragment结构转换为和来自流TLSCiphertext.fragment结构。

结构定义如下：

```c
struct {
    opaque content[TLSCompressed.length];
    opaque MAC[SecurityParameters.mac_length];
} GenericStreamCipher;
```

MAC的生成方式为：

MAC(MAC_write_key, seq_num +
                  TLSCompressed.type +
                  TLSCompressed.version +
                  TLSCompressed.length +
                  TLSCompressed.fragment);

其中“+”表示连接。

- seq_num：该记录的序列号。
- MAC：由SecurityParameters.mac_algorithm指定的MAC算法生成。

---

以上内容为该段英文的完整中文翻译。

请注意，MAC是在加密之前计算的。流密码会对整个数据块（包括MAC）进行加密。对于不使用同步向量（如RC4）的流密码，流密码的状态会在一个记录结束时保存，并在后续的数据包中继续使用。如果密码套件是TLS_NULL_WITH_NULL_NULL，则加密操作实际上是身份操作（即数据不被加密，MAC大小为零，意味着不使用MAC）。对于null密码和流密码，TLS密文的长度（TLSCiphertext.length）等于压缩后的长度（TLSCompressed.length）加上安全参数中的MAC长度（mac_length）。

6.2.3.2. CBC块密码

对于块密码（如3DES或AES），加密和MAC功能会将TLS压缩的片段结构（TLSCompressed.fragment）转换为块密码结构（TLSCiphertext.fragment），反之亦然。

结构定义如下：
```
struct {
    不透明的IV[SecurityParameters.record_iv_length];
    以块密码方式加密的结构{
        不透明的内容[TLSCompressed.length];
        不透明的MAC[SecurityParameters.mac_length];
        不透明的填充[GenericBlockCipher.padding_length];
        一个字节的填充长度字段
    };
} GenericBlockCipher;
```
MAC的生成方法如第6.2.3.1节所述。

IV（初始化向量）应随机选择，且必须不可预测。注意，在TLS 1.1之前的版本中，没有IV字段，上一记录的最后一个密文块（“CBC残留”）被用作IV。这一设计变更是为了防止[CBCATT]中描述的攻击。对于块密码，IV的长度为SecurityParameters.record_iv_length，等于SecurityParameters.block_size。

填充（padding）用于将明文长度调整为块长度的整数倍。填充长度可以是最多255字节的任何值，只要使TLSCiphertext的长度是块长度的整数倍。较长的填充可能有助于防止基于消息长度分析的攻击。每个填充字节都必须填充为填充长度值。接收方必须验证填充，并在填充错误时使用bad_record_mac警报。

padding_length字段必须确保整个GenericBlockCipher结构的总长度是块密码的块长度的整数倍。合法值范围为0到255。该长度表示除padding_length字段外的填充字段的长度。

加密后数据的长度（TLSCiphertext.length）比SecurityParameters.block_length、TLSCompressed.length、SecurityParameters.mac_length和padding_length的总和多1。例如：如果块长度为8字节，内容长度为61字节，MAC长度为20字节，则在填充前长度为82字节（不包括IV）。因此，为使总长度为8的倍数，padding_length模8应等于6，填充长度可以是6、14、22……直到254。若只用最少填充（6字节），则每个填充字节都为6，最后8个字节为xx 06 06 06 06 06 06 06，其中xx是MAC的最后一个字节。

注意：在CBC模式（链式密码块）中，必须在传输任何密文之前知道整个记录的明文，否则攻击者可能利用[CBCATT]中的攻击。实现时，为防止此类攻击，必须确保无论填充是否正确，处理记录的时间基本一致。通常做法是即使填充错误，也要计算MAC，然后再丢弃包。例如，如果填充看似错误，可以假设填充长度为0，继续计算MAC。这会引入微小的时间差，但由于MAC的块大小较大且时间信号较小，不大可能被利用。

6.2.3.3. AEAD密码

对于AEAD（如[CCM]或[GCM]）密码，AEAD函数会将TLSCompressed.fragment结构转换为AEAD TLSCiphertext.fragment结构，反之亦然。

结构定义：
```
struct {
    不透明的nonce_explicit[SecurityParameters.record_iv_length];
    以AEAD方式加密的结构{
        不透明的内容[TLSCompressed.length];
    };
} GenericAEADCipher;
```
AEAD密码套件需要指定如何构造传入AEAD操作的nonce，以及GenericAEADCipher.nonce_explicit部分的长度。通常，建议使用[AEAD]第3.2.1节描述的部分隐式nonce技术，其中record_iv_length为显式部分的长度。此时，隐式部分应从key_block中派生，例如client_write_iv和server_write_iv（见第6.3节），显式部分则包含在GenericAEADCipher.nonce_explicit中。

明文为TLSCompressed.fragment。

附加验证数据（additional_data）定义如下：
```
additional_data = seq_num + TLSCompressed.type + TLSCompressed.version + TLSCompressed.length;
```
其中“+”表示连接。

AEAD的输出（aead_output）是由AEAD加密操作产生的密文。其长度通常大于TLSCompressed.length，且具体增加的量依赖于所用的AEAD密码。由于可能包含填充，开销可能随TLSCompressed.length不同而变化。每个AEAD密码套件不得产生超过1024字节的扩展。符号表示为：
```
AEADEncrypted = AEAD-Encrypt(write_key, nonce, plaintext, additional_data)
```
解密和验证时，输入包括密钥、nonce、additional_data和AEADEncrypted值，输出为明文或错误（表示解密失败）。没有单独的完整性校验。即：
```
TLSCompressed.fragment = AEAD-Decrypt(write_key, nonce, AEADEncrypted, additional_data)
```
若解密失败，必须生成致命的bad_record_mac警报。

7. 密钥计算

记录协议需要一种算法，从握手协议提供的安全参数中生成当前连接状态所需的密钥（见附录A.6）。主密钥（master secret）会被扩展成一串安全字节，然后被拆分为客户端写MAC密钥、服务器写MAC密钥、客户端写加密密钥和服务器写加密密钥。每个密钥依次从字节序列中生成。未使用的值为空。有些AEAD密码套件可能还需要客户端写IV和服务器写IV（见第6.2.3.3节）。

在生成密钥和MAC密钥时，主密钥作为熵源。

生成密钥材料的方法如下：
```
key_block = PRF(SecurityParameters.master_secret,
                "key expansion",
                SecurityParameters.server_random + SecurityParameters.client_random);
```
直到生成足够的输出。然后，将key_block划分为：
- 客户端写MAC密钥（长度为SecurityParameters.mac_key_length）
- 服务器写MAC密钥（长度为SecurityParameters.mac_key_length）
- 客户端写加密密钥（长度为SecurityParameters.enc_key_length）
- 服务器写加密密钥（长度为SecurityParameters.enc_key_length）
- 客户端写IV（长度为SecurityParameters.fixed_iv_length）
- 服务器写IV（长度为SecurityParameters.fixed_iv_length）

目前，只有在第3.2.1节描述的隐式nonce技术中，才会生成client_write_IV和server_write_IV。

实现提示：目前定义的密码套件中，需求最大的为AES_256_CBC_SHA256。它需要两个32字节的密钥和两个32字节的MAC密钥，总共128字节的密钥材料。

7. TLS握手协议

TLS包含三个子协议，用于让通信双方协商安全参数、进行身份验证、建立已协商的安全参数，以及报告错误。

握手协议负责协商会话，包括以下内容：
- 会话标识符：由服务器选择的任意字节序列，用于标识活动或可恢复的会话状态。
- 对端证书：对端的X509v3证书（PKIX标准），此元素可以为空。
- 压缩方法：在加密前用于压缩数据的算法。
- 密码套件：定义用于生成密钥材料的伪随机函数（PRF）、数据加密算法（如null、AES等）和MAC算法（如HMAC-SHA1），以及密码属性如mac_length（详见附录A.6）。
- 主密钥：客户端和服务器共享的48字节秘密。
- 是否可恢复：指示会话是否可以用来启动新连接的标志。

这些元素用于创建记录层保护应用数据的安全参数。通过TLS握手协议的会话恢复功能，许多连接可以复用同一会话。

7.1. 变更密码规范协议

变更密码规范协议用于通知密码策略的变更。该协议只有一条消息，内容在当前（非待定）连接状态下加密和压缩。消息内容为单字节值1。

结构定义：
```
struct {
    enum { change_cipher_spec(1), (255) } type;
} ChangeCipherSpec;
```
客户端和服务器都发送此消息，通知对方后续记录将使用新协商的密码规范和密钥保护。收到此消息后，接收方会指示记录层立即将读取待处理状态复制到当前状态。发送此消息后，必须指示记录层将写待处理状态变为写激活状态（见第6.1节）。在握手过程中，安全参数达成一致后，发送此消息，但在发送Finished验证消息之前。

注意：如果在连接中进行重新握手时，数据仍在传输，通信双方可以继续使用旧的密码规范发送数据。但一旦发送了变更密码规范消息，必须使用新密码规范。第一个发送变更密码规范的端可能不知道对方是否已完成新密钥的计算（例如，若需要耗时的公钥操作），因此可能存在一个短暂的缓冲窗口。在实际中，现代机器上这个时间段通常很短。

任何一方都可以通过发送 close_notify 警报来发起关闭连接。 在关闭警报之后收到的任何数据都将被忽略。

除非已经传输了其他致命警报，否则每一方在关闭连接的写端之前都必须发送 close_notify 警报。 另一方必须用自己的 close_notify 警报作出响应，并立即关闭连接，丢弃任何待处理的写入数据。 发起关闭的一方不需要等待对方的 close_notify 警报响应就可以关闭连接的读端。

如果使用 TLS 的应用协议规定在 TLS 连接关闭后，仍可以在底层传输层上传输任何数据，则 TLS 实现必须在通知应用层 TLS 连接已结束之前，接收到对方的 close_notify 警报。 如果应用协议不会传输任何额外数据，而只会关闭底层传输连接，则实现可以选择在不等待对方响应的情况下关闭传输层连接。 本标准的任何部分都不应被理解为规定 TLS 使用配置文件管理其数据传输的方式，包括何时开启或关闭连接。

注意：假设关闭连接时，能可靠地传输完所有待处理的数据，然后再销毁传输层。

7.2.2 错误警报

TLS 握手协议中的错误处理非常简单。 当检测到错误时，检测方会向对方发送一条消息。 在传输或接收致命警报消息后，双方会立即关闭连接。 服务器和客户端必须忘记与失败连接相关的任何会话标识符、密钥和秘密信息。 因此，任何以致命警报终止的连接都不得被恢复。

每当实现遇到被定义为致命警报的情况时，必须在关闭连接之前发送相应的警报。 对于所有未明确指定警报级别的错误，发送方可以自行决定是否将其视为致命错误。 如果实现选择发送警报但打算立即关闭连接，则必须以致命警报级别发送该警报。

如果发送和接收的警报级别为 warning，通常连接可以正常继续。 如果接收方决定不继续连接（例如，收到不愿接受的 no_renegotiation 警报后），应发送致命警报以终止连接。 因此，发送方通常无法预知接收方的行为。 综上所述，警告警报在发送方希望继续连接时作用不大，因此有时会省略。 例如，如果对端决定接受过期的证书（可能在确认后通知用户），并希望继续连接，通常不会发送 certificate_expired 警报。

定义的错误警报包括：

- unexpected_message
  收到不适当的消息。此警报始终为致命，且在正常实现之间的通信中不应出现。

- bad_record_mac
  如果收到的记录 MAC 不正确，则返回此警报。 如果因为 TLS 密文解密不正确（如块长度不为偶数倍，或填充值不正确）而发送警报，也必须返回此警报。此消息始终为致命，且在正常实现之间的通信中不应出现（除非消息在网络中被破坏）。

- decryption_failed_RESERVED
  该警报曾在早期 TLS 版本中使用，可能允许针对 CBC 模式的某些攻击 [CBCATT]。合规实现不得发送。

- record_overflow
  收到的 TLS 密文记录长度超过 2^14+2048 字节，或解密后得到的 TLS 压缩记录长度超过 2^14+1024 字节。此消息始终为致命，且在正常实现之间的通信中不应出现（除非消息在网络中被破坏）。

- decompression_failure
  解压函数收到不正确的输入（如会扩展到过长的数据）。此消息始终为致命，且在正常实现之间的通信中不应出现。

- handshake_failure
  收到 handshake_failure 警报表示发送方无法协商出可接受的安全参数。这是一个致命错误。

- no_certificate_RESERVED
  该警报曾在 SSLv3 中使用，但未在任何 TLS 版本中使用。合规实现不得发送。

- bad_certificate
  证书损坏、签名验证失败等。

- unsupported_certificate
  证书类型不受支持。

- certificate_revoked
  证书已被签发者吊销。

- certificate_expired
  证书已过期或当前无效。

- certificate_unknown
  处理证书时出现其他（未指明）问题，导致其不可接受。

- illegal_parameter
  握手中的某个字段超出范围或与其他字段不一致。此消息始终为致命。

- unknown_ca
  收到有效的证书链或部分链，但因找不到或无法匹配已知的受信任 CA 证书而不接受该证书。此消息始终为致命。

- access_denied
  收到有效证书，但在应用访问控制时，发送方决定不继续协商。此消息始终为致命。

- decode_error
  消息无法解码，原因可能是某字段超出范围或消息长度不正确。此消息始终为致命，且在正常实现之间的通信中不应出现（除非消息在网络中被破坏）。

- decrypt_error
  握手中的加密操作失败，包括无法正确验证签名或验证 Finished 消息。此消息始终为致命。

- export_restriction_RESERVED
  该警报曾在早期 TLS 版本中使用，合规实现不得发送。

- protocol_version
  客户端尝试协商的协议版本被识别但不支持（例如，为安全考虑避免使用旧版本协议）。此消息始终为致命。

- insufficient_security
  在协商失败时返回，特别是当服务器要求比客户端支持的更安全的密码套件时。此消息始终为致命。

- internal_error
  由于与对端无关或协议正确性无关的内部错误（如内存分配失败）导致无法继续。此消息始终为致命。

- user_canceled
  由于某些与协议失败无关的原因，取消了握手。如果用户在握手完成后取消操作，关闭连接（发送 close_notify）更为合适。应在此之后发送 close_notify。此消息通常为警告。

- no_renegotiation
  客户端在响应 hello 请求时，或服务器在响应客户端 hello 后，发送此警报。通常会引发重新协商；当不适合重新协商时，接收方应用此警报。接收方可以决定是否继续连接。例如，服务器为满足请求启动了某个进程，可能在启动时获得安全参数（密钥长度、认证等），之后难以更改。此消息始终为警告。

- unsupported_extension
  客户端收到包含未在对应客户端 hello 中提出的扩展的扩展服务器 hello 时发送。此消息始终为致命。

新警报值由 IANA 根据第12节的规定分配。

7.3 握手协议概述

会话状态的加密参数由 TLS 握手协议生成，该协议在 TLS 记录层之上运行。 当 TLS 客户端和服务器首次开始通信时，它们会协商协议版本，选择加密算法，选择性地进行身份验证，并使用公钥加密技术生成共享秘密。

TLS 握手协议包括以下步骤：

- 交换 hello 消息，协商算法，交换随机值，并检查会话是否可以恢复。

- 交换必要的加密参数，以便客户端和服务器达成预主秘密。

- 交换证书和加密信息，以便双方进行身份验证。

- 从预主秘密和交换的随机值中生成主秘密。

- 向记录层提供安全参数。

- 让客户端和服务器验证对方是否计算出相同的安全参数，以及握手是否未被攻击者篡改。

注意：上层不应过度依赖 TLS 始终协商出最强的连接。 中间人攻击者可能试图让双方退回到支持的最低安全级别。 协议设计旨在降低此类风险，但仍存在攻击方式：例如，攻击者可能阻止访问安全服务端口，或试图让双方协商未认证的连接。 基本原则是，上层必须清楚自己的安全需求，绝不在安全级别低于需求的通道上传输信息。 TLS 协议的安全性在于任何密码套件都能提供其承诺的安全级别：如果你与验证过证书的主机协商使用 3DES 和 1024 位 RSA 密钥交换，你可以相信连接的安全性。

这些目标通过握手协议实现，概要如下： 客户端发送 ClientHello 消息，服务器必须回应 ServerHello 消息，否则会发生致命错误，连接失败。 ClientHello 和 ServerHello 用于建立客户端和服务器之间的安全增强能力。 它们确定的属性包括：协议版本、会话ID、密码套件和压缩方法。此外，客户端和服务器会生成并交换两个随机值：ClientHello.random 和 ServerHello.random。

实际的密钥交换最多使用四个消息：服务器证书、ServerKeyExchange、客户端证书和 ClientKeyExchange。 可以通过定义这些消息的格式和用途，创建新的密钥交换方法，以便客户端和服务器达成共享秘密。 该秘密必须足够长，目前定义的密钥交换方法交换的秘密长度从 46 字节起。

在 hello 消息之后，如果需要认证，服务器会在 Certificate 消息中发送其证书。 如果需要，服务器还可能发送 ServerKeyExchange 消息（例如，服务器没有证书或证书仅用于签名）。 如果服务器已认证，且所选密码套件允许，服务器可以请求客户端提供证书。 接下来，服务器会发送 ServerHelloDone，表示握手的 hello 阶段完成。 之后，服务器会等待客户端响应。 如果服务器已发送 CertificateRequest 消息，客户端必须发送 Certificate 消息。 之后，客户端会发送 ClientKeyExchange，内容取决于在 ClientHello 和 ServerHello 之间协商的公钥算法。 如果客户端提供了带签名能力的证书，还会发送数字签名的 CertificateVerify 消息，以明确验证其拥有证书中的私钥。

在这一点上，客户端会发送一个ChangeCipherSpec消息，并将待用的密码套件配置复制到当前密码套件配置中。随后，客户端会立即在新算法、密钥和秘密下发送Finished消息。作为回应，服务器也会发送自己的ChangeCipherSpec消息，将待用的密码套件配置转为当前配置，并在新密码套件下发送其Finished消息。至此，握手过程完成，客户端和服务器可以开始交换应用层数据。（见下方流程图。）在第一轮握手完成（即建立了除TLS_NULL_WITH_NULL_NULL之外的密码套件）之前，应用数据不得发送。

（流程图省略）

Dierks & Rescorla  规范标准 路径 [第35页]

RFC 5246  TLS  2008年8月

客户端                                              服务器

ClientHello                  -------->
                                                      ServerHello
                                                     Certificate*
                                               ServerKeyExchange*
                                              CertificateRequest*
                                   <--------      ServerHelloDone
Certificate*
ClientKeyExchange
CertificateVerify*
[ChangeCipherSpec]
Finished                     -------->
                                               [ChangeCipherSpec]
                                   <--------             Finished
Application Data             <------->     Application Data

图1. 完整握手的消息流程

* 表示可选或依赖具体情况的消息，并非每次都发送。

注意：为了避免流水线阻塞，ChangeCipherSpec是一个独立的TLS协议内容类型，实际上并不是一个TLS握手消息。

当客户端和服务器决定恢复之前的会话或复用现有会话（而不是协商新的安全参数）时，消息流程如下：

客户端使用要恢复的会话的会话ID发送ClientHello。服务器随后会在会话缓存中查找匹配项。如果找到匹配，并且服务器愿意在指定的会话状态下重新建立连接，它会用相同的会话ID值发送ServerHello。此时，客户端和服务器都必须发送ChangeCipherSpec消息，并直接进入Finished消息。一旦重新建立完成，客户端和服务器可以开始交换应用层数据。（见下方流程图。）如果未找到会话ID的匹配，服务器会生成一个新的会话ID，TLS客户端和服务器将进行完整的握手。

（流程图省略）

Dierks & Rescorla  规范标准 路径 [第36页]

RFC 5246  TLS  2008年8月

客户端                                              服务器

ClientHello                   -------->
                                                       ServerHello
                                                [ChangeCipherSpec]
                                    <--------             Finished
[ChangeCipherSpec]
Finished                      -------->
Application Data              <------->     Application Data

图2. 简化握手的消息流程

每个消息的内容和意义将在后续章节中详细介绍。

7.4 握手协议

TLS握手协议是定义在TLS记录协议之上的一种高级协议，用于协商会话的安全属性。握手消息由TLS记录层提供封装，封装在一个或多个TLSPlaintext结构中，按照当前激活的会话状态进行处理和传输。

枚举类型：

enum {
    hello_request(0), client_hello(1), server_hello(2),
    certificate(11), server_key_exchange(12),
    certificate_request(13), server_hello_done(14),
    certificate_verify(15), client_key_exchange(16),
    finished(20), (255)
} HandshakeType;

结构体定义：

struct {
    HandshakeType msg_type;    /* 握手类型 */
    uint24 length;             /* 消息长度（字节数） */
    select (HandshakeType) {
        case hello_request:       HelloRequest;
        case client_hello:        ClientHello;
        case server_hello:        ServerHello;
        case certificate:         Certificate;
        case server_key_exchange: ServerKeyExchange;
        case certificate_request: CertificateRequest;
        case server_hello_done:   ServerHelloDone;
        case certificate_verify:  CertificateVerify;
        case client_key_exchange: ClientKeyExchange;
        case finished:            Finished;
    } body;
} Handshake;

握手协议消息必须按特定顺序发送，顺序错误会导致严重错误。某些握手消息可以省略。唯一不受顺序限制的消息是HelloRequest，可以在任何时间发送，但如果在握手中途到达，客户端应忽略。

新类型的握手消息由IANA根据第12节的规定分配。

7.4.1 Hello消息

Hello阶段的消息用于客户端和服务器之间交换安全增强能力。当新会话开始时，记录层的连接状态（加密、哈希和压缩算法）初始化为空。当前连接状态用于重新协商。

7.4.1.1 Hello请求

何时发送：

- 服务器可以在任何时间发送HelloRequest。

消息含义：

- HelloRequest是一个简单通知，提示客户端重新开始协商过程。客户端收到后，应在方便时发送ClientHello。此消息不用于确定客户端或服务器身份，仅用于启动新协商。服务器不应在客户端首次连接时立即发送HelloRequest，客户端应在连接时主动发送ClientHello。

- 如果客户端正在进行会话协商，收到此消息会被忽略。客户端也可以选择不重新协商，或响应一个no_renegotiation警报。由于握手消息优先于应用数据传输，预期在收到少量记录之前，协商就会开始。如果服务器发送HelloRequest但未收到ClientHello，可能会关闭连接并发出严重警报。

- 发送HelloRequest后，服务器不应重复请求，直到下一次握手协商完成。

消息结构：

struct { } HelloRequest;

此消息不应包含在握手期间维护的消息哈希中，也不应包含在Finished和CertificateVerify消息中。

7.4.1.2 Client Hello

何时发送：

- 客户端首次连接服务器时，必须发送ClientHello作为第一个消息。也可以在收到HelloRequest后，或主动发起以重新协商安全参数。

消息结构：

ClientHello包含一个随机结构，用于后续协议。

结构定义：

struct {
    uint32 gmt_unix_time;
    opaque random_bytes[28];
} Random;

- gmt_unix_time：客户端系统时间（秒数，从1970年1月1日UTC起算，不考虑闰秒），用标准UNIX 32位格式表示。TLS基本协议不要求时间设置正确，高层协议可能有额外要求。注意，为历史原因，此字段名为GMT，现为UTC的前身。

- random_bytes：由安全随机数生成器产生的28字节。

ClientHello还包含一个可变长度的会话标识符，用于标识客户端希望重用的会话。如果为空，表示没有会话ID，或希望生成新参数。

会话ID可以来自之前的连接、当前连接或其他活动连接。第二种情况适用于只更新随机结构和派生值的场景，第三种则允许建立多个独立的安全连接，无需重复完整握手。会话ID在协商完成后有效，直到过期或出现致命错误。会话ID的具体内容由服务器定义。

定义如下：

opaque SessionID<0..32>;

注意：由于会话ID未加密且没有立即的MAC保护，服务器不得在会话ID中放置机密信息，也不得让伪造的会话ID泄露安全信息。（但握手整体内容，包括会话ID，受到握手结束时交换的Finished消息保护。）

客户端在ClientHello中还会提供支持的密码套件列表，按偏好顺序排列（首选项在前）。每个密码套件定义一种密钥交换算法、一种批量加密算法（包括密钥长度）、一种MAC算法和一种PRF。服务器会选择一个密码套件，或如果没有接受的选项，则发出握手失败警报并关闭连接。如果列表中包含服务器不识别、不支持或不愿使用的密码套件，服务器必须忽略这些密码套件，正常处理剩余的。

结构定义：

uint8 CipherSuite[2];    /* 密码套件选择器 */

客户端还会提供支持的压缩算法列表，按偏好顺序排列。

枚举定义：

enum { null(0), (255) } CompressionMethod;

结构定义：

struct {
    ProtocolVersion client_version;
    Random random;
    SessionID session_id;
    CipherSuite cipher_suites<2..2^16-2>;
    CompressionMethod compression_methods<1..2^8-1>;
    select (extensions_present) {
        case false:
            struct {};
        case true:
            Extension extensions<0..2^16-1>;
    };
} ClientHello;

TLS允许在extensions块中添加扩展功能。检测扩展存在的方法是查看ClientHello末尾是否有扩展字节。注意，这种检测方法不同于常规TLS的可变长度字段，但为了兼容早期未定义扩展的版本而采用。

- client_version：客户端希望使用的TLS协议版本，建议为支持的最高版本（即最新版本）。本规范中为3.3（详见附录E的向后兼容性说明）。

- random：客户端生成的随机结构。

- session_id：客户端希望使用的会话ID。如果为空，表示不使用会话ID或希望生成新参数。

- cipher_suites：客户端支持的密码套件列表，首选项在前。若会话ID非空（表示请求会话恢复），此列表必须包含该会话的密码套件。

- compression_methods：客户端支持的压缩方法列表，按偏好排序。若会话ID非空，必须包含该会话的压缩方法。所有实现必须支持null压缩方法。

- extensions：客户端可通过extensions字段请求扩展功能。具体格式在7.4.1.4节定义。

如果客户端请求扩展功能，但服务器未提供，客户端可以中止握手。服务器必须接受带或不带extensions字段的ClientHello，并确保消息数据符合定义的格式，否则应发出致命的decode_error警报。

发送ClientHello后，客户端等待ServerHello。除HelloRequest外，任何由服务器返回的握手消息都视为严重错误。

（未完待续）

扩展的存在可以通过检测ServerHello消息末尾是否有紧随compression_method字段之后的字节来识别。

server_version
该字段将包含由客户端在ClientHello中建议的版本和服务器支持的最高版本中的较低者。对于本规范版本，版本为3.3。（有关向后兼容性的详细信息，请参见附录E。）

random
该结构由服务器生成，必须与ClientHello.random独立生成。

session_id
这是与此次连接对应的会话标识符。如果ClientHello中的session_id非空，服务器将在其会话缓存中查找匹配项。如果找到匹配且服务器愿意使用指定的会话状态建立新连接，服务器将用与客户端提供的相同值作为响应。这表示会话已恢复，双方应直接进入Finished消息。否则，该字段将包含不同的值，用以标识新会话。服务器也可以返回空的session_id，表示不会缓存会话，因此无法恢复。如果会话被恢复，必须使用最初协商的相同密码套件。请注意，服务器没有义务即使之前提供过session_id，也恢复任何会话。客户端必须准备在任何握手过程中进行完整的协商，包括协商新的密码套件。

cipher_suite
由服务器从ClientHello.cipher_suites列表中选择的单一密码套件。对于恢复的会话，该字段是被恢复会话的状态中的值。

compression_method
由服务器从ClientHello.compression_methods列表中选择的单一压缩算法。对于恢复的会话，该字段是恢复会话状态中的值。

extensions
扩展列表。注意，服务器列表中只能出现由客户端提供的扩展。

7.4.1.4. 你好扩展（Hello Extensions）

扩展格式为：

```c
struct {
    ExtensionType extension_type;
    opaque extension_data<0..2^16-1>;
} Extension;

enum {
    signature_algorithms(13), (65535)
} ExtensionType;
```

其中：

- "extension_type"标识特定的扩展类型。

- "extension_data"包含特定扩展类型的相关信息。

初始的扩展集定义在配套文档[TLSEXT]中。扩展类型列表由IANA维护，如第12节所述。

除非对应的ClientHello中也出现相同的扩展类型，否则ServerHello中不得出现该扩展类型。如果客户端在ServerHello中收到未请求的扩展类型，必须中止握手并发出不支持的扩展（unsupported_extension）致命警报。

未来，可能会在此框架内提供“面向服务器”的扩展。这类扩展（例如，类型为x）要求客户端在ClientHello中以空的extension_data发送类型为x的扩展，以表明其支持该扩展类型。在这种情况下，客户端提供理解该扩展类型的能力，服务器接受客户端的提议。

当ClientHello或ServerHello中存在多个不同类型的扩展时，扩展可以以任何顺序出现。同一类型的扩展最多只能出现一次。

最后，注意扩展可以在建立新会话时或请求会话恢复时发送。实际上，请求会话恢复的客户端通常不知道服务器是否会接受此请求，因此应与非恢复时相同地发送扩展。

一般而言，每个扩展类型的规范需要描述其在完整握手和会话恢复中的作用。大多数TLS扩展仅在会话初始化时相关：在恢复旧会话时，服务器不会处理ClientHello中的扩展，也不会在ServerHello中包含它们。然而，某些扩展可能在会话恢复期间表现出不同的行为。

协议中可能存在微妙（甚至不那么微妙）的交互，涉及新功能与现有功能，可能导致整体安全性显著降低。在设计新扩展时，应考虑以下事项：

- 服务器不同意某个扩展的情况，有些是错误条件，有些仅是拒绝支持某些功能。一般而言，错误应使用警报（alert）处理，支持或不支持某功能的拒绝应在服务器扩展响应中体现。

- 扩展应尽可能设计成防止通过操纵握手消息强制使用（或不使用）某个特定功能的攻击。无论该功能是否被认为存在安全问题，都应遵循此原则。

- 通常，将扩展字段包含在Finished消息的哈希输入中已足够，但当扩展改变握手消息的含义时，必须格外小心。设计者和实现者应意识到，在握手未被认证之前，主动攻击者可以修改消息、插入、删除或替换扩展。

- 从技术上讲，可以使用扩展来改变TLS设计的主要方面，例如密码套件协商的设计。但不建议这样做，更合适的做法是定义TLS的新版本——尤其是因为TLS握手算法对基于版本号的回滚攻击提供了特定保护，版本回滚的可能性应在任何重大设计变更中被充分考虑。

7.4.1.4.1. 签名算法（Signature Algorithms）

客户端使用"signature_algorithms"扩展向服务器指示哪些签名/哈希算法对可以用于数字签名。该扩展的"extension_data"字段包含一个"supported_signature_algorithms"值。

```c
enum {
    none(0), md5(1), sha1(2), sha224(3), sha256(4), sha384(5),
    sha512(6), (255)
} HashAlgorithm;

enum { anonymous(0), rsa(1), dsa(2), ecdsa(3), (255) }
  SignatureAlgorithm;

struct {
    HashAlgorithm hash;
    SignatureAlgorithm signature;
} SignatureAndHashAlgorithm;

SignatureAndHashAlgorithm
  supported_signature_algorithms<2..2^16-2>;
```

每个SignatureAndHashAlgorithm值列出客户端愿意验证的单一哈希/签名对，按偏好降序排列。

注意：由于并非所有签名算法和哈希算法都被实现接受（例如，支持SHA-1的DSA，但不支持SHA-256），此处列出的算法以对形式出现。

hash
该字段指示可能使用的哈希算法。支持的值包括未哈希数据、MD5、SHA-1、SHA-224、SHA-256、SHA-384和SHA-512。提供"none"值以支持未来可能出现的不需要哈希的签名算法。

signature
该字段指示可能使用的签名算法。支持的值包括匿名签名、RSASSA-PKCS1-v1_5、DSA和ECDSA。在此上下文中，"anonymous"值无意义，但在第7.4.3节中使用。该值不得出现在此扩展中。

由于密码套件指示允许的签名算法但不指示哈希算法，此扩展的语义较为复杂。第7.4.2和7.4.3节将描述相关规则。

如果客户端仅支持本节列出的默认哈希和签名算法，可以省略signature_algorithms扩展。如果客户端不支持默认算法，或支持其他哈希和签名算法（并愿意用它们验证服务器发来的消息，例如服务器证书和密钥交换），则必须发送该扩展，列出其愿意接受的算法。

如果客户端未发送signature_algorithms扩展，服务器必须按以下规则处理：

- 如果协商的密钥交换算法是（RSA、DHE_RSA、DH_RSA、RSA_PSK、ECDH_RSA、ECDHE_RSA）之一，则视为客户端已发送{sha1, rsa}。

- 如果协商的密钥交换算法是（DHE_DSS、DH_DSS）之一，则视为客户端已发送{sha1, dsa}。

- 如果协商的密钥交换算法是（ECDH_ECDSA、ECDHE_ECDSA）之一，则视为客户端已发送{sha1, ecdsa}。

注意：这与TLS 1.1不同，后者没有明确规则，但实际上可以假设对等方支持MD5和SHA-1。

注意：此扩展对TLS 1.2之前的版本没有意义。如果客户端提供了早期版本，不得提出此扩展。即使客户端提供了，[TLSEXT]中规定的规则也要求服务器忽略其不理解的扩展。

服务器不得发送此扩展。TLS服务器必须支持接收此扩展。

在会话恢复时，此扩展不会包含在ServerHello中，服务器也会忽略ClientHello中的该扩展（如果存在）。

（完）

ECDHE_ECDSA        具有ECDSA能力的公钥；证书必须允许该密钥用于签名，使用将在服务器密钥交换消息中采用的哈希算法。公钥必须使用客户端支持的曲线和点格式，详见 [TLSECC]。

- "server_name" 和 "trusted_ca_keys" 扩展 [TLSEXT] 用于引导证书选择。

如果客户端提供了 "signature_algorithms" 扩展，则服务器提供的所有证书必须由该扩展中列出的哈希/签名算法对签名。注意，这意味着包含某一签名算法密钥的证书可能由不同的签名算法签名（例如，用DSA密钥签名的RSA密钥证书）。这不同于TLS 1.1的要求，后者要求算法必须相同。还要注意，这也意味着DH_DSS、DH_RSA、ECDH_ECDSA和ECDH_RSA密钥交换算法不限制用于签名证书的算法。固定的DH证书可以用扩展中出现的任何哈希/签名算法对签名。DH_DSS、DH_RSA、ECDH_ECDSA和ECDH_RSA的名称是历史遗留。

如果服务器有多个证书，它会根据上述标准（以及其他标准，如传输层端点、本地配置和偏好等）选择其中之一。如果服务器只有一份证书，应尝试验证其是否符合这些标准。

注意，有些证书使用的算法或算法组合目前不能与TLS一起使用。例如，带有RSASSA-PSS签名密钥（在SubjectPublicKeyInfo中的id-RSASSA-PSS OID）的证书不能使用，因为TLS没有定义相应的签名算法。

随着为TLS协议定义新的密钥交换方法的密码套件的出现，它们将暗示证书格式和所需的编码密钥信息。

7.4.3. 服务器密钥交换消息

何时发送：

- 该消息将在服务器证书消息（或在匿名协商中为ServerHello消息）之后立即发送。

- 仅当服务器证书消息（如果有）不包含足够数据以允许客户端交换预主密钥时，服务器才会发送ServerKeyExchange消息。以下密钥交换方法适用：

  DHE_DSS
  DHE_RSA
  DH_anon

- 不允许为以下密钥交换方法发送ServerKeyExchange消息：

  RSA
  DH_DSS
  DH_RSA

- 其他密钥交换算法（如[TLSECC]中定义的）必须指明是否发送ServerKeyExchange消息；如果发送，内容也必须指明。

消息的含义：

- 该消息传递加密信息，允许客户端传递预主密钥：可以是Diffie-Hellman的公钥（客户端用以完成密钥交换，得到预主密钥）或其他算法的公钥。

消息结构：

```c
enum { dhe_dss, dhe_rsa, dh_anon, rsa, dh_dss, dh_rsa /* 可扩展，例如支持ECDH -- 见 [TLSECC] */ } KeyExchangeAlgorithm;

struct {
    opaque dh_p<1..2^16-1>;
    opaque dh_g<1..2^16-1>;
    opaque dh_Ys<1..2^16-1>;
} ServerDHParams; /* 临时DH参数 */

dh_p：用于Diffie-Hellman操作的素数模数。

dh_g：用于Diffie-Hellman操作的生成元。

dh_Ys：服务器的Diffie-Hellman公钥（g^X mod p）。

结构体：

```c
struct {
    select (KeyExchangeAlgorithm) {
        case dh_anon:
            ServerDHParams params;
        case dhe_dss:
        case dhe_rsa:
            ServerDHParams params;
            digitally-signed struct {
                opaque client_random[32];
                opaque server_random[32];
                ServerDHParams params;
            } signed_params;
        case rsa:
        case dh_dss:
        case dh_rsa:
            struct {}; /* 这些情况省略消息内容 */
        /* 可扩展，例如支持ECDH -- 见 [TLSECC] */
    };
} ServerKeyExchange;
```

参数：

- params：服务器的密钥交换参数。

- signed_params：非匿名密钥交换中，服务器对密钥交换参数的签名。

如果客户端提供了 "signature_algorithms" 扩展，则签名算法和哈希算法必须是该扩展中列出的对。注意，可能存在不一致的情况，例如客户端提供DHE_DSS密钥交换，但在"signature_algorithms"中未列出任何DSS对。为了正确协商，服务器在选择密码套件前必须检查候选套件是否符合"signature_algorithms"的要求。这虽然不够优雅，但是为了在不大幅修改原有密码套件设计的情况下达成折中。

此外，哈希和签名算法必须与服务器端实体证书中的密钥兼容。RSA密钥可以与任何允许的哈希算法配合使用（受证书限制除外）。

由于DSA签名不包含任何安全的哈希算法指示，存在哈希替换的风险（即多个哈希可用时）。目前，DSA [DSS] 仅能用于SHA-1。未来的DSS [DSS-3] 预计将允许使用其他摘要算法，并提供每个密钥大小应使用的摘要算法的指导。此外，未来的[PKIX]修订可能会定义机制，让证书指示应使用的摘要算法。

随着TLS定义更多包含新密钥交换算法的密码套件，服务器密钥交换消息将仅在密钥交换算法对应的证书类型不能提供足够信息时才会发送。

7.4.4. 证书请求

何时发送：

- 非匿名服务器可以根据需要请求客户端提供证书。该消息在ServerKeyExchange消息之后立即发送（如果有的话；否则，紧接在服务器的Certificate消息之后）。

消息结构：

```c
enum {
    rsa_sign(1), dss_sign(2), rsa_fixed_dh(3), dss_fixed_dh(4),
    rsa_ephemeral_dh_RESERVED(5), dss_ephemeral_dh_RESERVED(6),
    fortezza_dms_RESERVED(20), (255)
} ClientCertificateType;

opaque DistinguishedName<1..2^16-1>;

struct {
    ClientCertificateType certificate_types<1..2^8-1>;
    SignatureAndHashAlgorithm supported_signature_algorithms<2^16-1>;
    DistinguishedName certificate_authorities<0..2^16-1>;
} CertificateRequest;
```

字段说明：

- certificate_types：客户端可能提供的证书类型列表。

  - rsa_sign：包含RSA密钥的证书。

  - dss_sign：包含DSA密钥的证书。

  - rsa_fixed_dh：包含静态DH密钥的证书。

  - dss_fixed_dh：包含静态DH密钥的证书。

- supported_signature_algorithms：服务器能验证的哈希/签名算法对，按偏好降序列出。

- certificate_authorities：接受的证书颁发机构（CA）的唯一标识名（DER编码），可指定根CA或下级CA的名称。若为空，客户端可以提供任何符合ClientCertificateType的证书，除非有外部限制。

certificate_types和supported_signature_algorithms的交互较复杂。certificate_types自TLS起就存在，但定义不够详细。其功能大部分被supported_signature_algorithms取代。规则如下：

- 客户端提供的任何证书必须由supported_signature_algorithms中列出的哈希/签名算法对签名。

- 客户端提供的终端实体证书的密钥必须与certificate_types兼容。如果是签名密钥，必须能用supported_signature_algorithms中的某个对签名。

- 出于历史原因，某些客户端证书类型的名称包含签名所用的算法。例如，早期TLS版本中的rsa_fixed_dh表示用RSA签名且含静态DH密钥的证书。在TLS 1.2中，这一功能被supported_signature_algorithms取代，证书类型不再限制签名算法。例如，服务器发送dss_fixed_dh证书类型和{sha1, dsa}、{sha1, rsa}签名类型，客户端可以用RSA-SHA1签名的静态DH密钥证书作出响应。

IANA为新的ClientCertificateType值的分配遵循第12节的规定。

注意：标记为RESERVED的值不能使用，曾在SSLv3中使用。

注意：匿名服务器请求客户端认证是致命的握手失败（handshake_failure）警报。

7.4.5. 服务器Hello完成

何时发送：

- 服务器用该消息表示结束ServerHello及相关消息。发送后，等待客户端响应。

消息含义：

- 表示服务器已完成密钥交换支持的消息，客户端可以继续其密钥交换阶段。

- 客户端收到ServerHelloDone后，应验证服务器提供的证书（如需要）并检查参数是否接受。

消息结构：

```c
struct { } ServerHelloDone;
```

7.4.6. 客户端证书

何时发送：

- 客户端在收到ServerHelloDone后可以发送此消息。仅在服务器请求证书时发送。如果没有合适的证书，必须发送空证书（certificate_list长度为零）。如果未发送任何证书，服务器可以选择继续握手（不进行客户端认证）或发出致命的握手失败警报。此外，如果证书链中某部分不可接受（如未由信任的CA签名），服务器也可以选择继续（视为未认证的客户端）或发出警报。

- 客户端证书使用第7.4.2节定义的Certificate结构。

消息含义：

- 传递客户端的证书链；服务器在验证CertificateVerify消息（基于签名的客户端认证）或计算预主密钥时使用。证书必须与协商的密钥交换算法和任何协商的扩展兼容。

具体要求：

- 证书类型必须是X.509v3，除非另行协商（如[TLSPGP]）。

- 终端实体证书的公钥（及相关限制）必须与CertificateRequest中列出的证书类型兼容：

| 客户端证书类型 | 证书密钥类型 | 说明 |
|----------------|--------------|-------|
| rsa_sign       | RSA公钥      | 证书必须允许用签名方案和哈希算法签名 |
| dss_sign       | DSA公钥      | 证书必须允许用签名方案和哈希算法签名 |
| ecdsa_sign     | 支持ECDSA的公钥 | 证书必须允许用签名方案和哈希算法签名，且公钥使用支持的曲线和点格式 |
| rsa_fixed_dh   | 静态DH公钥   | 使用与服务器相同的DH参数 |
| dss_fixed_dh   | 静态DH公钥   | 使用与服务器相同的DH参数 |
| rsa_fixed_ecdh | 支持ECDH的公钥 | 使用与服务器相同的曲线，点格式支持 |

- 如果CertificateRequest中的certificate_authorities列表非空，证书链中的某个证书应由列出的CA签发。

- 证书必须用支持的哈希/签名算法对签名（详见第7.4.4节）。这放宽了之前版本对签名算法的限制。

- 与服务器证书一样，存在不能与TLS兼容的算法/组合的证书。

7.4.7. 客户端密钥交换消息

何时发送：

此消息始终由客户端发送。如果客户端证书消息已发送，则此消息必须立即跟在其后。否则，它必须是客户端在收到ServerHelloDone消息后发送的第一个消息。

此消息的含义：

通过此消息，预主密钥被设置，要么通过直接传输RSA加密的密钥，要么通过传输Diffie-Hellman参数，使双方能够协商出相同的预主密钥。

当客户端使用临时Diffie-Hellman指数时，此消息包含客户端的Diffie-Hellman公钥值。如果客户端发送的证书包含静态DH指数（即进行固定DH客户端认证），则此消息必须发送，但内容为空。

此消息的结构：

消息的选择取决于所选的密钥交换方法。请参见第7.4.3节中的KeyExchangeAlgorithm定义。

``` 
struct {
    select (KeyExchangeAlgorithm) {
        case rsa:
            EncryptedPreMasterSecret;
        case dhe_dss:
        case dhe_rsa:
        case dh_dss:
        case dh_rsa:
        case dh_anon:
            ClientDiffieHellmanPublic;
    } exchange_keys;
} ClientKeyExchange;
```

7.4.7.1 RSA加密预主密钥消息

此消息的含义：

如果使用RSA进行密钥协商和认证，客户端会生成一个48字节的预主密钥，用服务器证书中的公钥加密后，通过加密预主密钥消息发送。此结构是ClientKeyExchange消息的变体，本身并不是一条独立的消息。

此消息的结构：

```
struct {
    ProtocolVersion client_version;
    opaque random[46];
} PreMasterSecret;

client_version
   客户端支持的最新（最晚）版本，用于检测版本回退攻击。

random
   46个安全生成的随机字节。

struct {
    public-key-encrypted PreMasterSecret pre_master_secret;
} EncryptedPreMasterSecret;

pre_master_secret
   由客户端生成，用于生成主密钥，详见第8.1节。
```

注意：PreMasterSecret中的版本号是客户端在ClientHello中的client_version字段中提供的版本，而不是协商确定的连接版本。此设计旨在防止版本回退攻击。不幸的是，一些旧实现会使用协商的版本号，因此检查版本号可能导致与此类不正确的客户端实现无法互操作。

客户端实现必须始终在PreMasterSecret中发送正确的版本号。如果ClientHello中的client_version是TLS 1.1或更高版本，服务器必须按照上述说明检查版本号。如果版本是TLS 1.0或更早，服务器应检查版本号，但可以配置禁用此检查。注意：如果检查失败，预主密钥应如下面所述随机化。

注意：Bleichenbacher [BLEI] 和 Klima等人 [KPR03] 发现的攻击可以用来攻击TLS服务器，利用解密后消息是否符合PKCS#1格式、是否包含有效的预主密钥结构或版本号是否正确。

如Klima [KPR03]所述，这些漏洞可以通过将格式错误或版本不匹配的消息块处理成与正确格式的RSA块无区别的方式来避免。换句话说：

1. 生成一个46字节的随机字符串R。

2. 解密消息以恢复明文M。

3. 如果PKCS#1填充不正确，或消息长度不正好为48字节：
   ```
   pre_master_secret = ClientHello.client_version || R
   ```
   否则，如果ClientHello中的client_version ≤ TLS 1.0，且显式禁用版本检查：
   ```
   pre_master_secret = M
   ```
   否则：
   ```
   pre_master_secret = ClientHello.client_version || M[2..47]
   ```

注意：用ClientHello中的版本号构造预主密钥，如果客户端在原始预主密钥中发送了错误的版本，可能会导致主密钥无效。

另一种方法是将版本号不匹配视为PKCS#1格式错误，完全随机化预主密钥：

1. 生成48字节的随机字符串R。

2. 解密消息以恢复明文M。

3. 如果PKCS#1填充不正确，或消息长度不正好为48字节：
   ```
   pre_master_secret = R
   ```
   否则，如果ClientHello中的版本 ≤ TLS 1.0，且禁用版本检查：
   ```
   pre_master_secret = M
   ```
   否则，如果M的前两个字节不等于ClientHello中的版本：
   ```
   pre_master_secret = R
   ```
   否则：
   ```
   pre_master_secret = M
   ```

虽然目前尚未发现针对此构造的实际攻击，但Klima等人 [KPR03] 描述了一些理论攻击，因此推荐采用第一种构造。

无论采用哪种方法，TLS服务器在处理RSA加密的预主密钥消息失败或版本号不符合预期时，不得生成警报，而应继续握手，使用随机生成的预主密钥。记录失败原因以便排查可能是有用的，但必须注意避免将信息泄露给攻击者（例如通过时间差、日志文件或其他渠道）。

[PKCS1]中定义的RSAES-OAEP加密方案对Bleichenbacher攻击更安全，但为了最大兼容性，本文采用RSAES-PKCS1-v1_5方案。只要遵循上述建议，就不存在已知的Bleichenbacher变体攻击。

实现说明：公钥加密数据以不透明向量<0..2^16-1>表示（见第4.7节）。因此，ClientKeyExchange中的RSA加密预主密钥前有两个长度字节。在RSA情况下，这两个字节是多余的，因为EncryptedPreMasterSecret是唯一的数据，其长度可以明确确定。SSLv3规范未明确公钥加密数据的编码方式，因此许多SSLv3实现未包含长度字节，直接在ClientKeyExchange消息中编码RSA加密数据。

本规范要求正确编码带长度字节的EncryptedPreMasterSecret。生成的PDU与许多SSLv3实现不兼容。升级自SSLv3的实现必须修改以生成和接受正确的编码。希望兼容SSLv3和TLS的实现应根据协议版本调整行为。

实现说明：现已知远程基于时间的TLS攻击在客户端和服务器在同一局域网时是可能的。因此，使用静态RSA密钥的实现必须采用RSA盲化或其他抗时间攻击技术（详见[TIMING]）。

7.4.7.2 客户端Diffie-Hellman公钥值

此消息的含义：

如果客户端的Diffie-Hellman公钥（Yc）未包含在客户端证书中，则此结构传达客户端的Diffie-Hellman公钥值。Yc的编码由枚举类型PublicValueEncoding确定。此结构是客户端密钥交换消息的变体，不是独立的消息。

此消息的结构：

```
enum { implicit, explicit } PublicValueEncoding;

implicit
   如果客户端已发送包含合适Diffie-Hellman密钥（用于固定DH客户端认证）的证书，则Yc为隐式，无需再次发送。在这种情况下，将发送客户端密钥交换消息，但内容必须为空。

explicit
   需要发送Yc。

struct {
    select (PublicValueEncoding) {
        case implicit: struct { };
        case explicit: opaque dh_Yc<1..2^16-1>;
    } dh_public;
} ClientDiffieHellmanPublic;
```

dh_Yc
   客户端的Diffie-Hellman公钥值（Yc）。

7.4.8 证书验证

此消息何时发送：

此消息用于明确验证客户端证书。仅在客户端具有签名能力（即除包含固定Diffie-Hellman参数的证书外的所有证书）时发送。发送时，必须紧跟在客户端密钥交换消息之后。

此消息的结构：

```
struct {
     digitally-signed struct {
         opaque handshake_messages[handshake_messages_length];
     }
} CertificateVerify;
```

其中，handshake_messages指从客户端Hello开始，到（但不包括）此消息的所有握手消息，包括消息类型和长度字段。这是到目前为止所有交换的握手结构（见第7.4节）连接而成的内容。注意，这要求双方要么缓存所有消息，要么在计算签名时对所有潜在的哈希算法进行连续哈希。服务器可以通过在CertificateRequest消息中提供有限的摘要算法集，减少此计算成本。

签名中使用的哈希和签名算法必须是CertificateRequest消息中的supported_signature_algorithms字段中列出的之一。此外，哈希和签名算法必须与客户端终端证书中的密钥兼容。RSA密钥可以与任何允许的哈希算法配合使用，但须遵守证书中的限制（如有）。

由于DSA签名不包含任何关于哈希算法的安全指示，存在哈希替换的风险（即可能用不同的哈希算法签名）。目前，DSA [DSS]仅能用于SHA-1。未来的DSS [DSS-3]版本预计将允许使用其他摘要算法，并提供每种密钥长度应使用的摘要算法的指导。此外，未来的[PKIX]版本可能会定义机制，允许证书指示应使用的DSA摘要算法。

7.4.9 完成（Finished）

此消息何时发送：

在变更密码规格（ChangeCipherSpec）消息之后立即发送，用以验证密钥交换和认证过程是否成功。必须在其他握手消息和Finished消息之间接收变更密码规格消息。

此消息的含义：

Finished消息是第一个用刚协商的算法、密钥和秘密保护的消息。接收方必须验证其内容的正确性。一旦一方发送了Finished消息并验证了对方的Finished消息，就可以开始在连接上发送和接收应用数据。

此消息的结构：

```
struct {
    opaque verify_data[verify_data_length];
} Finished;
```

verify_data
   由PRF（主密钥、finished标签、握手消息的哈希）生成，长度为verify_data_length（由握手消息的哈希算法决定，默认为12字节，详见第5节）。

finished_label
   客户端发出的Finished消息的标签为"client finished"；服务器发出的为"server finished"。

哈希值是所有握手消息的哈希值。对于第5节定义的PRF，哈希必须是用作PRF基础的哈希算法。任何定义不同PRF的密码套件也必须定义在Finished计算中使用的哈希算法。

在TLS的早期版本中，verify_data总是12字节长。当前版本中，其长度取决于密码套件。未明确指定verify_data_length的密码套件，其长度为12字节，包括所有现有的密码套件。此表示方式与早期版本相同。未来的密码套件可能会定义其他长度，但必须至少为12字节。

握手消息
   所有从ClientHello开始，到（但不包括）此Finished消息的所有握手消息数据。这仅包括握手层可见的数据，不包括记录层头部。是到目前为止所有交换的握手结构（见第7.4节）连接而成的内容。

如果Finished消息前没有在握手的适当点收到变更密码规格消息，将被视为致命错误。

handshake_messages包括从ClientHello开始，到（但不包括）此Finished消息的所有握手消息。这可能与第7.4.8节中的handshake_messages不同，因为它会包括CertificateVerify消息（如果已发送）。此外，客户端和服务器各自的Finished消息的handshake_messages也会不同，因为第二个发送的会包含之前的消息。

注意：ChangeCipherSpec消息、警报消息以及任何其他记录类型都不是握手消息，也不包含在哈希计算中。此外，HelloRequest消息也被省略在握手哈希之外。

8. 加密计算

为了开始连接保护，TLS记录协议需要指定一套算法、一个主密钥以及客户端和服务器的随机值。认证、加密和MAC算法由服务器选择的密码套件（cipher_suite）决定，并在ServerHello消息中披露。压缩算法在问候消息中协商，随机值也在问候消息中交换。剩下的就是计算主密钥。

8.1. 计算主密钥

对于所有密钥交换方法，将用相同的算法将pre_master_secret转换为master_secret。一旦计算出master_secret，pre_master_secret应从内存中删除。

```
master_secret = PRF(pre_master_secret, "master secret",
                    ClientHello.random + ServerHello.random)
                    [0..47];
```

主密钥的长度始终为48字节。预主密钥的长度会根据密钥交换方法而变化。

8.1.1. RSA

当RSA用于服务器认证和密钥交换时，客户端生成一个48字节的pre_master_secret，用服务器的公钥加密后发送给服务器。服务器用其私钥解密pre_master_secret。双方随后按照上述方式将pre_master_secret转换为master_secret。

8.1.2. Diffie-Hellman

执行常规的Diffie-Hellman计算。协商得到的密钥（Z）用作pre_master_secret，并按照上述方式转换为master_secret。在用作pre_master_secret之前，去除Z中所有零比特的前导字节。

注意：Diffie-Hellman参数由服务器指定，可能是临时的（ephemeral）或包含在服务器证书中。

9. 必须使用的密码套件

除非有其他应用配置标准，否则符合TLS的应用必须实现密码套件TLS_RSA_WITH_AES_128_CBC_SHA（详见附录A.5的定义）。

10. 应用数据协议

应用数据消息由记录层承载，基于当前连接状态进行碎片化、压缩和加密。对记录层而言，这些消息是透明数据。

11. 安全注意事项

安全问题在整个备忘录中都有讨论，特别是在附录D、E和F中。

12. IANA注意事项

本文档使用了几个最初在[TLS1.1]中创建的注册表，IANA已更新这些注册表以引用本文件。注册表及其分配策略（与[TLS1.1]保持一致）如下：

- TLS客户端证书类型标识符注册表：0-63（十进制）范围内的未来值通过标准行动（Standards Action）[RFC2434]分配。64-223（十进制）范围内的值通过规范要求（Specification Required）[RFC2434]分配。224-255（十进制）范围内的值保留用于私用[RFC2434]。

- TLS密码套件注册表：第一个字节在0-191（十进制）范围内的未来值通过标准行动分配。192-254（十进制）范围内的值通过规范要求分配。第一个字节为255（十进制）的值保留用于私用。

- 本文档定义了几个新的基于HMAC-SHA256的密码套件，其值（见附录A.5）已从TLS密码套件注册表中分配。

- TLS内容类型注册表：未来值通过标准行动分配。

- TLS警报注册表：未来值通过标准行动分配。

- TLS握手类型注册表：未来值通过标准行动分配。

此外，本文档还使用了最初在[RFC4366]中创建的注册表，IANA已更新其引用本文件。注册表及其分配策略（与[RFC4366]保持一致）如下：

- TLS扩展类型注册表：未来值通过IETF共识（IETF Consensus）[RFC2434]分配。IANA已更新此注册表，包括签名算法扩展及其对应值（见第7.4.1.4节）。

另外，本文档还定义了两个由IANA维护的新注册表：

- TLS签名算法注册表：最初已填充第7.4.1.4.1节中描述的值。未来在0-63（十进制）范围内的值通过标准行动分配；64-223（十进制）范围内的值通过规范要求分配；224-255（十进制）范围内的值保留用于私用。

- TLS哈希算法注册表：最初已填充第7.4.1.4.1节中描述的值。未来在0-63（十进制）范围内的值通过标准行动分配；64-223（十进制）范围内的值通过规范要求分配；224-255（十进制）范围内的值保留用于私用。

此外，本文档还使用了在[RFC3749]中定义的TLS压缩方法标识符注册表，IANA已为“null”压缩方法分配了值0。

附录A. 协议数据结构和常量值

本节描述协议类型和常量。

A.1. 记录层

```c
struct {
    uint8 major;
    uint8 minor;
} ProtocolVersion;

ProtocolVersion version = { 3, 3 }; /* TLS v1.2 */

enum {
    change_cipher_spec(20), alert(21), handshake(22),
    application_data(23), (255)
} ContentType;

struct {
    ContentType type;
    ProtocolVersion version;
    uint16 length;
    opaque fragment[TLSPlaintext.length];
} TLSPlaintext;

struct {
    ContentType type;
    ProtocolVersion version;
    uint16 length;
    opaque fragment[TLSCompressed.length];
} TLSCompressed;

struct {
    ContentType type;
    ProtocolVersion version;
    uint16 length;
    select (SecurityParameters.cipher_type) {
        case stream: GenericStreamCipher;
        case block:  GenericBlockCipher;
        case aead:   GenericAEADCipher;
    } fragment;
} TLSCiphertext;

stream-ciphered struct {
    opaque content[TLSCompressed.length];
    opaque MAC[SecurityParameters.mac_length];
} GenericStreamCipher;

struct {
    opaque IV[SecurityParameters.record_iv_length];
    block-ciphered struct {
        opaque content[TLSCompressed.length];
        opaque MAC[SecurityParameters.mac_length];
        uint8 padding[GenericBlockCipher.padding_length];
        uint8 padding_length;
    };
} GenericBlockCipher;

struct {
    opaque nonce_explicit[SecurityParameters.record_iv_length];
    aead-ciphered struct {
        opaque content[TLSCompressed.length];
    };
} GenericAEADCipher;
```

A.2. Change Cipher Specs消息

```c
struct {
    enum { change_cipher_spec(1), (255) } type;
} ChangeCipherSpec;
```

A.3. 警报消息

```c
enum { warning(1), fatal(2), (255) } AlertLevel;

enum {
    close_notify(0),
    unexpected_message(10),
    bad_record_mac(20),
    decryption_failed_RESERVED(21),
    record_overflow(22),
    decompression_failure(30),
    handshake_failure(40),
    no_certificate_RESERVED(41),
    bad_certificate(42),
    unsupported_certificate(43),
    certificate_revoked(44),
    certificate_expired(45),
    certificate_unknown(46),
    illegal_parameter(47),
    unknown_ca(48),
    access_denied(49),
    decode_error(50),
    decrypt_error(51),
    export_restriction_RESERVED(60),
    protocol_version(70),
    insufficient_security(71),
    internal_error(80),
    user_canceled(90),
    no_renegotiation(100),
    unsupported_extension(110), /* 新增 */
    (255)
} AlertDescription;

struct {
    AlertLevel level;
    AlertDescription description;
} Alert;
```

A.4. 握手协议

```c
enum {
    hello_request(0), client_hello(1), server_hello(2),
    certificate(11), server_key_exchange(12),
    certificate_request(13), server_hello_done(14),
    certificate_verify(15), client_key_exchange(16),
    finished(20)
    (255)
} HandshakeType;

struct {
    HandshakeType msg_type;
    uint24 length;
    select (HandshakeType) {
        case hello_request:       HelloRequest;
        case client_hello:        ClientHello;
        case server_hello:        ServerHello;
        case certificate:         Certificate;
        case server_key_exchange: ServerKeyExchange;
        case certificate_request: CertificateRequest;
        case server_hello_done:   ServerHelloDone;
        case certificate_verify:  CertificateVerify;
        case client_key_exchange: ClientKeyExchange;
        case finished:            Finished;
    } body;
} Handshake;
```

A.4.1. Hello消息

```c
struct { } HelloRequest;

struct {
    uint32 gmt_unix_time;
    opaque random_bytes[28];
} Random;

opaque SessionID<0..32>;

uint8 CipherSuite[2];

enum { null(0), (255) } CompressionMethod;

struct {
    ProtocolVersion client_version;
    Random random;
    SessionID session_id;
    CipherSuite cipher_suites<2..2^16-2>;
    CompressionMethod compression_methods<1..2^8-1>;
    select (extensions_present) {
        case false:
            struct {};
        case true:
            Extension extensions<0..2^16-1>;
    };
} ClientHello;

struct {
    ProtocolVersion server_version;
    Random random;
    SessionID session_id;
    CipherSuite cipher_suite;
    CompressionMethod compression_method;
    select (extensions_present) {
        case false:
            struct {};
        case true:
            Extension extensions<0..2^16-1>;
    };
} ServerHello;

struct {
    ExtensionType extension_type;
    opaque extension_data<0..2^16-1>;
} Extension;
```

A.4.2. 服务器认证与密钥交换消息

```c
opaque ASN.1Cert<2^24-1>;

struct {
    ASN.1Cert certificate_list<0..2^24-1>;
} Certificate;

enum { dhe_dss, dhe_rsa, dh_anon, rsa, dh_dss, dh_rsa
       /* 可能扩展，例如ECDH -- 参见 [TLSECC] */
     } KeyExchangeAlgorithm;

struct {
    opaque dh_p<1..2^16-1>;
    opaque dh_g<1..2^16-1>;
    opaque dh_Ys<1..2^16-1>;
} ServerDHParams; /* 临时DH参数 */

struct {
    select (KeyExchangeAlgorithm) {
        case dh_anon:
            ServerDHParams params;
        case dhe_dss:
        case dhe_rsa:
            ServerDHParams params;
            digitally-signed struct {
                opaque client_random[32];
                opaque server_random[32];
                ServerDHParams params;
            } signed_params;
        case rsa:
        case dh_dss:
        case dh_rsa:
            struct {}; /* 这些消息对rsa、dh_dss、dh_rsa省略 */
        /* 可能扩展，例如ECDH -- 参见 [TLSECC] */
    } ServerKeyExchange;
```

（后续内容省略，结构类似，定义了客户端证书请求、客户端密钥交换、证书验证、握手结束等消息结构。）

【总结】此部分内容详细描述了TLS协议中的关键数据结构、消息类型、密码套件定义及其注册策略，为实现TLS协议提供了基础规范。

以下密码套件用于完全匿名的Diffie-Hellman通信，其中双方都未经过身份验证。请注意，这种模式容易受到中间人攻击，因此使用价值有限：除非应用层明确要求允许匿名密钥交换，否则TLS 1.2的实现不得使用这些密码套件。（匿名密钥交换有时是可以接受的，例如在没有建立身份验证机制的情况下支持机会加密，或者当TLS作为更复杂安全协议的一部分使用时，其他方式可以确保身份验证。）

      密码套件 TLS_DH_anon_WITH_RC4_128_MD5          = { 0x00,0x18 };
      密码套件 TLS_DH_anon_WITH_3DES_EDE_CBC_SHA     = { 0x00,0x1B };
      密码套件 TLS_DH_anon_WITH_AES_128_CBC_SHA      = { 0x00,0x34 };
      密码套件 TLS_DH_anon_WITH_AES_256_CBC_SHA      = { 0x00,0x3A };
      密码套件 TLS_DH_anon_WITH_AES_128_CBC_SHA256   = { 0x00,0x6C };
      密码套件 TLS_DH_anon_WITH_AES_256_CBC_SHA256   = { 0x00,0x6D };

请注意，不经过身份验证的密钥交换如果没有实际验证密钥交换的真实性，本质上等同于匿名密钥交换，需采取相同的预防措施。虽然非匿名密钥交换通常会比匿名密钥交换消耗更多的计算和通信资源，但在应用层允许匿名密钥交换的情况下，为了互操作性，可能不应禁用非匿名密钥交换。

IANA已为新密码套件值分配了对应的编号，详见第12节。

注意：值为 { 0x00, 0x1C } 和 { 0x00, 0x1D } 的密码套件被保留，以避免与SSL 3中基于Fortezza的密码套件冲突。

A.6. 安全参数

这些安全参数由TLS握手协议确定，并作为参数提供给TLS记录层，用于初始化连接状态。SecurityParameters包括：

enum { null(0), (255) } 压缩方法;

enum { server, client } 连接端;

enum { tls_prf_sha256 } PRF算法;

enum { null, rc4, 3des, aes } 大块密码算法;

enum { stream, block, aead } 密码类型;

enum { null, hmac_md5, hmac_sha1, hmac_sha256, hmac_sha384, hmac_sha512 } MAC算法;

/* 其他值可能会被添加到压缩方法、PRF算法、大块密码算法和MAC算法中。 */

结构体 {
    连接端 entity;
    PRF算法 prf_algorithm;
    大块密码算法 bulk_cipher_algorithm;
    密码类型 cipher_type;
    uint8 enc_key_length;
    uint8 block_length;
    uint8 fixed_iv_length;
    uint8 record_iv_length;
    MAC算法 mac_algorithm;
    uint8 mac_length;
    uint8 mac_key_length;
    压缩方法 compression_algorithm;
    不透明型 master_secret[48];
    不透明型 client_random[32];
    不透明型 server_random[32];
} 安全参数。

A.7. 对RFC 4492的更改

RFC 4492 [TLSECC] 增加了椭圆曲线密码套件到TLS中。本文件对该文档中使用的部分结构进行了更改。本节详细说明了对RFC 4492和TLS 1.2的实现者所需的更改。未实现RFC 4492的TLS 1.2实现者无需阅读本节。

本文件在数字签名元素中添加了“签名算法”字段，用于标识用于创建签名的签名和摘要算法。这一更改也适用于使用ECDSA的数字签名，从而允许ECDSA签名使用除SHA-1之外的摘要算法，前提是这种使用方式与证书和未来的[PKIX]修订中的限制兼容。

如第7.4.2和7.4.6节所述，用于签署证书的签名算法的限制不再与密码套件（由服务器使用）或客户端证书类型（由客户端使用）绑定。因此，RFC 4492第2和第3节中关于签名算法的限制也得以放宽。与此类似，终端实体证书中的密钥限制仍然有效。

附录B. 术语表

高级加密标准（AES）
AES [AES]是一种广泛使用的对称加密算法。它是一个块密码，支持128、192或256位密钥，块大小为16字节。目前TLS只支持128和256位密钥。

应用协议
应用协议是直接在传输层（如TCP/IP）之上的协议。例如HTTP、TELNET、FTP和SMTP。

非对称密码
参见公钥密码学。

带附加数据的认证加密（AEAD）
一种同时提供机密性和消息完整性的对称加密算法。

认证
认证是指一方确认另一方身份的能力。

块密码
一种对明文按块（通常为64或128位）操作的算法。

大块密码
用于加密大量数据的对称加密算法。

密码块链（CBC）
CBC模式中，每个明文块在加密前会先与前一个密文块（或第一个块时与初始化向量）进行异或操作。解密时，先解密每个块，然后与前一个密文块（或IV）异或。

证书
作为X.509协议（又称ISO认证框架）的一部分，由受信任的证书授权机构（CA）颁发，提供实体身份或其他属性与其公钥之间的强绑定。

客户端
发起TLS连接的应用实体。可能或可能不意味着客户端发起了底层传输连接。主要区别在于，服务器通常经过身份验证，而客户端可选。

客户端写入密钥
用于加密客户端写入数据的密钥。

客户端写入MAC密钥
用于验证客户端写入数据的秘密数据。

连接
在OSI模型中，连接是提供特定服务类型的传输（在TLS中，连接是点对点关系，具有短暂性，每个连接对应一个会话）。

数据加密标准（DES）
DES [DES]仍然是广泛使用的对称加密算法，尽管现在被认为较弱。它是一个56位密钥、块大小为8字节的块密码。注意，在TLS中，为了密钥生成，DES被视为具有8字节（64位）密钥长度，但实际上只提供56位的保护（每个密钥字节的最低位被设为奇偶校验位）。DES也可以在三重加密模式（3DES）中使用，使用三把不同的密钥进行三次加密，密钥长度为168位（TLS中为24字节），提供等同于112位的安全性。

数字签名标准（DSS）
由美国国家标准与技术研究院（NIST）批准的数字签名标准，包括数字签名算法（DSA），定义在NIST FIPS PUB 186-2中，于2000年1月发布。2006年3月发布了重要更新（DSS-3）。

数字签名
利用公钥密码学和单向哈希函数生成的签名，能被验证且难以伪造或否认。

握手
客户端与服务器之间的初始协商，用于建立交易参数。

初始化向量（IV）
在CBC模式中，IV在加密前与第一个明文块进行异或。

消息认证码（MAC）
由消息和秘密数据计算得出的一次性哈希，用于验证消息是否被篡改。

主秘密
用于生成加密密钥、MAC秘密和IV的安全秘密数据。

MD5
MD5 [MD5]是一种哈希函数，将任意长度的数据流转换为固定大小（16字节）的哈希值。由于密码分析的重大进展，发布时已不再被认为是“安全”的哈希函数。

公钥密码学
使用两把密钥的密码技术。用公钥加密的消息只能用对应的私钥解密；用私钥签名的消息可以用公钥验证。

单向哈希函数
一种将任意数据转换为固定长度哈希的单向变换，反向计算或找到碰撞非常困难。MD5和SHA是常见的单向哈希函数。

RC4
由Ron Rivest发明的流密码。兼容密码在[SCH]中描述。

RSA
一种广泛使用的公钥算法，可用于加密或数字签名。[RSA]

服务器
响应客户端连接请求的应用实体。

会话
TLS会话是客户端与服务器之间的关联。由握手协议创建，定义一组可在多个连接中共享的加密安全参数，用以避免每次连接都进行昂贵的协商。

会话标识符
由服务器生成，用于标识特定会话的值。

服务器写入密钥
用于加密服务器写入数据的密钥。

服务器写入MAC密钥
用于验证服务器写入数据的秘密数据。

SHA
安全哈希算法 [SHS]，定义在FIPS PUB 180-2中，输出20字节。所有不带数字后缀的SHA引用实际上都使用修改版的SHA-1算法。

SHA-256
定义在FIPS PUB 180-2中的256位安全哈希算法，输出32字节。

SSL
Netscape的安全套接层协议 [SSL3]，TLS基于SSL 3.0。

流密码
将密钥转换为强密码流，然后与明文进行异或的加密算法。

对称密码
参见大块密码。

传输层安全（TLS）
本协议；亦指互联网工程任务组（IETF）的传输层安全工作组。详见本文末“工作组信息”（第99页）。

附录C. 密码套件定义

密码套件                            密钥交换方式        密码算法        MAC算法
----------------------------------  ------------------  --------------  --------------
TLS_NULL_WITH_NULL_NULL             无                  无              无
TLS_RSA_WITH_NULL_MD5               RSA                 无              MD5
TLS_RSA_WITH_NULL_SHA               RSA                 无              SHA
TLS_RSA_WITH_NULL_SHA256            RSA                 无              SHA256
TLS_RSA_WITH_RC4_128_MD5            RSA                 RC4_128         MD5
TLS_RSA_WITH_RC4_128_SHA            RSA                 RC4_128         SHA
TLS_RSA_WITH_3DES_EDE_CBC_SHA       RSA                 3DES_EDE_CBC    SHA
TLS_RSA_WITH_AES_128_CBC_SHA        RSA                 AES_128_CBC     SHA
TLS_RSA_WITH_AES_256_CBC_SHA        RSA                 AES_256_CBC     SHA
TLS_RSA_WITH_AES_128_CBC_SHA256     RSA                 AES_128_CBC     SHA256
TLS_RSA_WITH_AES_256_CBC_SHA256     RSA                 AES_256_CBC     SHA256
TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA    DH_DSS              3DES_EDE_CBC    SHA
TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA    DH_RSA              3DES_EDE_CBC    SHA
TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA   DHE_DSS             3DES_EDE_CBC    SHA
TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA   DHE_RSA             3DES_EDE_CBC    SHA
TLS_DH_anon_WITH_RC4_128_MD5        DH_anon             RC4_128         MD5
TLS_DH_anon_WITH_3DES_EDE_CBC_SHA   DH_anon             3DES_EDE_CBC    SHA
TLS_DH_DSS_WITH_AES_128_CBC_SHA     DH_DSS              AES_128_CBC     SHA
TLS_DH_RSA_WITH_AES_128_CBC_SHA     DH_RSA              AES_128_CBC     SHA
TLS_DHE_DSS_WITH_AES_128_CBC_SHA    DHE_DSS             AES_128_CBC     SHA
TLS_DHE_RSA_WITH_AES_128_CBC_SHA    DHE_RSA             AES_128_CBC     SHA
TLS_DH_anon_WITH_AES_128_CBC_SHA    DH_anon             AES_128_CBC     SHA
TLS_DH_DSS_WITH_AES_256_CBC_SHA     DH_DSS              AES_256_CBC     SHA
TLS_DH_RSA_WITH_AES_256_CBC_SHA     DH_RSA              AES_256_CBC     SHA
TLS_DHE_DSS_WITH_AES_256_CBC_SHA    DHE_DSS             AES_256_CBC     SHA
TLS_DHE_RSA_WITH_AES_256_CBC_SHA    DHE_RSA             AES_256_CBC     SHA
TLS_DH_anon_WITH_AES_256_CBC_SHA    DH_anon             AES_256_CBC     SHA
TLS_DH_DSS_WITH_AES_128_CBC_SHA256  DH_DSS              AES_128_CBC     SHA256
TLS_DH_RSA_WITH_AES_128_CBC_SHA256  DH_RSA              AES_128_CBC     SHA256
TLS_DHE_DSS_WITH_AES_128_CBC_SHA256 DHE_DSS             AES_128_CBC     SHA256
TLS_DHE_RSA_WITH_AES_128_CBC_SHA256 DHE_RSA             AES_128_CBC     SHA256
TLS_DH_anon_WITH_AES_128_CBC_SHA256 DH_anon             AES_128_CBC     SHA256
TLS_DH_DSS_WITH_AES_256_CBC_SHA256  DH_DSS              AES_256_CBC     SHA256
TLS_DH_RSA_WITH_AES_256_CBC_SHA256  DH_RSA              AES_256_CBC     SHA256
TLS_DHE_DSS_WITH_AES_256_CBC_SHA256 DHE_DSS             AES_256_CBC     SHA256
TLS_DHE_RSA_WITH_AES_256_CBC_SHA256 DHE_RSA             AES_256_CBC     SHA256

密文算法类型        模式    密钥长度  IV大小  块大小
------------------  ------  --------  ------  ------
NULL                流密码      0       0     不适用
RC4_128             流密码     16       0     不适用
3DES_EDE_CBC        块密码      24       8      8
AES_128_CBC         块密码      16      16     16
AES_256_CBC         块密码      32      16     16

MAC算法        MAC长度  MAC密钥长度
------------  --------  --------------
无            不适用      0        0
MD5           HMAC-MD5   16       16
SHA           HMAC-SHA1  20       20
SHA256        HMAC-SHA256 32      32

说明：
- 类型：指示这是流密码还是在CBC模式下运行的块密码。
- 密钥材料：用于生成写入密钥的密钥块中的字节数。
- IV大小：生成初始化向量所需的数据量。流密码为0；块密码等于块大小（即SecurityParameters.record_iv_length）。

块大小
    指一个块密码在一次处理中的数据量；在CBC模式下运行的块密码只能加密其块大小的整数倍数据。

Dierks & Rescorla           标准轨道                    [第84页]

RFC 5246                          TLS                        2008年8月

附录D.  实现注意事项

   TLS协议无法防止许多常见的安全错误。本节提供若干建议，以协助实现者。

D.1.  随机数生成与种子初始化

   TLS要求使用密码学安全的伪随机数生成器（PRNG）。在设计和初始化PRNG时必须格外小心。基于安全哈希操作（尤其是SHA-1）的PRNG是可以接受的，但其安全性不应超过随机数生成器状态的大小。

   为估算生成的种子材料量，应在每个种子字节中加入不可预测信息的比特数。例如，从PC兼容机的18.2Hz定时器获取的击键时间值，每次提供1或2个安全比特，尽管计数器值的总大小为16位或更多。为一个128位的PRNG提供种子，大约需要100个此类定时器值。

   [RANDOM]提供了关于随机值生成的指导。

D.2.  证书与认证

   实现者负责验证证书的完整性，并应支持证书吊销消息。证书必须经过验证，以确保由受信任的证书授权中心（CA）正确签名。选择和添加受信任的CA时应非常谨慎。用户应能够查看证书和根CA的相关信息。

D.3.  密码套件

   TLS支持多种密钥长度和安全级别，包括一些几乎不提供或仅提供最低安全保障的套件。一个合理的实现可能不会支持许多密码套件。例如，强烈不建议使用匿名Diffie-Hellman，因为它无法防止中间人攻击。应用程序还应强制执行最小和最大密钥长度。例如，包含512位RSA密钥或签名的证书链不适用于高安全性应用。

D.4.  实现陷阱

   实践经验表明，早期TLS规范中的某些部分难以理解，导致互操作性和安全性问题。这些问题在本文档中已得到澄清，但附录中列出一些需要特别注意的关键点。

   TLS协议相关问题：

   - 你是否正确处理了被分片到多个TLS记录的握手消息（见第6.2.1节）？包括像ClientHello被拆分成多个小片段的极端情况？你是否对超过最大片段大小的握手消息进行分片？特别是，证书和证书请求握手消息可能足够大，需要分片。

   - 你是否忽略了所有TLS记录中ServerHello之前的记录层版本号（见附录E.1）？

   - 你是否正确处理ClientHello中的TLS扩展，包括完全省略扩展字段的情况？

   - 你是否支持重新协商（客户端和服务器发起）？虽然重新协商是可选的，但强烈建议支持。

   - 当服务器请求客户端证书，但没有合适证书时，你是否正确发送空的Certificate消息，而不是省略整个消息（见第7.4.6节）？

   密码学细节：

   - 在RSA加密的预主密钥中，你是否正确发送和验证版本号？遇到错误时，你是否继续握手以避免Bleichenbacher攻击（见第7.4.7.1节）？

   - 你采用了哪些措施防止针对RSA解密和签名操作的时间攻击（见第7.4.7.1节）？

   - 在验证RSA签名时，你是否接受NULL参数或缺失参数（见第4.7节）？你是否验证RSA填充后没有多余数据？[FI06]

   - 使用Diffie-Hellman密钥交换时，你是否正确去除协商密钥中的前导零字节（见第8.1.2节）？

   - 你的TLS客户端是否检查服务器发送的Diffie-Hellman参数是否合理（见第F.1.1.3节）？

   - 你如何为CBC模式密码生成不可预测的初始化向量（IV）（见第6.2.3.2节）？

   - 你是否接受较长的CBC模式填充（最多255字节；见第6.2.3.2节）？

   - 你如何应对CBC模式的时间攻击（见第6.2.3.2节）？

   - 你是否使用强大且正确种子化的随机数生成器（见附录D.1）来生成预主密钥（RSA密钥交换）、Diffie-Hellman私值、DSA的"k"参数及其他安全关键值？

附录E.  向后兼容性

E.1.  与TLS 1.0/1.1和SSL 3.0的兼容性

   由于存在多个TLS版本（1.0、1.1、1.2及未来版本）和SSL（2.0和3.0），因此需要协商使用的具体协议版本。TLS协议提供了内置的版本协商机制，以避免其他协议组件处理版本选择的复杂性。

   TLS 1.0、1.1、1.2和SSL 3.0非常相似，使用兼容的ClientHello消息，因此支持全部版本相对容易。类似地，服务器也可以轻松处理试图使用未来TLS版本的客户端，只要ClientHello格式保持兼容，且客户端支持服务器支持的最高协议版本。

   TLS 1.2客户端若希望与此类较旧的服务器协商，将发送标准的TLS 1.2 ClientHello，client_version字段中包含{3,3}（TLS 1.2）。如果服务器不支持此版本，将以包含较旧版本号的ServerHello响应。如果客户端同意使用该版本，协商将按相应协议进行。

   如果服务器选择的版本不被客户端支持（或不可接受），客户端必须发送“protocol_version”警报消息并关闭连接。

   如果TLS服务器收到包含高于其支持的最高版本的ClientHello，必须以其支持的最高版本作出响应。

   服务器也可能收到版本号低于其支持的最高版本的ClientHello。如果服务器希望与旧客户端协商，将按支持的最高版本（不高于client_version）进行。

   例如，若服务器支持TLS 1.0、1.1和1.2，且client_version为TLS 1.0，服务器将使用TLS 1.0的ServerHello。如果服务器只支持（或愿意使用）高于client_version的版本，则必须发送“protocol_version”警报并关闭连接。

   当客户端已知服务器支持的最高协议版本（如会话恢复时），应以该协议版本发起连接。

   注意：某些服务器实现存在版本协商错误。例如，存在一些TLS 1.0服务器在客户端提供比TLS 1.0更高版本时会直接关闭连接。此外，已知某些服务器在ClientHello中包含任何TLS扩展时会拒绝连接。与此类有缺陷的服务器的互操作性是一个复杂话题，超出本文范围，可能需要多次连接尝试。

   早期的TLS规范未明确说明在发送ClientHello（即在确定使用哪个协议版本之前）时，记录层版本号（TLSPlaintext.version）应包含什么值。因此，符合本规范的TLS服务器必须接受任何值{03,XX}作为ClientHello的记录层版本号。

   希望与较旧服务器协商的TLS客户端可以发送任何{03,XX}作为记录层版本号。常用值包括{03,00}（客户端支持的最低版本）和ClientHello.client_version。没有单一值能保证与所有旧服务器的互操作性，超出本文范围。

E.2.  与SSL 2.0的兼容性

   希望支持SSL 2.0服务器的TLS 1.2客户端必须发送[SSL2]定义的版本2.0的CLIENT-HELLO消息。该消息必须包含与普通ClientHello相同的版本号，并在CIPHER-SPECS-DATA字段中以描述的方式编码支持的TLS密码套件。

   警告：由于新ClientHello格式提供了更好的迁移和扩展协商机制，支持SSL 2.0的能力将逐步淘汰。TLS 1.2客户端不应支持SSL 2.0。

   即使TLS服务器不支持SSL 2.0，也可能接受版本2.0的CLIENT-HELLO消息。以下为此消息的详细定义，供TLS服务器实现者参考；其正式定义仍假设为[SSL2]。

   在协商中，2.0的CLIENT-HELLO被视为具有“null”压缩方法且无扩展的ClientHello。注意，该消息必须直接在网络上传输，不应封装为TLS记录。在计算Finished和CertificateVerify时，msg_length字段不视为握手消息的一部分。

      uint8 V2CipherSpec[3];
      struct {
          uint16 msg_length;
          uint8 msg_type;
          Version version;
          uint16 cipher_spec_length;
          uint16 session_id_length;
          uint16 challenge_length;
          V2CipherSpec cipher_specs[V2ClientHello.cipher_spec_length];
          opaque session_id[V2ClientHello.session_id_length];
          opaque challenge[V2ClientHello.challenge_length];
      } V2ClientHello;

   msg_length
      最高位必须为1；其余位包含后续数据的长度（字节数）。

   msg_type
      与version字段共同标识一个版本2的ClientHello消息。值必须为1。

   version
      等于ClientHello.client_version。

   cipher_spec_length
      该字段为cipher_specs字段的总长度。不能为零，且必须是V2CipherSpec长度（3）的倍数。

   session_id_length
      对于声称支持TLS 1.2的客户端，该字段必须为零。

   challenge_length
      客户端向服务器发起的挑战长度（字节数），用于验证自身。历史上允许的值在16到32字节之间。使用SSLv2向后兼容握手时，客户端应使用32字节的挑战。

   cipher_specs
      这是客户端愿意使用的所有CipherSpec的列表。除了[SSL2]定义的2.0密码套件外，还包括在ClientHello.cipher_suites中通常发送的TLS密码套件，每个密码套件前加一个零字节。例如，TLS密码套件{0x00,0x0A}将作为{0x00,0x00,0x0A}发送。

   session_id
      该字段必须为空。

   challenge
      对应ClientHello.random。如果challenge长度小于32，TLS服务器会用前导（非尾部）零字节填充至32字节。

   注意：请求恢复TLS会话必须使用TLS客户端问候。

E.3.  避免中间人攻击导致的版本回退

   当TLS客户端降级到版本2.0兼容模式时，必须使用特殊的PKCS#1块格式。这是为了让TLS服务器拒绝支持TLS的版本2.0会话。

   当客户端协商SSL 2.0但同时支持TLS时，必须将PKCS填充的右端（最低有效字节）8个随机字节（不包括终止空字节）设置为0x03（其他填充字节为随机值），用于RSA加密的ENCRYPTED-KEY-DATA字段。

   当支持TLS的服务器协商SSL 2.0时，应在解密ENCRYPTED-KEY-DATA后检查这8个填充字节是否为0x03。如果不是，服务器应生成随机值作为SECRET-KEY-DATA，并继续握手（最终会失败，因为密钥不匹配）。注意，将错误情况报告给客户端可能使服务器易受[BLEI]中描述的攻击。

   （后续内容省略，因篇幅较长）

TLS协议旨在在客户端和服务器之间建立一个安全的连接，通信是在不安全的通道上进行的。本文在设计时做出了一些传统假设，包括攻击者拥有强大的计算资源，且无法从协议外部获取秘密信息。假设攻击者具有捕获、修改、删除、重放以及篡改通信消息的能力。本文附录概述了TLS如何设计以抵抗各种攻击。

F.1. 握手协议

握手协议负责选择密码套件和生成主秘密，这两者共同构成安全会话的主要加密参数。握手协议还可以选择性地对持有由受信任证书机构签发证书的双方进行身份验证。

F.1.1. 认证与密钥交换

TLS支持三种认证模式：双方认证、服务器认证（客户端未认证）以及完全匿名。每当服务器被认证时，通信通道即可防止中间人攻击，但完全匿名的会话本质上容易受到此类攻击。匿名服务器无法验证客户端身份。如果服务器被认证，其证书消息必须提供一条有效的证书链，指向受信任的证书颁发机构。同样，经过认证的客户端必须向服务器提供有效的证书。每一方都负责验证对方证书的有效性、未过期且未被吊销。

密钥交换的总体目标是创建一个双方都知道、攻击者不知道的预主秘密（pre_master_secret）。预主秘密将用于生成主秘密（参见第8.1节）。主秘密用于生成Finished消息、加密密钥和MAC密钥（参见第7.4.9节和第6.3节）。通过正确的Finished消息，双方证明自己知道正确的预主秘密。

F.1.1.1. 匿名密钥交换

可以使用Diffie-Hellman（DH）实现完全匿名的会话。服务器的公参数包含在服务器密钥交换消息中，客户端的参数在客户端密钥交换消息中发送。未知道私有值的窃听者不应能计算出Diffie-Hellman结果（即预主秘密）。

警告：完全匿名连接仅能防御被动窃听。除非使用独立的防篡改通道验证Finished消息未被攻击者篡改，否则在存在主动中间人攻击的环境中，仍需服务器认证。

F.1.1.2. RSA密钥交换与认证

使用RSA时，密钥交换和服务器认证结合在一起。公钥包含在服务器证书中。注意，若服务器的静态RSA密钥被攻破，则所有受该密钥保护的会话的机密性将丧失。希望实现完美前向保密的用户应使用DHE密码套件。通过频繁更换私钥（及证书），可以限制私钥泄露带来的损害。

验证服务器证书后，客户端用服务器的公钥加密预主秘密。成功解码预主秘密并生成正确的Finished消息后，服务器证明其拥有对应私钥。

当使用RSA进行密钥交换时，客户端通过证书验证消息（参见第7.4.8节）进行身份验证。客户端签名一个由之前所有握手消息派生的值，这些消息包括服务器证书（绑定到服务器）和ServerHello.random（绑定到当前握手过程）。

F.1.1.3. 带认证的Diffie-Hellman密钥交换

使用Diffie-Hellman密钥交换时，服务器可以提供包含固定Diffie-Hellman参数的证书，或通过服务器密钥交换消息发送一组临时参数，并用DSA或RSA证书签名。临时参数在签名前会与hello.random值哈希，以防止重放攻击。无论哪种方式，客户端都可以验证证书或签名，确保参数属于服务器。

如果客户端持有包含固定DH参数的证书，其证书中包含完成密钥交换所需的信息。注意，在此情况下，客户端和服务器每次通信时会生成相同的预主秘密（即DH结果）。为了避免预主秘密在内存中存留过长，应尽快将其转换为主秘密。客户端的DH参数必须与服务器提供的参数兼容。

如果客户端拥有标准的DSA或RSA证书，或未认证，则在客户端密钥交换消息中向服务器发送一组临时参数，并可选择用证书验证消息进行身份验证。

若要在多次握手中使用相同的DH密钥对，应注意防止小子群攻击。实现应遵循[SUBGROUP]中的指南。

避免小子群攻击的最有效方法是使用DHE密码套件，并为每次握手生成新的DH私钥（X）。选择合适的底数（如2）后，g^X mod p的计算非常快，从而最小化性能损失。此外，使用新密钥还能实现完美前向保密。建议在使用DHE密码套件时，为每次握手生成新的X。

由于TLS允许服务器提供任意DH组，客户端应验证DH组的大小符合本地策略。还应验证DH公指数的大小是否合理。[KEYSIZ]提供了不同组大小的安全性指南。服务器可以通过提供已知组（如[IKEALG]或[MODP]定义的组）协助客户端验证。

F.1.2. 版本回退攻击

由于TLS在SSL 2.0基础上有显著改进，攻击者可能试图让支持TLS的客户端和服务器退回到SSL 2.0。这种攻击只有在双方都使用SSL 2.0握手时才会发生。

虽然采用非随机PKCS #1块类型2填充的方案不够优雅，但为TLS 3.0服务器检测此类攻击提供了合理的安全措施。该方案对能进行穷举攻击的攻击者并不完全安全，攻击者可以在未过期的等待阈值内，用正常填充替换已知密钥的加密密钥数据（ENCRYPTED-KEY-DATA）消息，从而绕过检测。对PKCS填充的最低8字节进行修改不会影响协议中签名哈希和RSA密钥长度的安全性，因为这实际上等同于将输入块大小增加8字节。

F.1.3. 握手协议攻击检测

攻击者可能试图影响握手交换，使双方选择不同的加密算法。

此类攻击需要攻击者主动修改一个或多个握手消息。如果发生，客户端和服务器将计算出不同的握手消息哈希值，从而导致双方不接受对方的Finished消息。没有主秘密，攻击者无法修复Finished消息，因此攻击会被检测到。

F.1.4. 会话恢复

通过会话恢复建立连接时，客户端和服务器会用会话的主秘密对新的ClientHello.random和ServerHello.random值进行哈希。只要主秘密未被泄露，且用于生成加密密钥和MAC密钥的哈希操作安全，连接应是安全的，并且与之前的连接基本无关。攻击者无法利用已知的加密密钥或MAC秘密破坏主秘密，除非破解了哈希算法。

会话不能在双方都同意的情况下恢复。如果任何一方怀疑会话可能被攻破，或证书已过期或被吊销，应强制进行完整握手。建议会话ID的有效期不超过24小时，因为攻击者获得主秘密后，直到会话ID被废弃前，可能伪装成受害方。运行在相对不安全环境中的应用不应将会话ID写入持久存储。

F.2. 保护应用数据

主秘密与ClientHello.random和ServerHello.random哈希后，生成每个连接的唯一数据加密密钥和MAC秘密。

出站数据在传输前用MAC保护。为防止消息重放或篡改，MAC由MAC密钥、序列号、消息长度、消息内容和两个固定字符字符串计算得出。消息类型字段确保只将消息传送到正确的TLS记录层客户端。序列号确保能检测到删除或重排消息的尝试。由于序列号为64位，不应溢出。来自一方的消息不能被插入到另一方的输出中，因为它们使用不同的MAC密钥。同样，服务器写入密钥和客户端写入密钥是独立的，因此流密码密钥只用一次。

如果攻击者破解了某个加密密钥，所有用该密钥加密的消息都可以被读取。同理，MAC密钥被攻破也可能导致消息篡改攻击。由于MAC本身也被加密，消息篡改攻击通常需要同时破解加密算法和MAC。

注意：MAC密钥可能比加密密钥更大，即使加密密钥被攻破，消息仍能保持篡改防护。

F.3. 明确初始化向量（IV）

[CBCATT]描述了针对TLS的选择明文攻击，依赖于知道记录的IV。TLS的早期版本[TLS1.0]使用前一记录的CBC残差作为IV，导致此类攻击。新版TLS采用显式IV，以防止此攻击。

F.4. 复合密码模式的安全性

TLS通过在协商的密码套件中定义的对称加密和认证函数，保护传输的应用数据。目标是防止网络中的恶意攻击者破坏数据的完整性和机密性。研究发现，应用加密和认证的顺序对实现此目标至关重要[ENCAUTH]。

最强的方法称为“先加密后认证”，即先对数据加密，再对密文计算MAC。这种方法确保只要加密算法对选择明文攻击安全，MAC对选择消息攻击安全，无论使用何种加密和MAC组合，都能实现数据的完整性和机密性。

另一种方法是“先认证后加密”，即先对明文计算MAC，然后将明文和MAC拼接后加密。此方法在某些加密和MAC组合下已被证明安全，但不能保证在所有情况下都安全。

特别地，已证明存在在信息论意义上完全安全的加密函数（即无条件安全），与任何安全的MAC结合后，仍无法在主动攻击下保证机密性。因此，TLS中采用的新密码套件和操作模式需要经过“先认证后加密”方式的分析，以确保其满足完整性和机密性目标。

目前，已在一些重要情况下证明了“先认证后加密”方法的安全性。其中一种情况是流密码，在这种情况下，使用伪随机生成器产生一个长度等于消息长度（加上MAC标签长度）的计算上不可预测的填充，然后将该填充与明文和MAC标签的连接部分进行异或操作。另一种情况是使用安全块密码的CBC模式。在这种情况下，如果对明文和MAC的连接部分应用一次CBC加密，并且为每一对新的明文和MAC使用一个新的、独立的、不可预测的初始化向量（IV），则可以证明其安全性。在TLS 1.1之前的版本中，CBC模式被正确使用，除了它使用了一个可预测的IV，即前一个密文块的最后一块。这使得TLS容易受到选择明文攻击。该版本的协议已免疫于这些攻击。关于已被证明安全的加密模式的详细信息，请参见[ENCAUTH]。

F.5 拒绝服务（DoS）

TLS容易受到多种拒绝服务攻击。特别是，攻击者可以发起大量的TCP连接，导致服务器在进行RSA解密时消耗大量CPU资源。然而，由于TLS通常在TCP之上运行，如果采用了适当的TCP SYN随机化[SEQNUM]，攻击者很难隐藏其发起点。

由于TLS在TCP之上运行，它也容易受到针对单个连接的多种DoS攻击。具体而言，攻击者可以伪造RST包以终止连接，或伪造部分TLS记录，导致连接阻塞。这些攻击通常无法通过使用TCP的协议来防御。关心此类攻击的实现者或用户应使用IPsec的AH[AH]或ESP[ESP]。

F.6 最后说明

为了使TLS能够提供安全的连接，客户端和服务器系统、密钥以及应用程序都必须是安全的。此外，实施也必须没有安全漏洞。

系统的安全性仅取决于支持的最弱的密钥交换和认证算法，且应只使用可信的加密函数。应谨慎使用短公钥和匿名服务器。实现者和用户在决定哪些证书和证书颁发机构可以接受时也应格外小心；不诚实的证书颁发机构可能造成巨大损害。

规范性参考文献

[AES] 美国国家标准与技术研究院，“高级加密标准（AES）规范” FIPS 197，2001年11月26日。

[3DES] 美国国家标准与技术研究院，“三重数据加密算法（TDEA）块密码建议”，NIST特别出版物800-67，2004年5月。

[DSS] NIST FIPS PUB 186-2，“数字签名标准”，美国国家标准与技术研究院，2000年。

[HMAC] Krawczyk, Bellare 和 Canetti，“HMAC：用于消息认证的密钥哈希”，RFC 2104，1997年2月。

[MD5] Rivest，“MD5消息摘要算法”，RFC 1321，1992年4月。

[PKCS1] Jonsson 和 Kaliski，“公钥密码标准（PKCS）#1：RSA密码学规范版本2.1”，RFC 3447，2003年2月。

[PKIX] Housley, Polk, Ford 和 Solo，“互联网X.509公钥基础设施证书及吊销列表（CRL）配置文件”，RFC 3280，2002年4月。

[SCH] Schneier， 《应用密码学：协议、算法与C语言源代码（第2版）》，约翰·威利与公司，1996年。

[SHS] NIST FIPS PUB 180-2，“安全哈希标准”，美国国家标准与技术研究院，2002年8月。

[REQ] Bradner，“在RFC中使用关键词表示需求级别”，BCP 14，RFC 2119，1997年3月。

[RFC2434] Narten 和 Alvestrand，“撰写IANA考虑事项部分的指南”，BCP 26，RFC 2434，1998年10月。

[X680] ITU-T推荐X.680（2002）| ISO/IEC 8824-1:2002，“信息技术-抽象语法标记（ASN.1）基础符号的规范”。

[X690] ITU-T推荐X.690（2002）| ISO/IEC 8825-1:2002，“信息技术-ASN.1编码规则：基本编码规则（BER）、规范编码规则（CER）和区别编码规则（DER）”。

补充性参考文献

[AEAD] McGrew，“认证加密的接口与算法”，RFC 5116，2008年1月。

[AH] Kent，“IP认证头”，RFC 4302，2005年12月。

[BLEI] Bleichenbacher，“基于RSA加密标准PKCS#1的选择密文攻击”，在《密码学进展——CRYPTO’98》，LNCS第1462卷，1998年，第1-12页。

[CBCATT] Moeller，“SSL/TLS中CBC密码套件的安全性：问题与对策”，http://www.openssl.org/~bodo/tls-cbc.txt。

[CBCTIME] Canvel, Hiltgen, Vaudenay 和 Vuagnoux，“SSL/TLS通道中的密码拦截”，在《密码学进展——CRYPTO 2003》，LNCS第2729卷，2003年。

[CCM] “NIST特别出版物800-38C：用于认证和保密的CCM模式”，http://csrc.nist.gov/publications/nistpubs/800-38C/SP800-38C.pdf。

[DES] 美国国家标准与技术研究院，“数据加密标准（DES）”，FIPS PUB 46-3，1999年10月。

[DSS-3] NIST FIPS PUB 186-3草案，“数字签名标准”，美国国家标准与技术研究院，2006年。

[ECDSA] 美国国家标准协会，“金融行业的公钥密码学：椭圆曲线数字签名算法（ECDSA）”，ANS X9.62-2005，2005年11月。

[ENCAUTH] Krawczyk，“保护通信的加密与认证顺序（或者：SSL有多安全？）”，Crypto 2001。

[ESP] Kent，“IP封装安全载荷（ESP）”，RFC 4303，2005年12月。

[FI06] Hal Finney，“基于实现错误的Bleichenbacher RSA签名伪造”，ietf-openpgp@imc.org邮件列表，2006年8月27日，http://www.imc.org/ietf-openpgp/mail-archive/msg14307.html。

[GCM] Dworkin，“块密码操作模式的推荐：Galois/Counter模式（GCM）和GMAC”，NIST特别出版物800-38D，2007年11月。

[IKEALG] Schiller，“互联网密钥交换协议第2版（IKEv2）中的密码算法”，RFC 4307，2005年12月。

[KEYSIZ] Orman 和 Hoffman，“用于交换对称密钥的公钥强度的确定”，BCP 86，RFC 3766，2004年4月。

[KPR03] Klima, Pokorny, Rosa，“针对SSL/TLS中的RSA会话的攻击”，http://eprint.iacr.org/2003/052/，2003年3月。

[MODP] Kivinen 和 Kojo，“互联网密钥交换（IKE）中更模组化的指数（MODP）Diffie-Hellman组”，RFC 3526，2003年5月。

[PKCS6] RSA实验室，“PKCS #6：RSA扩展证书语法标准”，第1.5版，1993年11月。

[PKCS7] RSA实验室，“PKCS #7：RSA密码消息语法标准”，第1.5版，1993年11月。

[RANDOM] Eastlake三世、Schiller 和 Crocker，“安全的随机性需求”，BCP 106，RFC 4086，2005年6月。

[RFC3749] Hollenbeck，“传输层安全协议压缩方法”，RFC 3749，2004年5月。

[RFC4366] Blake-Wilson, Nystrom, Hopwood, Mikkelsen 和 Wright，“传输层安全（TLS）扩展”，RFC 4366，2006年4月。

[RSA] Rivest、Shamir 和 Adleman，“获得数字签名和公钥密码系统的方法”，ACM通讯，第21卷第2期，1978年2月，第120-126页。

[SEQNUM] Bellovin，“防御序列号攻击”，RFC 1948，1996年5月。

[SSL2] Hickman，“SSL协议”，Netscape Communications，1995年2月9日。

[SSL3] Freier、Karlton 和 Kocher，“SSL 3.0协议”，Netscape Communications，1996年11月18日。

[SUBGROUP] Zuccherato，“避免Diffie-Hellman密钥交换中的“小子群”攻击的方法（用于S/MIME）”，RFC 2785，2000年3月。

[TCP] Postel，“传输控制协议（TCP）”，STD 7，RFC 793，1981年9月。

[TIMING] Boneh 和 Brumley，“远程定时攻击是切实可行的”，USENIX安全研讨会2003。

[TLSAES] Chown，“传输层安全（TLS）的高级加密标准（AES）密码套件”，RFC 3268，2002年6月。

[TLSECC] Blake-Wilson, Bolyard, Gupta, Hawk 和 Moeller，“用于传输层安全（TLS）的椭圆曲线密码套件（ECC）”，RFC 4492，2006年5月。

[TLSEXT] Eastlake三世，“传输层安全（TLS）扩展：扩展定义”，工作进展中，2008年2月。

[TLSPGP] Mavrogiannopoulos，“使用OpenPGP密钥进行传输层安全（TLS）认证”，RFC 5081，2007年11月。

[TLSPSK] Eronen、Tschofenig，“预共享密钥密码套件（PSK）在传输层安全（TLS）中的应用”，RFC 4279，2005年12月。

[TLS1.0] Dierks 和 Allen，“TLS协议版本1.0”，RFC 2246，1999年1月。

[TLS1.1] Dierks 和 Rescorla，“传输层安全（TLS）协议版本1.1”，RFC 4346，2006年4月。

[X501] ITU-T推荐X.501：“信息技术-开放系统互联-目录：模型”，1993年。

[XDR] Eisler，M.（编），“XDR：外部数据表示标准”，STD 67，RFC 4506，2006年5月。

工作组信息

IETF TLS工作组的讨论列表地址为 <tls@ietf.org>。关于该组的信息及订阅方式请访问 <https://www1.ietf.org/mailman/listinfo/tls>。

邮件存档可在：<http://www.ietf.org/mail-archive/web/tls/current/index.html>。

贡献者

- Christopher Allen（TLS 1.0的共同编辑）
  Alacrity Ventures
  ChristopherA@AlacrityManagement.com

- Martin Abadi
  加州大学圣克鲁斯分校
  abadi@cs.ucsc.edu

- Steven M. Bellovin
  哥伦比亚大学
  smb@cs.columbia.edu

- Simon Blake-Wilson
  BCI
  sblakewilson@bcisse.com

- Ran Canetti
  IBM
  canetti@watson.ibm.com

- Pete Chown
  Skygate Technology Ltd
  pc@skygate.co.uk

- Taher Elgamal
  taher@securify.com
  Securify

- Pasi Eronen
  pasi.eronen@nokia.com
  诺基亚

- Anil Gangolli
  anil@busybuddha.org

- Kipp Hickman

- Alfred Hoenes

- David Hopwood
  独立顾问
  david.hopwood@blueyonder.co.uk

- Phil Karlton（SSLv3的共同作者）

- Paul Kocher（SSLv3的共同作者）
  密码学研究
  paul@cryptography.com

- Hugo Krawczyk
  IBM
  hugo@ee.technion.ac.il

- Jan Mikkelsen
  Transactionware
  janm@transactionware.com

- Magnus Nystrom
  RSA Security
  magnus@rsasecurity.com

- Robert Relyea
  Netscape Communications
  relyea@netscape.com

- Jim Roskind
  Netscape Communications
  jar@netscape.com

- Michael Sabin

- Dan Simon
  微软公司
  dansimon@microsoft.com

- Tom Weinstein

- Tim Wright
  Vodafone
  timothy.wright@vodafone.com

编辑地址

- Tim Dierks
  独立
  邮箱：tim@dierks.org

- Eric Rescorla
  RTFM公司
  邮箱：ekr@rtfm.com

版权所有声明

本文件的版权归IETF信托（2008）所有。

本文件受BCP 78中的权利、许可证和限制约束，除非另有说明，作者保留所有权利。

本文件及其中包含的信息按“原样”提供，贡献者、其代表的组织（如有）、互联网协会、IETF信托和互联网工程任务组均不对其内容的准确性或适用性作任何保证，包括但不限于不保证其不会侵犯任何权利或具有适销性和特定用途的适用性。