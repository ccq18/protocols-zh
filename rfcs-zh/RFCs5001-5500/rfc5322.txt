# RFC 5322 中文翻译 (stub)
# 原文文件: ../../rfcs/RFCs5001-5500/rfc5322.txt

网络工作组                                    P. Resnick，主编
意见请求编号：5322                         高通公司
废止：2822                                              2008年10月
更新：4021
类别：标准轨道


                        互联网消息格式

本备忘录的状态

   本文件为互联网社区制定的互联网标准轨道协议，旨在征求讨论和改进建议。请参阅当前版本的《互联网官方协议标准》（STD 1），了解该协议的标准化状态和现行状态。本备忘录的分发不受限制。

摘要

   本文件定义了互联网消息格式（IMF），一种用于在计算机用户之间通过“电子邮件”消息框架发送文本消息的语法规范。该规范是对RFC 2822的修订，RFC 2822本身已取代RFC 822（“ARPA互联网文本消息格式标准”），并进行了更新以反映当前实践，同时结合了其他RFC中规定的增量变更。

























Resnick                     标准轨道                     [第1页]


RFC 5322                互联网消息格式             2008年10月


目录

   1.  引言 . . . . . . . . . . . . . . . . . . . . . . . . .  4
     1.1.  范围  . . . . . . . . . . . . . . . . . . . . . . .  4
     1.2.  表示符约定 . . . . . . . . . . . . . . . . . . .  5
       1.2.1.  需求符号 . . . . . . . . . . . . . . . . .  5
       1.2.2.  语法符号 . . . . . . . . . . . . . . . . .  5
       1.2.3.  本文档结构 . . . . . . . . . . . . . . .  5
   2.  消息的词法分析 . . . . . . . . . . . . . . . . .  6
     2.1.  一般描述  . . . . . . . . . . . . . . . . .  6
       2.1.1.  行长度限制 . . . . . . . . . . . . . .  7
     2.2.  头字段  . . . . . . . . . . . . . . . . .  8
       2.2.1.  非结构化头字段体 . . . . . . . . .  8
       2.2.2.  结构化头字段体 . . . . . . . . .  8
       2.2.3.  长头字段 . . . . . . . . . . . .  8
     2.3.  正文部分 . . . . . . . . . . . . . . .  9
   3.  语法 . . . . . . . . . . . . . . . . . . . 10
     3.1.  引言 . . . . . . . . . . . . . . . 10
     3.2.  词法标记 . . . . . . . . . . . . . 10
       3.2.1.  引号字符  . . . . . . . . . . 10
       3.2.2.  换行空白和注释 . . . . . . 11
       3.2.3.  原子（atom） . . . . . . . . 12
       3.2.4.  引号字符串 . . . . . . . . 13
       3.2.5.  其他标记 . . . . . . . . 14
     3.3.  日期和时间的规范 . . . . . . . 14
     3.4.  地址规范 . . . . . . . . . . . 16
       3.4.1.  地址规范（Addr-Spec） . . . 17
     3.5.  整体消息语法 . . . . . . . . 18
     3.6.  字段定义 . . . . . . . . . . 19
       3.6.1.  发件日期字段 . . . . . . 22
       3.6.2.  发件人字段  . . . . . . 22
       3.6.3.  目的地址字段 . . . . . 23
       3.6.4.  标识字段  . . . . . . 25
       3.6.5.  信息字段 . . . . . . 27
       3.6.6.  重新发送字段  . . . . 28
       3.6.7.  跟踪字段 . . . . . . 30
       3.6.8.  可选字段 . . . . . . 30
   4.  已废弃的语法 . . . . . . . . . . . 31
     4.1.  其他废弃标记  . . . . . . . 32
     4.2.  废弃的换行空白 . . . . . . 33
     4.3.  废弃的日期和时间 . . . . 33
     4.4.  废弃的地址格式 . . . . 35
     4.5.  废弃的头字段 . . . . 35
       4.5.1.  废弃的发件日期字段  . . . 36
       4.5.2.  废弃的发件人字段  . . . 36
       4.5.3.  废弃的目的地址字段  . . . 37
       4.5.4.  废弃的标识字段  . . . 37
       4.5.5.  废弃的信息字段  . . . 37
       4.5.6.  废弃的重新发送字段  . . . 38
       4.5.7.  废弃的跟踪字段  . . . 38
       4.5.8.  废弃的可选字段  . . . 38
   5.  安全考虑 . . . . . . . . . . . 38
   6.  IANA注意事项 . . . . . . . . . 39
   附录A.  示例消息 . . . . . . . . . 43
   附录A.1.  地址示例  . . . . . . . 44
   附录A.1.1. 一人发给另一人的简单地址示例  . . 44
   附录A.1.2. 不同类型的邮箱  . . . . . 45
   附录A.1.3. 群组地址  . . . . . . 45
   附录A.2.  回复消息  . . . . . . 46
   附录A.3.  重新发送的消息  . . . 47
   附录A.4.  带跟踪字段的消息  . . 48
   附录A.5.  空白字符、注释及其他奇异情况  . 49
   附录A.6.  已废弃的格式  . . . 50
   附录A.6.1.  废弃的地址格式  . . . 50
   附录A.6.2.  废弃的日期  . . . 50
   附录A.6.3.  废弃的空白字符和注释  . 51
   附录B.  与早期规范的差异  . . . 52
   附录C.  致谢  . . . . . . . . 53
   7.  参考文献 . . . . . . . . . . . 55
     7.1.  标准性参考文献  . . . . . . 55
     7.2.  资料性参考文献  . . . . . 55























Resnick                     标准轨道                     [第3页]


RFC 5322                互联网消息格式             2008年10月


1.  引言

1.1.  范围

   本文件定义了互联网消息格式（IMF），一种用于在计算机用户之间通过“电子邮件”消息框架发送文本消息的语法规范。该规范是对[RFC2822]的更新，RFC 2822曾取代[RFC0822]，并进行了更新以反映当前实践，同时结合了其他RFC中规定的增量变更，例如[RFC1123]。

   本文件仅定义文本消息的语法。特别地，不涉及在电子邮件中传输图片、音频或其他结构化数据的机制。已有多个扩展方案发布，例如MIME系列文档（[RFC2045]、[RFC2046]、[RFC2049]），它们描述了通过电子邮件传输此类数据的机制，或通过扩展此处提供的语法或结构化消息以符合此语法。这些机制超出了本规范的范围。

   在电子邮件的上下文中，消息被视为具有信封和内容。信封包含完成传输和投递所需的所有信息（详见[RFC5321]关于信封的讨论）。内容则是要交付给收件人的对象。本规范仅适用于消息内容的格式和部分语义，不涉及信封中的信息。

   不过，某些消息系统可能会利用内容中的信息来创建信封。本规范旨在促进程序获取此类信息。

   本规范旨在定义系统之间传递的消息内容格式。虽然一些消息系统会在本格式中本地存储消息（避免格式转换），而其他系统使用不同的格式，但本地存储的细节超出本规范的范围。

注意：本规范并不旨在规定站点内部使用的格式、它们应支持的具体消息系统功能，或创建或读取消息的用户界面程序的任何特性。此外，本文件也未对字符的编码方式（用于传输或存储）作出规定；也就是说，它没有规定所用的比特数或这些比特在传输线上的具体传输方式或在磁盘上的存储方式。

Resnick                     标准轨道                     [第4页]

RFC 5322                互联网消息格式             2008年10月

1.2. 记号约定

1.2.1. 需求符号

   本文档偶尔会使用大写字母的术语。当“必须（MUST）”、“应（SHOULD）”、“建议（RECOMMENDED）”、“不得（MUST NOT）”、“不应（SHOULD NOT）”和“可以（MAY）”这些术语以大写出现时，表示它们用来指示本规范的特定要求。关于这些术语的含义，详见[RFC2119]。

1.2.2. 语法符号

   本规范采用增强巴克斯-诺尔范式（ABNF）[RFC5234]，对消息语法的正式定义。字符将通过十进制值（例如，大写字母A的值为%d65，小写字母a的值为%d97）或不区分大小写的字面值（用引号括起，例如“A”代表大写或小写的A）来指定。

1.2.3. 本文件结构

   本文件分为几个部分。

   本节（第1节）为对全文的简要介绍。

   第2节概述了消息及其组成部分的总体描述。这是一个帮助读者理解后续内容中所用一些基本原则的概览。任何本节中的示例都不得被视为对消息任何部分正式语法的规范。

   第3节规定了每个消息部分结构的正式ABNF规则（语法），并描述了这些部分在消息中的含义（语义）。也就是说，它详细列出了每个部分的结构规则（语法）以及对这些部分的解释和解读指令（语义）。包括对具有特定结构的子部分的语法和语义分析。本节所包含的语法定义了消息必须遵循的创建规则。第3节中也有注释，指出在语法中规定的选项中，哪些应优先使用。

   第2节和第3节都描述了为本规范合法生成的消息。

   第4节规定了“过时”的语法。第3节中也提及了这些过时的语法元素。这些元素是早期版本中出现的，或曾被广泛用于互联网消息中的内容。作为规范的一部分，消息解析器必须理解这些元素以确保兼容性。然而，由于这些元素被认为存在互操作性差或会引起接收方重大问题，符合规范的消息创建者不得生成这些元素。

   第5节讨论了在实现本规范时应考虑的安全事项。

   附录A列出不同类型消息的示例。这些示例并不涵盖互联网中所有消息类型，但提供了某些语法形式的广泛概览。

   附录B列出了本规范与早期互联网消息规范的差异。

   附录C包含致谢。

2. 词法分析

2.1. 一般描述

   最基本的层面上，消息是一系列字符。符合本规范的消息由值在1到127范围内的字符组成，且被解释为US-ASCII [ANSI.X3-4.1986]字符。为简洁起见，本文档有时将此字符范围简称为“US-ASCII字符”。

      注意：本文件规定消息由US-ASCII范围内的字符（值在1到127之间）组成。还有其他文档，特别是MIME系列文档（[RFC2045]、[RFC2046]、[RFC2047]、[RFC2049]、[RFC4288]、[RFC4289]），对本规范进行了扩展，允许使用超出该范围的值。这些机制的讨论不在本规范的范围内。

   消息被划分为多行字符。每行由字符组成，以回车符（CR，ASCII值13）和换行符（LF，ASCII值10）两个字符组成的行结束符（CRLF）分隔。（在本文档中，回车/换行对通常写作“CRLF”。）

   一条消息由头字段（统称“消息的头部部分”）开始，之后可选地跟随消息体。头部部分由一系列字符行组成，具有本规范定义的特殊语法。消息体则是紧随头部部分之后的字符序列，两者之间由一空行（即没有任何内容的CRLF行）隔开。

      注意：常用语和早期版本的规范中，“头部”一词既可指整个头部部分，也可指单个头字段。为避免歧义，本文档不单独使用“头部”或“头部字段”这些术语，而是始终用“头字段”指单个字段，用“头部部分”指整个集合。

2.1.1. 行长度限制

   本规范对每行字符数设有两个限制。每行字符数不得超过998个，且应尽量不超过78个（不包括CRLF）。

   998字符的限制源于许多实现（如发送、接收或存储IMF消息的系统）无法处理超过998字符的行。为了增强鲁棒性，接收端实现应能处理任意长度的行。然而，由于许多实现（符合[RFC5321]的传输要求）不接受每行超过1000字符（包括CR和LF）的消息，因此，创建消息的实现应避免生成此类消息。

   更保守的78字符建议是为了适应许多用户界面实现，这些界面在显示消息时可能会截断或错误地换行超过78字符的行。尽管这些实现不符合本规范（甚至违反[RFC5321]，如果它们导致信息丢失），但为了鲁棒性，显示消息的实现应能处理任意长度的行（至少到998字符的限制）。

2.2. 头字段

   头字段是以字段名开头，后跟冒号（":"），再跟字段内容，最后以CRLF结束的行。字段名必须由可打印的US-ASCII字符（值在33到126之间）组成，不能包含冒号。字段内容可以由可打印的US-ASCII字符、空格（ASCII值32）和水平制表符（ASCII值9，简称HTAB）组成（统称空白字符WSP）。除非用于“折叠”和“展开”，否则字段内容不得包含CR和LF。所有字段内容必须符合本规范第3和第4节所描述的语法。

2.2.1. 非结构化头字段内容

   本规范中某些字段内容定义为“非结构化”（在第3.2.5节中定义为任何可打印的US-ASCII字符加空白字符），没有其他限制。这些称为非结构化字段内容。从语义上讲，非结构化字段内容仅需作为一行字符处理，无需额外处理（折叠和展开除外，详见第2.2.3节）。

2.2.2. 结构化头字段内容

   某些字段内容的语法比上述非结构化内容更为严格。这些称为“结构化”字段内容。结构化字段内容是由特定词法标记组成的序列，详见第3和第4节。许多这些标记允许（根据其语法）引入或结束评论（详见第3.2.2节）以及空白字符，这些空白字符可以进行“折叠”和“展开”（详见第2.2.3节）。结构化字段内容的语义分析与其语法一同给出。

2.2.3. 长头字段

   每个头字段在逻辑上是一行字符，包括字段名、冒号和字段内容。为了方便起见，为了应对998/78字符限制，头字段的字段内容部分可以拆分成多行表示，这称为“折叠”。一般规则是在允许折叠空白（非简单的WSP字符）的位置，可以在任何WSP前插入CRLF。

   例如，以下头字段：

   Subject: This is a test

   可以表示为：

   Subject: This
    is a test

   注意：虽然结构化字段内容定义允许在许多词法标记之间甚至在某些词法标记内部进行折叠，但应限制折叠在较高层次的句法断点处。例如，如果字段内容定义为逗号分隔值，建议在逗号后进行折叠，而不是在其他位置。

   将折叠的多行表示转换为单行表示的过程称为“展开”。展开只需删除紧跟在WSP前的CRLF。每个头字段在展开后应作为单行进行语法和语义的进一步处理。展开后的头字段没有长度限制，可以无限长。

2.3. 消息体

   消息体仅由US-ASCII字符行组成。对消息体的唯一两个限制是：

   - CR和LF必须成对出现，组成CRLF，不能单独出现。
   - 消息体中的字符行长度不得超过998个字符，建议不超过78个字符（不包括CRLF）。

      注意：如前所述，还有其他文档（特别是MIME系列文档：[RFC2045]、[RFC2046]、[RFC2049]、[RFC4288]、[RFC4289]）对本规范进行了扩展（或限制），以支持不同类型的消息体。这些机制超出了本规范的范围。

3. 语法

3.1. 引言

   本节定义了互联网消息的合法语法。符合本规范的消息必须遵守本节的语法。如果本节中的某些选项应生成特定形式，则在正文或语法旁的注释中会注明。

   对于定义的表达式，首先给出语法和用途的简要描述，然后是ABNF语法，最后是语义分析。所用但未具体定义的基本词法标记（如CR、LF、CRLF、HTAB、SP、WSP、DQUOTE、DIGIT、ALPHA和VCHAR）取自[RFC5234]的“核心规则”附录B.1。

在某些定义中，会出现以“obs-”开头的非终结符名称。这些“obs-”元素指的是第4节中定义的过时语法中的标记。在所有情况下，为了生成合法的互联网消息，这些产生式应被忽略，且不得作为消息的一部分使用。然而，在解释消息时，这些标记必须作为合法语法的一部分予以遵循。从这个意义上说，第3节定义了用于生成消息的语法，其中包含应被忽略的“obs-”元素，而第4节则增加了用于解释消息的语法。

3.2. 词法标记

以下规则用于定义基础词法分析器，它向更高级的解析器提供标记。本节定义了结构化头字段主体中使用的标记。

注意：本规范的读者需要特别注意这些词法标记在文档后续低级和高级语法中的使用方式。特别是，第3.2.2节中定义的空白字符和注释标记会在这里定义的低级标记中使用，而这些低级标记又会作为后续定义的高级标记的一部分。因此，即使在某个特定定义中没有明确出现，空白和注释在高级标记中也可能被允许。

3.2.1. 引用字符

某些字符被保留用于特殊解释，例如用来界定词法标记。为了允许将这些字符用作未解释的数据，提供了引用机制。

引用对（quoted-pair）定义为：
```
   quoted-pair = ("\" (VCHAR / WSP)) / obs-qp
```
在任何出现引用对的地方，应将其解释为单个字符。也就是说，作为引用对一部分出现的“\”字符在语义上是“不可见”的。

注意：在消息中，“\”字符可能出现在非引用对的地方。未作为引用对出现的“\”字符在语义上不是“不可见”的。本规范中目前只在ccontent、qcontent和第4节中的obs-dtext中出现引用对。

3.2.2. 折叠空白和注释

空白字符（包括在折叠中使用的空白字符，详见第2.2.3节）可以出现在头字段主体的许多元素之间。此外，作为注释的字符串（用括号括起来）也可以包含在结构化字段主体中。以下定义了折叠白空间（FWS）和注释结构。

用括号括起来的字符串被视为注释，只要它们不出现在“引号字符串”中（定义在第3.2.4节）。注释可以嵌套。

在本规范的多个位置，可以自由插入注释和FWS。为了适应这种语法，定义了“CFWS”标记，用于注释和/或FWS可能出现的地方。然而，在本规范中出现的CFWS，不能以使折叠头字段的任何一行完全由空白字符组成的方式插入。

折叠白空间（FWS）定义为：
```
   FWS = ([*WSP CRLF] 1*WSP) / obs-FWS
```
其中，ctext定义为：
```
   ctext = %d33-39 / %d42-91 / %d93-126 / obs-ctext
```
（即除“(”、“)”和“\”之外的可打印US-ASCII字符）

ccontent定义为：
```
   ccontent = ctext / quoted-pair / comment
```
注释定义为：
```
   comment = "(" *([FWS] ccontent) [FWS] ")"
```
CFWS定义为：
```
   CFWS = (1*([FWS] comment) [FWS]) / FWS
```

在整个规范中，FWS（折叠白空间）出现的地方，表示可以进行折叠（如第2.2.3节所述）。在消息中（即包含CRLF后跟任何WSP的头字段主体），在进行任何语义分析之前，CRLF会被展开（移除）。因此，FWS中的CRLF在语义上是“不可见”的。

注释通常用于结构化字段主体中提供一些人类可读的信息。由于注释允许包含FWS，注释中也允许折叠。由于在注释中允许引用对，括号和反斜杠字符也可以作为引用对出现。语义上，括号是注释的界定符，不属于注释内容；注释内容是括号之间的部分。前述，任何引用对中的“\”和FWS中的CRLF在注释中也是“不可见”的。

在结构化头字段中，词法标记之间的FWS、注释或CFWS连续出现时，语义上被视为一个空格字符。

3.2.3. 原子（Atom）

结构化头字段主体中的一些产生式仅由特定基本字符组成，这些被称为“原子”。

某些结构化头字段主体允许在连续的a-文本（atext）中出现句点（“.”，ASCII值46）。为此定义了“点原子”（dot-atom）标记。

注意：“specials”标记在本规范的其他地方未出现。它仅指那些在a-文本中未出现的可见字符（非控制字符、非空白字符）。提供此标记是为了方便使用词法分析工具的实现者。每个“specials”字符都可以用作词法分析中的标记点。

定义如下：
```
   atext = ALPHA / DIGIT / "!" / "#" / "$" / "%" / "&" / "'" / "*" / "+" / "-" / "/" / "=" / "?" / "^" / "_" / "`" / "{" / "|" / "}" / "~"
```
以及：
```
   atom = [CFWS] 1*atext [CFWS]
   dot-atom-text = 1*atext *("." 1*atext)
   dot-atom = [CFWS] dot-atom-text [CFWS]
   specials = "(" / ")" / "<" / ">" / "[" / "]" / ":" / ";" / "@" / "\" / "," / "." / DQUOTE
```
“atom”和“dot-atom”都被视为单一单位，包含组成它们的字符串。语义上，包裹在它们周围的可选注释和FWS不属于原子；原子仅指由连续的atext字符组成的字符串，或在点原子中由atext和“.”组成的字符串。

3.2.4. 引号字符串（Quoted Strings）

包含非a-文本字符的字符串可以用引号字符串（quoted-string）表示，字符被引号（DQUOTE，ASCII值34）括起来。

定义如下：
```
   qtext = %d33 / %d35-91 / %d93-126 / obs-qtext
   qcontent = qtext / quoted-pair
   quoted-string = [CFWS] DQUOTE *([FWS] qcontent) [FWS] DQUOTE [CFWS]
```
引号字符串作为一个整体处理。语义上，quoted-string与atom相同。由于允许在引号字符串中包含FWS，折叠也是允许的。注意，引用对中的“\”和引号字符也可以在引号字符串中出现，只要它们作为引用对出现。

语义上，括号和引号本身不属于引号字符串；引号字符串是括号之间的内容。前述，任何引号对中的“\”和引号中的CRLF在引号字符串中也是“不可见”的。

3.2.5. 其他标记

定义另外三种标记：word和phrase用于组合原子和/或引号字符串，unstructured用于非结构化头字段和某些结构化字段中的部分。

定义如下：
```
   word = atom / quoted-string
   phrase = 1*word / obs-phrase
   unstructured = (*([FWS] VCHAR) *WSP) / obs-unstruct
```

3.3. 日期和时间规范

日期和时间值出现在多个头字段中。本节定义完整日期和时间的语法。虽然在日期时间规范中允许折叠白空间，但建议在每个FWS出现的地方（无论是否强制）使用单个空格；一些旧的实现可能无法正确解析较长的折叠白空间序列。

定义如下：
```
   date-time = [ day-of-week "," ] date time [CFWS]
   day-of-week = ([FWS] day-name) / obs-day-of-week
   day-name = "Mon" / "Tue" / "Wed" / "Thu" / "Fri" / "Sat" / "Sun"
   date = day month year
   day = ([FWS] 1*2DIGIT FWS) / obs-day
   month = "Jan" / "Feb" / "Mar" / "Apr" / "May" / "Jun" / "Jul" / "Aug" / "Sep" / "Oct" / "Nov" / "Dec"
   year = (FWS 4*DIGIT FWS) / obs-year
   time = time-of-day zone
   time-of-day = hour ":" minute [ ":" second ]
   hour = 2DIGIT / obs-hour
   minute = 2DIGIT / obs-minute
   second = 2DIGIT / obs-second
   zone = (FWS ( "+" / "-" ) 4DIGIT) / obs-zone
```
日期中的“day”是月份中的数字日，“year”是1900年及以后的任何数字年份。

“time-of-day”表示从午夜起的小时、分钟，和可选的秒数。

日期和时间应表达本地时间。

时区（zone）表示与协调世界时（UTC）之间的偏移。符号“+”或“-”指示时间是比UTC快（东偏）还是慢（西偏）。前两位数字表示小时差，后两位数字表示分钟差。应使用“+0000”表示UTC时区。虽然“-0000”也表示UTC，但它用于指示时间是在可能位于非UTC本地时区的系统上生成的，且日期时间不包含本地时区信息。

日期时间规范必须在语义上有效，即：
- 如果包含星期几（day-of-week），必须与日期相符；
- 数字日必须在1到该月允许的天数范围内；
- 时间必须在00:00:00到23:59:60（考虑闰秒）范围内；
- 时区的最后两位数字必须在00到59之间。

3.4. 地址规范

地址出现在多个消息头字段中，用于指示发件人和收件人。地址可以是单个邮箱，也可以是邮箱组。

定义如下：
```
   address = mailbox / group
   mailbox = name-addr / addr-spec
   name-addr = [display-name] angle-addr
   angle-addr = [CFWS] "<" addr-spec ">" [CFWS] / obs-angle-addr
   group = display-name ":" [group-list] ";" [CFWS]
   display-name = phrase
   mailbox-list = (mailbox *("," mailbox)) / obs-mbox-list
   address-list = (address *("," address)) / obs-addr-list
   group-list = mailbox-list / CFWS / obs-group-list
```
邮箱（mailbox）代表收件箱，是一个概念实体，不一定涉及文件存储。例如，有些站点可能选择将邮件打印出来，送到收件人的办公桌。

通常，一个邮箱由两部分组成：
1. 一个可选的显示名（display-name），指示收件人（人或系统）的名字，可能显示给邮件应用的用户；
2. 一个用尖括号括起来的addr-spec地址。

（未完，后续内容继续定义邮箱组、显示名、地址列表等。）

（以下为翻译内容）

“<”和“>”。 邮箱的另一种简单形式是只出现地址部分（addr-spec），没有收件人姓名或角括号。互联网地址的addr-spec在第3.4.1节中描述。

注意：一些旧版本的实现使用了只显示地址部分（addr-spec）而没有角括号的简单形式，但在地址后面用括号作为注释包含收件人的姓名。由于注释中的信息含义未定义，建议实现应使用完整的姓名-地址（name-addr）形式的邮箱，而非旧式形式，以指定与邮箱关联的显示名称。此外，由于一些旧版本的实现会解释注释内容，为避免混淆，地址字段中通常不应使用注释。

当需要将多个邮箱视为一个整体（例如在分发列表中）时，可以使用组（group）结构。组结构允许发件人指示一组有名称的收件人。操作方式是先给出组的显示名称，后跟冒号，再列出用逗号分隔的任意数量（包括零或一个）的邮箱地址，最后以分号结束。由于邮箱列表可以为空，使用组结构也是一种简便的方式，向收件人传达消息是发给一个或多个有名集合的收件人，而无需提供每个收件人的具体邮箱地址。

3.4.1. 地址规格（Addr-Spec）定义

addr-spec是一个特定的互联网标识符，包含一个本地部分（local-part），后跟“@”符号（ASCII值64），再跟一个互联网域（domain）。本地部分可以是引号字符串（quoted-string）或点原子（dot-atom）。如果该字符串可以用点原子表示（即只包含文本字符或由文本字符包围的点“.”），则应使用点原子形式，不应使用引号字符串。addr-spec中的“@”符号前后不应有注释或折叠空白。

注意：这里给出了addr-spec域部分的宽松语法。然而，域部分包含由其他协议（如[RFC1034]、[RFC1035]、[RFC1123]、[RFC5321]）定义和使用的地址信息。因此，实现应遵循其使用环境中的地址语法。

addr-spec = local-part "@" domain

local-part = dot-atom / quoted-string / obs-local-part

domain = dot-atom / domain-literal / obs-domain

domain-literal = [CFWS] "[" *([FWS] dtext) [FWS] "]" [CFWS]

dtext = %d33-90 / %d94-126 / obs-dtext
（其中，%d表示对应的ASCII码值，obs-dtext为观察性定义的字符）

域部分标识邮件投递的目标点。在点原子形式中，它被解释为互联网域名（可以是主机名或邮件交换器名），如[RFC1034]、[RFC1035]和[RFC1123]中描述的那样。在域字面量形式中，域被解释为特定主机的字面互联网地址。无论哪种形式，地址的使用和消息传输方式在其他文档中（如[RFC5321]）有详细说明，本规范未涉及。

本地部分是一个依赖域的字符串。在地址中，它被简单地解释为特定主机上的邮箱名。

3.5. 整体消息语法

一条消息由头字段组成，可选地后跟消息体。消息中的行长度不得超过998个字符（不包括CRLF），但建议限制为78个字符（不包括CRLF）（详见第2.1.1节）。在消息体中，虽然可以使用文本规则中列出的所有字符，但不鼓励使用US-ASCII控制字符（值1至8、11、12，以及14至31），因为接收方对这些字符的显示解释不一定可靠。

message = (fields / obs-fields) [CRLF body]

body = (*(*998text CRLF) *998text) / obs-body

text = %d1-9 / %d11 / %d12 / %d14-127
（表示除CR和LF之外的字符）

头字段携带大部分语义信息，定义在第3.6节。消息体则是未被本规范解释的一系列文本行。

3.6. 字段定义

消息的头字段在此定义。所有头字段具有相同的基本语法结构：字段名，后跟冒号，再跟字段内容。每个字段的具体语法在后续章节中详细定义。

注意：在后续章节的ABNF语法中，每个字段名后都必须跟冒号。为了简洁，有时在描述中未特别提及冒号，但实际上它是必须的。

需要注意的是，头字段的顺序不保证。它们可以以任何顺序出现，且在互联网传输过程中有时会被重新排序。然而，为了本规范的目的，建议在消息传输或转换时不要重新排序头字段。更重要的是，追踪（trace）头字段和重发（resent）头字段不得重新排序，应保持在消息前的块中。详见第3.6.6和第3.6.7节。

唯一必须的头字段是发起日期（origination date）和发件人地址（originator address）字段。其他头字段在语法上是可选的。更多信息请参见后续表格。

字段 = *(trace / *optional-field / *(resent-date / resent-from / resent-sender / resent-to / resent-cc / resent-bcc / resent-msg-id)) *(orig-date / from / sender / reply-to / to / cc / bcc / message-id / in-reply-to / references / subject / comments / keywords / optional-field)

下表列出了每个字段在消息头中的最大出现次数及其使用限制。带有“*”的值表示有特殊限制，详见备注。

（此处省略详细表格内容）

3.6.1. 发起日期字段

发起日期字段由字段名“Date”加上日期时间规范组成。

orig-date = "Date:" date-time CRLF

发起日期指示消息创建者声明消息已完成、准备进入邮件投递系统的时间。例如，用户在应用程序中点击“发送”或“提交”按钮的时间。它明确不表示消息实际传输的时间，而是指用户或其他创建者将消息整理成最终形式、准备传送的时间。（例如，一个未连接网络的便携电脑用户可能会将消息排队等待发送。发起日期应包含用户排队的时间，而非用户连接网络的时间。）

3.6.2. 发件人字段

发件人字段由“From”字段名和一个或多个邮箱地址组成的逗号分隔列表。如果“From”字段中包含多个邮箱地址，则必须有“Sender”字段，包含“Sender”字段名和单个邮箱地址。在任何情况下，也可以选择加入“Reply-To”字段，包含“Reply-To”字段名和一个或多个地址的逗号分隔列表。

from = "From:" mailbox-list CRLF

sender = "Sender:" mailbox CRLF

reply-to = "Reply-To:" address-list CRLF

发件人字段指示消息的源头邮箱。 “From:”字段指定消息的作者，即负责撰写消息的个人或系统的邮箱。 “Sender:”字段指定实际传输消息的代理邮箱。例如，如果一位秘书代表另一人发送消息，秘书的邮箱会出现在“Sender:”字段中，实际作者的邮箱会出现在“From:”字段中。如果可以用单一邮箱标识消息的发起者，且作者与传输者相同，则“Sender:”字段不应使用，否则应同时出现。

注意：传输者信息总是存在的。缺少“Sender:”字段有时会被误解为未指定传输代理，但实际上意味着传输者与作者相同，无需重复放在“Sender:”中。

发件人字段还提供回复消息所需的信息。当“Reply-To:”字段存在时，表示作者建议回复的地址。若无此字段，默认回复应发到“From:”字段指定的地址，除非回复者另有说明。

在所有情况下，“From:”字段不应包含任何不属于该消息作者的邮箱地址。另请参阅第3.6.3节，以获取有关形成回复目标地址的更多信息。

3.6.3.  目标地址字段

消息的目标字段由三种可能的字段组成，每个字段的格式相同：字段名（“To”、“Cc”或“Bcc”），后跟用逗号分隔的一个或多个地址（可以是邮箱地址或群组语法）。

to              =   "To:" 地址列表 CRLF

cc              =   "Cc:" 地址列表 CRLF

bcc             =   "Bcc:" [地址列表 / 纯白空格] CRLF

目标字段指定消息的收件人。每个目标字段可以包含一个或多个地址，这些地址表示消息的预期收件人。这三者之间的唯一区别在于它们的用途不同。

“To:”字段包含消息的主要收件人地址。

“Cc:”字段（“Carbon Copy”的意思，指用碳纸复写的副本）包含其他应接收该消息的地址，尽管消息内容可能并非针对他们。

“Bcc:”字段（“Blind Carbon Copy”的意思，指密件副本）包含收件人的地址，这些地址不应向其他收件人披露。使用“Bcc:”字段有三种方式：第一种是在准备发送包含“Bcc:”字段的消息时，发送前会将“Bcc:”行删除，但所有收件人（包括“Bcc:”字段中的人）仍会收到消息的副本；第二种是在“To:”和“Cc:”行中指定的收件人会收到一份没有“Bcc:”行的消息副本，而“Bcc:”行中的收件人会收到一份包含“Bcc:”行的单独副本（当“Bcc:”字段中有多个地址时，一些实现会为每个收件人单独发送一份只包含该收件人地址的“Bcc:”副本）；第三种是“Bcc:”字段可以为空，即可以不包含任何地址，向收件人表明已向某些人发送了密件副本。使用哪种方法由实现决定，但请参阅本文档的“安全考虑”部分，以了解每种方法的讨论。

当一条消息是对另一条消息的回复时，原始消息的发件人邮箱（“From:”字段中的邮箱）或“Reply-To:”字段（如果存在）中的邮箱可以出现在回复的“To:”字段中，因为这些通常是主要收件人。如果回复的消息包含目标字段，通常希望将回复的副本也发给所有原始消息的收件人，除了作者之外。当形成这样的回复时，原始消息中的“To:”和“Cc:”字段中的地址可以出现在回复的“Cc:”字段中，因为这些通常是次要收件人。如果原始消息中有“Bcc:”字段，其地址可以出现在回复的“Bcc:”字段中，但不应出现在“To:”或“Cc:”字段中。

注意：一些邮件应用程序具有自动回复命令，这些命令会在回复的目标地址中包含原始消息的目标地址。这些回复命令的行为取决于实现，超出本文范围。特别是，是否在原始消息中包含“Reply-To:”字段时包含原始目标地址，也未在此讨论。

3.6.4.  标识字段

虽然在第3.6节的表中列为可选，但每条消息都应包含“Message-ID:”字段。此外，回复消息应根据需要包含“In-Reply-To:”和“References:”字段，具体如下。

“Message-ID:”字段包含一个唯一的消息标识符。 “References:”和“In-Reply-To:”字段各自包含一个或多个唯一的消息标识符，之间可用CFWS（纯白空格）隔开。

消息标识符（msg-id）的语法是受限的addr-spec构造，包裹在尖括号“<”和“>”中。与addr-spec不同，这种语法只允许在“@”左侧使用点原子文本（dot-atom-text），且在消息标识符中不允许内部有CFWS。

注意：与addr-spec一样，msg-id的右侧（“@”之后）语法较为宽松，但建议在“@”右侧使用域名（或域名字面量IP地址）。域名的语法由其他协议（如[RFC1034]、[RFC1035]、[RFC1123]、[RFC5321]）定义和使用，因此实现应遵循其语法规则。

message-id      =   "Message-ID:" msg-id CRLF

in-reply-to     =   "In-Reply-To:" 1*msg-id CRLF

references      =   "References:" 1*msg-id CRLF

msg-id          =   [CFWS] "<" id-left "@" id-right ">" [CFWS]

id-left         =   dot-atom-text / obs-id-left

id-right        =   dot-atom-text / no-fold-literal / obs-id-right

no-fold-literal =   "[" *dtext "]"

“Message-ID:”字段提供一个唯一的消息标识符，用于标识特定版本的特定消息。该标识符的唯一性由生成它的主机保证（见下文）。此标识符旨在机器可读，不一定对人类有意义。一个消息标识符对应一条消息的特定版本；消息的后续修订会获得新的消息标识符。

注意：在许多情况下，消息会被“更改”，但这些更改不构成该消息的全新实例，因此不会获得新的消息标识符。例如，在消息进入传输系统时，常会在消息头中添加追踪字段（第3.6.7节）和重发字段（第3.6.6节），这些添加不会改变消息的身份，因此原有的“Message-ID:”字段会被保留。无论何时，决定“Message-ID:”字段是否变化的依据是消息的实际含义（即是否为同一消息或不同消息），而非消息中出现的任何特定语法差异。

“In-Reply-To:”和“References:”字段在创建回复时使用。它们存储原始消息的消息标识符，以及其他消息的标识符（例如，回复本身也是对某个回复的情况）。 “In-Reply-To:”字段用于标识回复的目标消息（或消息），而“References:”字段用于标识一串对话。

在创建回复时，结果消息的“In-Reply-To:”和“References:”字段按如下方式构造：

“In-Reply-To:”字段将包含被回复消息（“父消息”）的“Message-ID:”字段内容。如果有多个父消息，则“In-Reply-To:”字段将包含所有父消息的“Message-ID:”内容。如果任何父消息没有“Message-ID:”字段，则新消息将没有“In-Reply-To:”字段。

“References:”字段将包含父消息的“References:”字段内容（如果有）以及父消息的“Message-ID:”内容（如果有）。如果父消息没有“References:”字段，但有“In-Reply-To:”字段且只包含一个消息标识符，则“References:”字段将包含父消息的“In-Reply-To:”内容，后跟父消息的“Message-ID:”内容（如果有）。如果父消息没有“References:”、“In-Reply-To:”或“Message-ID:”字段，则新消息不会有“References:”字段。

注意：一些实现会解析“References:”字段以显示“讨论串”。这些实现假设每个新消息都是对单个父消息的回复，因此可以向后遍历“References:”字段，找到每个列出消息的父消息。因此，不建议为具有多个父消息的回复构造“References:”字段；如何实现此功能未在本文中定义。

消息标识符（msg-id）必须是全局唯一的，用于标识一条消息。生成该标识符的系统必须保证其唯一性。实现可以采用多种算法来实现此目标。由于msg-id的语法类似于addr-spec（唯一不同之处在于不允许引号字符串、注释和折叠空白），一种较好的方法是在“@”右侧放置生成消息标识符的主机的域名（或域名字面量IP地址），因为域名和IP地址通常是唯一的；在“@”左侧放置当前的绝对日期和时间，以及系统中可用的其他唯一（或序列化）标识符（例如，进程ID）。虽然其他算法也可行，但建议在“@”右侧包含某个域名标识符（无论是主机本身还是其他），以保证在该域范围内左侧的唯一性。

语义上，尖括号字符不是msg-id的一部分；msg-id是指尖括号之间的内容。

3.6.5.  信息字段

信息字段全部为可选。 “Subject:”和“Comments:”字段为非结构化字段（见第2.2.1节），可以包含文本或折叠空白。 “Keywords:”字段包含由逗号分隔的一个或多个词或引号字符串。

subject         =   "Subject:" unstructured CRLF

comments        =   "Comments:" unstructured CRLF

keywords        =   "Keywords:" phrase *("," phrase) CRLF

这三个字段旨在提供关于消息的可读信息。“Subject:”字段最常用，包含简短的字符串，用于标识消息主题。

在回复中，字段内容可以以“Re: ”（拉丁语“in re”的缩写，意为“关于”）开头，后跟原始消息“Subject:”字段的内容。如果这样做，建议只使用一次“Re: ”，避免多次叠加，以免引起不良后果。“Comments:”字段包含对消息正文的任何补充评论。“Keywords:”字段包含一串重要词汇和短语，便于收件人理解或分类。

3.6.6.  重发字段

重发字段应添加到由用户重新引入传输系统的任何消息中。每次重发都应添加一组新的重发字段。所有对应同一次重发的重发字段应组合在一起。每组新重发字段会被插入到消息的最前面，即最新的重发字段出现在消息的较前位置。添加重发字段时，消息中的其他字段不应被更改。

每个“Resent-”字段对应语法中其他位置的特定字段。例如，“Resent-Date:”字段对应“Date:”字段，“Resent-To:”字段对应“To:”字段。在每种情况下，字段主体的语法与之前为相应字段给出的语法完全相同。

当使用“Resent-”字段时，必须发送“Resent-From:”和“Resent-Date:”字段。应当发送“Resent-Message-ID:”字段。如果“Resent-Sender:”字段的内容与“Resent-From:”字段相同，则不应使用“Resent-Sender:”字段。

resent-date     =   “Resent-Date:” date-time CRLF

resent-from     =   “Resent-From:” mailbox-list CRLF

resent-sender   =   “Resent-Sender:” mailbox CRLF

resent-to       =   “Resent-To:” address-list CRLF

resent-cc       =   “Resent-Cc:” address-list CRLF

resent-bcc      =   “Resent-Bcc:” [address-list / CFWS] CRLF

resent-msg-id   =   “Resent-Message-ID:” msg-id CRLF

Resnick                     标准轨迹                    [第28页]

RFC 5322                互联网消息格式             2008年10月

“Resent”字段用于标识一条消息已被用户重新引入传输系统。使用“Resent”字段的目的是让最终收件人看到的消息似乎是由原始发件人直接发送的，且所有原始字段保持不变。每组“Resent”字段对应一次特定的重新发送事件。也就是说，如果一条消息被多次转发，每次转发都应有一组“Resent”字段，提供每次转发的识别信息。“Resent”字段仅供信息使用，不能在回复或其他自动处理消息的正常流程中使用。

注意：将消息重新引入传输系统并使用“Resent”字段与“转发”操作不同。“转发”有两个含义：一种是邮件阅读程序被用户指示将一份消息转发给他人，转发的消息成为新消息的正文。这种转发的消息看起来不像来自原始发件人，而是由转发者发出的全新消息。另一种是邮件传输程序接收一条消息后，将其转发到另一个目的地进行最终投递。无论哪种情况，转发都不应使用“Resent”头字段。

“Resent-”起始字段指示重新转发消息的邮箱地址。与普通发件人字段一样，有两种形式：一种是简单的“Resent-From:”形式，包含执行转发的个人邮箱；另一种较复杂的形式是由“Resent-Sender:”字段中的个人代表一人或多人（在“Resent-From:”字段中列出）进行转发。

注意：回复“Resent”消息时，回复行为与对其他消息相同，使用原始的“From:”、“Reply-To:”、“Message-ID:”等字段。 “Resent”字段仅供信息参考，不能在回复的正常处理流程中使用。

“Resent-Date:”表示由转发者发出该“Resent”消息的日期和时间。它与“Date:”字段不同，后者是消息实际传输的日期和时间。

“Resent-To:”、“Resent-Cc:”、“Resent-Bcc:”字段的功能与“To:”、“Cc:”、“Bcc:”字段相同，但它们指示的是“Resent”消息的收件人，而非原始消息的收件人。

“Resent-Message-ID:”字段为“Resent”消息提供唯一标识符。

3.6.7. 追踪字段

追踪字段是一组头字段，包括一个可选的“Return-Path:”字段和一个或多个“Received:”字段。“Return-Path:”头字段包含一对尖括号，括起一个可选的地址规范（addr-spec）。 “Received:”字段包含一系列（可能为空）标记，后跟分号和日期时间说明。每个标记必须是单词、角括地址（angle-addr）、地址规范或域名。追踪字段的语法还受到其他规范（如[RFC5321]）的限制。

trace           =   [return]
                   1*received

return          =   “Return-Path:” path CRLF

path            =   angle-addr / ([CFWS] “<” [CFWS] “>” [CFWS])

received        =   “Received:” *received-token “;” date-time CRLF

received-token  =   word / angle-addr / addr-spec / domain

关于追踪字段在互联网邮件中的完整用法，详见[RFC5321]。在本规范中，追踪字段仅供信息用途，任何对其的正式解释超出本文范围。

3.6.8. 可选字段

消息中可以出现本规范未规定的字段。这些字段必须符合“optional-field”的语法，即由字段名、冒号和符合非结构化语法的文本组成。

任何可选字段的字段名不得与本文其他部分规定的字段名相同。

optional-field  =   field-name ":" unstructured CRLF

field-name      =   1*ftext

ftext           =   %d33-57 /          ; 可打印的US-ASCII字符
                   %d59-126           ; 不包括冒号的字符

在本规范中，任何可选字段都视为未解释的。

4. 过时的语法

早期版本的规范允许比本版本更宽松的语法。此外，互联网消息中曾使用一些语法元素，其含义从未被正式文档化。虽然这些语法形式不得根据第3节的语法规则生成，但符合规范的接收端必须接受并解析它们。本节列出许多此类语法元素。将第3节的语法加入本节的定义后，即形成用于解释消息的语法。

注意：本节所列的语法形式是任何实现必须合理解释的。然而，实际上仍存在不符合本节附加语法的互联网消息。某些形式未在本文任何部分出现，并不意味着程序必须崩溃或错误数据无法处理。实现应以鲁棒的方式处理消息。

过时（解释性）语法与当前（生成性）语法的一个重要区别在于：在结构化头字段主体（即冒号与CRLF之间的部分）中，可以自由插入空白字符（包括折叠空白）和注释。这导致许多复杂形式难以被某些实现解析。

另一个区别是，第3.2.2节关于纯空白行（在注释和折叠空白中）的规则不再适用。关于折叠空白的讨论请参见下文第4.2节。

最后，某些曾允许出现在消息中的字符在本节中出现。曾允许的NUL字符（ASCII值0）已不再允许以保持兼容性。同样，除了CR、LF、SP和HTAB（ASCII值1-8、11、12、14-31和127）之外的US-ASCII控制字符也曾允许出现在头字段主体中。消息中也允许出现CR和LF，但必须作为CRLF使用。

其他语法和语义的差异请参见后续章节。

4.1. 其他过时的标记

这些语法元素在过时的语法或主语法中被使用。裸CR、裸LF和NUL已加入obs-qp、obs-body和obs-unstruct。US-ASCII控制字符也加入obs-qp、obs-unstruct、obs-ctext和obs-qtext。句点字符（"."）加入obs-phrase。obs-phrase-list允许包含“空”元素的（可能为空的）逗号分隔短语列表，即列表中可以有两个或多个连续的逗号，中间没有内容，或在列表开始或结束处有逗号。

注意：“句点”（或“句号”）字符（"."）在obs-phrase中不是早期版本或其他规范允许的形式。因为句点会引起解析困难（区分短语和addr-spec的部分），所以在早期版本中未允许。之所以出现在此，是因为在许多地址的显示名部分，尤其是名字的首字母中，句点被广泛使用，因此必须正确解释。

obs-NO-WS-CTL   =   %d1-8 /            ; US-ASCII控制字符
                   %d11 /             ; 不包括回车、换行和空白字符
                   %d12 /             
                   %d14-31 /          
                   %d127              

obs-ctext       =   obs-NO-WS-CTL

obs-qtext       =   obs-NO-WS-CTL

obs-utext       =   %d0 / obs-NO-WS-CTL / VCHAR

obs-qp          =   "\" (%d0 / obs-NO-WS-CTL / LF / CR)

obs-body        =   *((*LF *CR *((%d0 / text) *LF *CR)) / CRLF)

obs-unstruct    =   *((*LF *CR *(obs-utext *LF *CR)) / FWS)

obs-phrase      =   word *(word / "." / CFWS)

obs-phrase-list =   [phrase / CFWS] *("," [phrase / CFWS])

裸CR和裸LF在消息中具有不同的含义。在许多情况下，裸CR或裸LF被错误地用作CRLF的替代，表示行分隔符。在其他情况下，裸CR和裸LF仅作为US-ASCII控制字符，具有其传统的ASCII含义。

4.2. 过时的折叠空白

在过时的语法中，可以在允许使用obs-FWS的任何位置插入任意数量的折叠空白。这可能导致一行中连续出现两个“折叠”，因此一行组成折叠头字段时可能完全由空白字符组成。

obs-FWS         =   1*WSP *(CRLF 1*WSP)

4.3. 过时的日期和时间

过时日期格式的语法允许日期字段中的年份为两位数字，并允许使用早期版本中使用的字母时区说明符列表。它还允许在许多标记之间插入注释和折叠空白。

obs-day-of-week =   [CFWS] day-name [CFWS]

obs-day         =   [CFWS] 1*2DIGIT [CFWS]

obs-year        =   [CFWS] 2*DIGIT [CFWS]

obs-hour        =   [CFWS] 2DIGIT [CFWS]

obs-minute      =   [CFWS] 2DIGIT [CFWS]

obs-second      =   [CFWS] 2DIGIT [CFWS]

obs-zone        =   “UT” / “GMT” /     ; 通用时间
                                      ; 北美UT偏移
                   “EST” / “EDT” /    ; 东部：-5/-4
                   “CST” / “CDT” /    ; 中部：-6/-5
                   “MST” / “MDT” /    ; 山地：-7/-6
                   “PST” / “PDT” /    ; 太平洋：-8/-7
                                      ;

% d65-73 /          ; 军事时区 - “A”
% d75-90 /          ; 通过 “I” 和 “K”
% d97-105 /         ; 通过 “Z”，大小写皆可
% d107-122

当日期中出现两位或三位数字的年份时，解释规则如下：如果年份为两位数字，且值在00到49之间，则年份为2000加上该值，即2000到2049之间；如果值在50到99之间，或是三位数字，则年份为1900加上该值。

在过时的时区中，“UT”和“GMT”分别表示“通用时间”和“格林威治标准时间”，二者语义相同，均等价于“+0000”。

其余三个字符的时区代表美国的时区。第一个字母“E”、“C”、“M”或“P”代表“东部”、“中部”、“山地”和“太平洋”时区。第二个字母“S”表示“标准”时间，“D”表示“夏令时（日光节约时间）”。它们的含义如下：

EDT（东部夏令时）在语义上等同于-0400
EST（东部标准时）在语义上等同于-0500
CDT（中部夏令时）在语义上等同于-0500
CST（中部标准时）在语义上等同于-0600
MDT（山地夏令时）在语义上等同于-0600
MST（山地标准时）在语义上等同于-0700
PDT（太平洋夏令时）在语义上等同于-0700
PST（太平洋标准时）在语义上等同于-0800

单字符的军用时区在[RFC0822]中以非标准方式定义，因此其含义难以预测。最初定义的“ A”到“I”军用时区分别等同于“+0100”到“+0900”；“K”、“L”、“M”分别等同于“+1000”、“+1100”、“+1200”；“N”到“Y”则等同于“-0100”到“-1200”；而“Z”则等同于“+0000”。然而，由于[RFC0822]中的错误，除非有带外信息确认其含义，否则应将它们全部视为等同于“-0000”。

其他多字符（通常在3到5个字母）表示的时区在互联网消息中也有使用。任何此类时区若其含义未知，应视为等同于“-0000”，除非有带外信息确认其含义。

4.4. 过时的地址表示法

在地址表示中，主要有四个差异。首先，邮箱地址允许在“<”和“>”之间有路由部分。路由是由逗号分隔的域名列表，每个域名前有“@”，列表以冒号结束。第二，允许在本地部分和域名的点分隔元素之间有CFWS（可选的空白字符），即不使用点原子（dot-atom）。此外，本地部分允许包含引号字符串（quoted-string），而不仅仅是原子（atom）。第三，邮箱列表和地址列表允许“空”成员，即列表中可以有两个或多个逗号，中间没有内容，或者在列表的开头或结尾有逗号。最后，域字面值中允许使用US-ASCII控制字符和引号对（quoted-pair）。

定义如下：
obs-angle-addr  =   [CFWS] "<" obs-route addr-spec ">" [CFWS]
obs-route       =   obs-domain-list ":"
obs-domain-list =   *(CFWS / ",") "@" domain *(("," [CFWS] ["@" domain]))
obs-mbox-list   =   *([CFWS] ",") mailbox *("," [mailbox / CFWS])
obs-addr-list   =   *([CFWS] ",") address *("," [address / CFWS])
obs-group-list  =   1*([CFWS] ",") [CFWS]
obs-local-part  =   word *("." word)
obs-domain      =   atom *("." atom)
obs-dtext       =   obs-NO-WS-CTL / quoted-pair

在解析地址时，应忽略路由部分。

4.5. 过时的头字段

在语法上，过时字段的主要差异在于允许字段出现多次，且顺序不限。此外，字段名后可以有任意数量的空白字符。

定义如下：
obs-fields      =   *(obs-return /
                       obs-received /
                       obs-orig-date /
                       obs-from /
                       obs-sender /
                       obs-reply-to /
                       obs-to /
                       obs-cc /
                       obs-bcc /
                       obs-message-id /
                       obs-in-reply-to /
                       obs-references /
                       obs-subject /
                       obs-comments /
                       obs-keywords /
                       obs-resent-date /
                       obs-resent-from /
                       obs-resent-send /
                       obs-resent-rply /
                       obs-resent-to /
                       obs-resent-cc /
                       obs-resent-bcc /
                       obs-resent-mid /
                       obs-optional)

除目的地址字段（详见4.5.3）外，字段多次出现的解释未定义。对于追踪字段和重发字段（不在消息前块中的字段），其解释也未定义。除非后续章节另有说明，否则其他字段的解释与第3节中非过时对应字段的解释相同。

4.5.1 过时的发件日期字段

obs-orig-date   =   "Date" *WSP ":" date-time CRLF

4.5.2 过时的发件人字段

obs-from        =   "From" *WSP ":" mailbox-list CRLF
obs-sender      =   "Sender" *WSP ":" mailbox CRLF
obs-reply-to    =   "Reply-To" *WSP ":" address-list CRLF

4.5.3 过时的目的地址字段

obs-to          =   "To" *WSP ":" address-list CRLF
obs-cc          =   "Cc" *WSP ":" address-list CRLF
obs-bcc         =   "Bcc" *WSP ":"
                       (address-list / (*([CFWS] ",") [CFWS])) CRLF

当消息中出现多个目的地址字段时，应将第一个字段中的地址列表与后续字段的地址列表合并，即在地址列表之间添加逗号并连接。

4.5.4 过时的标识字段

“ In-Reply-To:” 和 “References:” 字段的过时形式允许出现短语（词或引号字符串）。它们的左右两侧的msg-id的旧形式允许插入CFWS，使其在语法上与本地部分和域名相同。

定义如下：
obs-message-id  =   "Message-ID" *WSP ":" msg-id CRLF
obs-in-reply-to =   "In-Reply-To" *WSP ":" *(phrase / msg-id) CRLF
obs-references  =   "References" *WSP ":" *(phrase / msg-id) CRLF
obs-id-left     =   local-part
obs-id-right    =   domain

在解析时，“In-Reply-To:” 和 “References:” 字段中的短语将被忽略。语义上，本地部分和域名中的可选CFWS不属于obs-id-left和obs-id-right。

4.5.5 过时的信息字段

obs-subject     =   "Subject" *WSP ":" unstructured CRLF
obs-comments    =   "Comments" *WSP ":" unstructured CRLF
obs-keywords    =   "Keywords" *WSP ":" obs-phrase-list CRLF

4.5.6 过时的重发字段

过时的语法增加了“Resent-Reply-To:”字段，包括字段名、可选的注释和折叠空白、冒号以及逗号分隔的地址列表。

定义如下：
obs-resent-from =   "Resent-From" *WSP ":" mailbox-list CRLF
obs-resent-send =   "Resent-Sender" *WSP ":" mailbox CRLF
obs-resent-date =   "Resent-Date" *WSP ":" date-time CRLF
obs-resent-to   =   "Resent-To" *WSP ":" address-list CRLF
obs-resent-cc   =   "Resent-Cc" *WSP ":" address-list CRLF
obs-resent-bcc  =   "Resent-Bcc" *WSP ":"
                       (address-list / (*([CFWS] ",") [CFWS])) CRLF
obs-resent-mid  =   "Resent-Message-ID" *WSP ":" msg-id CRLF
obs-resent-rply =   "Resent-Reply-To" *WSP ":" address-list CRLF

与其他重发字段一样，“Resent-Reply-To:”字段仅作为追踪信息处理。

4.5.7 过时的追踪字段

obs-return 和 obs-received 作为模板定义再次出现，类似第3节中的 return 和 received。它们的完整语法见[RFC5321]。

定义如下：
obs-return      =   "Return-Path" *WSP ":" path CRLF
obs-received    =   "Received" *WSP ":" *received-token CRLF

4.5.8 过时的可选字段

obs-optional    =   field-name *WSP ":" unstructured CRLF

5. 安全注意事项

在终端或终端模拟器上显示消息时需谨慎。强大的终端可能会对转义序列和其他US-ASCII控制字符组合作出反应，可能导致多种后果，包括重新映射键盘、修改终端行为，甚至引发拒绝服务或数据损坏。它们还可能触发（有时可编程的）应答消息，使消息能代表接收方发出命令，或影响连接的打印机等设备的操作。消息查看器应考虑在显示前剥离潜在危险的终端转义序列，但也不能盲目剥除所有转义序列，因为一些用于有用目的的转义序列（参见[ISO.2022.1994]、[RFC2045]、[RFC2046]、[RFC2047]、[RFC2049]、[RFC4288]、[RFC4289]）也会出现。

在消息中传输非文本对象会引发额外的安全问题，详见相关RFC。

许多实现使用“Bcc:”（盲碳复制）字段（详见第3.6.3节）来向收件人发送消息而不泄露其他收件人的地址。错误处理“Bcc:”的方式可能泄露机密信息，甚至导致安全问题。例如，若采用在第3.6.3节中描述的第一种方法，即删除“Bcc:”行，盲收件人不会明确知道自己收到了盲抄，除非其地址未出现在消息头中。这样，盲抄收件人可能会不小心通过回复全部收件人而泄露自己是盲抄的事实。第二种方法是在单独的副本中显示“Bcc:”字段，若该字段包含所有盲抄地址，则每个盲抄收件人都能看到其他盲抄地址。即使为每个盲抄收件人单独发送只含其地址的消息，也需小心处理回复，以避免无意中泄露盲抄收件人信息。

6. IANA考虑事项

本文件更新了[RFC4021]中注册的内容，这些内容涉及[RFC2822]中的定义。IANA已根据[RFC3864]的程序，将以下头字段加入永久消息头字段库：

字段名：Date
适用协议：邮件
状态：标准
作者/变更控制：IETF
规范文档：本文件（第3.6.1节）

字段名：From
适用协议：邮件
状态：标准
作者/变更控制：IETF
规范文档：本文件（第3.6.2节）

字段名：Sender
适用协议：邮件
状态：标准
作者/变更控制：IETF
规范文档：本文件（第3.6.2节）

字段名：Reply-To
适用协议：邮件
状态：标准
作者/变更控制：IETF
规范文档：本文件（第3.6.2节）

字段名：To
适用协议：邮件
状态：标准
作者/变更控制：IETF
规范文档：本文件（第3.6.3节）

字段名：Cc
适用协议：邮件
状态：标准
作者/变更控制：IETF
规范文档：本文件（第3.6.3节）

字段名：Bcc
适用协议：邮件
状态：标准
作者/变更控制：IETF
规范文档：本文件（第3.6.3节）

字段名：Message-ID
适用协议：邮件
状态：标准
作者/变更控制：IETF
规范文档：本文件（第3.6.4节）

字段名：In-Reply-To
适用协议：邮件
状态：标准
作者/变更控制：IETF
规范文档：本文件（第3.6.4节）

字段名：References
适用协议：邮件
状态：标准
作者/变更控制：IETF
规范文档：本文件（第3.6.4节）

字段名：Subject
适用协议：邮件
状态：标准
作者/变更控制：IETF
规范文档：本文件（第3.6.5节）

字段名：Comments
适用协议：邮件
状态：标准
作者/变更控制：IETF
规范文档：本文件（第3.6.5节）

字段名：Keywords
适用协议：邮件
状态：标准
作者/变更控制：IETF
规范文档：本文件（第3.6.5节）

字段名：Resent-Date
适用协议：邮件
状态：标准
作者/变更控制：IETF
规范文档：本文件（第3.6.6节）

字段名：Resent-From
适用协议：邮件
状态：标准
作者/变更控制：IETF
规范文档：本文件（第3.6.6节）

字段名：Resent-Sender
适用协议：邮件
状态：标准
作者/变更控制：IETF
规范文档：本文件（第3.6.6节）

字段名：Resent-To
适用协议：邮件
状态：标准
作者/变更控制：IETF
规范文档：本文件（第3.6.6节）

（以下省略其他注册字段，内容与前面类似）

（附录A：示例消息部分略，内容为示意说明，不作翻译）

在本文档的文本版本中，本节中的消息内容以“----”线条为界。  
这些“----”线条不属于消息本身。

（空白行和空白字符省略）

Resnick                     标准轨道                    [第43页]

RFC 5322                互联网消息格式             2008年10月

附录A.1.  地址示例

以下是两个个人之间可能发送的消息示例。

A.1.1.  简单地址的单人消息

这可以称为规范消息。它有单一作者John Doe，单一收件人Mary Smith，主题、日期、消息ID，以及正文中的文本消息。

----
发件人：John Doe <jdoe@machine.example>  
收件人：Mary Smith <mary@example.net>  
主题：打招呼  
日期：1997年11月21日星期五 09:55:06 -0600  
消息ID：<1234@local.machine.example>  

这只是一条打招呼的消息。  
所以，"Hello"。  
----

如果John的秘书Michael实际上发了这条消息，尽管John是作者，回复也应发回他，  
那么发件人字段会使用：

----
发件人：John Doe <jdoe@machine.example>  
发件人（Sender）：Michael Jones <mjones@machine.example>  
收件人：Mary Smith <mary@example.net>  
主题：打招呼  
日期：1997年11月21日星期五 09:55:06 -0600  
消息ID：<1234@local.machine.example>  

这只是一条打招呼的消息。  
所以，"Hello"。  
----

（空白行和空白字符省略）

Resnick                     标准轨道                    [第44页]

RFC 5322                互联网消息格式             2008年10月

附录A.1.2.  邮箱的不同类型

此消息的目标字段中包含多个地址，并且使用了几种不同的地址格式。

----
发件人：“Joe Q. Public” <john.q.public@example.com>  
收件人：Mary Smith <mary@x.test>、jdoe@example.org、Who? <one@y.test>  
抄送：<boss@nil.test>、“Giant; \"Big\" Box” <sysservices@example.net>  
日期：2003年7月1日星期二 10:52:37 +0200  
消息ID：<5678.21-Nov-1997@example.com>  

大家好。  
----

注意，Joe Q. Public 和 Giant; "Big" Box 的显示名需要用双引号括起来，因为前者包含句点，后者包含分号和双引号字符（双引号以转义对的形式出现）。  
相反，Who? 的显示名可以不用引号，因为问号在原子中是合法的。  
还要注意，jdoe@example.org 和 boss@nil.test 没有显示名，且jdoe@example.org使用了不带尖括号的简洁地址格式。

A.1.3.  组地址

----
发件人：Pete <pete@silly.example>  
收件人：A组：Ed Jones <c@a.test>、joe@where.test、John <jdoe@one.test>；  
抄送：未公开收件人：；  
日期：1969年2月13日星期四 23:32:54 -0330  
消息ID：<testabcd.1234@silly.example>  

测试。  
----

在此消息中，“To:”字段包含一个名为“A组”的组收件人，组内有3个地址，“Cc:”字段包含一个空组“未公开收件人”。

（空白行和空白字符省略）

Resnick                     标准轨道                    [第45页]

RFC 5322                互联网消息格式             2008年10月

A.2.  回复消息

以下是一组由三条消息组成的对话，涉及John和Mary。  
John首先发消息给Mary，Mary回复John的消息，然后John回复Mary的回复。

特别注意每条消息中的“Message-ID:”、“References:”和“In-Reply-To:”字段。

----
发件人：John Doe <jdoe@machine.example>  
收件人：Mary Smith <mary@example.net>  
主题：打招呼  
日期：1997年11月21日星期五 09:55:06 -0600  
消息ID：<1234@local.machine.example>  

这只是一条打招呼的消息。  
所以，"Hello"。  
----

回复时，主题字段通常会保留，但会在前面加上“Re: ”，如第3.6.5节所述。

----
发件人：Mary Smith <mary@example.net>  
收件人：John Doe <jdoe@machine.example>  
回复地址：“Mary Smith: Personal Account” <smith@home.example>  
主题：Re: 打招呼  
日期：1997年11月21日星期五 10:01:10 -0600  
消息ID：<3456@example.net>  
In-Reply-To：<1234@local.machine.example>  
References：<1234@local.machine.example>  

这是对你的打招呼的回复。  
----

注意上面消息中的“Reply-To:”字段。当John回复Mary的消息时，回复应发到“Reply-To:”字段中的地址，而不是“From:”字段中的地址。

（空白行和空白字符省略）

Resnick                     标准轨道                    [第46页]

RFC 5322                互联网消息格式             2008年10月

----
收件人：“Mary Smith: Personal Account” <smith@home.example>  
发件人：John Doe <jdoe@machine.example>  
主题：Re: 打招呼  
日期：1997年11月21日星期五 11:00:00 -0600  
消息ID：<abcd.1234@local.machine.test>  
In-Reply-To：<3456@example.net>  
References：<1234@local.machine.example> <3456@example.net>  

这是对你的回复的回复。  
----

（空白行和空白字符省略）

A.3.  重新发送的消息

从之前多次示例的消息开始：  

----
发件人：John Doe <jdoe@machine.example>  
收件人：Mary Smith <mary@example.net>  
主题：打招呼  
日期：1997年11月21日星期五 09:55:06 -0600  
消息ID：<1234@local.machine.example>  

这只是一条打招呼的消息。  
所以，"Hello"。  
----

假设Mary收到此消息后，想将其转发给Jane，要求：  
(a) 这条消息看起来像是直接来自John；  
(b) 如果Jane回复，回复应发回John；  
(c) 保留所有原始信息，如原始发送日期、消息ID和原始收件人。  
在这种情况下，转发的字段会被添加到消息前面：

----
转发自：Mary Smith <mary@example.net>  
转发给：Jane Brown <j-brown@other.example>  
转发日期：1997年11月24日星期一 14:22:01 -0800  
转发消息ID：<78910@example.net>  
发件人：John Doe <jdoe@machine.example>  
收件人：Mary Smith <mary@example.net>  
主题：打招呼  
日期：1997年11月21日星期五 09:55:06 -0600  
消息ID：<1234@local.machine.example>  

这只是一条打招呼的消息。  
所以，"Hello"。  
----

如果Jane想将此消息转发给其他人，她会在上述基础上添加自己的转发字段，然后发送（注意，为简洁起见，追踪字段未显示）。

（空白行和空白字符省略）

A.4.  带追踪字段的消息

如通过[RFC5321]描述的传输系统中所示，消息在传输过程中会在前面添加追踪字段。  
以下是这些追踪字段可能的示例。注意第一行中有一些折叠空白，因为这些行可能较长。

----
已接收：来自x.y.test  
      通过example.net  
      通过TCP  
      使用ESMTP  
      ID ABC12345  
      发送到 <mary@example.net>；  1997年11月21日 10:05:43 -0600  
已接收：来自node.example，经过x.y.test； 1997年11月21日 10:01:22 -0600  
发件人：John Doe <jdoe@node.example>  
收件人：Mary Smith <mary@example.net>  
主题：打招呼  
日期：1997年11月21日 09:55:06 -0600  
消息ID：<1234@local.node.example>  

这只是一条打招呼的消息。  
所以，"Hello"。  
----

（空白行和空白字符省略）

A.5.  空白、注释及其他奇异之处

空白字符，包括折叠空白，以及注释，可以插入到字段的许多位置。  
以A.1.3中的示例为例，空白和注释可以插入到所有字段中。

----
发件人：Pete(A nice \) chap) <pete(his account)@silly.test(his host)>  
收件人：A组（一些人）  
        :Chris Jones <c@(Chris's host.)public.example>，  
            joe@example.org，  
     John <jdoe@one.test>（我亲爱的朋友）；（组的结束）  
抄送：（空列表）（开始）隐藏收件人  ：（我认识的）无；  
日期：星期四，  
       2月13日，  
       1969年，  
       23:32  
               -0330（纽芬兰时间）  
消息ID：<testabcd.1234@silly.test>  

测试。  
----

上述示例在美学上不佳，但完全合法。  
特别注意（1）“From:”字段中的注释（包括包含“)”字符的引号对）；  
（2）“To:”字段中“:”后没有空白，以及组名后面的注释和折叠空白，Chris Jones地址中的特殊字符“.”，以及“joe@example.org,”前后折叠空白；  
（3）“Cc:”字段中的多个嵌套注释，以及“Cc”后紧跟的注释；  
（4）折叠空白（但没有注释，除了最后）以及日期字段中缺少秒数；  
（5）“Message-ID:”字段中标识符前的空白。

（空白行和空白字符省略）

Resnick                     标准轨道                    [第49页]

A.6.  已废弃的格式

以下是一些在本文件第4节中描述的已废弃（即“不得生成”）的语法元素示例。

A.6.1.  已废弃的地址格式

注意示例中没有用引号括起Joe Q. Public，Mary Smith地址中的路由信息，"To:"字段中的两个逗号，以及jdoe地址中“.”两边的空格。

----
发件人：Joe Q. Public <john.q.public@example.com>  
收件人：Mary Smith <@node.test:mary@example.net>、、jdoe@test  . example  
日期：2003年7月1日星期二 10:52:37 +0200  
消息ID：<5678.21-Nov-1997@example.com>  

大家好。  
----

A.6.2.  已废弃的日期格式

以下消息使用了已废弃的日期格式，包括非数字时区和两位数年份。  
注意，虽然缺少星期几，但这并非特定于废弃语法；在当前语法中也是可选的。

----
发件人：John Doe <jdoe@machine.example>  
收件人：Mary Smith <mary@example.net>  
主题：打招呼  
日期：1997年11月21日 09:55:06 GMT  
消息ID：<1234@local.machine.example>  

这只是一条打招呼的消息。  
所以，"Hello"。  
----

（后续内容省略，格式类似）

（空白行和空白字符省略）

A.6.3.  已废弃的空白和注释

空白字符和注释可以出现在比当前语法允许的更多位置。  
此外，完全由空白组成的折叠行也是合法的。

----
从：John Doe <jdoe@machine(comment).  example>  
到：Mary Smith  
__  
             <mary@example.net>  
主题：打招呼  
日期：1997年11月21日 09(comment): 55  :  06 -0600  
消息ID：<1234   @   local(blah)  .machine .example>  

这只是一条打招呼的消息。  
所以，"Hello"。  
----

特别注意“到:”字段的第二行。它以两个空格字符开始。（“__”代表空格）  
因此，它被视为折叠的一部分，如第4.2节所述。  
此外，地址、日期和消息ID中的注释和空白也都属于已废弃语法的一部分。

（空白行和空白字符省略）

Resnick                     标准轨道                    [第51页]

A.6.4.  已废弃的格式示例总结

（此部分内容省略，内容与前述类似，强调已废弃的语法元素）

（空白行和空白字符省略）

附录B.  与早期规范的差异

本附录列出自早期规范（特别是[RFC0822]、[RFC1123]和[RFC2822]）以来，互联网消息格式所做的更改。  
带有星号（*）的条目在本文件第4节中出现，意味着不能再生成。

以下是从[RFC0822]和[RFC1123]到[RFC2822]的变更，且仍在本文档中：

1.  过时格式中的句点允许使用。  
2.  ABNF已从文档中移出，现定义于[RFC5234]。  
3.  允许年份为四位或更多数字。  
4.  明确规定了头字段的顺序（或无顺序）。  
5.  移除加密的头字段。  
6.  明确允许并定义“-0000”时区的含义。  
7.  不允许在每个标记之间折叠空白。  
8.  移除了对目的地的要求。  
9.  转发和重发的定义被重新定义。  
10.  扩展头字段不再特别列出。  
11.  移除ASCII 0（空字符）。*  
12.  折叠续行不能只包含空白字符。*  
13.  不允许在日期中随意插入注释。*  
14.  不允许非数字时区。*  
15.  不允许两位数年份。*  
16. 解释三位数年份，但不允许生成。*  
17.  地址中的路由不允许。*  
18.  本地部分和域中的CFWS（折叠白空白）不允许。*  
19.  地址列表中的空成员不允许。*  
20.  字段名与冒号之间不允许折叠空白。*  
21.  字段名与冒号之间不允许注释。*  
22.  对“In-Reply-To”和“References”语法进行了严格限制。*  
23.  “Message-ID”中的CFWS不允许。*  
24.  重发字段的语义被严格限定为仅供参考。*  
25.  Resent-Reply-To不允许。*  
26.  字段不允许多次出现（除Resent和Received外）。*  
27.  不允许自由的CR和LF。*  
28.  规定了行长度限制。  
29.  更明确地规定了Bcc字段。

（后续内容省略，内容与前述类似）

（空白行和空白字符省略）

以下内容是对[RFC2822]的变更内容：
1. 修正了各种排版和语法错误，并进行了澄清。
2. 将“标准”一词在全文中改为“文档”或“规范”。
3. 区分了“头字段”和“头部区域”。
4. 从ctext、qtext、dtext和非结构化文本中移除了NO-WS-CTL。
5. 将关于特殊字符的讨论移至“Atom”部分，并将相关内容移至“整体消息语法”部分。
6. 简化了CFWS（评论和空白符）语法。
7. 修正了非结构化语法。
8. 改变了日期和时间的语法，以处理过时日期语法中的空白字符。
9. 从域字面值和消息标识符中移除了引号对。
10. 澄清了其他规范对域名语法的限制。
11. 简化了“Bcc:”和“Resent-Bcc:”的语法。
12. 允许trace信息中出现可选字段。
13. 从msg-id中移除了no-fold-quote，并澄清了语法限制。
14. 将“Received:”语法进行了泛化，以修正错误，并将定义移出本规范。
15. 简化了obs-qp（过时的Quoted-Printable编码），修正并简化了obs-utext（仅在过时语法中出现），移除了obs-text和obs-char，新增了obs-body。
16. 修正了过时日期语法，以允许更多或更少的注释和空白字符。
17. 修正所有过时的列表语法（包括obs-domain-list、obs-mbox-list、obs-addr-list、obs-phrase-list以及新加入的obs-group-list）。
18. 修正了obs-reply-to语法。
19. 修正了obs-bcc和obs-resent-bcc以允许空列表。
20. 移除了obs-path。

附录C：致谢
许多人为本文件的完成做出了贡献，包括参与互联网工程任务组（IETF）消息标准详细修订与更新（DRUMS）工作组的成员、DRUMS的主席、IETF的区域主管以及通过电子邮件提供意见的人们。编辑对他们表示深深的感谢，以下名单包括所有就本文件和[RFC2822]提供过电子邮件反馈的人士。希望所有贡献者都在此被提及。

（名单省略，内容为众多贡献者的姓名列表）

第7节 参考文献
7.1. 必要性参考文献
（列出相关标准和规范的引用，包括ANSI标准、RFC系列文档、ISO标准等）
7.2. 说明性参考文献
（列出提供背景信息和补充资料的文献，包括RFC 822、RFC 1305、ISO 2022、MIME相关RFC等）

作者联系方式
彼得·W·Resnick（编辑）
高通公司
地址：加利福尼亚州圣地亚哥莫尔豪斯大道5775号，邮编92121-1714
电话：+1 858 651 4478
电子邮箱：presnick@qualcomm.com
网址：http://www.qualcomm.com/~presnick/

版权声明
本文件版权归IETF信托所有（2008年）。本文件依据BCP 78的权利、许可和限制发布，除非另有说明，作者保留所有权利。本文件及其中信息按“原样”提供，不对其适用性、完整性或准确性作任何保证，包括不侵犯任何权利或适销性、适用特定用途的隐含保证。

知识产权
IETF不对本文件所涉及技术的任何知识产权或其他权利的有效性或范围发表立场，也不保证已进行任何相关权利的独立调查。关于RFC文档中的权利程序，详见BCP 78和BCP 79。有关已向IETF秘书处披露的知识产权声明及许可保证的副本，或为获得使用这些专有权利的通用许可或权限而进行的尝试的结果，可在IETF的在线知识产权存储库中查阅：http://www.ietf.org/ipr。

IETF鼓励任何有兴趣的方向其披露可能涉及实现本标准所需技术的版权、专利或专利申请及其他专有权利。请将相关信息发送至：ietf-ipr@ietf.org。