# RFC 3447 中文翻译 (stub)
# 原文文件: ../../rfcs/RFCs3001-3500/rfc3447.txt

网络工作组                                         J. Jonsson
意见征求稿：3447                                    B. Kaliski
废止：2437                                         RSA实验室
类别：信息性                                    2003年2月


     公钥密码标准（PKCS）#1：RSA密码学
                      规范版本2.1

本备忘录的状态

   本备忘录旨在向互联网社区提供信息。它不规定任何类型的互联网标准。 本备忘录的分发不受限制。

版权声明

   版权所有（C）互联网协会（2003年）。保留所有权利。

摘要

   本备忘录是对RSA实验室的公钥密码标准（PKCS）系列中PKCS #1 v2.1的重新发布，变更控制仍由PKCS流程管理。本文档的正文内容直接取自PKCS #1 v2.1文档，在出版过程中做了若干修正。

目录

   1. 引言...............................................2
   2. 符号说明...........................................3
   3. 密钥类型...........................................6
      3.1 RSA公钥........................................6
      3.2 RSA私钥........................................7
   4. 数据转换原语.......................................8
      4.1 I2OSP...........................................9
      4.2 OS2IP...........................................9
   5. 密码学原语........................................10
      5.1 加密与解密原语.................................10
      5.2 签名与验证原语.................................12
   6. 概述方案..........................................14
   7. 加密方案..........................................15
      7.1 RSAES-OAEP.....................................16
      7.2 RSAES-PKCS1-v1_5.................................23
   8. 签名方案（附录）................................27
      8.1 RSASSA-PSS.....................................29
      8.2 RSASSA-PKCS1-v1_5...............................32
   9. 签名编码方法（附录）..............................35

附录A. ASN.1语法........................................44
   A.1 RSA密钥表示......................................44
   A.2 方案识别.........................................46
附录B. 支持技术.........................................52
   B.1 哈希函数.........................................52
   B.2 掩码生成函数.....................................54
附录C. ASN.1模块........................................56
附录D. 知识产权事项....................................63
附录E. 修订历史........................................64
附录F. 参考文献........................................65
附录G. 关于PKCS.........................................70
附录H. RFC发布过程中所做的更正.........................70
安全注意事项............................................70
致谢....................................................71
作者联系方式............................................71
完整版权声明............................................72

1. 引言

   本文档提供了基于RSA算法[42]的公钥密码学实现建议，涵盖以下方面：

    * 密码学原语

    * 加密方案

    * 签名方案（附录）

    * 表示密钥和识别方案的ASN.1语法

   这些建议旨在广泛应用于计算机和通信系统中，具有一定的灵活性。预期基于这些规范的应用标准可能会包含额外的限制条件。建议与标准IEEE-1363-2000[26]以及由ANSI X9F1[1]和IEEE P1363[27]工作组制定的草案标准保持兼容。

   本文档取代了PKCS #1 v2.0版本[35][44]，但包含兼容的技术。

组织结构如下：

* 第1节为引言。

* 第2节定义了本文档中使用的符号。

* 第3节定义了RSA公钥和私钥的类型。

* 第4节和第5节定义了几种原语，即基本的数学操作。第4节为数据转换原语，第5节为密码学原语（加密-解密、签名-验证）。

* 第6、7、8节涉及本文档中的加密和签名方案。第6节提供概述。除了PKCS #1 v1.5中的方法外，第7节定义了基于OAEP[3]的加密方案，第8节定义了基于PSS[4][5]的签名方案（附录部分）。

* 第9节定义了第8节中签名方案的编码方法。

* 附录A定义了第3节中密钥和第7、8节中方案的ASN.1语法。

* 附录B定义了本文档中使用的哈希函数和掩码生成函数，包括相关技术的ASN.1语法。

* 附录C提供了ASN.1模块。

* 附录D、E、F和G涉及知识产权问题、PKCS #1的修订历史、其他出版物和标准的参考，以及关于公钥密码学标准的常规信息。

2. 符号说明

c              密文代表，整数，范围0到n-1

C              密文，八位字节字符串

d              RSA私钥指数

d_i            额外因子r_i的CRT指数，是一个正整数，满足

                  e * d_i ≡ 1 (mod r_i-1)，i=3,...,u

dP             p的CRT指数，是一个正整数，满足

                  e * dP ≡ 1 (mod p-1)

dQ             q的CRT指数，是一个正整数，满足

                  e * dQ ≡ 1 (mod q-1)

e              RSA公钥指数

EM             编码消息，八位字节字符串

emBits         编码消息EM的（预期）长度（比特）

emLen          编码消息EM的（预期）长度（字节）

GCD(. , .)     两个非负整数的最大公约数

Hash           哈希函数

hLen           哈希函数Hash的输出长度（字节）

k              RSA模数n的长度（字节）

K              RSA私钥

L              可选的RSAES-OAEP标签，八位字节字符串

LCM(., ..., .)  一组非负整数的最小公倍数

m              消息代表，范围0到n-1的整数

M              消息，八位字节字符串

mask           MGF的输出，八位字节字符串

maskLen        掩码的（预期）长度（字节）

MGF            掩码生成函数

mgfSeed        生成掩码的种子，八位字节字符串

（以下符号定义省略，内容与原文一致）

3. 密钥类型

   本文定义的原语和方案中使用两种密钥类型：RSA公钥和RSA私钥。两者共同组成RSA密钥对。

   本规范支持所谓的“多质数”RSA，即模数可能由多于两个质数组成。多质数RSA的优点在于在使用CRT（中国剩余定理）时，解密和签名的计算成本较低。在单处理器平台上性能提升有限，但在多处理器平台上效果更佳，因为涉及的模幂运算可以并行进行。

   关于多质数对RSA密码体系安全性的影响，读者可参考[49]。

3.1 RSA公钥

   在本文件中，RSA公钥由两个组成部分构成：

      n        RSA模数，为正整数
      e        RSA公钥指数，为正整数

   有效的RSA公钥中，模数n是由u个不同的奇质数r_i（i=1,2,...,u，u≥2）相乘而成，且公钥指数e是介于3和n-1之间的整数，满足GCD(e, λ(n))=1，其中λ(n)=LCM(r_1-1, ..., r_u-1)。按照惯例，前两个质数r_1和r_2也可以分别记为p和q。

   交换RSA公钥的推荐语法见附录A.1.1；实现的内部表示可能不同。

3.2 RSA私钥

   在本文件中，RSA私钥可以采用两种表示方式。

   1. 第一种表示由一对(n, d)组成，其中：

      n        RSA模数，为正整数
      d        RSA私钥指数，为正整数

   2. 第二种表示由五元组(p, q, dP, dQ, qInv)和（可能为空的）三元组(r_i, d_i, t_i)序列组成，i=3,...,u，分别对应模数中除p和q外的其他质因数。其含义如下：

      p        第一个因数，为正整数
      q        第二个因数，为正整数
      dP       p的CRT指数，为正整数
      dQ       q的CRT指数，为正整数
      qInv     CRT系数，为正整数，满足

                  q * qInv ≡ 1 (mod p)

      r_i      第i个因数，为正整数
      d_i      第i个因数的CRT指数，为正整数
      t_i      第i个因数的CRT系数，为正整数

   在有效的RSA私钥（第一种表示）中，模数n与对应的公钥相同，为u个不同奇质数r_i的乘积（u≥2）。私钥指数d是小于n的正整数，满足

      e * d ≡ 1 (mod λ(n))，

   其中e为对应的公钥指数，λ(n)定义如第3.1节。

   在有效的RSA私钥（第二种表示）中，p和q为模数n的前两个质因数（即r_1和r_2），CRT指数dP和dQ分别为小于p和q的正整数，满足

      e * dP ≡ 1 (mod p-1)
      e * dQ ≡ 1 (mod q-1)

   以及CRT系数qInv为小于p的正整数，满足

      q * qInv ≡ 1 (mod p)

   如果u>2，表示中还会包括一个或多个三元组(r_i, d_i, t_i)，i=3,...,u。r_i为模数的附加质因数。每个CRT指数d_i满足

      e * d_i ≡ 1 (mod r_i-1)

   每个CRT系数t_i（i=3,...,u）为小于r_i的正整数，满足

      R_i * t_i ≡ 1 (mod r_i)

   其中，R_i = r_1 * r_2 * ... * r_(i-1)。

   交换RSA私钥的推荐语法（同时包含两种表示的组件）见附录A.1.2；实现的内部表示可能不同。

   备注：

   1. 这里定义的CRT系数及其在第5节原语中的应用公式，基本遵循Garner算法[22]（另见[37]中的算法14.71）。但为了与PKCS #1 v2.0及之前版本中RSA私钥的表示保持兼容，p和q的角色被反转。因此，第一个CRT系数qInv定义为q模p的逆，而非p模q的逆（即，反转了p和q的角色）。

   2. Quisquater和Couvreur[40]指出，将中国剩余定理应用到RSA运算中的好处。

4. 数据转换原语

   本文定义的方案中使用两种数据转换原语：

      * I2OSP - 整数到八位字节字符串的转换原语

* OS2IP - 八位字节串转整数原语

在本文件中，为了与ASN.1语法保持一致，八位字节串被定义为有序的八位字节（八位字节串）序列。该序列从第一个（习惯上为最左边）到最后一个（最右边）进行索引。在进行整数的转换（转为或从）时，首个八位字节被视为最高有效字节。

Jonsson & Kaliski            信息性文档                      [第8页]

RFC 3447        PKCS #1：RSA密码学规范   2003年2月

4.1 I2OSP（整数转八位字节串）

I2OSP将非负整数转换为指定长度的八位字节串。

I2OSP (x, xLen)

输入：
x        要转换的非负整数
xLen     目标八位字节串的长度

输出：
X        长度为xLen的对应八位字节串

错误： "整数过大"

步骤：

1. 如果x ≥ 256^xLen，则输出“整数过大”并停止。

2. 将整数x以基数256的唯一xLen位表示：

   x = x_(xLen-1) * 256^(xLen-1) + x_(xLen-2) * 256^(xLen-2) + ... + x_1 * 256 + x_0，

   其中0 ≤ x_i < 256（注意，如果x小于256^(xLen-1)，则前导数字会有一个或多个为零）。

3. 令八位字节X_i的整数值为x_(xLen-i)，对于1 ≤ i ≤ xLen。输出八位字节串

   X = X_1 X_2 ... X_xLen。

4.2 OS2IP（八位字节串转整数）

OS2IP将八位字节串转换为非负整数。

OS2IP (X)

输入：
X        要转换的八位字节串

输出：
x        对应的非负整数

步骤：

1. 令X_1 X_2 ... X_xLen为X的八个字节，从第一个到最后一个，且令x_(xLen-i)为八个字节X_i的整数值，1 ≤ i ≤ xLen。

2. 计算x = x_(xLen-1) * 256^(xLen-1) + x_(xLen-2) * 256^(xLen-2) + ... + x_1 * 256 + x_0。

3. 输出x。

5. 密码学原语

密码学原语是构建密码方案的基础数学操作。它们旨在硬件实现或软件模块实现，不旨在提供除方案外的安全性。

本文定义了四种类型的原语，按对组织：加密与解密；签名与验证。

这些原语的规范假设输入满足某些条件，特别是RSA公钥和私钥是有效的。

5.1 加密与解密原语

加密原语在公钥控制下，将消息代表转换为密文代表；解密原语在私钥控制下，从密文代表恢复消息代表。

在本文定义的加密方案中，采用一对加密和解密原语：RSAEP/RSADP。RSAEP和RSADP涉及相同的数学操作，但输入的密钥不同。

这些原语与IEEE Std 1363-2000 [26]中的IFEP-RSA/IFDP-RSA相同（支持多素数RSA已加入），并兼容PKCS #1 v1.5。

每个原语的主要数学操作是指数运算。

5.1.1 RSAEP（RSA加密原语）

RSAEP ((n, e), m)

输入：
(n, e)   RSA公钥
m        消息代表，整数范围在0到n-1之间

输出：
c        密文代表，整数范围在0到n-1之间

错误： "消息代表超出范围"

假设：RSA公钥(n, e)有效

步骤：

1. 如果m不在0到n-1之间，输出“消息代表超出范围”并停止。

2. 计算c = m^e mod n。

3. 输出c。

5.1.2 RSADP（RSA解密原语）

RSADP (K, c)

输入：
K        RSA私钥，K可以是以下形式之一：
         - 一对(n, d)
         - 一五元组(p, q, dP, dQ, qInv)及可能为空的三元组序列(r_i, d_i, t_i)，i=3,...,u
c        密文代表，整数范围在0到n-1之间

输出：
m        消息代表，整数范围在0到n-1之间

错误： "密文代表超出范围"

假设：RSA私钥K有效

步骤：

1. 如果c不在0到n-1之间，输出“密文代表超出范围”并停止。

2. 计算消息代表m，方法如下：

   a. 若使用第一种形式(n, d)，则m = c^d mod n。

   b. 若使用第二种形式(p, q, dP, dQ, qInv)和(r_i, d_i, t_i)，则：

      i. 计算m_1 = c^dP mod p，m_2 = c^dQ mod q。

      ii. 若u > 2，计算m_i = c^(d_i) mod r_i，i=3,...,u。

      iii. 计算h = (m_1 - m_2) * qInv mod p。

      iv. 计算m = m_2 + q * h。

      v. 若u > 2，定义R = r_1，且对于i=3,...,u，执行：

         1. R = R * r_(i-1)。

         2. h = (m_i - m) * t_i mod r_i。

         3. m = m + R * h。

3. 输出m。

注意：步骤2.b可以改写为单个循环，只需将p和q的顺序反转。然而，为了与PKCS #1 v2.0保持一致，前两个素数p和q会单独处理，不与其他素数混合。

5.2 签名与验证原语

签名原语在私钥控制下，从消息代表生成签名代表；验证原语在公钥控制下，从签名代表恢复消息代表。本文定义的一对签名与验证原语为RSASP1/RSAVP1。

这些原语与IEEE 1363-2000 [26]中的IFSP-RSA1/IFVP-RSA1相同（支持多素数RSA已加入），并兼容PKCS #1 v1.5。

每个原语的主要数学操作是指数运算，类似于第5.1节中的加密和解密原语。RSASP1和RSAVP1与RSADP和RSAEP相同，只是输入输出参数的命名不同，旨在不同用途。

5.2.1 RSASP1（RSA签名原语）

RSASP1 (K, m)

输入：
K        RSA私钥，K可以是以下形式之一：
         - 一对(n, d)
         - 一五元组(p, q, dP, dQ, qInv)及可能为空的三元组序列(r_i, d_i, t_i)，i=3,...,u
m        消息代表，整数范围在0到n-1之间

输出：
s        签名代表，整数范围在0到n-1之间

错误： "消息代表超出范围"

假设：RSA私钥K有效

步骤：

1. 如果m不在0到n-1之间，输出“消息代表超出范围”并停止。

2. 计算签名代表s，方法如下：

   a. 若使用第一种形式(n, d)，则s = m^d mod n。

   b. 若使用第二种形式(p, q, dP, dQ, qInv)和(r_i, d_i, t_i)，则：

      i. 计算s_1 = m^dP mod p，s_2 = m^dQ mod q。

      ii. 若u > 2，计算s_i = m^(d_i) mod r_i，i=3,...,u。

      iii. 计算h = (s_1 - s_2) * qInv mod p。

      iv. 计算s = s_2 + q * h。

      v. 若u > 2，定义R = r_1，且对于i=3,...,u，执行：

         1. R = R * r_(i-1)。

         2. h = (s_i - s) * t_i mod r_i。

         3. s = s + R * h。

3. 输出s。

注意：步骤2.b可以改写为单个循环，只需将p和q的顺序反转。然而，为了与PKCS #1 v2.0保持一致，前两个素数p和q会单独处理，不与其他素数混合。

5.2.2 RSAVP1（RSA验证原语）

RSAVP1 ((n, e), s)

输入：
(n, e)   RSA公钥
s        签名代表，整数范围在0到n-1之间

输出：
m        消息代表，整数范围在0到n-1之间

错误： "签名代表超出范围"

假设：RSA公钥(n, e)有效

步骤：

1. 如果s不在0到n-1之间，输出“签名代表超出范围”并停止。

2. 计算m = s^e mod n。

3. 输出m。

6. 方案概述

方案结合密码学原语和其他技术，以实现特定的安全目标。本文定义了两类方案：加密方案和带附录的签名方案。

这些方案的范围有限，因为它们的操作仅包括使用RSA公钥或私钥处理数据的步骤，不包括获取或验证密钥的步骤。因此，除了方案操作外，应用程序通常还会包括密钥管理操作，由此用户可以选择RSA公私钥用于方案操作。具体的附加操作和细节超出本文范围。

与第5节中的密码学原语类似，方案操作的规范假设输入满足某些条件，特别是RSA公钥和私钥是有效的。当密钥无效时，实施的行为未加定义。这类未定义行为的影响取决于具体应用。解决密钥验证的可能方法包括：应用程序显式验证密钥；公钥基础设施中的密钥验证；以及将使用无效密钥进行操作的责任归于生成密钥的方。

良好的密码学实践建议每个RSA密钥对仅用于一种方案，以避免一种方案的漏洞影响另一方案的安全性，且可能是保持可证明安全性的必要条件。虽然RSAES-PKCS1-v1_5（第7.2节）和RSASSA-PKCS1-v1_5（第8.2节）传统上可以一起使用且无已知不良交互（实际上PKCS #1 v1.5引入的模型），但不建议在新应用中将同一RSA密钥对用于多种方案。

为了说明在多方案中使用同一RSA密钥对的风险，假设一个RSA密钥对同时用于RSAES-OAEP（第7.1节）和RSAES-PKCS1-v1_5。虽然RSAES-OAEP本身能抵抗攻击，但攻击者可能利用RSAES-PKCS1-v1_5实现中的弱点，恢复用任一方案加密的消息。另一个例子是，假设RSA密钥对同时用于RSASSA-PSS（第8.1节）和RSASSA-PKCS1-v1_5，则RSASSA-PSS的安全证明可能不再充分，因为该证明未考虑用第二方案生成签名的可能性。如果在本方案之一和其他定义的变体中使用同一RSA密钥对，也可能存在类似风险。

7. 加密方案

在本文中，加密方案由加密操作和解密操作组成：加密操作用接收者的RSA公钥将消息转换为密文，解密操作用对应的RSA私钥从密文中恢复消息。

一种加密方案可以应用于多种场景。典型的应用之一是密钥建立协议，其中消息包含要从一方安全传递给另一方的密钥材料。例如，PKCS #7 [45] 就采用了此类协议，将内容加密密钥从发送方传递给接收方；此处定义的加密方案适合作为该场景中的密钥加密算法。

本文中规定了两种加密方案：RSAES-OAEP 和 RSAES-PKCS1-v1_5。建议在新应用中采用 RSAES-OAEP；而 RSAES-PKCS1-v1_5 仅为兼容现有应用而提供，不建议在新项目中使用。

这里介绍的加密方案遵循一种类似于 IEEE Std 1363-2000 [26] 中采用的通用模型，将加密和解密原语与编码方法结合，用于加密操作。加密过程包括对消息进行编码，生成编码消息，然后将其转换为整数消息代表。接着，对该消息代表应用加密原语，得到密文。解密过程则反向操作：对密文应用解密原语，恢复出消息代表，再将其转换为编码消息的字节串。最后，应用消息解码操作，恢复原始消息并验证解密的正确性。

为了避免因解码操作中错误处理方式带来的安全漏洞（参见 [6] 和 [36]），RSAES-OAEP 和 RSAES-PKCS1-v1_5 的编码与解码操作嵌入在各自方案的规范中，而非单独定义。两者均与 PKCS #1 v2.0 中的相应方案兼容。

7.1 RSAES-OAEP

RSAES-OAEP 结合了 RSAEP 和 RSADP 原语（第 5.1.1 和第 5.1.2 节）以及 EME-OAEP 编码方法（第 7.1.1 节第 1.b 步和第 7.1.2 节第 3 步）。EME-OAEP 基于 Bellare 和 Rogaway 提出的最优非对称加密方案 [3]（OAEP 代表“最优非对称填充”）。它与 IEEE Std 1363-2000 [26] 中定义的 IFES 方案兼容，其中加密和解密原语为 IFEP-RSA 和 IFDP-RSA，消息编码方法为 EME-OAEP。RSAES-OAEP 可处理长度最多为 k - 2hLen - 2 字节的消息（hLen 为底层哈希函数输出长度，k 为接收方 RSA 模数的字节长度）。

假设计算模 n 的 e 次根是不可行的，并且 RSAES-OAEP 中的掩码生成函数具有适当的性质，则 RSAES-OAEP 在语义上对抗自适应选择密文攻击是安全的。这一安全性可以证明，其依据是破解 RSAES-OAEP 的难度与逆转 RSA 函数的难度直接相关，前提是掩码生成函数被视为黑盒或随机预言机；详见 [21] 及下文说明。

RSAES-OAEP 的加密和解密操作都接受标签 L 作为输入。在本版本的 PKCS #1 中，L 默认为空字符串；其他标签的使用超出本文范围。相关 ASN.1 语法详见附录 A.2.1。

RSAES-OAEP 的参数包括哈希函数和掩码生成函数的选择。应为每个 RSA 密钥固定这些参数。建议的哈希和掩码生成函数列于附录 B。

注意事项：近期研究明确了 OAEP 编码方法 [3]（大致对应第 7.1.1 节第 1.b 步描述的过程）的安全属性。背景如下：1994 年，Bellare 和 Rogaway [3] 引入了“明文意识” (plaintext awareness, PA94) 的安全概念，并证明如果确定性公钥加密原语（如 RSAEP）在没有私钥的情况下难以逆转，则基于 OAEP 的加密方案在随机预言机模型中具有明文意识，即攻击者不能在不知道明文的情况下生成有效密文。明文意识与抗选择密文攻击的能力密切相关。在此类攻击中，攻击者可以向模拟解密原语的预言机发出查询，并利用查询结果尝试解密挑战密文。

然而，存在两种不同的选择密文攻击（CCA）模型，PA94 只保证对其中一种的安全性。区别在于攻击者在获得挑战密文后能做什么：在 CCA1（非自适应）场景中，攻击者不能再向解密预言机发出任何查询；而在 CCA2（自适应）场景中，攻击者可以继续查询，除了不能解密挑战密文（即解密预言机拒绝解密挑战密文）。1998 年，Bellare 和 Rogaway 以及 Desai 和 Pointcheval [2] 提出了更强的“明文意识”概念（PA98），并证明其在 CCA2 场景下的安全性。

总结：曾有人误以为 PA94 和 PA98 是等价的，或 CCA1 和 CCA2 是等价的。这些误解导致错误地认为 Bellare 和 Rogaway 的论文证明了 OAEP 在 CCA2 下的安全性，但实际上并非如此。

（脚注：PKCS #1 v2.0 引用 [3]，并声称“对 RSAES-OAEP 这类明文意识加密方案，选择密文攻击无效”，但未说明所考虑的明文意识或选择密文攻击的具体类型。）

OAEP 从未被证明在 CCA2 下绝对安全。事实上，Victor Shoup [48] 证明了在一般情况下不存在此类证明。简而言之，Shoup 展示了在 CCA2 场景中，攻击者如果知道如何部分逆转加密原语（但不完全逆转）可能仍能破解方案。例如，假设攻击者能破解 RSAES-OAEP，只要她能恢复用 RSAEP 加密的随机整数的前 20 字节（未必需要完全逆转 RSAEP）。这种攻击者无需完全逆转 RSAEP，因为她不使用前 20 字节。

尽管如此，RSAES-OAEP 在 CCA2 下仍然是安全的，这由 Fujisaki、Okamoto、Pointcheval 和 Stern [21] 证明。通过巧妙的格基还原技术，他们展示了如何在已知足够多的预像部分的情况下完全逆转 RSAEP。这一发现结合了 OAEP 在基础加密原语难以部分逆转时的安全性证明，弥补了 Bellare 和 Rogaway 关于 RSAES-OAEP 安全性证明的不足。令人意外的是，RSAEP 的潜在弱点（即可以从部分信息推导出全部逆）反而成为 RSAES-OAEP 安全性的保障。

然而，具体参数下的安全还原并不高效。虽然该证明将 CCA2 攻击者 Adv 转化为逆转 RSA 的算法 Inv，成功建立了关系，但 Inv 成功的概率约为 \(\epsilon^2 / 2^{18}\)，其中 \(\epsilon\) 为 Adv 成功的概率。

（脚注：在 [21] 中，逆转器 Inv 的成功概率为 \(\epsilon^2 / 4\)，额外的 \(1/2^{16}\) 因素源于编码消息 EM 开头的八个零比特（在 [21] 中未出现），每次逆转 RSA 需调用 Inv 两次，每次对应一个 \(1/2^8\) 因素。）

此外，Inv 的运行时间大约为 \(t^2\)，其中 t 为攻击者的运行时间。这意味着，针对具体参数，攻击 RSAES-OAEP 可能比逆转 RSA 更容易。尽管如此，安全证明的存在仍为 RSAES-OAEP 提供了一定的保障，表明其比随意构造的 RSAES-PKCS1-v1_5 更加安全。

基于 RSA-KEM 密钥封装范式的混合加密方案提供了紧密的安全性证明，适用于具体参数（详见 [30]）。未来的 PKCS #1 版本可能会引入基于此范式的方案。

7.1.1 加密操作

RSAES-OAEP-ENCRYPT ((n, e), M, L)

选项：
- Hash：哈希函数（hLen 表示哈希输出的字节长度）
- MGF：掩码生成函数

输入：
- (n, e)：接收方的 RSA 公钥（k 表示模数 n 的字节长度）
- M：待加密的消息，为长度为 mLen 的字节串，满足 mLen ≤ k - 2hLen - 2
- L：可选的标签，与消息关联；若未提供，默认为空字符串

输出：
- C：密文，为长度为 k 的字节串

错误：
- “消息过长”
- “标签过长”

假设：
- RSA 公钥 (n, e) 有效

步骤：
1. 长度检查：
   a. 若 L 的长度超过哈希函数的输入限制（SHA-1 为 2^61 - 1 字节），输出“标签过长”并停止。
   b. 若 mLen > k - 2hLen - 2，输出“消息过长”并停止。

2. EME-OAEP 编码（见图 1）：
   a. 若未提供 L，则 L 为空字符串。计算 lHash = Hash(L)，长度为 hLen。
   b. 生成长度为 k - mLen - 2hLen - 2 的全零字节串 PS。
   c. 构造数据块 DB = lHash || PS || 0x01 || M。
   d. 生成随机种子 seed，长度为 hLen。
   e. 计算 dbMask = MGF(seed, k - hLen - 1)。
   f. 计算 maskedDB = DB \xor dbMask。
   g. 计算 seedMask = MGF(maskedDB, hLen)。
   h. 计算 maskedSeed = seed \xor seedMask。
   i. 构造编码消息 EM = 0x00 || maskedSeed || maskedDB。

3. RSA 加密：
   a. 将 EM 转换为整数消息 m（参见第 4.2 节）：
      \( m = OS2IP(EM) \)
   b. 使用 RSAEP 原语（第 5.1.1 节）对 (n, e) 和 m 进行加密，得到整数密文代表 c：
      \( c = RSAEP((n, e), m) \)
   c. 将 c 转换为长度为 k 的字节串 C（参见第 4.1 节）：
      \( C = I2OSP(c, k) \)

4. 输出密文 C。

注意：如果 L 为空字符串，则对应的 lHash 具有以下十六进制表示（不同哈希函数的示例）：
- SHA-1: (0x)da39a3ee 5e6b4b0d 3255bfef 95601890 afd80709
- SHA-256: (0x)e3b0c442 98fc1c14 9afbf4c8 996fb924 27ae41e4 649b934c  a495991b 7852b855
- SHA-384: (0x)38b060a7 51ac9638 4cd9327e b1b1e36a 21fdb711 14be0743  4c0cc7bf 63f6e1da 274edebf e76f65fb d51ad2f1 4898b95b
- SHA-512: (0x)cf83e135 7eefb8bd f1542850 d66d8007 d620e405 0b5715dc  83f4a921 d36ce9ce 47d0d13c 5d85f2b0 ff8318d2 877eec2f  63b931bd 47417a81 a538327a f927da3e

图 1：EME-OAEP 编码操作示意图。lHash 为标签 L 的哈希值。解码操作则逆向步骤，恢复消息 M 并验证 lHash 和 PS。

7.1.2 解密操作

RSAES-OAEP-DECRYPT (K, C, L)

选项：
- Hash：哈希函数（hLen 表示哈希输出的字节长度）
- MGF：掩码生成函数

RFC 3447  PKCS #1：RSA密码学规范  2003年2月

输入：
K        收件人的RSA私钥（k表示RSA模数n的长度（以字节为单位））
C        待解密的密文，是一个长度为k的字节串，其中k = 2hLen + 2
L        可选的标签，用于与消息的关联性验证；如果未提供L，则默认为空字符串

输出：
M        消息，是一个长度为mLen的字节串，其中mLen <= k - 2hLen - 2

错误信息：
“解密错误”

步骤：

1. 长度检查：
   a. 如果标签L的长度大于哈希函数的输入限制（SHA-1为2^61 - 1字节），则输出“解密错误”并停止。
   b. 如果密文C的长度不等于k字节，则输出“解密错误”并停止。
   c. 如果k < 2hLen + 2，则输出“解密错误”并停止。

2. RSA解密：
   a. 将密文C转换为整数密文代表c（参见第4.2节）：
      c = OS2IP(C)。
   b. 使用RSA私钥K和密文代表c执行RSA解密原语（第5.1.2节），得到消息代表m：
      m = RSADP(K, c)。
      如果RSADP输出“密文代表超出范围”（即c >= n），则输出“解密错误”并停止。
   c. 将消息代表m转换为长度为k的编码消息EM（参见第4.1节）：
      EM = I2OSP(m, k)。

3. EME-OAEP解码：
   a. 如果未提供标签L，则令L为空字符串。令lHash = Hash(L)，为长度为hLen的字节串（参见第7.1.1节中的注释）。
   b. 将编码消息EM拆分为单字节Y、长度为hLen的掩码种子maskedSeed，以及长度为k - hLen - 1的掩码数据库maskedDB：
      EM = Y || maskedSeed || maskedDB。
   c. 计算seedMask = MGF(maskedDB, hLen)。
   d. 计算seed = maskedSeed ⊕ seedMask。
   e. 计算dbMask = MGF(seed, k - hLen - 1)。
   f. 计算DB = maskedDB ⊕ dbMask。
   g. 将DB拆分为长度为hLen的lHash'、可能为空的由0x00组成的填充字符串PS，以及消息M：
      DB = lHash' || PS || 0x01 || M。
      如果没有用0x01的字节将PS与M分隔，或lHash不等于lHash'，或Y非零，则输出“解密错误”并停止。（见下面的注释）

4. 输出消息M。

注意：必须确保对手无法通过错误信息或时间差异区分步骤3.g中的不同错误条件，避免泄露部分编码消息EM的信息。否则，攻击者可能利用这些信息进行选择密文攻击，如Manger [36]所描述。

7.2 RSAES-PKCS1-v1_5

RSAES-PKCS1-v1_5结合了RSAEP和RSADP原语（第5.1.1和第5.1.2节）以及EME-PKCS1-v1_5编码方法（第7.2.1节第1步和第7.2.2节第3步）。它在数学上等同于PKCS #1 v1.5中的加密方案。RSAES-PKCS1-v1_5可以对长度最多为k - 11字节的消息进行操作（k为RSA模数的字节长度），但应注意避免因低指数RSA在加密长消息时受到Coppersmith、Franklin、Patarin和Reiter提出的某些攻击（参见下文的第三点和[10]，[14]中有改进的攻击）。一般而言，不建议用此方案对任意消息（而非随机生成的密钥）进行加密。

可以在不知道对应明文的情况下，以合理概率生成有效的RSAES-PKCS1-v1_5密文。这一能力可被用在选择密文攻击中，如[6]所示。因此，若使用RSAES-PKCS1-v1_5，应采取某些易于实现的反制措施，以防止[6]中的攻击。常见措施包括：在待编码数据中加入结构信息、严格检查解密消息的PKCS #1 v1.5符合性（及其他冗余信息）、以及在基于PKCS #1 v1.5的客户端-服务器协议中统一错误信息。这些措施都能有效防范攻击，且无需修改基于PKCS #1 v1.5的协议。关于其他反制措施的详细讨论，请参见[7]。近期研究表明，使用RSAES-PKCS1-v1_5及某些反制措施的SSL/TLS握手协议的安全性，可能与RSA问题的某一变体相关；详见[32]。

注意：以下内容涉及关于RSAES-PKCS1-v1_5安全性的一些建议。既有版本1.5中的建议，也包括近年来密码分析进展带来的新建议。

* 建议每次加密操作中，独立生成第7.2.1节第2步中的伪随机字节串，尤其是在多次加密相同数据时。Haastad的研究结果[24]是此建议的一个依据。
* 第7.2.1节第2步中的填充字符串PS长度至少为8字节，这是公钥操作的安全条件，能防止攻击者通过尝试所有可能的加密块来恢复数据。
* 伪随机字节串还能帮助防止Coppersmith等人[10]（[14]中有改进）提出的攻击，特别是在待加密消息较小时。该攻击针对低指数RSA（如e=3）中，使用相同RSA公钥加密类似消息的情况。具体而言，当两个输入到RSAEP的值在大量比特（8/9）上相同时，攻击者可能恢复出两个输入；或者在已知RSAEP输入的2/3部分的情况下，攻击也能成功。对于短消息（如128位对称密钥）而言，攻击难度较大，但若消息较长或部分已知，则攻击可能得手。RSAES-OAEP方案能有效防止此类攻击。

7.2.1 加密操作

RSAES-PKCS1-V1_5-ENCRYPT ((n, e), M)

输入：
(n, e)  收件人的RSA公钥（k为模数n的字节长度）
M       待加密的消息，是长度为mLen的字节串，满足mLen <= k - 11

输出：
C       密文，是长度为k的字节串

错误：
“消息过长”

步骤：
1. 长度检查：若mLen > k - 11，则输出“消息过长”并停止。
2. EME-PKCS1-v1_5编码：
   a. 生成长度为k - mLen - 3的伪随机非零字节串PS，长度至少为8字节。
   b. 将PS、消息M及其他填充连接，形成长度为k的编码消息EM：
      EM = 0x00 || 0x02 || PS || 0x00 || M。
3. RSA加密：
   a. 将编码消息EM转换为整数消息代表m（参见第4.2节）：
      m = OS2IP(EM)。
   b. 使用RSA公钥(n, e)对m执行RSAEP，得到密文代表c：
      c = RSAEP((n, e), m)。
   c. 将密文代表c转换为长度为k的密文C（参见第4.1节）：
      C = I2OSP(c, k)。
4. 输出密文C。

7.2.2 解密操作

RSAES-PKCS1-V1_5-DECRYPT (K, C)

输入：
K        收件人的RSA私钥
C        密文，是长度为k的字节串（k为模数n的字节长度）

输出：
M        明文，是长度最多为k - 11的字节串

错误：
“解密错误”

步骤：
1. 长度检查：若密文C的长度不等于k（或k<11），则输出“解密错误”并停止。
2. RSA解密：
   a. 将密文C转换为整数密文代表c（参见第4.2节）：
      c = OS2IP(C)。
   b. 使用RSA私钥(n, d)对c执行RSADP，得到消息代表m：
      m = RSADP((n, d), c)。
      若RSADP输出“密文代表超出范围”（即c >= n），则输出“解密错误”并停止。
   c. 将消息代表m转换为长度为k的编码消息EM（参见第4.1节）：
      EM = I2OSP(m, k)。
3. EME-PKCS1-v1_5解码：将编码消息EM拆分为非零字节串PS和消息M：
   EM = 0x00 || 0x02 || PS || 0x00 || M。
   若EM的第一个字节不是0x00，或第二个字节不是0x02，或没有0x00字节将PS与M分隔，或PS长度少于8字节，则输出“解密错误”并停止（见下方注释）。
4. 输出消息M。

注意：应确保对手无法通过错误信息或时间差异区分步骤3中的不同错误条件，以防泄露关于密文C解密的有用信息，从而避免类似Bleichenbacher攻击[6]的增强版。

8. 附录签名方案

对于本文档，带附录的签名方案由签名生成操作和签名验证操作组成。签名生成操作使用签名者的RSA私钥对消息生成签名，签名验证操作用签名者的RSA公钥验证签名。验证签名时必须提供原始消息本身。由此，带附录的签名方案区别于消息恢复签名方案（后者在本文件中未支持）。

带附录的签名方案可应用于多种场景。例如，本文定义的签名方案适合作为X.509证书[28]的签名算法。相关的签名方案也可用于PKCS #7[45]，但出于技术原因，当前版本的PKCS #7将哈希函数与签名方案分离（与此不同；详见附录A.2.3中的说明）。

本文还定义了两种带附录的签名方案：RSASSA-PSS和RSASSA-PKCS1-v1_5。虽然目前尚未发现针对RSASSA-PKCS1-v1_5的攻击，为增强安全性，建议未来在新应用中采用RSASSA-PSS。为了兼容现有应用，仍保留RSASSA-PKCS1-v1_5，但鼓励逐步过渡到RSASSA-PSS。

以下是英文内容的中文流畅翻译：

---

这里给出的带附录的签名方案遵循一种通用模型，类似于IEEE Std 1363-2000 [26]中采用的模型，将签名和验证原语与签名编码方法相结合。签名生成操作包括对消息进行编码，得到编码消息，然后将其转换为一个整数消息代表。接着，将签名原语应用于该消息代表以生成签名。反之，验证操作则对签名应用验证原语以恢复消息代表，然后将其转换为一个八位字节串编码的消息。验证操作会对消息和编码消息进行比对，以判断它们是否一致。

如果编码方法是确定性的（例如，EMSA-PKCS1-v1_5），验证操作可以对消息再次应用编码操作，并将结果与之前得到的编码消息进行比较。如果两者匹配，则签名被视为有效。如果编码方法是随机化的（例如，EMSA-PSS），验证操作通常会更复杂。例如，EMSA-PSS的验证操作会从编码消息中提取随机盐和哈希输出，并检查哈希输出、盐值与消息是否一致；其中，哈希输出是关于消息和盐的确定性函数。

对于本文定义的两种带附录的签名方案，若签名放在消息之后，签名生成和验证操作可以方便地实现为“单次扫描”操作。以RSASSA-PKCS1-v1_5为例，可以参考PKCS #7 [45]中的示例格式。

---

**8.1 RSASSA-PSS**

RSASSA-PSS结合了RSASP1和RSAVP1原语与EMSA-PSS编码方法。它与IEEE P1363a草案 [27]中修订的IFSSA方案兼容，其中签名和验证原语为IFSP-RSA1和IFVP-RSA1，消息编码方法为EMSA4。EMSA4比EMSA-PSS更为通用，因为它作用于比特串而非八位字节串。EMSA-PSS实际上是EMSA4的限制版本，操作对象和哈希值、盐值均为八位字节串。

RSASSA-PSS可以操作的消息长度要么无限制，要么受到底层哈希函数的限制，具体取决于所用的哈希函数。

假设计算模n的e次方根不可行，且EMSA-PSS中的哈希和掩码生成函数具有适当的性质，RSASSA-PSS能提供安全的签名。这一安全性可以被证明——即伪造签名的难度与RSA函数的逆运算难度直接相关，前提是哈希和掩码生成函数被视为黑盒或随机预言机。安全证明中的界限基本是“紧”的，也就是说，最强攻击者成功的概率和所需时间与最优RSA逆算法的参数非常接近；详见[4][13][31]。

不同于PKCS#1 v1.5签名方案，EMSA-PSS编码中没有嵌入哈希函数标识符，因此理论上攻击者可以用不同（可能更弱的）哈希函数替代签名者选择的哈希函数。因此，建议将EMSA-PSS的掩码生成函数基于相同的哈希函数。这样，整个编码消息都依赖于该哈希函数，攻击者就难以用不同的哈希函数替代。此处的哈希函数匹配仅为防止哈希函数替换之用，如果通过其他手段（如验证者只接受特定哈希函数）已解决哈希替换问题，则无需此匹配。详见[34]。RSASSA-PSS的安全性证明不依赖于掩码生成中的哈希函数与消息哈希相同。

RSASSA-PSS不同于其他基于RSA的签名方案，它是概率性的，包含随机盐值。盐值增强了方案的安全性，提供比全域哈希（FDH）等确定性方案更“紧密”的安全证明（详见[4]）。不过，随机性本身对安全性不是关键。在无法随机生成的情况下，可以用固定值或序列号代替，安全性仍可类似于FDH。

**8.1.1 签名生成操作**

RSASSA-PSS-SIGN (K, M)

输入：
- K：签名者的RSA私钥
- M：待签名消息（八位字节串）

输出：
- S：签名（长度为k的八位字节串，其中k为RSA模数n的字节长度）

错误：
- “消息过长”
- “编码错误”

步骤：
1. EMSA-PSS编码：对消息M应用EMSA-PSS编码（第9.1.1节），得到长度为\ceil((modBits - 1)/8)字节的编码消息EM，确保整数OS2IP(EM)的比特长度不超过modBits - 1（其中，modBits为模数n的比特长度）：
   
   EM = EMSA-PSS-ENCODE(M, modBits - 1)

   注意：如果modBits - 1能被8整除，则EM的字节长度为k-1，否则为k。若编码操作输出“消息过长”或“编码错误”，则停止。

2. RSA签名：
   a. 将编码消息EM转换为整数消息代表m（第4.2节）：
   
      m = OS2IP(EM)
   
   b. 使用RSASP1签名原语（第5.2.1节）对私钥K和消息代表m进行签名，得到签名代表s：
   
      s = RSASP1(K, m)
   
   c. 将签名代表s转换为长度为k的签名S（第4.1节）：
   
      S = I2OSP(s, k)

3. 输出签名S。

**8.1.2 签名验证操作**

RSASSA-PSS-VERIFY ((n, e), M, S)

输入：
- (n, e)：签名者的RSA公钥
- M：待验证签名的消息
- S：待验证的签名（长度为k的八位字节串，k为模数n的字节长度）

输出：
- “有效签名”或“无效签名”

步骤：
1. 长度检查：若S的长度不为k字节，则输出“无效签名”并停止。

2. RSA验证：
   a. 将签名S转换为整数签名代表s（第4.2节）：
   
      s = OS2IP(S)
   
   b. 使用RSAVP1验证原语（第5.2.2节）对公钥(n, e)和s进行验证，得到消息代表m：
   
      m = RSAVP1((n, e), s)
   
   若RSAVP1输出“签名代表超出范围”，则输出“无效签名”并停止。

   c. 将消息代表m转换为长度为emLen = \ceil((modBits - 1)/8)字节的编码消息EM（第4.1节）：
   
      EM = I2OSP(m, emLen)
   
   若emLen为k-1且modBits - 1能被8整除，否则为k。若I2OSP输出“整数过大”，则输出“无效签名”并停止。

3. EMSA-PSS验证：对消息M和编码消息EM应用EMSA-PSS验证（第9.1.2节），判断两者是否一致：
   
   Result = EMSA-PSS-VERIFY(M, EM, modBits - 1)

4. 若Result为“匹配”，输出“有效签名”；否则，输出“无效签名”。

---

**8.2 RSASSA-PKCS1-v1_5**

RSASSA-PKCS1-v1_5结合了RSASP1和RSAVP1原语与EMSA-PKCS1-v1_5编码方法。它与IEEE Std 1363-2000 [26]中定义的IFSSA方案兼容，其中签名和验证原语为IFSP-RSA1和IFVP-RSA1，消息编码方法为EMSA-PKCS1-v1_5（该方法在IEEE P1363a草案 [27]中定义，但未在IEEE Std 1363-2000中出现）。

RSASSA-PKCS1-v1_5能操作的消息长度要么无限制，要么受到底层哈希函数的限制，具体取决于所用的哈希函数。

假设计算模n的e次方根不可行，且EMSA-PKCS1-v1_5中的哈希函数具有适当性质，RSASSA-PKCS1-v1_5被推测能提供安全的签名。更确切地说，未经私钥授权伪造签名在计算上被认为是不可行的。在编码中，EMSA-PKCS1-v1_5会嵌入哈希函数标识符。由于此特性，攻击者若试图找到具有相同签名的不同消息，必须找到该哈希函数的碰撞；攻击不同的哈希函数则无用。详见[34]。

注意：正如PKCS#1 v1.5中所述，EMSA-PKCS1-v1_5编码方法保证编码消息（转换为整数代表后）具有较大且“较随机”的值。这防止了Desmedt和Odlyzko [16]提出的攻击——通过将消息代表分解为一组小值（如小素数）来构造消息间的乘法关系。Coron、Naccache和Stern [15]显示，这类攻击在某些ISO/IEC 9796-2签名方案中效果较强。他们还分析了此类攻击对EMSA-PKCS1-v1_5的复杂度，得出攻击在实际中不切实际——所需操作次数超过对底层哈希的碰撞搜索（即超过2^80次操作）。随后，Coppersmith、Halevi和Jutla [11]将此攻击扩展到破解带消息恢复的ISO/IEC 9796-1签名方案。这些攻击强调了在签名方案中精心设计RSA签名原语输入的重要性，尤其是在带消息恢复的方案中。因此，EMSA-PKCS1-v1_5明确包含哈希操作，不适用于带消息恢复的签名方案。虽然目前未发现针对EMSA-PKCS1-v1_5的攻击，但建议逐步过渡到EMSA-PSS以防未来出现新威胁。

---

**8.2.1 签名生成操作**

RSASSA-PKCS1-V1_5-SIGN (K, M)

输入：
- K：签名者的RSA私钥
- M：待签名消息（八位字节串）

输出：
- S：签名（长度为k的八位字节串，k为模数n的字节长度）

错误：
- “消息过长”
- “RSA模数过短”

步骤：
1. EMSA-PKCS1-v1_5编码：对消息M应用EMSA-PKCS1-v1_5编码（第9.2节），得到长度为k的编码消息EM：
   
   EM = EMSA-PKCS1-V1_5-ENCODE(M, k)

   若编码输出“消息过长”或“编码的消息长度过短”，则停止。

2. RSA签名：
   a. 将编码消息EM转换为整数消息代表m（第4.2节）：
   
      m = OS2IP(EM)
   
   b. 使用RSASP1签名原语（第5.2.1节）对私钥K和m签名，得到签名代表s：
   
      s = RSASP1(K, m)
   
   c. 将签名代表s转换为长度为k的签名S（第4.1节）：
   
      S = I2OSP(s, k)

3. 输出签名S。

**8.2.2 签名验证操作**

RSASSA-PKCS1-V1_5-VERIFY ((n, e), M, S)

（内容未完，后续步骤类似，涉及将签名转换为整数，验证原语，解码，比较等，详见原文。）

---

以上为全文的中文翻译。

输入：
(n, e)   签名者的RSA公钥
M        需要验证签名的消息，是一个八位字节字符串
S        待验证的签名，是一个长度为k的八位字节字符串，其中
        k是RSA模数n的字节长度

输出：
"有效签名"或"无效签名"

错误：
"消息过长"；"RSA模数过短"

步骤：

1. 长度检查：如果签名S的长度不是k字节，
   则输出"无效签名"并停止。

2. RSA验证：

   a. 将签名S转换为一个整数签名代表值s（参见第4.2节）：
      
      s = OS2IP(S)。

   b. 对RSA公钥(n, e)和签名代表值s应用RSAVP1验证原语（第5.2.2节），
      生成一个整数消息代表值m：
      
      m = RSAVP1((n, e), s)。

      如果RSAVP1输出"签名代表值超出范围"，则输出"无效签名"并停止。

   c. 将消息代表值m转换为长度为k的编码消息EM（参见第4.1节）：
      
      EM' = I2OSP(m, k)。

      如果I2OSP输出"整数过大"，则输出"无效签名"并停止。

3. EMSA-PKCS1-v1_5编码：对消息M应用EMSA-PKCS1-v1_5编码操作（第9.2节），
   生成长度为k的第二个编码消息EM'：
   
   EM' = EMSA-PKCS1-V1_5-ENCODE(M, k)。

   如果编码操作输出"消息过长"，则输出"消息过长"并停止；
   如果输出"预期编码消息长度过短"，则输出"RSA模数过短"并停止。

4. 比较编码消息EM和第二个编码消息EM'：
   如果相同，则输出"有效签名"；
   否则，输出"无效签名"。

注意：实现签名验证的另一种方法是对编码消息应用（未在本文档中定义的）"解码"操作，以恢复底层的哈希值，然后将其与新计算的哈希值进行比较。这种方法的优点是所需的中间存储较少（两个哈希值而非两个编码消息），但缺点是需要额外的代码。

9. 带附录的签名的编码方法

编码方法包括在八位字节字符串消息和八位字节字符串编码消息之间映射的操作，这些操作在方案中转换为整数消息代表值。整数消息代表值通过原语处理。编码方法因此提供了处理消息的方案与处理原语之间的连接。

对于本文档目的，带附录的签名的编码方法由编码操作和可选的验证操作组成。编码操作将消息M映射为长度为指定值的编码消息EM。验证操作则判断消息M和编码消息EM是否一致，即编码消息EM是否是消息M的有效编码。

编码操作可能引入一些随机性，因此对同一消息多次应用编码操作会产生不同的编码消息，这对可证明的安全性有益。对于此类编码方法，除非验证者能重现随机性（例如通过从签名者获取盐值），否则需要同时实现编码和验证操作。对于确定性编码方法，只需编码操作。

签名方案中采用的两种带附录的编码方法是：EMSA-PSS和EMSA-PKCS1-v1_5。

9.1 EMSA-PSS

此编码方法由哈希函数、掩码生成函数和盐长度的选择参数化。这些参数应在给定RSA密钥的情况下固定，除非盐长度可变（详见[31]讨论）。建议的哈希和掩码生成函数在附录B中给出。该编码方法基于Bellare和Rogaway的概率签名方案（PSS）[4][5]，具有随机性，包含编码和验证操作。

图2展示了编码操作。

__________________________________________________________________

                                  +-----------+
                                  |     M     |
                                  +-----------+
                                        |
                                        V
                                      Hash
                                        |
                                        V
                          +--------+----------+----------+
                     M' = |Padding1|  mHash   |   salt   |
                          +--------+----------+----------+
                                         |
               +--------+----------+     V
         DB =  |Padding2|maskedseed|   Hash
               +--------+----------+     |
                         |               |
                         V               |    +--+
                        xor <--- MGF <---|    |bc|
                         |               |    +--+
                         |               |      |
                         V               V      V
               +-------------------+----------+--+
         EM =  |    maskedDB       |maskedseed|bc|
               +-------------------+----------+--+
__________________________________________________________________

图2：EMSA-PSS编码操作。验证操作按逆步骤恢复盐值，然后正向步骤重新计算并比较H。

注意事项：
1. 此处定义的编码方法与Bellare和Rogaway提交给IEEE P1363a的方案不同，主要有三点差异：
   
   * 它对消息直接应用哈希函数，而非掩码生成函数。虽然掩码生成函数也是基于哈希，但直接用哈希更自然。
   
   * 被哈希的内容是字符串（0x）00 00 00 00 00 00 00 00 || mHash，而非消息M本身。这里，mHash是消息M的哈希值。注意哈希函数在两个步骤中是相同的。详见下面第3点的讨论（"盐"用"种子"的说法更贴切，反映其作用）。
   
   * EMSA-PSS中的编码消息有九个固定比特；第一个比特为0，最后八个比特组成"尾部字段"，即字节0xbc。在原始方案中，只有第一个比特是固定的。尾部字段的设计是为了与IEEE Std 1363-2000 [26]中的Rabin-Williams IFSP-RW签名原语及ISO/IEC 9796-2草案中的对应原语兼容。

2. 假设掩码生成函数基于哈希函数，建议哈希函数与对消息应用的哈希函数相同；详见第8.1节。

3. 在不影响RSASSA-PSS安全证明的前提下，可以在执行EMSA-PSS-ENCODE和EMSA-PSS-VERIFY（对消息应用哈希）步骤之外进行，确保输入模块的仅是mHash而非完整消息M。这意味着即使对手控制了mHash的值，安全性证明仍成立。这对于输入带宽有限的设备（如智能卡）非常方便。注意，早期版本的PSS[4][5]没有此特性。当然，为了安全考虑，也可以让模块处理完整消息，例如模块需要“看到”签名内容以防不信任签名的哈希计算组件。

4. 常用的盐长度（以字节为单位）为hLen（哈希输出长度）或0。在这两种情况下，RSASSA-PSS的安全性都与RSAVP1的难解性密切相关。Bellare和Rogaway[4]给出了原始RSA-PSS方案的紧密下界，约对应前者；而Coron[12]给出了相关的全域哈希方案的下界，约对应后者。文献[13]中，Coron提供了从0到hLen多种盐长度的通用分析，详见[27]讨论。另请参见[31]，该文将[4][13]中的安全证明适配到RSA-PSS的不同版本（如上文第1点所列差异）。

5. 如IEEE P1363a[27]所述，签名方案中的随机化（如EMSA-PSS中的盐值）可能提供“隐蔽信道”以传输除签名消息之外的其他信息。关于隐蔽信道的更多内容，详见[50]。

9.1.1 编码操作

EMSA-PSS-ENCODE(M, emBits)

参数：
- Hash：哈希函数（hLen为哈希输出的字节长度）
- MGF：掩码生成函数
- sLen：盐的预期长度（字节数）

输入：
- M：待编码的消息，是一个八位字节字符串
- emBits：整数EM的最大比特长度（参见第4.2节），至少为8hLen + 8sLen + 9

输出：
- EM：编码消息，是长度为emLen = ⌈emBits/8⌉的八位字节字符串

错误：
- "编码错误"；"消息过长"

步骤：
1. 若M的长度超过哈希函数的输入限制（SHA-1为2^61 - 1字节），则输出"消息过长"并停止。
2. 计算mHash = Hash(M)，长度为hLen的八位字节字符串。
3. 若emLen < hLen + sLen + 2，则输出"编码错误"并停止。
4. 生成长度为sLen的随机八位字节字符串盐；若sLen=0，则盐为空字符串。
5. 计算：
   
      M' = 0x0000000000000000 || mHash || salt；
   
   这里，"||"表示连接，M'长度为8 + hLen + sLen，前8个字节为零。
6. 计算H = Hash(M')，长度为hLen的八位字节字符串。
7. 生成长度为emLen - sLen - hLen - 2的八位字节字符串PS，全为零，长度可为0。
8. 构造数据块：
   
      DB = PS || 0x01 || salt；
   
   长度为emLen - hLen - 1的八位字节字符串。
9. 计算：
   
      dbMask = MGF(H, emLen - hLen - 1)
   
10. 计算：
    
      maskedDB = DB ⊕ dbMask
    
11. 将maskedDB中最左边的8*emLen - emBits比特设为零。
12. 生成最终编码消息：
    
      EM = maskedDB || H || 0xbc
13. 输出EM。

9.1.2 验证操作

EMSA-PSS-VERIFY(M, EM, emBits)

参数：
- Hash：哈希函数（hLen为哈希输出的字节长度）
- MGF：掩码生成函数
- sLen：盐的预期长度（字节数）

输入：
- M：待验证的消息，是一个八位字节字符串
- EM：编码消息，是长度为emLen = ⌈emBits/8⌉的八位字节字符串
- emBits：整数EM的最大比特长度（参见第4.2节），至少为8hLen + 8sLen + 9

输出：
- "一致"或"不一致"

步骤：
1. 若M的长度超过哈希函数的输入限制（SHA-1为2^61 - 1字节），则输出"不一致"并停止。
2. 计算mHash = Hash(M)，长度为hLen的八位字节字符串。
3. 若emLen < hLen + sLen + 2，则输出"不一致"并停止。
4. 若EM的最右边一个字节的值不是0xbc，则输出"不一致"并停止。
5. 取EM的前emLen - hLen - 1个字节作为maskedDB，接下来的hLen个字节作为H。
6. 若maskedDB的最左边8*emLen - emBits比特不全为零，则输出"不一致"并停止。
7. 计算：
   
      dbMask = MGF(H, emLen - hLen - 1)
   
8. 计算：
   
      DB = maskedDB ⊕ dbMask
    
9. 将DB中最左边的8*emLen - emBits比特设为零。
10. 若DB的前emLen - hLen - sLen - 2个字节不全为零，或第emLen - hLen - sLen - 1个字节（第1个字节为"位置1"）的值不是0x01，则输出"不一致"并停止。
11. 取DB的最后sLen个字节作为盐值。
12. 计算：
    
      M' = 0x0000000000000000 || mHash || salt；
    
    长度为8 + hLen + sLen，前8个字节为零。
13. 计算H' = Hash(M')，长度为hLen的八位字节字符串。
14. 若H = H'，则输出"一致"；否则，输出"不一致"。

9.2 EMSA-PKCS1-v1_5

这种编码方法是确定性的，只有编码操作。

EMSA-PKCS1-v1_5-ENCODE (M, emLen)

可选参数：
哈希函数（hash），其中hLen表示哈希函数输出的字节长度

输入：
M        要编码的消息
emLen    编码后消息的预期长度（以字节为单位），至少为tLen + 11，其中tLen是编码过程中计算得到的某个值的DER编码T的字节长度

输出：
EM       编码后的消息，是长度为emLen的字节串

错误：
“消息过长”；“预期编码消息长度过短”

步骤：

1. 对消息M应用哈希函数，得到哈希值H：

   H = Hash(M)。

   如果哈希函数输出“消息过长”，则输出“消息过长”并停止。

2. 将哈希函数的算法标识符和哈希值编码成ASN.1类型DigestInfo的值（参见附录A.2.4），采用辨别编码规则（DER），其中DigestInfo的语法如下：

   DigestInfo ::= SEQUENCE {
       digestAlgorithm AlgorithmIdentifier,
       digest OCTET STRING
   }

   第一个字段标识哈希函数，第二个字段包含哈希值。令T为DigestInfo值的DER编码（见下文注释），tLen为T的字节长度。

3. 如果emLen < tLen + 11，则输出“预期编码消息长度过短”并停止。

4. 生成一个由emLen - tLen - 3个字节组成的全0xff的字节串PS。PS的长度至少为8个字节。

5. 将PS、DER编码的T和其他填充内容连接，形成编码消息EM：

   EM = 0x00 || 0x01 || PS || 0x00 || T。

6. 输出EM。

附注：

1. 对于附录B.1中提到的六种哈希函数，DigestInfo值的DER编码T如下：

   MD2:     30 20 30 0c 06 08 2a 86 48 86 f7 0d 02 02 05 00 04 10 || H
   MD5:     30 20 30 0c 06 08 2a 86 48 86 f7 0d 02 05 05 00 04 10 || H
   SHA-1:   30 21 30 09 06 05 2b 0e 03 02 1a 05 00 04 14 || H
   SHA-256: 30 31 30 0d 06 09 60 86 48 01 65 03 04 02 01 05 00 04 20 || H
   SHA-384: 30 41 30 0d 06 09 60 86 48 01 65 03 04 02 02 05 00 04 30 || H
   SHA-512: 30 51 30 0d 06 09 60 86 48 01 65 03 04 02 03 05 00 04 40 || H

2. 在本文件的1.5版本中，T曾被定义为DigestInfo值的BER编码，而非DER编码。特别是在理论上，验证操作（包括在版本2.0中）可能会拒绝符合PKCS#1 v1.5规范的有效签名，如果对DigestInfo采用了非DER的编码（例如，使用不定长编码的SEQUENCE类型）。虽然在实际中这种情况不太可能成为问题，但谨慎的实现者可以选择基于BER解码的验证操作，以确保与任何基于PKCS#1 v1.5的有效实现兼容。这种验证操作应指示底层BER编码是否为DER编码，从而判断签名是否符合本规范的要求。

PKCS1MGFAlgorithms（参见附录A.2.1）。默认的掩码生成函数是使用SHA-1的MGF1。对于MGF1（以及更一般地，基于哈希函数的其他掩码生成函数），建议底层的哈希函数与hashAlgorithm所指定的相同；详见第9.1节中的注释2。

* saltLength是盐值的八位字节长度。它应为一个整数。对于给定的hashAlgorithm，saltLength的默认值为哈希值的八位字节长度。与其他类型为RSASSA-PSS-params的字段不同，saltLength不需要为特定RSA密钥对固定。

* trailerField是用于兼容IEEE P1363a草案的尾部字段编号。本版本的文档中，trailerField应为1，表示尾部字段的十六进制值为0xbc。其他尾部字段（包括IEEE P1363a中的HashID || 0xcc尾部字段）在本文件中不支持。

         TrailerField ::= INTEGER { trailerFieldBC(1) }

如果使用RSASSA-PSS参数中的hashAlgorithm、maskGenAlgorithm和trailerField字段的默认值，则算法标识符的值如下：

```
rSASSA-PSS-Default-Identifier  RSASSA-AlgorithmIdentifier ::= {
    algorithm   id-RSASSA-PSS,
    parameters  RSASSA-PSS-params : {
        hashAlgorithm       sha1,
        maskGenAlgorithm    mgf1SHA1,
        saltLength          20,
        trailerField        trailerFieldBC
    }
}
```

RSASSA-AlgorithmIdentifier ::= 由AlgorithmIdentifier { {PKCS1Algorithms} }定义。

注意：在某些应用中，签名方案所用底层的哈希函数会与签名方案的其他操作分开标识。例如，在PKCS #7 [45]中，哈希函数标识符放在消息之前，"摘要加密"算法标识符（指示其余操作）随签名一起携带。为了让PKCS #7支持RSASSA-PSS签名方案，需要定义一个对象标识符，用于标识在哈希函数之后的RSASSA-PSS操作（类似于RSAEncryption OID用于RSASSA-PKCS1-v1_5方案）。S/MIME CMS [25]采用不同的方法，虽然哈希函数标识符放在消息之前，但完整签名方案的算法标识符可以随CMS签名一起携带（这在DSA签名中也有体现）。按照此惯例，id-RSASSA-PSS OID可以用来标识CMS中的RSASSA-PSS签名。由于CMS被视为PKCS #7的继任者，且未来会在CMS中发展支持RSASSA-PSS的功能（而非PKCS #7），因此在本版本的PKCS #1中未定义"其余"RSASSA-PSS的OID。

A.2.4 RSASSA-PKCS1-v1_5

RSASSA-PKCS1-v1_5的对象标识符应为以下之一。选择的OID取决于所用的哈希算法：MD2、MD5、SHA-1、SHA-256、SHA-384或SHA-512。注意，如果使用MD2或MD5，则OID与PKCS #1 v1.5中的相同。每个OID对应的参数字段在类型为AlgorithmIdentifier的值中应为NULL。应根据下表选择OID：

| 哈希算法 | OID |
| -------- | ---------------------------------------------- |
| MD2      | md2WithRSAEncryption ::= {pkcs-1 2}        |
| MD5      | md5WithRSAEncryption ::= {pkcs-1 4}        |
| SHA-1    | sha1WithRSAEncryption ::= {pkcs-1 5}       |
| SHA-256  | sha256WithRSAEncryption ::= {pkcs-1 11}   |
| SHA-384  | sha384WithRSAEncryption ::= {pkcs-1 12}   |
| SHA-512  | sha512WithRSAEncryption ::= {pkcs-1 13}   |

EMSA-PKCS1-v1_5编码方法包括一个类型为DigestInfo的ASN.1值，其结构如下：

```
DigestInfo ::= SEQUENCE {
    digestAlgorithm DigestAlgorithm,
    digest OCTET STRING
}
```

digestAlgorithm标识哈希函数，应为在PKCS1-v1-5DigestAlgorithms集合中的算法ID。关于支持的哈希函数，详见附录B.1。

DigestAlgorithm ::= AlgorithmIdentifier { {PKCS1-v1-5DigestAlgorithms} }

PKCS1-v1-5DigestAlgorithms定义如下：

```
ALGORITHM-IDENTIFIER ::= {
    { OID id-md2 PARAMETERS NULL }|
    { OID id-md5 PARAMETERS NULL }|
    { OID id-sha1 PARAMETERS NULL }|
    { OID id-sha256 PARAMETERS NULL }|
    { OID id-sha384 PARAMETERS NULL }|
    { OID id-sha512 PARAMETERS NULL }
}
```

附录B. 支持技术

本节提供多种支持第7节加密方案和第9节编码方法的底层技术示例。这里列出多种技术，以便兼容现有应用和支持迁移到新技术。虽然这些支持技术适合应用实现，但并非必须全部实现。预计将制定PKCS #1 v2.1的配置文件，明确具体的支持技术。

本节还提供支持技术的对象标识符。

B.1 哈希函数

哈希函数在第7和第9节的操作中使用。哈希函数是确定性的，即输出完全由输入决定。它们接受可变长度的八位字节串，生成固定长度的八位字节串。

在第7和第9节的操作中，建议使用抗碰撞的哈希函数。这意味着找到两个不同输入产生相同输出应是不可行的。抗碰撞哈希函数还应具有单向性：给定输出，几乎不可能找到对应的输入。除了这些要求外，哈希函数还应能生成伪随机的掩码（详见附录B.2）。

本文列出六个示例哈希函数：MD2 [33]、MD5 [41]、SHA-1 [38]，以及提议的SHA-256、SHA-384和SHA-512 [39]。对于RSAES-OAEP加密方案和EMSA-PSS编码方法，建议仅使用SHA-1和SHA-256/384/512。对于EMSA-PKCS1-v1_5编码方法，建议新应用使用SHA-1或SHA-256/384/512。MD2和MD5仅建议用于与现有PKCS #1 v1.5应用的兼容。

以下对象标识符对应各哈希函数：

```
id-md2      OBJECT IDENTIFIER ::= { iso(1) member-body(2) us(840) rsadsi(113549) digestAlgorithm(2) 2 }
id-md5      OBJECT IDENTIFIER ::= { iso(1) member-body(2) us(840) rsadsi(113549) digestAlgorithm(2) 5 }
id-sha1    OBJECT IDENTIFIER ::= { iso(1) identified-organization(3) oiw(14) secsig(3) algorithms(2) 26 }
id-sha256  OBJECT IDENTIFIER ::= { joint-iso-itu-t(2) country(16) us(840) organization(1) gov(101) csor(3) nistalgorithm(4) hashalgs(2) 1 }
id-sha384  OBJECT IDENTIFIER ::= { joint-iso-itu-t(2) country(16) us(840) organization(1) gov(101) csor(3) nistalgorithm(4) hashalgs(2) 2 }
id-sha512  OBJECT IDENTIFIER ::= { joint-iso-itu-t(2) country(16) us(840) organization(1) gov(101) csor(3) nistalgorithm(4) hashalgs(2) 3 }
```

对应的参数字段应为NULL（类型为NULL），除非特别说明。

注意：PKCS #1 v1.5的版本1.5曾允许使用MD4，但近年来MD4的密码分析已取得重大进展，例如Dobbertin [18]证明了MD4的碰撞和前两轮不可逆性[20]。因此，不再推荐使用MD4。MD2和MD5的密码分析也有所进展，但尚不足以完全淘汰它们（如[8]、[43]、[9][19]所示）。为确保安全，建议新应用采用SHA-1、SHA-256、SHA-384或SHA-512。当前已知的碰撞攻击复杂度为2^(L/2)，其中L为哈希输出的比特长度。对于签名方案，碰撞攻击等同于伪造签名，因此L/2应至少等于所需的安全级别（以比特为单位）。同样，建议RSAES-OAEP的种子长度（等于哈希输出长度）应为所需安全级别的两倍。

B.2 掩码生成函数

掩码生成函数接受一个可变长度的八位字节串和期望输出长度，输出一个相同长度的八位字节串。输入和输出的长度可能有限制，但通常限制很大。掩码生成函数是确定性的，输出完全由输入决定。其输出应具有伪随机性：已知输出的一部分而未知输入时，应几乎不可能预测输出的另一部分。RSAES-OAEP和RSASSA-PSS的安全性依赖于掩码生成函数输出的随机性，这又依赖于底层哈希的随机性。

此处定义一种掩码生成函数：MGF1，它基于哈希函数。MGF1与IEEE Std 1363-2000 [26]和草案ANSI X9.44 [1]中的掩码生成函数一致。未来版本可能定义其他掩码生成函数。

B.2.1 MGF1

MGF1是基于哈希函数的掩码生成函数。

```
MGF1 (mgfSeed, maskLen)

参数：
Hash     哈希函数（hLen为哈希输出的字节长度）

输入：
mgfSeed  用于生成掩码的种子，是一个八位字节串
maskLen  期望的掩码长度（字节），最多为2^32 * hLen

输出：
mask     掩码，是长度为maskLen的八位字节串

错误：
"mask too long"（掩码过长）

步骤：
1. 如果maskLen > 2^32 * hLen，则输出"掩码过长"并停止。
2. 令T为空八位字节串。
3. 对于counter从0到ceil(maskLen / hLen) - 1，执行：
   a. 将counter转换为4字节长的八位字节串C（见第4.1节）：
      C = I2OSP(counter, 4)
   b. 将Hash(mgfSeed || C)连接到T的末尾：
      T = T || Hash(mgfSeed || C)
4. 输出T的前maskLen个字节作为掩码。

对象标识符id-mgf1标识MGF1掩码生成函数：

id-mgf1 ::= { pkcs-1 8 }

与此OID相关联的参数字段应为哈希算法ID（hashAlgorithm），指明MGF1所基于的哈希函数。

当在AlgorithmIdentifier中使用id-pSpecified时，参数必须是一个OCTET STRING。

id-pSpecified    OBJECT IDENTIFIER ::= { pkcs-1 9 }

当在AlgorithmIdentifier中使用id-RSASSA-PSS时，参数必须存在，并且必须是RSASSA-PSS-params。

id-RSASSA-PSS    OBJECT IDENTIFIER ::= { pkcs-1 10 }

当在AlgorithmIdentifier中使用以下OID时，参数必须存在且必须为NULL。

md2WithRSAEncryption       OBJECT IDENTIFIER ::= { pkcs-1 2 }
md5WithRSAEncryption       OBJECT IDENTIFIER ::= { pkcs-1 4 }
sha1WithRSAEncryption      OBJECT IDENTIFIER ::= { pkcs-1 5 }
sha256WithRSAEncryption    OBJECT IDENTIFIER ::= { pkcs-1 11 }
sha384WithRSAEncryption    OBJECT IDENTIFIER ::= { pkcs-1 12 }
sha512WithRSAEncryption    OBJECT IDENTIFIER ::= { pkcs-1 13 }

这个OID实际上属于包含sec sig OIDs的模块。

id-sha1    OBJECT IDENTIFIER ::= {
    iso(1) 识别组织(3) oiw(14) secsig(3)
    algorithms(2) 26
}

MD2和MD5的OID，只允许在EMSA-PKCS1-v1_5中使用。

id-md2 OBJECT IDENTIFIER ::= {
    iso(1) 会员机构(2) 美国(840) rsadsi(113549) digestAlgorithm(2) 2
}

id-md5 OBJECT IDENTIFIER ::= {
    iso(1) 会员机构(2) 美国(840) rsadsi(113549) digestAlgorithm(2) 5
}

当在AlgorithmIdentifier中使用id-mgf1时，参数必须存在，并且必须是HashAlgorithm，例如sha1。

id-mgf1    OBJECT IDENTIFIER ::= { pkcs-1 8 }

================
有用的类型
================

ALGORITHM-IDENTIFIER ::= 类定义 {
    &id    OBJECT IDENTIFIER  唯一,
    &Type  可选
}
    语法：{ OID &id [PARAMETERS &Type] }

注意：以下定义中的参数InfoObjectSet允许为算法集指定不同的信息对象集，例如：
DigestAlgorithms    ALGORITHM-IDENTIFIER ::= {
    { OID id-md2  PARAMETERS NULL }|
    { OID id-md5  PARAMETERS NULL }|
    { OID id-sha1 PARAMETERS NULL }
}

AlgorithmIdentifier { ALGORITHM-IDENTIFIER:InfoObjectSet } ::= 序列 {
    algorithm  ALGORITHM-IDENTIFIER.&id({InfoObjectSet}),
    parameters
        ALGORITHM-IDENTIFIER.&Type({InfoObjectSet}{@.algorithm})
            可选
}

================
算法
================

允许的EME-OAEP和EMSA-PSS摘要算法：
OAEP-PSSDigestAlgorithms    ALGORITHM-IDENTIFIER ::= {
    { OID id-sha1 PARAMETERS NULL }|
    { OID id-sha256 PARAMETERS NULL }|
    { OID id-sha384 PARAMETERS NULL }|
    { OID id-sha512 PARAMETERS NULL },
    ...  -- 允许未来扩展 --
}

允许的EMSA-PKCS1-v1_5摘要算法：
PKCS1-v1-5DigestAlgorithms    ALGORITHM-IDENTIFIER ::= {
    { OID id-md2 PARAMETERS NULL }|
    { OID id-md5 PARAMETERS NULL }|
    { OID id-sha1 PARAMETERS NULL }|
    { OID id-sha256 PARAMETERS NULL }|
    { OID id-sha384 PARAMETERS NULL }|
    { OID id-sha512 PARAMETERS NULL }
}

当在AlgorithmIdentifier中使用id-md2和id-md5时，参数必须存在且必须为NULL。

当在AlgorithmIdentifier中使用id-sha1、id-sha256、id-sha384和id-sha512时，参数（可选）应省略，但实现也必须接受参数为NULL的情况。

sha1    HashAlgorithm ::= {
    algorithm   id-sha1,
    parameters  SHA1Parameters : NULL  -- 为兼容现有实现而包含
}

HashAlgorithm ::= AlgorithmIdentifier { {OAEP-PSSDigestAlgorithms} }

SHA1Parameters ::= NULL

允许的掩码生成函数算法：
如果标识符是id-mgf1，参数是HashAlgorithm。

PKCS1MGFAlgorithms    ALGORITHM-IDENTIFIER ::= {
    { OID id-mgf1 PARAMETERS HashAlgorithm },
    ...  -- 允许未来扩展 --
}

默认的id-RSAES-OAEP.maskGenAlgorithm和id-RSASSA-PSS.maskGenAlgorithm的AlgorithmIdentifier：
mgf1SHA1    MaskGenAlgorithm ::= {
    algorithm   id-mgf1,
    parameters  HashAlgorithm : sha1
}

MaskGenAlgorithm ::= AlgorithmIdentifier { {PKCS1MGFAlgorithms} }

允许的pSourceAlgorithm：
PKCS1PSourceAlgorithms    ALGORITHM-IDENTIFIER ::= {
    { OID id-pSpecified PARAMETERS EncodingParameters },
    ...  -- 允许未来扩展 --
}

EncodingParameters ::= OCTET STRING(SIZE(0..MAX))

此标识符表示标签L为空字符串，因此空字符串的摘要在RSA块中掩码之前出现。

pSpecifiedEmpty    PSourceAlgorithm ::= {
    algorithm   id-pSpecified,
    parameters  EncodingParameters : 空字符串
}

PSourceAlgorithm ::= AlgorithmIdentifier { {PKCS1PSourceAlgorithms} }

emptyString    EncodingParameters ::= ''H

PKCS #1 OID的类型标识定义：
PKCS1Algorithms    ALGORITHM-IDENTIFIER ::= {
    { OID rsaEncryption              PARAMETERS NULL } |
    { OID md2WithRSAEncryption       PARAMETERS NULL } |
    { OID md5WithRSAEncryption       PARAMETERS NULL } |
    { OID sha1WithRSAEncryption      PARAMETERS NULL } |
    { OID sha256WithRSAEncryption    PARAMETERS NULL } |
    { OID sha384WithRSAEncryption    PARAMETERS NULL } |
    { OID sha512WithRSAEncryption    PARAMETERS NULL } |
    { OID id-RSAES-OAEP PARAMETERS RSAES-OAEP-params } |
    PKCS1PSourceAlgorithms                             |
}

主要结构
RSAPublicKey ::= 序列 {
    modulus           INTEGER,  -- n
    publicExponent    INTEGER   -- e
}

表示带有CRT算法信息的RSA私钥：
RSAPrivateKey ::= 序列 {
    version           版本,
    modulus           INTEGER,  -- n
    publicExponent    INTEGER,  -- e
    privateExponent   INTEGER,  -- d
    prime1            INTEGER,  -- p
    prime2            INTEGER,  -- q
    exponent1         INTEGER,  -- d mod (p-1)
    exponent2         INTEGER,  -- d mod (q-1)
    coefficient       INTEGER,  -- (q的逆元) mod p
    otherPrimeInfos   其他质数信息（可选）
}

版本 ::= INTEGER { 两质数(0), 多质数(1) }
    (受约束：{
        -- 如果存在otherPrimeInfos，则版本必须是多质数 --
    })

其他质数信息 ::= 序列 大小(1..MAX) OF OtherPrimeInfo

其他质数信息 ::= 序列 {
    prime             INTEGER,  -- ri
    exponent          INTEGER,  -- di
    coefficient       INTEGER   -- ti
}

RSAES-OAEP的AlgorithmIdentifier参数：
注意：此序列中的标签是显式的。
RSAES-OAEP-params ::= 序列 {
    hashAlgorithm      [0] HashAlgorithm      默认 sha1,
    maskGenAlgorithm   [1] MaskGenAlgorithm   默认 mgf1SHA1,
    pSourceAlgorithm   [2] PSourceAlgorithm   默认 pSpecifiedEmpty
}

默认的RSAES-OAEP算法标识符：
rSAES-OAEP-Default-Identifier    RSAES-算法标识符 ::= {
    algorithm   id-RSAES-OAEP,
    parameters  RSAES-OAEP-params : {
        hashAlgorithm       sha1,
        maskGenAlgorithm    mgf1SHA1,
        pSourceAlgorithm    pSpecifiedEmpty
    }
}

RSAES-算法标识符：
AlgorithmIdentifier { {PKCS1Algorithms} }

id-RSASSA-PSS的AlgorithmIdentifier参数：
注意：此序列中的标签是显式的。
RSASSA-PSS-params ::= 序列 {
    hashAlgorithm      [0] HashAlgorithm      默认 sha1,
    maskGenAlgorithm   [1] MaskGenAlgorithm   默认 mgf1SHA1,
    saltLength         [2] INTEGER            默认 20,
    trailerField       [3] TrailerField       默认 trailerFieldBC
}

TrailerField ::= INTEGER { trailerFieldBC(1) }

默认的RSASSA-PSS算法标识符：
RSASSA-AlgorithmIdentifier ::= {
    algorithm   id-RSASSA-PSS,
    parameters  RSASSA-PSS-params : {
        hashAlgorithm       sha1,
        maskGenAlgorithm    mgf1SHA1,
        saltLength          20,
        trailerField        trailerFieldBC
    }
}

RSASSA-算法标识符：
AlgorithmIdentifier { {PKCS1Algorithms} }

PKCS #1的散列标识符的语法：
DigestInfo ::= 序列 {
    digestAlgorithm DigestAlgorithm,
    digest OCTET STRING
}

DigestAlgorithm ::=
    AlgorithmIdentifier { {PKCS1-v1-5DigestAlgorithms} }

结束 -- PKCS1Definitions

附录D. 知识产权注意事项

RSA公钥密码系统在美国专利号4,405,829中描述，该专利于2000年9月20日到期。RSA Security Inc.对本文档中描述的结构不再提出其他专利要求，但某些底层技术可能仍受保护。

多质数RSA在美国专利号5,848,159中描述。

加州大学已表示其对PSS签名方案拥有待批的专利[5]。并向IEEE P1363工作组提供了一封声明信，表示如果PSS签名方案被纳入IEEE标准，“加州大学将在该标准采纳时，免费授权任何符合的实现作为实现带附录的数字签名的技术”[23]。PSS签名方案在IEEE P1363a草案[27]中已被规定，且在本文发布时正处于表决阶段。

复制本文档的许可：
只要在所有提及或引用本文件的材料中标明“RSA Security Inc. 公钥密码标准（PKCS）”，即可获得复制许可。

RSA Security Inc.不对其他方的知识产权声明作出任何声明。此类判断由用户自行负责。

附录E. 修订历史

版本1.0 - 1.3
- 这些版本在1991年2月和3月由RSA Data Security, Inc.的PKCS会议参与者分发。

版本1.4
- 1991年6月3日的PKCS首次公开发布中包含版本1.4。作为NIST/OSI实现者研讨会文件SEC-SIG-91-18发布。

版本1.5
- 版本1.5加入了多项编辑变更，包括更新参考资料和增加修订历史。主要变更：
  - 第10节：加入MD4签名和验证过程。
  - 第11节：加入md4WithRSAEncryption对象标识符。
- 该版本后被重新发布为IETF RFC 2313。

版本2.0
- 结构上进行了重大编辑，加入了RSAES-OAEP加密方案。继续支持1.5版本中的签名和加密过程，但由于近年来的密码分析进展，不再允许使用MD4哈希算法。该版本后被重新发布为IETF RFC 2437[35]。

版本2.1
- 引入多质数RSA和带附录的RSASSA-PSS签名方案，并进行了多项编辑改进。继续支持2.0版本的方案。

附录F. 参考文献
（此处列出详细的参考文献列表）

以下是该英文内容的中文翻译：

```
   [10]  D. Coppersmith, M. Franklin, J. Patarin 和 M. Reiter。 具有相关消息的低指数RSA。收录于 U. Maurer 编者，《密码学进展 - Eurocrypt '96》，第1070卷《计算机科学讲义笔记》，第1-9页。施普林格出版社，1996年。

   [11]  D. Coppersmith, S. Halevi 和 C. Jutla。 ISO 9796-1 与新的伪造策略。在Crypto '99的休会环节中展示，1999年8月。

   [12]  J.-S. Coron。 关于全域哈希的安全性精确分析。收录于 M. Bellare 编者，《密码学进展 - Crypto 2000》，第1880卷《计算机科学讲义笔记》，第229-235页。施普林格出版社，2000年。

   [13]  J.-S. Coron。 PSS及其他签名方案的最优安全性证明。收录于 L. Knudsen 编者，《密码学进展 - Eurocrypt 2002》，第2332卷《计算机科学讲义笔记》，第272-287页。施普林格出版社，2002年。

   [14]  J.-S. Coron, M. Joye, D. Naccache 和 P. Paillier。 针对PKCS #1 v1.5加密的新攻击。在 B. Preneel 编者，《密码学进展 - Eurocrypt 2000》，第1807卷《计算机科学讲义笔记》，第369-379页。施普林格出版社，2000年。

   [15]  J.-S. Coron, D. Naccache 和 J. P. Stern。 关于RSA填充的安全性。在 M. Wiener 编者，《密码学进展 - Crypto '99》，第1666卷《计算机科学讲义笔记》，第1-18页。施普林格出版社，1999年。

   [16]  Y. Desmedt 和 A.M. Odlyzko。 针对RSA密码系统及某些离散对数方案的选择文本攻击。在 H.C. Williams 编者，《密码学进展 - Crypto '85》，第218卷《计算机科学讲义笔记》，第516-522页。施普林格出版社，1986年。

   [17]  Dierks, T. 和 C. Allen，“TLS协议，第1.0版”，RFC 2246，1999年1月。

   [18]  H. Dobbertin。 MD4的密码分析。在 D. Gollmann 编者，《快速软件加密 '96》，第1039卷《计算机科学讲义笔记》，第55-72页。施普林格出版社，1996年。

   [19]  H. Dobbertin。 MD5压缩的密码分析。在Eurocrypt '96的休会环节中展示，1996年5月。

   [20]  H. Dobbertin。 MD4的前两轮不是单向的。在 S. Vaudenay 编者，《快速软件加密 '98》，第1372卷《计算机科学讲义笔记》，第284-292页。施普林格出版社，1998年。

   [21]  E. Fujisaki, T. Okamoto, D. Pointcheval 和 J. Stern。 RSA-OAEP在RSA假设下是安全的。在 J. Kilian 编者，《密码学进展 - Crypto 2001》，第2139卷《计算机科学讲义笔记》，第260-274页。施普林格出版社，2001年。

   [22]  H. Garner。 残数系统。IRE电子计算机学报，EC-8(6)，第140-147页，1959年6月。

   [23]  M.L. Grell。 关于PSS/PSS-R编码方法。致加州大学IEEE P1363工作组的信，1999年6月15日。可从 http://grouper.ieee.org/groups/1363/P1363/patents.html 获取。

   [24]  J. Haastad。 低阶同时模方程的求解。SIAM计算机学报，第17卷，第336-341页，1988年。

   [25]  R. Housley。“密码消息语法（CMS）”，RFC 3369，2002年8月。R. Housley。“密码消息语法（CMS）算法”，RFC 3370，2002年8月。

   [26]  IEEE标准1363-2000：公钥密码学标准。IEEE，2000年8月。

   [27]  IEEE P1363工作组。IEEE P1363a D11：公钥密码学草案标准规范——修正案1：附加技术。2002年12月16日。可从 http://grouper.ieee.org/groups/1363/ 获取。

   [28]  ISO/IEC 9594-8:1997：信息技术——开放系统互联——目录：认证框架。1997年。

   [29]  ISO/IEC FDIS 9796-2：信息技术——安全技术——数字签名方案（带消息恢复）——第2部分：基于整数分解的机制。2001年12月最终草案国际标准。

   [30]  ISO/IEC 18033-2：信息技术——安全技术——加密算法——第2部分：非对称密码。V. Shoup，编辑，2002年1月第二工作草案文本。

   [31]  J. Jonsson。 RSA-PSS签名方案的安全性证明（扩展摘要）。第二届开放的NESSIE研讨会。2001年9月。完整版本可从 http://eprint.iacr.org/2001/053/ 获取。

   [32]  J. Jonsson 和 B. Kaliski。 关于TLS中RSA加密的安全性。在 M. Yung 编者，《密码学进展 - CRYPTO 2002》，第2442卷《计算机科学讲义笔记》，第127-142页。施普林格出版社，2002年。

   [33]  B. Kaliski。“MD2消息摘要算法”，RFC 1319，1992年4月。

   [34]  B. Kaliski。 关于签名方案中哈希函数识别的问题。在 B. Preneel 编者，2002年RSA会议密码学家专场，卷2271《计算机科学讲义笔记》，第1-16页。施普林格出版社，2002年。

   [35]  B. Kaliski 和 J. Staddon。“PKCS #1：RSA密码学规范第2.0版”，RFC 2437，1998年10月。

   [36]  J. Manger。 针对PKCS #1 v2.0中标准化的RSA最优非对称加密填充（OAEP）的选择密文攻击。在 J. Kilian 编者，《密码学进展 - Crypto 2001》，第2139卷《计算机科学讲义笔记》，第260-274页。施普林格出版社，2001年。

   [37]  A. Menezes, P. van Oorschot 和 S. Vanstone。 《应用密码学手册》。CRC出版社，1996年。

   [38]  美国国家标准与技术研究院（NIST）。FIPS发布180-1：安全哈希标准。1994年4月。

   [39]  美国国家标准与技术研究院（NIST）。FIPS 180-2草案：安全哈希标准。2001年5月草案。可从 http://www.nist.gov/sha/ 获取。

   [40]  J.-J. Quisquater 和 C. Couvreur。 RSA公钥密码系统的快速解密算法。电子信函，18(21)，第905-907页，1982年10月。

   [41]  R. Rivest。“MD5消息摘要算法”，RFC 1321，1992年4月。

   [42]  R. Rivest, A. Shamir 和 L. Adleman。 获取数字签名和公钥密码系统的方法。Communications of the ACM，21(2)，第120-126页，1978年2月。

   [43]  N. Rogier 和 P. Chauvaud。 MD2的压缩函数不是碰撞自由的。在密码学“特定领域”会议上展示，1995年5月，加拿大渥太华卡尔顿大学。

   [44]  RSA实验室。PKCS #1 v2.0：RSA加密标准。1998年10月。

   [45]  RSA实验室。PKCS #7 v1.5：密码消息语法标准。1993年11月（作为IETF RFC 2315重新发布）。

   [46]  RSA实验室。PKCS #8 v1.2：私钥信息语法标准。1993年11月。

   [47]  RSA实验室。PKCS #12 v1.0：个人信息交换语法标准。1999年6月。

   [48]  V. Shoup。 OAEP的重新考虑。在 J. Kilian 编者，《密码学进展 - Crypto 2001》，第2139卷《计算机科学讲义笔记》，第239-259页。施普林格出版社，2001年。

   [49]  R. D. Silverman。 对对称和非对称密钥长度的成本基础安全性分析。RSA实验室公告第13号，2000年4月。可从 http://www.rsasecurity.com.rsalabs/bulletins/ 获取。

   [50]  G. J. Simmons。 使用DSA进行隐形通信非常容易。在 T. Helleseth 编者，《密码学进展 - Eurocrypt '93》，第765卷《计算机科学讲义笔记》，第218-232页。施普林格出版社，1993年。










   附录G：关于PKCS

   公钥密码学标准（PKCS）是由RSA实验室与全球安全系统开发者合作制定的规范，旨在加快公钥密码学的推广。该标准首次发布于1991年，源于与一小部分早期采用者的会议，PKCS文档已被广泛引用和实施。PKCS系列的贡献已成为许多正式和事实上的标准的一部分，包括ANSI X9、IEEE P1363、PKIX、SET、S/MIME、SSL/TLS和WAP/WTLS。

   PKCS的进一步发展通过邮件讨论和偶尔的研讨会进行，欢迎提出改进建议。更多信息请联系：

      PKCS编辑
      RSA实验室
      174 Middlesex Turnpike
      贝德福德，马萨诸塞州 01730 美国
      pkcs-editor@rsasecurity.com
      http://www.rsasecurity.com/rsalabs/pkcs

附录H：RFC发布过程中所做的更正

   在将PKCS #1 v2.1文档转为本RFC的过程中，做出了以下更正：

   *  将id-sha1、id-sha256、id-sha384和id-sha512的AlgorithmIdentifier参数中参数必须为NULL的要求，改为建议省略参数（同时仍允许参数为NULL）。此举旨在与NIST最初公布的定义保持一致。实现必须接受无参数和带NULL参数的AlgorithmIdentifier值。

   *  对RSADP和RSASP1（第5.1.2节和5.2.1节）之后的注释进行了修正，改为引用步骤2.b而非2.a。

   *  更新了参考文献[25]、[27]和[32]，以反映新的出版日期。

   这些更正将在未来的PKCS #1 v2.1版本中体现。

安全注意事项

   本备忘录中对安全问题进行了讨论。





   附录J：致谢

   本文基于RSA实验室的贡献，RSA实验室是RSA Security Inc.的研究中心。任何大量使用本文内容的行为都必须注明来源为RSA Security Inc.。RSA Security Inc.要求所有提及或引用本文件的材料标明“RSA Security Inc. PKCS #1 v2.1”。

作者联系方式

   约翰·乔恩松
   马尔堡菲尔普斯大学
   数学与信息学系
   汉斯·米尔维街，拉恩贝格
   德国 35032 马尔堡

   电话：+49 6421 28 25672
   电子邮箱：jonsson@mathematik.uni-marburg.de

   伯特·卡利斯基
   RSA实验室
   174 Middlesex Turnpike
   贝德福德，马萨诸塞州 01730 美国

   电话：+1 781 515 7073
   电子邮箱：bkaliski@rsasecurity.com









   附录J：本文件的版权声明

   版权所有（C）互联网协会 2003年。保留所有权利。

   本文件及其翻译版本可复制并提供给他人，前提是所有副本都必须包含上述版权声明和本段内容。然而，除非为将其翻译成非英语语言所必需，否则不得以任何方式修改本文件，例如删除版权声明或提及互联网协会或其他互联网组织。

   上述授予的有限权限是永久的，不会被互联网协会或其继任者或受让人撤销。

   本文件及其中包含的信息是“按原样”提供的，互联网协会和互联网工程任务组（IETF）不对其作任何明示或暗示的保证，包括但不限于使用本文件中的信息不会侵犯任何权利或对其作出任何关于适销性或特定用途适用性的暗示保证。

致谢

   目前，RFC编辑的资金由互联网协会提供。

```