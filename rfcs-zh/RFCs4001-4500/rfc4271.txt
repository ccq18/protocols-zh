# RFC 4271 中文翻译 (stub)
# 原文文件: ../../rfcs/RFCs4001-4500/rfc4271.txt

网络工作组                                    Y. Rekhter，主编
意见请求：4271                                    T. Li，主编
废止：1771                                            S. Hares，主编
类别：标准轨道                                   2006年1月


                  边界网关协议4（BGP-4）

本备忘录的状态

   本文件为互联网社区制定的互联网标准轨道协议，旨在征求讨论和改进建议。请参阅当前版本的《互联网官方协议标准》（STD 1）以了解该协议的标准化状态和最新情况。本备忘录的分发不受限制。

版权声明

   版权所有（C）互联网协会（2006年）。

摘要

   本文档讨论了边界网关协议（BGP），这是一种自治系统之间的路由协议。

   支持BGP的系统的主要功能是与其他BGP系统交换网络可达性信息。这些信息包括经过的自治系统（AS）列表。这些信息足以构建该可达性对应的AS连接图，从中可以剪除路由环路，并在AS层面上执行一些策略决策。

   BGP-4提供了一套支持无类别域间路由（CIDR）机制。这些机制包括支持将一组目的地作为IP前缀进行广告，以及在BGP中消除网络“类别”的概念。BGP-4还引入了允许路由聚合的机制，包括AS路径的聚合。

   本文档废止RFC 1771。









Rekhter 等人             标准轨道                     [第1页]


RFC 4271                         BGP-4                      2006年1月


目录

   1. 引言 ....................................................4
      1.1. 常用术语定义 ........................................4
      1.2. 需求规范 ............................................6
   2. 致谢 ....................................................6
   3. 操作概要 ................................................7
      3.1. 路由：广告与存储 ....................................9
      3.2. 路由信息库 ..........................................10
   4. 消息格式 .................................................11
      4.1. 消息头格式 ..........................................12
      4.2. OPEN消息格式 ........................................13
      4.3. UPDATE消息格式 ......................................14
      4.4. KEEPALIVE消息格式 ...................................21
      4.5. NOTIFICATION消息格式 ................................21
   5. 路径属性 .................................................23
      5.1. 路径属性的使用 ......................................25
           5.1.1. ORIGIN .........................................25
           5.1.2. AS_PATH ........................................25
           5.1.3. NEXT_HOP .......................................26
           5.1.4. MULTI_EXIT_DISC ................................28
           5.1.5. LOCAL_PREF .....................................29
           5.1.6. ATOMIC_AGGREGATE .................................29
           5.1.7. AGGREGATOR .....................................30
   6. BGP错误处理 .............................................30
      6.1. 消息头错误处理 ......................................31
      6.2. OPEN消息错误处理 ....................................31
      6.3. UPDATE消息错误处理 ..................................32
      6.4. NOTIFICATION消息错误处理 ..............................34
      6.5. 保持定时器超时错误处理 ..............................34
      6.6. 有限状态机错误处理 ..................................35
      6.7. 终止 ..................................................35
      6.8. BGP连接冲突检测 .....................................35
   7. BGP版本协商 .............................................36
   8. BGP有限状态机（FSM） ..................................37
      8.1. BGP FSM的事件 .......................................38
           8.1.1. 与可选会话属性相关的可选事件 ..................38
           8.1.2. 管理事件 .......................................42
           8.1.3. 定时器事件 .....................................46
           8.1.4. 基于TCP连接的事件 ..............................47
           8.1.5. 基于BGP消息的事件 ...............................49
      8.2. FSM的描述 ...........................................51
           8.2.1. FSM定义 .........................................51
                  8.2.1.1. “主动”和“被动”术语 ....................52
                  8.2.1.2. FSM与冲突检测 ..........................52
                  8.2.1.3. FSM与可选会话属性 ......................52
                  8.2.1.4. FSM事件编号 ............................53
                  8.2.1.5. 实现依赖的FSM动作 ....................53
           8.2.2. 有限状态机 .....................................53
   9. UPDATE消息处理 ..........................................75
      9.1. 决策过程 ............................................76
           9.1.1. 阶段1：偏好度计算 ..............................77
           9.1.2. 阶段2：路由选择 ................................77
                  9.1.2.1. 路由可解析性条件 ......................79
                  9.1.2.2. 打破平局（阶段2） ......................80
           9.1.3. 阶段3：路由传播 ................................82
           9.1.4. 重叠路由 ........................................83
      9.2. 更新发送流程 ........................................84
           9.2.1. 控制路由流量开销 ..............................85
                  9.2.1.1. 路由广告频率 ..........................85
                  9.2.1.2. 路由产生频率 ..........................85
           9.2.2. 高效组织路由信息 ..............................86
                  9.2.2.1. 信息减少 ..............................86
                  9.2.2.2. 路由信息聚合 ..........................87
      9.3. 路由选择标准 ........................................89
      9.4. BGP路由的产生 ........................................89
   10. BGP定时器 ..............................................90
   附录A. 与RFC 1771的比较 ....................................92
   附录B. 与RFC 1267的比较 ....................................93
   附录C. 与RFC 1163的比较 ....................................93
   附录D. 与RFC 1105的比较 ....................................94
   附录E. 可与BGP一起使用的TCP选项 ..........................94
   附录F. 实现建议 ............................................95
                F.1. 每条消息多网络 ................................95
                F.2. 减少路由抖动 ..................................96
                F.3. 路径属性排序 ..................................96
                F.4. AS_SET排序 ....................................96
                F.5. 控制版本协商 ..................................96
                F.6. 复杂的AS_PATH聚合 .............................96
安全考虑 ....................................................97
IANA考虑 ....................................................99
规范性参考文献 ...........................................101
信息性参考文献 ...........................................101







Rekhter 等人             标准轨道                     [第3页]


RFC 4271                         BGP-4                      2006年1月


1. 引言

   边界网关协议（BGP）是一种自治系统间的路由协议。

   支持BGP的系统的主要功能是与其他BGP系统交换网络可达性信息。这些信息包括经过的自治系统（AS）列表。这些信息足以构建该可达性对应的AS连接图，从中可以剪除路由环路，并在AS层面上执行一些策略决策。

   BGP-4提供了一套支持无类别域间路由（CIDR）机制。这些机制包括支持将一组目的地作为IP前缀进行广告，以及在BGP中消除网络“类别”的概念。BGP-4还引入了允许路由聚合的机制，包括AS路径的聚合。

   通过BGP交换的路由信息仅支持基于目的地的转发范式，该范式假设路由器仅根据IP包头中的目的地址转发数据包。这反映了可以（以及不能）通过BGP强制执行的策略决策集。需要注意的是，一些策略无法通过目的地转发范式支持，因此需要使用源路由（即显式路由）等技术来强制执行。这些策略也不能通过BGP实现。例如，BGP不允许一个AS向另一个AS发送特定的策略信息。

1.1. 常用术语定义

   本节定义了在BGP协议中具有特定含义的术语，这些术语在全文中使用。

   Adj-RIB-In
      Adj-RIBs-In包含由邻居广告给本地BGP发言人的未处理路由信息。

   Adj-RIB-Out
      Adj-RIBs-Out包含通过本地发言人的UPDATE消息广告给特定邻居的路由。

   自治系统（AS）
      传统定义：由单一技术管理的路由器集合，使用内部网关协议（IGP）和共同的度量标准在AS内确定路由方式，使用自治系统间路由协议确定到其他AS的路由。随着发展，单一AS可能使用多种IGP和多套度量标准。强调“自治系统”一词，表明即使使用多种IGP和度量，AS的管理在其他AS看来仍是一个具有统一内部路由策略的实体，提供一致的可达性视图。

   BGP标识符
      一个4字节无符号整数，表示BGP消息的发起者的BGP标识符。每个BGP发言人将其BGP标识符设置为分配给该发言人的IP地址。该值在启动时确定，且在所有本地接口和BGP邻居中保持一致。

   BGP发言人
      实现BGP的路由器。

   EBGP
      对外BGP（不同自治系统之间的BGP连接）。

   外部邻居
      位于不同自治系统的邻居。

   可行路由
      广告的、可供接收方使用的路由。

   IBGP
      内部BGP（同一自治系统内的BGP连接）。

   内部邻居
      位于与本地系统相同自治系统的邻居。

   IGP
      内部网关协议——在单一自治系统内交换路由信息的协议。

   Loc-RIB
      Loc-RIB包含由本地BGP发言人的决策过程选定的路由。

   NLRI
      网络层可达性信息。

   路由
      一组目的地与到这些目的地路径属性的配对信息。目的地是其IP地址包含在UPDATE消息中的IP前缀内的系统。路径是该UPDATE消息中路径属性字段报告的信息。

   RIB
      路由信息库。

   不可行路由
      以前广告的可行路由，现已不再可用。

1.2. 需求规范

   本文档中的关键词“必须”、“不得”、“要求”、“应”、“不应”、“推荐”、“可以”和“可选”均按RFC 2119 [RFC2119]中的定义解释。

2. 致谢

   本文最初作为[RFC1267]于1991年10月发布，由Kirk Lougheed和Yakov Rekhter共同撰写。

   特别感谢Guy Almes、Len Bosack和Jeffrey C. Honig对早期版本（BGP-1）的贡献。

   特别感谢Dennis Ferguson对早期版本的多次贡献。

   感谢Bob Braden对早期版本（BGP-2）的审阅及其建设性意见。

   还要感谢互联网工程指导组（IETF）路由方向主管Bob Hinden及其组建的评审团队，包括Deborah Estrin、Milo Medin、John Moy、Radia Perlman、Martha Steenstrup、Mike St. Johns和Paul Tsuchiya，他们以严谨、专业和礼貌的态度进行了评审。

   本文部分内容借鉴了OSI的IDRP [IS10747]，应归功于由Lyman Chapin主持的ANSI X3S3.3组以及该组的IDRP编辑Charles Kunzinger。

   还要感谢Benjamin Abarbanel、Enke Chen、Edward Crabbe、Mike Craren、Vincent Gillet、Eric Gray、Jeffrey Haas、Dimitry Haskin、Stephen Kent、John Krawczyk、David LeRoy、Dan Massey、Jonathan Natale、Dan Pei、Mathew Richardson、John Scudder、John Stewart III、Dave Thaler、Paul Traina、Russ White、Curtis Villamizar和Alex Zinin等人的意见。

   特别感谢Andrew Lange在准备本文最终版本中的帮助。

   最后，感谢所有IDR工作组成员的思想和支持。

3. 操作概要

   边界网关协议（BGP）是一种自治系统间的路由协议。其基础源于EGP（定义见[RFC904]）以及NSFNET骨干网中EGP的应用（详见[RFC1092]和[RFC1093]）。更多关于BGP的信息请参见[RFC1772]、[RFC1930]、[RFC1997]和[RFC2858]。

   支持BGP的系统的主要功能是与其他BGP系统交换网络可达性信息。这些信息包括经过的自治系统（AS）列表。这些信息足以构建AS连接图，从中可以剪除路由环路，并在AS层面上执行一些策略决策。

   在本文的语境中，假设BGP发言人只向邻居广告其自身使用的路由（在此语境中，如果某条BGP路由是最优的并被用于转发，则称其“使用”该路由）。其他情况超出本文范围。

   在本文中，“IP地址”指的是IPv4地址[RFC791]。

   通过BGP交换的路由信息仅支持基于目的地的转发范式，该范式假设路由器仅根据IP包头中的目的地址转发数据包。这反映了可以（以及不能）通过BGP强制执行的策略集。需要注意的是，一些策略无法通过目的地转发范式支持，因此需要使用源路由（即显式路由）等技术来强制执行。这些策略也不能通过BGP实现。例如，BGP不允许一个AS向另一个AS发送特定的策略信息。

（以下内容为全文节选的部分，全文内容较长，以上为主要翻译部分。）

以下是英文内容的中文翻译：

---

为了将流量引导到邻接的自治系统（AS）以转发到某个目的地（通过但超出该邻接AS），意在让流量走不同于起源于该邻接AS的流量（对于相同目的地）的路线。另一方面，BGP可以支持任何符合基于目的地的转发范式的策略。

BGP-4提供了一套支持无类别域间路由（CIDR）[RFC1518, RFC1519]的新机制。这些机制包括支持将一组目的地作为IP前缀进行广告，以及在BGP中消除“网络类别”的概念。BGP-4还引入了允许路由聚合的机制，包括对AS路径的聚合。

本文档在全文中使用“自治系统”（AS）一词。经典定义的自治系统是由一组在单一技术管理下的路由器组成，使用内部网关协议（IGP）和共同的度量标准来确定在AS内部的包路由方式，以及使用AS间路由协议来确定到其他AS的包路由方式。自从这一经典定义提出以来，已普遍出现一个AS中使用多种IGP，甚至在某些情况下在一个AS内使用多组度量的情况。使用“自治系统”这一术语强调，即使使用多种IGP和多组度量，AS的管理在其他AS看来，仍表现为具有单一连贯的内部路由计划，并呈现出一组一致的可达目的地。

BGP使用TCP [RFC793]作为其传输协议。这消除了实现显式更新分段、重传、确认和排序的需要。BGP监听TCP端口179。BGP中使用的错误通知机制假设TCP支持“优雅关闭”（即在关闭连接前，所有未完成的数据都已传送完毕）。

TCP连接在两个系统之间建立。它们交换消息以打开并确认连接参数。

初始数据流是由导出策略允许的BGP路由表部分，称为Adj-Ribs-Out（见3.2）。随着路由表的变化，增量更新会被发送。BGP不要求定期刷新路由表。为了让本地策略的变更能正确生效而不重置任何BGP连接，BGP发起者应当要么（a）在连接期间保持所有对等体所广告的路由的当前版本，要么（b）使用路由刷新扩展 [RFC2918]。

可以定期发送KEEPALIVE消息以确保连接正常。NOTIFICATION消息在出现错误或特殊条件时发送。如果连接遇到错误情况，将发送NOTIFICATION消息并关闭连接。

不同AS中的对等体称为外部对等体（external peer），而同一AS中的对等体称为内部对等体（internal peer）。内部BGP和外部BGP通常缩写为IBGP和EBGP。

如果某个AS拥有多个BGP发起者，并为其他AS提供中转服务，则必须确保AS内部的路由视图一致。AS内部路由视图的一致性由AS内使用的IGP提供。本文假设通过让所有BGP发起者相互维护IBGP，从而提供对AS外部路由的一致视图。

本文档规定了BGP协议的基本行为。这些行为可以通过扩展规范进行修改。当协议被扩展时，新的行为会在扩展规范中详细描述。

### 3.1 路由：广告与存储

在本协议中，路由被定义为一单位信息，它将一组目的地与到这些目的地路径的属性配对。目的地是其IP地址包含在一个IP前缀中的系统，该前缀在UPDATE消息的网络层可达信息（NLRI）字段中传递；路径是同一UPDATE消息中路径属性字段报告的信息。

路由通过UPDATE消息在BGP发起者之间进行广告。具有相同路径属性的多条路由可以在单个UPDATE消息中通过包含多个前缀在NLRI字段中一同广告。

路由存储在路由信息库（RIB）中，包括邻接RIB入（Adj-RIBs-In）、本地RIB（Loc-RIB）和邻接RIB出（Adj-RIBs-Out），详见3.2节。

如果BGP发起者选择广告之前接收的路由，它可以在广告给对等体之前，添加或修改该路由的路径属性。

BGP提供机制，使发起者可以通知其对等体某条已广告的路由不再可用。有三种方法可以表示某条路由已被撤销：

a) 在UPDATE消息的“撤销路由”字段中广告表达目的地的IP前缀，从而标记相关路由不再可用；

b) 广告具有相同NLRI的替代路由；

c) 关闭BGP连接，隐含地将双方已广告的所有路由从服务中移除。

更改路由的属性是通过广告一条替代路由实现的。替代路由携带新的（已更改的）属性，并具有与原始路由相同的地址前缀。

### 3.2 路由信息库

BGP发起者的路由信息库（RIB）由三个不同部分组成：

a) **邻接RIB入（Adj-RIBs-In）**：存储从其他BGP发起者接收的入站UPDATE消息中学到的路由信息。这些内容代表可作为决策过程输入的路由。

b) **本地RIB（Loc-RIB）**：包含BGP发起者根据其本地策略，从邻接RIB入中选出的本地路由信息。这些路由由本地BGP发起者使用。每条路由的下一跳必须能通过本地BGP发起者的路由表解析。

c) **邻接RIB出（Adj-RIBs-Out）**：存储本地BGP发起者选择广告给对等体的信息。存储在邻接RIB出中的路由信息会在本地BGP发起者的UPDATE消息中携带，并广告给对等体。

总结来说，邻接RIB入包含由对等体广告给本地BGP发起者的未处理路由信息；本地RIB包含由本地BGP发起者的决策过程选出的路由；邻接RIB出组织待广告给特定对等体的路由（通过本地发起者的UPDATE消息）。

虽然概念模型区分了邻接RIB入、本地RIB和邻接RIB出，但这并不意味着实现必须维护三份不同的路由信息副本。实现方式（例如，三份副本或一份副本加指针）不受协议限制。

用于转发包（或构建转发表以进行包转发）的路由信息存储在路由表中。路由表累积直连网络、静态路由、从IGP协议学习的路由以及从BGP学习的路由。是否将某条BGP路由安装到路由表中，以及是否由BGP路由覆盖其他来源的同一目的地路由，是本地策略决定，本文未作规定。除了实际包转发外，路由表还用于解析BGP更新中指定的下一跳地址（见5.1.3节）。

---

如果需要更详细的某部分翻译或其他帮助，请告诉我！

这1个字节的无符号整数表示可选参数字段的总长度（以字节为单位）。如果该字段的值为零，表示没有可选参数。

可选参数：

该字段包含一组可选参数的列表，每个参数以<参数类型、参数长度、参数值>三元组的形式编码。

示意图如下（每个参数从第0位开始编号）：
```
0                   1
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  参数类型   | 参数长度  |  参数值（可变）  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

参数类型是一个字节，用于唯一标识单个参数。参数长度是一个字节，表示参数值字段的长度（以字节为单位）。参数值是一个可变长度的字段，其含义根据参数类型的值而定。

[RFC3392]定义了能力（Capabilities）可选参数。

OPEN消息的最小长度为29个字节（包括消息头）。

4.3. UPDATE消息格式

UPDATE消息用于在BGP对等体之间传输路由信息。UPDATE消息中的信息可以用来构建描述不同自治系统关系的图。通过应用后续讨论的规则，可以检测并消除路由环路及其他异常。

UPDATE消息用于向对等体广告具有共同路径属性的可行路由，或从服务中撤销多个不可行路由（详见3.1）。UPDATE消息可以同时广告一个可行路由并撤销多个不可行路由。每个UPDATE消息始终包含固定长度的BGP头部，还包括其他字段（如下所示，注意，某些字段可能在每个UPDATE中不存在）：

```
+-----------------------------------------------------+
|   撤销路由长度（2字节）                              |
+-----------------------------------------------------+
|   撤销路由（可变）                                    |
+-----------------------------------------------------+
|   路径属性总长度（2字节）                              |
+-----------------------------------------------------+
|   路径属性（可变）                                    |
+-----------------------------------------------------+
|   网络层可达性信息（可变）                              |
+-----------------------------------------------------+
```

撤销路由长度：

该2字节无符号整数表示撤销路由字段的总长度（以字节为单位）。其值允许确定网络层可达性信息字段的长度，具体如下。

值为0表示没有路由被撤销，且UPDATE消息中不包含撤销路由字段。

撤销路由：

这是一个可变长度字段，包含被撤销的IP地址前缀列表。每个IP地址前缀以<长度、前缀>的二元组编码，字段说明如下：

```
+---------------------------+
|   长度（1字节）           |
+---------------------------+
|   前缀（可变）             |
+---------------------------+
```

这些字段的用途和含义如下：

a) 长度：

表示IP地址前缀的长度（以比特为单位）。长度为零表示匹配所有IP地址的前缀（前缀本身长度为零字节）。

b) 前缀：

包含一个IP地址前缀，后跟足够的尾随比特，使字段末端对齐到字节边界。尾随比特的值无关紧要。

总路径属性长度：

该2字节无符号整数表示路径属性字段的总长度（以字节为单位）。其值允许确定网络层可达性信息字段的长度，具体如下。

值为0表示该UPDATE消息中既不包含网络层可达性信息字段，也不包含路径属性字段。

路径属性：

每个UPDATE消息都包含一组路径属性（除了只携带撤销路由的UPDATE消息），每个路径属性以<属性类型、属性长度、属性值>三元组的可变长度结构表示。

属性类型是两个字节的字段，由属性标志（Attribute Flags）字节和属性类型代码（Attribute Type Code）字节组成。

示意图：
```
0                   1
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  属性标志  |  属性类型代码  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

属性标志字节的最高位（第0位）是可选位，定义该属性是否为可选（1）或为众所周知（0）。

第二高位（第1位）是传递性（Transitive）位，定义可选属性是否为传递性（1）或非传递性（0）。

对于众所周知的属性，传递性位必须设置为1（详见第5节关于传递性属性的讨论）。

第三高位（第2位）是部分（Partial）位，定义可选传递性属性中的信息是否为部分（1）或完整（0）。对于众所周知的属性和非传递性可选属性，必须设置为0。

第四高位（第3位）是扩展长度（Extended Length）位，定义属性长度字段是一个字节（0）还是两个字节（1）。

属性标志字节的低四位未使用，发送时必须为零，接收时应忽略。

属性类型代码（Attribute Type Code）字节包含属性类型的标识码。当前定义的属性类型码在第5节中讨论。

如果扩展长度位为0，则路径属性的第三个字节包含属性数据的长度（以字节为单位）。

如果扩展长度位为1，则路径属性的第三和第四个字节共同表示属性数据的长度。

路径属性的剩余字节为属性值，根据属性标志和属性类型代码进行解释。支持的属性类型码及其值和用途如下：

a) ORIGIN（类型码1）：

定义路径信息的起源，是一个众所周知的强制性属性。数据字节可以取以下值：

| 值 | 含义 |
|-----|-------|
| 0   | IGP - 网络层可达性信息，位于起始AS内部 |
| 1   | EGP - 通过EGP协议学习到的网络层可达性信息 [RFC904] |
| 2   | INCOMPLETE - 通过其他方式学习到的网络层可达性信息 |

详见第5.1.1节。

b) AS_PATH（类型码2）：

定义路径中的AS序列，是一个众所周知的强制性属性，由一系列AS路径段组成。每个路径段由<路径段类型、路径段长度、路径段值>三元组编码。

路径段类型是一个字节，定义如下值：
| 值 | 类型 |
|-----|-------|
| 1   | AS_SET：无序的AS集合，表示路径经过的AS集合（无序） |
| 2   | AS_SEQUENCE：有序的AS序列，表示路径经过的AS的顺序 |

路径段长度是一个字节，表示路径段值中AS的个数（不是字节数）。

路径段值包含一个或多个AS编号，每个AS编号用两个字节编码。

详见第5.1.2节。

c) NEXT_HOP（类型码3）：

定义一个众所周知的强制性属性，表示应作为下一跳的（单播）IP地址，用于到UPDATE消息中网络层可达性信息列出的目的地。

详见第5.1.3节。

d) MULTI_EXIT_DISC（类型码4）：

这是一个可选的非传递性属性，长度为4个字节的无符号整数。该值可被BGP决策过程用来区分邻接自治系统的多个入口点。

详见第5.1.4节。

e) LOCAL_PREF（类型码5）：

定义一个众所周知的属性，是一个4字节的无符号整数。BGP对等体用它通知其他内部对等体其偏好程度。

详见第5.1.5节。

f) ATOMIC_AGGREGATE（类型码6）：

这是一个众所周知的可选属性，长度为0。

详见第5.1.6节。

g) AGGREGATOR（类型码7）：

这是一个可选的传递性属性，长度为6字节。包含形成聚合路由的最后一个AS编号（两个字节）和形成该聚合路由的BGP对等体的IP地址（四个字节）。应与用于BGP标识符的地址相同。

详见第5.1.7节。

网络层可达性信息：

这是一个可变长度字段，包含IP地址前缀列表。网络层可达性信息的长度（以字节为单位）未显式编码，而是通过以下公式计算：

```
UPDATE消息长度 - 23 - 路径属性总长度 - 撤销路由长度
```

其中，UPDATE消息长度是固定头部中的值，路径属性总长度和撤销路由长度是UPDATE消息中可变部分的值，23是固定头部、路径属性总长度字段和撤销路由长度字段的总长度。

可达性信息以一个或多个<长度、前缀>二元组编码，字段说明如下：

```
+---------------------------+
|   长度（1字节）           |
+---------------------------+
|   前缀（可变）             |
+---------------------------+
```

字段的用途和含义如下：

a) 长度：

表示IP地址前缀的长度（以比特为单位）。长度为零表示匹配所有IP地址的前缀（前缀本身长度为零字节）。

b) 前缀：

包含一个IP地址前缀，后跟足够的尾随比特，使字段末端对齐到字节边界。尾随比特的值无关紧要。

UPDATE消息的最小长度为23个字节——固定头部19个字节，加上撤销路由长度2个字节（值为0时不包含撤销路由字段），以及路径属性总长度2个字节（值为0时不包含路径属性字段）。

一个UPDATE消息最多可以只广告一组路径属性，但可以针对多个目的地，只要这些目的地共享这些属性。所有包含在某个UPDATE消息中的路径属性，适用于UPDATE消息中的所有NLRI目的地。

UPDATE消息还可以列出多个路由以供撤销。每个路由由其目的地（以IP前缀表示）唯一标识，确保在BGP对等体中唯一对应之前广告的路由。

一个UPDATE消息可能只广告要撤销的路由，此时不会包含路径属性或网络层可达性信息。相反，它也可以只广告一个可行路由，此时撤销路由字段可以省略。

UPDATE消息不应在撤销路由和网络层可达性信息字段中包含相同的地址前缀，但BGP对等体必须能处理此类消息。建议将此类消息视为撤销路由中不包含该地址前缀。

4.4. KEEPALIVE消息格式

BGP 不使用任何基于 TCP 的保持连接机制来判断对等体是否可达。相反，BGP 会在对等体之间频繁交换 KEEPALIVE 消息，以避免超时计时器（Hold Timer）到期。合理的最大间隔时间为 Hold 时间间隔的三分之一。KEEPALIVE 消息必须每秒不超过一次地发送。实现可以根据 Hold 时间间隔调整发送 KEEPALIVE 消息的频率。

如果协商的 Hold 时间间隔为零，则不得定期发送 KEEPALIVE 消息。

一个 KEEPALIVE 消息仅由消息头组成，长度为 19 个八位字节（octets）。

4.5. 通知消息格式

当检测到错误条件时，会发送通知（NOTIFICATION）消息。消息发送后，BGP 连接会立即关闭。

除了固定大小的 BGP 头部外，通知消息还包含以下字段：

```
0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| 错误代码       | 错误子代码     |   数据（可变长度）             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

错误代码：

此 1 字节无符号整数表示通知的类型。已定义的错误代码包括：

| 错误代码 | 符号名             | 参考章节   |
| -------- | ------------------ | ---------- |
| 1        | 消息头错误         | 第6.1节   |
| 2        | OPEN 消息错误      | 第6.2节   |
| 3        | UPDATE 消息错误    | 第6.3节   |
| 4        | Hold Timer 已过期  | 第6.5节   |
| 5        | 有限状态机错误     | 第6.6节   |
| 6        | 停止               | 第6.7节   |

错误子代码：

此 1 字节无符号整数提供关于报告错误的更具体信息。每个错误代码可能对应一个或多个错误子代码。如果没有定义合适的错误子代码，则使用值零（不具体）。

消息头错误子代码：

- 1：连接不同步
- 2：消息长度错误
- 3：消息类型错误

OPEN 消息错误子代码：

- 1：不支持的版本号
- 2：对等体 AS 不正确
- 3：BGP 标识符错误
- 4：不支持的可选参数
- 5：［已废弃 - 见附录A］
- 6：不可接受的 Hold 时间

UPDATE 消息错误子代码：

- 1：属性列表格式错误
- 2：未识别的已知属性
- 3：缺少已知属性
- 4：属性标志错误
- 5：属性长度错误
- 6：无效的 ORIGIN 属性
- 7：［已废弃 - 见附录A］
- 8：无效的 NEXT_HOP 属性
- 9：可选属性错误
- 10：网络字段无效
- 11：AS_PATH 格式错误

数据字段：

此可变长度字段用于诊断通知的原因。Data 字段的内容取决于错误代码和子代码。详见第6节。

注意，Data 字段的长度可以通过消息长度字段（Message Length）计算得出，公式为：

消息长度 = 21 + Data 长度

通知消息的最小长度为 21 个八位字节（包括消息头）。

5. 路径属性

本节讨论 UPDATE 消息中的路径属性。

路径属性分为四类：

1. 重要的已知属性（Well-known mandatory）
2. 重要的可知属性（Well-known discretionary）
3. 可选的传递性属性（Optional transitive）
4. 可选的非传递性属性（Optional non-transitive）

BGP 实现必须识别所有已知属性。其中一些是强制性的，必须包含在每个包含 NLRI 的 UPDATE 消息中。其他则是可选的，可以在特定 UPDATE 消息中选择性地发送。

一旦 BGP 对等体更新了任何已知属性，它必须在传输的任何更新中将这些属性传递给对等体。

除了已知属性外，每条路径还可以包含一个或多个可选属性。并非所有 BGP 实现都支持所有可选属性。对未识别的可选传递性属性的处理由属性标志字节中的传递（Transitive）位决定。带有未识别传递性可选属性的路径应被接受。如果接受并传递了带有未识别传递性可选属性的路径，则该属性必须与路径一起传递给其他对等体，并在属性标志字节中将 Partial 位设置为 1。对于已识别且传递性为传递的可选属性，如果路径已被接受并传递，且之前的自治系统（AS）已将 Partial 位设置为 1，则当前自治系统不得将其重置为 0。未识别的非传递性可选属性应被静默忽略，不传递给其他对等体。

新的传递性可选属性可以由路径的发起者或路径中的任何其他 BGP 说话者附加。如果不是由发起者附加，则属性标志中的 Partial 位应设置为 1。关于如何附加新的非传递性可选属性，将取决于具体属性的性质。每个新非传递性可选属性的文档应包括相关规则（例如 MULTI_EXIT_DISC 属性的描述即为示例）。所有可选属性（传递性和非传递性）都可以由路径中的 BGP 说话者在适当情况下进行更新。

发送 UPDATE 消息的端点应按属性类型的升序排列路径属性。接收方必须准备好处理可能无序的路径属性。

在特定 UPDATE 消息的路径属性字段中，同一类型的属性不应出现多次。

强制类别指在包含 NLRI 的 UPDATE 消息中，必须同时在 IBGP 和 EBGP 交换中出现的属性。对于协议扩展机制而言，标记为可选的属性可能在某些上下文中是纯粹的可选、可选、必需或被禁止的。

| 属性             | EBGP                  | IBGP                  |
| ---------------- | --------------------- | --------------------- |
| ORIGIN           | 必须                  | 必须                  |
| AS_PATH          | 必须                  | 必须                  |
| NEXT_HOP         | 必须                  | 必须                  |
| MULTI_EXIT_DISC  | 可选                  | 可选                  |
| LOCAL_PREF       | 见第5.1.5节           | 必须                  |
| ATOMIC_AGGREGATE | 见第5.1.6节和9.1.4节  | 见第5.1.6节和9.1.4节  |
| AGGREGATOR       | 可选                  | 可选                  |

5.1. 路径属性的使用

以下章节描述每个 BGP 路径属性的具体用法。

5.1.1. ORIGIN

ORIGIN 是一个已知的强制性属性。由产生相关路由信息的说话者生成。其值不应由其他说话者更改。

5.1.2. AS_PATH

AS_PATH 是一个已知的强制性属性。它标识了携带在此 UPDATE 消息中的路由经过的自治系统（AS）。该列表的组成可以是 AS_SET 或 AS_SEQUENCE。

当 BGP 说话者转发从另一 BGP 说话者学到的路由时，会根据路由将要发往的对等体的位置修改 AS_PATH 属性：

a) 当向内部对等体广告路由时，广告者不得修改该路由的 AS_PATH。

b) 当向外部对等体广告路由时，广告者会按以下规则更新 AS_PATH：

1）如果第一个路径段是 AS_SEQUENCE，则本地系统会在该序列的最后添加自己的 AS 号（将其放在协议消息中八位字节的最左端位置）。如果添加导致 AS_PATH 段溢出（超过255个AS），应新建一个 AS_SEQUENCE 段，并将自己的AS号添加到该段中。

2）如果第一个路径段是 AS_SET，则本地系统会在 AS_PATH 前面添加一个 AS_SEQUENCE 段，并在其中包括自己的AS号。

3）如果 AS_PATH 为空，则本地系统会创建一个 AS_SEQUENCE 段，将自己的AS放入该段，并将该段放入 AS_PATH。

当 BGP 说话者发起路由时：

a) 发起者会在所有发往外部对等体的 UPDATE 消息中的 AS_PATH 属性里包含一个类型为 AS_SEQUENCE 的路径段，并将自己的AS号放入其中。在这种情况下，路径段中只有发起者的AS号，且该路径段也是 AS_PATH 中唯一的段。

b) 发起者会在所有发往内部对等体的 UPDATE 消息中包含空的 AS_PATH 属性（长度字段为零）。

每当修改 AS_PATH 属性以包含或预置本地AS号时，本地系统可以在 AS_PATH 中包含多个自己的AS号实例。这由本地配置控制。

5.1.3. NEXT_HOP

NEXT_HOP 是一个已知的强制性属性，定义了应作为下一跳的路由器的IP地址，用于到达 UPDATE 消息中列出的目的地。NEXT_HOP 的计算规则如下：

1）向内部对等体发送消息时，如果路由不是本地产生的，除非明确配置为宣布自己的IP地址作为NEXT_HOP，否则不应修改 NEXT_HOP 属性。当宣布本地产生的路由给内部对等体时，应使用通过的接口地址作为 NEXT_HOP（即用于到达该网络的接口地址）。

2）向外部对等体X发送消息，且该对等体距离说话者只有一个IP跳时：

- 如果所宣布的路由是从内部对等体学到的或是本地产生的，BGP 说话者可以使用内部对等体路由器的接口地址（或内部路由器的地址）作为 NEXT_HOP，只要对等体X与该地址在同一子网内。这是一种“第三方” NEXT_HOP。

- 否则，如果路由是从外部对等体学到的，且说话者自己使用的地址（从接收到的 NEXT_HOP 属性中得知）在本地路由计算中使用，且对等体X与该地址在同一子网内，则可以在 NEXT_HOP 中使用该地址。这也是一种“第三方” NEXT_HOP。

- 如果对等体X与宣布的BGP说话者的某个接口在同一子网内，则可以在 NEXT_HOP 中使用该接口的IP地址。这被称为“第一方” NEXT_HOP。

- 默认情况下（如果不满足上述条件），BGP 说话者应在 NEXT_HOP 中使用其用以建立BGP连接的接口的IP地址。

3）向多个IP跳外部对等体X发送消息时（即“多跳EBGP”）……

- 该发言者可以被配置为传播NEXT_HOP属性。在这种情况下，当广告一个由其从其对等体学到的路由时，所广告路由的NEXT_HOP属性与学到的路由的NEXT_HOP属性完全相同（发言者不修改NEXT_HOP属性）。

- 默认情况下，BGP发言者应使用其用于建立与对等体X的BGP连接的接口的IP地址作为NEXT_HOP属性，以支持路由的转发。

通常，NEXT_HOP属性的选择应确保选择最短的可用路径。BGP发言者必须支持禁用第三方NEXT_HOP属性的广告，以应对媒介不完全桥接的情况。

由BGP发言者发起的路由不得使用该对等体的地址作为NEXT_HOP进行广告。BGP发言者不得将自己作为下一跳的路由安装到路由表中。

NEXT_HOP属性由BGP发言者用以确定实际的出接口和应使用的直接下一跳地址，以便将中转包转发到相关目的地。

直接下一跳地址通过对NEXT_HOP属性中的IP地址执行递归路由查找操作确定，使用路由表的内容，若存在多个等价路径，则选择其中一条。解析出NEXT_HOP属性中IP地址的路由表项将始终指定出接口。如果该路由表项指定了附属子网，但未指定下一跳地址，则应使用NEXT_HOP属性中的地址作为直接下一跳地址；如果该路由表项还指定了下一跳地址，则应将其用作包转发的直接下一跳地址。

5.1.4. 多出口折扣（MULTI_EXIT_DISC）

MULTI_EXIT_DISC是一个可选的非传递性属性，旨在用于外部（跨AS）链路，以区分多个出口或入口点到同一邻近AS的路径。其值为一个四字节无符号数，称为度量（metric）。在其他条件相等的情况下，应优先选择度量较低的出口点。若通过EBGP接收，MULTI_EXIT_DISC可以在IBGP中传播给同一AS内的其他BGP发言者（详见9.1.2.2）。从邻近AS接收的MULTI_EXIT_DISC属性不得传播到其他邻近AS。

BGP发言者必须实现一种机制（基于本地配置），允许从路由中移除MULTI_EXIT_DISC属性。如果配置为移除该属性，则必须在确定路由偏好度和进行路由选择（决策过程第1和第2阶段）之前完成。

实现还可以（基于本地配置）修改通过EBGP接收的MULTI_EXIT_DISC值。在进行路由偏好度计算和路由选择之前，必须对该值进行修改（详见9.1.2.2的限制）。

5.1.5. 本地偏好（LOCAL_PREF）

LOCAL_PREF是一个众所周知的属性，必须包含在所有由某个BGP发言者发出的更新消息中。BGP发言者应根据本地配置的策略，为每个外部路由计算偏好度，并在向内部对等体广告时包含该偏好度。偏好度越高越优先。BGP发言者在其决策过程中（见第9.1.1节）使用通过LOCAL_PREF学到的偏好度。

除非在BGP联盟（RFC3065）中，否则BGP发言者不得在向外部对等体发送的更新消息中包含此属性。如果从外部对等体接收到包含此属性的更新，则接收方应忽略该属性（除非在BGP联盟中）。

5.1.6. 原子聚合（ATOMIC_AGGREGATE）

ATOMIC_AGGREGATE是一个众所周知的自主性属性。

当BGP发言者对多个路由进行聚合以向特定对等体广告时，聚合路由的AS_PATH通常包含由形成该聚合的AS集合组成的AS_SET。在许多情况下，网络管理员可以判断是否可以在不包含AS_SET且不形成路由环的情况下安全地广告该聚合。

如果聚合排除了在被聚合的路由的AS_PATH中存在的某些AS号码（即省略了AS_SET），则在向对等体广告时，聚合路由应包含ATOMIC_AGGREGATE属性。

接收到带有ATOMIC_AGGREGATE属性的路由的BGP发言者，不应在传播该路由时移除该属性。

接收带有ATOMIC_AGGREGATE属性的路由的BGP发言者，不得在向其他BGP发言者广告时使该路由的NLRI变得更具体（详见9.1.4）。

接收带有ATOMIC_AGGREGATE属性的路由的BGP发言者，应意识到，虽然该路由的NLRI所指定的到目的地的路径具有无环性，但实际路径可能与AS_PATH中所示的路径不同。

5.1.7. 聚合器（AGGREGATOR）

AGGREGATOR是一个可选的传递性属性，可在聚合形成的更新中包含（详见9.2.2.2节）。执行路由聚合的BGP发言者可以添加AGGREGATOR属性，该属性应包含其自身的AS号和IP地址。IP地址应与发言者的BGP标识符相同。

6. BGP错误处理

本节描述在处理BGP消息时检测到错误时应采取的措施。

当检测到本文描述的任何条件时，应发送带有相应错误代码、子代码和数据字段的通知（NOTIFICATION）消息，并关闭BGP连接（除非明确说明不应发送通知或不应关闭连接）。如果未指定子代码，则必须使用零。

“关闭BGP连接”意味着TCP连接已关闭，相关的邻接RIB-In已清除，所有与该BGP连接相关的资源已被释放。与远端对等体相关的本地RIB中的条目被标记为无效。本地系统会重新计算其对被标记为无效的目的地的最佳路由。在删除无效路由之前，系统会向对等体广告或撤销这些路由，或广告新的最佳路由。

除非明确说明，否则通知消息的Data字段为空，用于指示错误。

6.1. 消息头错误处理

在处理消息头时检测到的所有错误，必须通过发送带有“消息头错误”错误代码的通知消息来指示。子代码详细说明具体错误性质。

消息头的Marker字段预期值应全部为1。如果Marker字段不符合预期，则发生同步错误，子代码必须设置为“连接未同步”。

如果满足以下任意条件：

- 消息头的Length字段小于19或大于4096，或
- OPEN消息的Length字段小于OPEN消息的最小长度，或
- UPDATE消息的Length字段小于UPDATE消息的最小长度，或
- KEEPALIVE消息的Length字段不等于19，或
- NOTIFICATION消息的Length字段小于其最小长度，

则子代码必须设置为“消息长度错误”。数据字段应包含错误的长度值。

如果消息头的Type字段不被识别，则子代码必须设置为“消息类型错误”。数据字段应包含错误的Type值。

6.2. OPEN消息错误处理

在处理OPEN消息时检测到的所有错误，必须通过发送带有“OPEN消息错误”错误代码的通知消息来指示。子代码详细说明具体错误。

如果接收的OPEN消息中的版本号不被支持，则子代码必须设置为“版本号不支持”。数据字段为一个2字节无符号整数，表示本地支持的最大版本号（小于远端BGP对等体在接收的OPEN消息中提出的版本号），或如果本地支持的最小版本号大于远端提出的版本号，则为本地支持的最小版本号。

如果OPEN消息中的自治系统（AS）字段不可接受，则子代码必须设置为“对等体AS错误”。可接受的自治系统号码的判定超出本协议范围。

如果OPEN消息中的Hold Time字段不可接受，则子代码必须设置为“不可接受的Hold Time”。实现必须拒绝1秒或2秒的Hold Time值。实现可以拒绝任何提出的Hold Time。接受Hold Time的实现必须使用协商的值。

如果OPEN消息中的BGP标识符字段语法不正确，则子代码必须设置为“BGP标识符错误”。语法正确性意味着该字段表示一个有效的单播IP主机地址。

如果OPEN消息中的可选参数之一未被识别，则子代码必须设置为“未支持的可选参数”。

如果识别了某个可选参数，但其格式错误，则子代码必须设置为0（不具体说明）。

6.3. UPDATE消息错误处理

在处理UPDATE消息时检测到的所有错误，必须通过发送带有“UPDATE消息错误”错误代码的通知消息来指示。子代码详细说明具体错误。

对UPDATE消息的错误检查始于检查路径属性。如果Withdrawn Routes长度或总属性长度过大（即：Withdrawn Routes长度 + 总属性长度 + 23超过消息长度），则子代码必须设置为“属性列表格式错误”。

如果任何已识别的属性的属性标志与属性类型代码冲突，则子代码必须设置为“属性标志错误”。数据字段应包含错误的属性（类型、长度和值）。

如果任何已识别的属性的长度与预期长度（基于属性类型代码）冲突，则子代码必须设置为“属性长度错误”。数据字段应包含错误的属性（类型、长度和值）。

如果任何众所周知的必需属性缺失，则子代码必须设置为“缺少众所周知的属性”。数据字段应包含缺失的属性类型代码。

如果任何众所周知的必需属性未被识别，则子代码必须设置为“未识别的众所周知的属性”。数据字段应包含未识别的属性（类型、长度和值）。

如果ORIGIN属性的值未定义，则必须将错误子码设置为“无效的起源属性”。数据字段必须包含无法识别的属性（类型、长度和值）。

如果NEXT_HOP属性字段在语法上不正确，则必须将错误子码设置为“无效的NEXT_HOP属性”。数据字段必须包含该不正确的属性（类型、长度和值）。语法正确性意味着NEXT_HOP属性表示一个有效的IP主机地址。

在语义上，NEXT_HOP中的IP地址必须满足以下条件，才能被视为正确：

a) 它不得是接收方的IP地址。

b) 在EBGP的情况下，发送方和接收方相距一个IP跳，或者，NEXT_HOP中的IP地址要么是用于建立BGP连接的发送方IP地址，要么与接收方BGP设备共享一个子网的接口的IP地址。

如果NEXT_HOP属性在语义上不正确，应记录错误，并忽略该路由。在这种情况下，不应发送通知消息，也不应关闭连接。

应检查AS_PATH属性的语法正确性。如果路径在语法上不正确，则必须将错误子码设置为“格式错误的AS_PATH”。

如果从外部对等体接收到UPDATE消息，本地系统可以检查AS_PATH属性中最左边（相对于协议消息中八位字节位置）的AS是否等于发送该消息的对等体的自治系统编号。如果检查发现不一致，必须将错误子码设置为“格式错误的AS_PATH”。

如果识别出某个可选属性，则必须检查该属性的值。如果检测到错误，必须丢弃该属性，并将错误子码设置为“可选属性错误”。数据字段必须包含该属性（类型、长度和值）。

如果在UPDATE消息中任何属性出现多次，则必须将错误子码设置为“格式错误的属性列表”。

应检查UPDATE消息中的NLRI字段的语法有效性。如果字段在语法上不正确，则必须将错误子码设置为“无效的网络字段”。

如果NLRI字段中的前缀在语义上不正确（例如，意外的多播IP地址），应在本地记录错误，并忽略该前缀。

包含正确路径属性但没有NLRI的UPDATE消息，应视为有效的UPDATE消息。

6.4. 通知消息的错误处理

如果对等体发送通知消息，接收方检测到该消息中存在错误，则不能通过通知消息将错误反馈给对等体。任何此类错误（例如，无法识别的错误码或错误子码）应在本地注意到、记录，并通知对等体的管理人员。然而，具体的通知方式超出了本文档的范围。

6.5. 保持计时器过期的错误处理

如果系统在OPEN消息中的保持时间内未收到连续的KEEPALIVE、UPDATE和/或通知消息，则会发送带有“保持计时器过期”错误码的通知消息，并关闭BGP连接。

6.6. 有限状态机错误处理

任何由BGP有限状态机检测到的错误（例如，收到意外事件）都应通过发送带有“有限状态机错误”错误码的通知消息来指示。

6.7. 终止

在没有任何致命错误（本节所述）发生的情况下，BGP对等体可以随时通过发送带有“终止”错误码的通知消息来关闭其BGP连接。然而，当存在本节所述的致命错误时，不应使用终止通知消息。

BGP发言人可以支持一种功能，即对从邻居接受的地址前缀数量施加本地配置的上限。当达到上限时，发言人可以在本地配置控制下选择： (a) 丢弃来自邻居的新地址前缀（同时保持与邻居的BGP连接），或 (b) 终止与邻居的BGP连接。如果发言人决定因为从邻居接收的地址前缀超过本地配置的上限而终止连接，则必须向邻居发送带有“终止”错误码的通知消息，也可以在本地记录此事件。

6.8. BGP连接冲突检测

如果一对BGP发言体试图同时建立彼此的BGP连接，则会形成两个平行的连接。如果其中一个连接使用的源IP地址与另一个连接的目标IP地址相同，且第一个连接的目标IP地址与第二个连接的源IP地址相同，则发生了连接冲突。在发生冲突时，必须关闭其中一个连接。

根据BGP标识符的值，建立一种检测冲突时保留哪个连接的约定。该约定是比较冲突中涉及的对等体的BGP标识符，只保留BGP标识符较高的那个连接。

在收到OPEN消息后，本地系统必须检查所有处于OpenConfirm状态的连接。如果知道对等体的BGP标识符（通过协议外的方式），也可以检查处于OpenSent状态的连接。如果在这些连接中，有一个连接到的远程BGP发言体的BGP标识符与OPEN消息中的相同，并且该连接与接收OPEN消息的连接发生冲突，则本地系统应执行以下冲突解决程序：

1) 比较本地系统的BGP标识符与远程系统的BGP标识符（如OPEN消息中所述）。比较时，将它们转换为主机字节序，并作为4字节无符号整数处理。

2) 如果本地BGP标识符的值小于远程的，则关闭已存在的BGP连接（即已处于OpenConfirm状态的连接），并接受远程系统发起的BGP连接。

3) 否则，关闭新建立的BGP连接（即与新接收的OPEN消息相关联的连接），并继续使用已有的连接（已处于OpenConfirm状态的连接）。

除非通过配置允许，否则与处于Established状态的现有BGP连接发生冲突时，应关闭新建立的连接。

请注意，无法检测处于Idle、Connect或Active状态的连接之间的冲突。

由冲突解决程序引起的BGP连接关闭，须通过发送带有“终止”错误码的通知消息实现。

7. BGP版本协商

BGP发言体可以通过多次尝试建立BGP连接来协商协议版本，从最高支持的版本开始。如果尝试打开连接时出现错误码为“OPEN消息错误”、子码为“不支持的版本号”的错误，则表示该发言体支持的版本包括：尝试的版本、对等体尝试的版本、对等体在通知消息中传递的版本，以及支持的版本列表。如果两个对等体支持一个或多个共同的版本，则可以快速确定最高的共同版本。为了支持BGP版本协商，未来的BGP版本必须保持OPEN和NOTIFICATION消息的格式不变。

8. BGP有限状态机（FSM）

本文描述的BGP数据结构和有限状态机（FSM）是概念性的，不必严格按照本文所述实现，只要实现支持所描述的功能，并表现出相同的外部可见行为。

本节以有限状态机（FSM）形式说明BGP的操作。内容分为两部分：

1) 状态机事件描述（第8.1节）
2) FSM的详细描述（第8.2节）

每个连接所需的（强制）会话属性包括：

1) 状态
2) ConnectRetryCounter（重试次数）
3) ConnectRetryTimer（重试计时器）
4) ConnectRetryTime（重试时间）
5) HoldTimer（保持计时器）
6) HoldTime（保持时间）
7) KeepaliveTimer（保持存活计时器）
8) KeepaliveTime（保持存活时间）

状态会话属性表示BGP FSM的当前状态。ConnectRetryCounter表示BGP对等体尝试建立会话的次数。

与计时器相关的强制属性在第10节中描述。每个计时器有“计时器”和“时间”两个值（初始值）。

以下列出可选的会话属性。这些可选属性可以支持，也可以按连接或本地系统支持：

1) AcceptConnectionsUnconfiguredPeers（接受未配置对等体的连接）
2) AllowAutomaticStart（允许自动启动）
3) AllowAutomaticStop（允许自动停止）
4) CollisionDetectEstablishedState（冲突检测已建立状态）
5) DampPeerOscillations（抑制对等体振荡）
6) DelayOpen（延迟打开）
7) DelayOpenTime（延迟打开时间）
8) DelayOpenTimer（延迟打开计时器）
9) IdleHoldTime（空闲保持时间）
10) IdleHoldTimer（空闲保持计时器）
11) PassiveTcpEstablishment（被动TCP建立）
12) SendNOTIFICATIONwithoutOPEN（无OPEN时发送通知）
13) TrackTcpState（跟踪TCP状态）

这些可选会话属性支持BGP功能的不同特性，影响BGP FSM状态转移。与计时器相关的两个属性组为：

- 组1：DelayOpen、DelayOpenTime、DelayOpenTimer
- 组2：DampPeerOscillations、IdleHoldTime、IdleHoldTimer

第一个参数（DelayOpen、DampPeerOscillations）是可选属性，表示计时器功能已激活。“Time”值指定“Timer”的初始值（DelayOpenTime、IdleHoldTime）。“Timer”表示实际的计时器。

请参阅第8.1.1节，了解这些可选属性与信号事件之间的交互关系。第8.2.1.3节还简要介绍了不同类型的可选属性（标志或计时器）。

以下是该英文内容的中文翻译：

```
                      DampPeerOscillations 逻辑的一个示例是
                      当一个 BGP 对等体在一定时间内反复出现连接（连接/断开）波动时，增加 IdleHoldTime 值。为了启用此逻辑，一个对等体可以在5分钟内连接和断开10次。此时，IdleHoldTime 的值会从0重置为120秒。

         取值：      TRUE 或 FALSE

         选项2：    AllowAutomaticStop（允许自动停止）

         描述：此BGP对等会话的可选属性表示该BGP连接允许“自动”停止。  
                      “自动”停止定义为由实现特定逻辑控制的停止。  
                      该实现特定逻辑超出了本规范的范围。

         取值：      TRUE 或 FALSE

         选项3：    DampPeerOscillations（抑制对等体振荡）

         描述：此可选会话属性指示BGP连接使用一种抑制Idle状态下BGP对等体振荡的逻辑。

         取值：      TRUE 或 FALSE

         选项4：    IdleHoldTime（空闲保持时间）

         描述：IdleHoldTime是设置在IdleHoldTimer中的值。

         取值：      以秒为单位的时间

         选项5：    IdleHoldTimer（空闲保持定时器）

         描述：IdleHoldTimer有助于控制BGP对等体的振荡。  
                      IdleHoldTimer用于让BGP对等体在特定时间内保持在空闲状态。  
                      IdleHoldTimer_Expires事件在第8.1.3节中描述。

         取值：      以秒为单位的时间

      第2组：未配置的对等体

         可选会话属性：AcceptConnectionsUnconfiguredPeers（接受未配置对等体的连接）

         选项1：    AcceptConnectionsUnconfiguredPeers（接受未配置对等体的连接）

         描述：BGP有限状态机（FSM）可选择接受来自未预配置邻居的BGP对等连接。  
                      “AcceptConnectionsUnconfiguredPeers”可选会话属性允许FSM支持状态转换，从而实现接受或拒绝这些未配置的对等体。

                      该属性具有安全隐患。详情请参阅BGP漏洞文档[RFC4272]。

         取值：      True 或 False

      第3组：TCP处理

         可选会话属性：PassiveTcpEstablishment（被动TCP建立），
                        TrackTcpState（跟踪TCP状态）

         选项1：    PassiveTcpEstablishment（被动TCP建立）

         描述：此选项表示BGP FSM将被动等待远端BGP对等体建立TCP连接。

         取值：      TRUE 或 FALSE

         选项2：    TrackTcpState（跟踪TCP状态）

         描述：通常，BGP FSM跟踪TCP连接尝试的最终结果，而非单个TCP消息。  
                      可选地，BGP FSM可以支持与TCP连接协商的额外交互。  
                      与TCP事件的交互可能会增加BGP对等连接所需的日志量和FSM状态变化次数。

         取值：      TRUE 或 FALSE

      第4组：BGP消息处理

         可选会话属性：DelayOpen（延迟打开），DelayOpenTime（延迟打开时间），
                        DelayOpenTimer（延迟打开定时器），
                        SendNOTIFICATIONwithoutOPEN（无OPEN消息发送通知），
                        CollisionDetectEstablishedState（碰撞检测已建立状态）

         选项1：    DelayOpen（延迟打开）

         描述：此可选会话属性允许实现配置延迟一定时间（DelayOpenTime）后再发送OPEN消息。  
                      这样可以让远端BGP对等体有时间发送第一个OPEN消息。

         取值：      TRUE 或 FALSE

         选项2：    DelayOpenTime（延迟打开时间）

         描述：DelayOpenTime是设置在DelayOpenTimer中的初始值。

         取值：      以秒为单位的时间

         选项3：    DelayOpenTimer（延迟打开定时器）

         描述：DelayOpenTimer是用于延迟在连接上发送OPEN消息的可选会话属性。  
                      DelayOpenTimer_Expires事件在第8.1.3节中描述。

         取值：      以秒为单位的时间

         选项4：    SendNOTIFICATIONwithoutOPEN（无OPEN消息发送通知）

         描述：此选项允许对等体在未先发送OPEN消息的情况下，直接发送NOTIFICATION消息。  
                      如果没有此可选会话属性，BGP连接假定对等体必须先发送OPEN消息，然后才能发送NOTIFICATION。

         取值：      TRUE 或 FALSE

         选项5：    CollisionDetectEstablishedState（碰撞检测已建立状态）

         描述：通常，在已建立状态下会忽略碰撞检测（见第6.8节）。  
                      此可选会话属性表示在已建立状态下也会处理碰撞。

         取值：      TRUE 或 FALSE

      注意：这些可选会话属性旨在澄清BGP FSM对现有BGP实现特性的描述。  
            它们可能在某些实现中预定义，且不可通过管理接口读取，特别是在现有正确实现中。  
            随着支持更新的BGP MIB（版本2及以后），这些字段将可以通过管理接口访问。

8.1.2.  管理事件

   管理事件是指操作界面和BGP策略引擎向BGP有限状态机（FSM）发出启动或停止信号的事件。  
   基本的启动和停止指示可以通过可选的连接属性进行补充，这些属性向BGP FSM信号特定的启动或停止机制。  
   例如，事件5“自动启动带被动TCP建立”即是此类组合的示例。  
   通过此事件，BGP实现向BGP FSM发出信号，表明实现使用带有被动TCP建立选项的自动启动。  
   被动TCP建立表示该BGP FSM将等待远端启动TCP建立。

   注意，只有事件1（手动启动）和事件2（手动停止）是强制的管理事件。  
   其他事件（3-8）为可选。  
   每个事件都包括名称、定义、状态（强制或可选）以及在每个阶段应设置的可选会话属性。  
   在为BGP FSM生成事件1至事件8时，会验证“可选属性状态”部分中规定的条件。  
   如果任何条件不满足，本地系统应记录FSM错误。

   可选会话属性的设置在某些实现中可能是隐式的，因此可能不会由外部操作明确设置。  
   第8.2.1.5节描述了这些隐式设置。  
   下面描述的管理状态在某些实现中也可能是隐式的，且不能由外部操作直接配置。

      事件1：ManualStart（手动启动）

         定义：本地系统管理员手动启动对等连接。

         状态：强制

         可选属性状态：  
             PassiveTcpEstablishment属性应设置为FALSE。

      事件2：ManualStop（手动停止）

         定义：本地系统管理员手动停止对等连接。

         状态：强制

         可选属性状态：  
             不与任何可选属性交互。

      事件3：AutomaticStart（自动启动）

         定义：本地系统自动启动BGP连接。

         状态：可选，取决于本地系统

         可选属性状态：  
             1）如果发生此事件，AllowAutomaticStart属性应设置为TRUE。  
             2）如果支持PassiveTcpEstablishment，应该设置为FALSE。  
             3）如果支持DampPeerOscillations，发生此事件时应设置为FALSE。

      事件4：ManualStart_with_PassiveTcpEstablishment（带被动TCP建立的手动启动）

         定义：本地系统管理员手动启动对等连接，但启用了PassiveTcpEstablishment。  
                      被动TCP建立表示在建立连接前，对等体会监听。

         状态：可选，取决于本地系统

         可选属性状态：  
             1）发生此事件时，PassiveTcpEstablishment应设置为TRUE。  
             2）DampPeerOscillations应设置为FALSE。

      事件5：AutomaticStart_with_PassiveTcpEstablishment（带被动TCP建立的自动启动）

         定义：本地系统自动启动BGP连接，启用PassiveTcpEstablishment。  
                      表示在建立连接前，对等体会监听。

         状态：可选，取决于本地系统

         可选属性状态：  
             1）AllowAutomaticStart应设置为TRUE。  
             2）PassiveTcpEstablishment应设置为TRUE。  
             3）如果支持DampPeerOscillations，应设置为FALSE。

      事件6：AutomaticStart_with_DampPeerOscillations（带振荡抑制的自动启动）

         定义：本地系统自动启动BGP对等连接，并启用对等振荡抑制。  
                      持续振荡抑制的具体方法由实现决定，不在本文范围内。

         状态：可选，取决于本地系统

         可选属性状态：  
             1）AllowAutomaticStart应设置为TRUE。  
             2）DampPeerOscillations应设置为TRUE。  
             3）PassiveTcpEstablishment应设置为FALSE。

      事件7：AutomaticStart_with_DampPeerOscillations_and_PassiveTcpEstablishment（同时启用振荡抑制和被动TCP建立的自动启动）

         定义：本地系统自动启动BGP对等连接，启用振荡抑制和被动TCP建立。  
                      持续振荡抑制的具体方法由实现决定。

         状态：可选，取决于本地系统

         可选属性状态：  
             1）AllowAutomaticStart应设置为TRUE。  
             2）DampPeerOscillations应设置为TRUE。  
             3）PassiveTcpEstablishment应设置为TRUE。

      事件8：AutomaticStop（自动停止）

         定义：本地系统自动停止BGP连接。

                     一个自动停止事件的示例是超过某个对等体的前缀数，导致本地系统自动断开连接。

         状态：可选，取决于本地系统

         可选属性状态：  
             1）AllowAutomaticStop应设置为TRUE。

8.1.3.  定时器事件

      事件9：ConnectRetryTimer_Expires（连接重试定时器到期）

         定义：当ConnectRetryTimer到期时生成的事件。

         状态：强制

      事件10：HoldTimer_Expires（保持定时器到期）

         定义：当HoldTimer到期时生成的事件。

         状态：强制

      事件11：KeepaliveTimer_Expires（保持存活定时器到期）

         定义：当KeepaliveTimer到期时生成的事件。

         状态：强制

      事件12：DelayOpenTimer_Expires（延迟打开定时器到期）

         定义：当DelayOpenTimer到期时生成的事件。

                     状态：可选

         可选属性状态：  
             如果发生此事件，  
             1）DelayOpen属性应设置为TRUE，  
             2）DelayOpenTime属性应支持，  
             3）DelayOpenTimer应支持。

      事件13：IdleHoldTimer_Expires（空闲保持定时器到期）

         定义：当IdleHoldTimer到期时生成的事件，表示BGP连接已完成等待以防止振荡的退避期。

                     IdleHoldTimer仅在启用持续振荡抑制功能（将DampPeerOscillations设置为TRUE）时使用。

                     未启用持续振荡抑制功能的实现可能没有IdleHoldTimer。

         状态：可选

         可选属性状态：  
             如果发生此事件：  
             1）DampPeerOscillations应设置为TRUE。  
             2）IdleHoldTimer刚刚到期。

8.1.4.  基于TCP连接的事件

      事件14：TcpConnection_Valid（TCP连接有效）

         定义：表示本地系统收到带有有效源IP地址、TCP端口、目标IP地址和TCP端口的TCP连接请求。  
                      无效源IP和无效目标IP的定义由实现决定。

                     BGP的目标端口应为179，由IANA定义。

                     TCP连接请求由本地系统收到TCP SYN表示。

         状态：可选

         可选属性状态：  
             如果发生此事件，TrackTcpState应设置为TRUE。

      事件15：Tcp_CR_Invalid（TCP连接请求无效）

         定义：表示本地系统收到的TCP连接请求，其源地址或端口号无效，或目标地址或端口号无效。

                     BGP的目标端口应为179，由IANA定义。

                     TCP连接请求发生在本地系统收到TCP SYN时。

         状态：可选

         可选属性状态：  
             如果发生此事件，TrackTcpState应设置为TRUE。

      事件16：Tcp_CR_Acked（TCP连接已确认）

         定义：表示本地系统请求建立TCP连接的事件。  
                      本地系统的TCP已发送SYN，收到SYN/ACK消息，并已发送ACK。

         状态：强制

      事件17：TcpConnectionConfirmed（TCP连接已确认）

         定义：表示本地系统已收到远端确认TCP连接已建立的事件。  
                      远端BGP对等体的TCP引擎已发送SYN，本地对等体的TCP引擎已发送SYN和ACK，并已收到最终的ACK。

         状态：强制

      事件18：TcpConnectionFails（TCP连接失败）

         定义：表示本地系统收到TCP连接失败通知的事件。  
                      远端BGP对等体的TCP端可能已发送FIN，本地对等体会响应FIN-ACK。  
                      另一种可能是本地对等体指示TCP连接超时并关闭连接。

         状态：强制

8.1.5.  基于BGP消息的事件

      事件19：BGPOpen（BGP打开消息）

         定义：收到有效的OPEN消息时生成的事件。

         状态：强制

         可选属性状态：  
             1）DelayOpen属性应设置为FALSE。  
             2）DelayOpenTimer不应在运行。

      事件20：BGPOpen带DelayOpenTimer运行（未完待续）

定义：当已成功建立传输连接且当前延迟发送BGP打开消息的对等体收到有效的OPEN消息时，会生成一个事件。

状态：可选

可选属性
状态：1）DelayOpen属性应设置为TRUE。2）DelayOpenTimer应处于运行状态。

事件21：BGPHeaderErr

定义：当接收到的BGP消息头不合法时，会生成一个事件。

状态：强制

事件22：BGPOpenMsgErr

定义：当接收到带有错误的OPEN消息时，会生成一个事件。

状态：强制

事件23：OpenCollisionDump

定义：在处理传入的OPEN消息时检测到连接冲突，并由管理机构生成的事件，此时已决定断开该连接。详见第6.8节关于冲突检测的更多信息。

事件23是由实现逻辑生成的管理操作，用于判断是否需要根据第6.8节的规则断开连接。如果有限状态机（FSM）作为两个关联的状态机实现，则可能发生此事件。

状态：可选

可选属性
状态：如果在已建立状态（Established）中处理此事件，
1）CollisionDetectEstablishedState（冲突检测已建立状态）应设置为TRUE。

请注意：OpenCollisionDump事件可以在空闲（Idle）、连接（Connect）、活动（Active）、已发送OPEN（OpenSent）和已确认OPEN（OpenConfirm）状态下发生，而无需设置任何可选属性。

事件24：NotifMsgVerErr

定义：当接收到“版本错误”的通知（NOTIFICATION）消息时，会生成一个事件。

状态：强制

事件25：NotifMsg

定义：当接收到通知消息且错误代码不是“版本错误”时，会生成一个事件。

状态：强制

事件26：KeepAliveMsg

定义：当接收到KEEPALIVE消息时，会生成一个事件。

状态：强制

事件27：UpdateMsg

定义：当接收到有效的UPDATE消息时，会生成一个事件。

状态：强制

事件28：UpdateMsgErr

定义：当接收到无效的UPDATE消息时，会生成一个事件。

状态：强制

8.2. 有限状态机（FSM）描述

8.2.1. FSM定义

每个配置的对等体（peer）都必须维护一个单独的FSM。每对潜在连接的BGP对等体会尝试相互连接，除非配置为保持在空闲状态（Idle）或被动状态（Passive）。在此讨论中，TCP连接的主动端（发起第一个TCP SYN包的一端）称为“出站（outgoing）”，被动端（发送第一个SYN/ACK的一端）称为“入站（incoming）”。（关于主动和被动的术语详见第8.2.1.1节。）

BGP实现必须在TCP端口179上监听入站连接，同时尝试连接对等体。每个入站连接都必须实例化一个状态机。在此期间，可能已知对端的身份，但尚未知道BGP标识符。在此期间，同一配置的对等体可能同时存在入站和出站连接，这被称为连接冲突（详见第6.8节）。

每个BGP实现最多为每个配置的对等体维护一个FSM，以及为尚未识别的每个入站TCP连接维护一个FSM。每个FSM对应一条TCP连接。

如果连接配置为使用不同的IP地址对，也可能存在多个连接。这被称为“多重配置对等”。

8.2.1.1. “主动”和“被动”术语

“主动”和“被动”这两个术语在互联网运营中已使用近十年，且非常有用。它们在应用于TCP连接或对等体时含义略有不同。每个TCP连接只有一个主动端和一个被动端，定义如上，且符合下述状态机。当BGP对等体配置为主动时，它可能最终处于已建立连接的主动端或被动端。一旦TCP连接建立，无论哪一端是主动端，哪一端是被动端，都不再重要。唯一的区别在于哪一端使用端口号179。

8.2.1.2. FSM与冲突检测

每个BGP连接对应一个FSM。当在确定连接所属的对等体之前发生连接冲突时，可能会出现两个连接对应同一对等体的情况。冲突解决后（详见第6.8节），应丢弃关闭的连接对应的FSM。

8.2.1.3. FSM与可选会话属性

可选会话属性可以是作为标志（TRUE或FALSE）或可选定时器的属性。对于作为标志的可选属性，如果系统支持将其设置为TRUE，则必须支持相应的BGP FSM操作。例如，如果可以在BGP实现中设置AutoStart和PassiveTcpEstablishment两个选项，则必须支持事件3、4和5。如果某个可选会话属性不能设置为TRUE，则不必支持支持该组选项的事件。

每个可选定时器（DelayOpenTimer和IdleHoldTimer）都包含一组属性：

- 支持标志
- 定时器设置的时间
- 定时器

这两个可选定时器的格式如下：

DelayOpenTimer：DelayOpen、DelayOpenTime、DelayOpenTimer  
IdleHoldTimer：DampPeerOscillations、IdleHoldTime、IdleHoldTimer

如果不能将支持某个可选定时器（如DelayOpen或DampPeerOscillations）的标志设置为TRUE，则不必支持对应的定时器和事件。

8.2.1.4. FSM事件编号

本状态机描述中使用的事件编号（1-28）有助于定义BGP状态机的行为。实现可以使用这些编号提供网络管理信息。具体的FSM或事件形式因实现而异。

8.2.1.5. 实现依赖的FSM操作

在某些时刻，BGP FSM会指定进行BGP初始化或删除BGP资源。BGP FSM的初始化和相关资源的管理依赖于BGP实现的策略部分。这些操作的细节超出本文档的范围。

8.2.2. 有限状态机（FSM）流程

空闲状态（Idle）：

- 初始时，BGP对等体FSM处于空闲状态。此后，简称“BGP FSM”。

- 在此状态下，BGP FSM拒绝所有入站连接，不为对等体分配资源。在收到手动启动（Event 1）或自动启动（Event 3）事件后，本地系统会：

  - 初始化所有对等连接的BGP资源，

  - 将ConnectRetryCounter置零，

  - 启动带有初始值的ConnectRetryTimer，

  - 向另一对等体发起TCP连接，

  - 监听可能由远端对等体发起的连接，

  - 将状态变更为“连接（Connect）”。

- 对于手动停止（Event 2）和自动停止（Event 8）事件，在空闲状态下会被忽略。

- 对于“带被动TCP建立的手动启动（Event 4）”或“带被动TCP建立的自动启动（Event 5）”事件，本地系统会：

  - 初始化所有BGP资源，

  - 将ConnectRetryCounter置零，

  - 启动带有初始值的ConnectRetryTimer，

  - 监听可能由远端发起的连接，

  - 将状态变更为“活动（Active）”。

- ConnectRetryTimer的具体值由本地决定，但应足够大以允许TCP初始化。

- 如果设置了DampPeerOscillations属性为TRUE，则在空闲状态下可能发生以下三种额外事件：

  - 自动启动带抑制对等体振荡（Event 6），

  - 自动启动带抑制对等体振荡和被动TCP建立（Event 7），

  - IdleHoldTimer到期（Event 13）。

  收到这三种事件后，本地系统将利用这些事件防止对等体振荡。防止持续对等体振荡的方法超出本文档范围。

- 在空闲状态下，任何其他事件（Events 9-12、15-28）都不会引起状态变化。

连接状态（Connect）：

- 在此状态下，BGP FSM等待TCP连接完成。

- 在连接状态下，启动事件（Events 1、3-7）会被忽略。

- 收到手动停止（Event 2）事件后，本地系统会：

  - 断开TCP连接，

  - 释放所有BGP资源，

  - 将ConnectRetryCounter置零，

  - 停止ConnectRetryTimer并将其设置为零，

  - 将状态变更为“空闲（Idle）”。

- 收到ConnectRetryTimer到期（Event 9）后，本地系统会：

  - 断开TCP连接，

  - 重新启动ConnectRetryTimer，

  - 停止DelayOpenTimer并将其重置为零，

  - 向对端发起TCP连接，

  - 继续监听可能由远端发起的连接，

  - 保持在“连接”状态。

- 如果在连接状态下发生DelayOpenTimer到期（Event 12），本地系统会：

  - 发送OPEN消息给对端，

  - 将HoldTimer设置为较大值，

  - 将状态变为“OpenSent”。

- 如果收到TcpConnection_Valid事件（Event 14），TCP连接被确认，连接保持在“连接”状态。

- 如果收到Tcp_CR_Invalid事件（Event 15），本地系统会拒绝TCP连接，连接仍在“连接”状态。

- 如果TCP连接成功（Event 16或17），在处理之前，本地系统会检查DelayOpen属性。如果设置为TRUE，则：

  - 停止（如果在运行）并将ConnectRetryTimer设为零，

  - 将DelayOpenTimer设为初始值，

  - 保持在“连接”状态。

- 如果DelayOpen属性为FALSE，则：

  - 停止（如果在运行）并将ConnectRetryTimer设为零，

  - 完成BGP初始化，

  - 发送OPEN消息给对端，

  - 将HoldTimer设置为较大值，

  - 状态变为“OpenSent”。

建议HoldTimer为4分钟。

- 如果TCP连接失败（Event 18），本地系统会检查DelayOpenTimer。如果DelayOpenTimer在运行，则：

  - 以初始值重新启动ConnectRetryTimer，

  - 停止DelayOpenTimer并重置为零，

  - 继续监听可能由远端发起的连接，

  - 状态变为“活动（Active）”。

- 如果DelayOpenTimer未在运行，则：

  - 停止（设为零）ConnectRetryTimer，

  - 断开TCP连接，

  - 释放所有BGP资源，

  - 状态变为“空闲（Idle）”。

- 在DelayOpenTimer运行时收到OPEN消息（Event 20），本地系统会：

  - 停止（如果在运行）并将ConnectRetryTimer设为零，

  - 完成BGP初始化，

  - 停止并清除DelayOpenTimer（设为零），

  - 发送OPEN消息，

  - 发送KEEPALIVE消息，

  - 如果HoldTimer的初始值非零，则：

    - 启动KeepaliveTimer，设为初始值，

    - 将HoldTimer重置为协商值，

  - 否则（初始值为零）：

    - 重置KeepaliveTimer，

    - 将HoldTimer设为零。

  - 状态变为“OpenConfirm”。

- 如果自治系统字段的值与本地自治系统号相同，则连接状态设为“内部连接（internal）”；否则为“外部连接（external）”。

如果在检查BGP消息头（事件21）或OPEN消息（事件22）时检测到错误（详见第6.2节），本地系统将执行以下操作：

- （可选）如果SendNOTIFICATIONwithoutOPEN属性被设置为TRUE，则本地系统首先发送带有相应错误代码的NOTIFICATION消息，然后
- 停止（如果正在运行的话）ConnectRetryTimer，并将其设置为零，
- 释放所有BGP资源，
- 断开TCP连接，
- 将ConnectRetryCounter加一，
- （可选）如果DampPeerOscillations属性被设置为TRUE，则执行对等体振荡抑制，
- 将状态切换为Idle。

如果收到带有版本错误的NOTIFICATION消息（事件24），本地系统会检查DelayOpenTimer。如果DelayOpenTimer正在运行，则：

- 停止（如果正在运行的话）ConnectRetryTimer，并将其设置为零，
- 停止并重置DelayOpenTimer（设置为零），
- 释放所有BGP资源，
- 断开TCP连接，
- 将状态切换为Idle。

如果DelayOpenTimer未在运行中，本地系统会：

- 停止并重置ConnectRetryTimer（设置为零），
- 释放所有BGP资源，
- 断开TCP连接，
- 将ConnectRetryCounter加一，
- 如果DampPeerOscillations属性被设置为TRUE，则执行对等体振荡抑制，
- 将状态切换为Idle。

对于其他任何事件（事件8、10-11、13、19、23、25-28），本地系统将：

- 如果ConnectRetryTimer正在运行，则停止并重置它（设置为零），
- 如果DelayOpenTimer正在运行，则停止并重置它（设置为零），
- 释放所有BGP资源，
- 断开TCP连接，
- 将ConnectRetryCounter加一，
- 如果DampPeerOscillations属性被设置为TRUE，则执行对等体振荡抑制，
- 将状态切换为Idle。

活动状态（Active State）：

在此状态下，BGP有限状态机（FSM）试图通过监听和接受TCP连接来获取对等体。

在活动状态下，启动事件（事件1、3-7）被忽略。

响应手动停止事件（事件2），本地系统将：

- 如果DelayOpenTimer正在运行且SendNOTIFICATIONwithoutOPEN会话属性被设置，则发送带有“停止”代码的NOTIFICATION，
- 释放所有BGP资源，包括停止DelayOpenTimer，
- 断开TCP连接，
- 将ConnectRetryCounter设为零，
- 停止（如果正在运行的话）ConnectRetryTimer并将其设置为零，
- 将状态切换为Idle。

响应ConnectRetryTimer_Expires事件（事件9），本地系统将：

- 重新启动ConnectRetryTimer（使用初始值），
- 启动到另一BGP对等体的TCP连接，
- 继续监听可能由远程BGP对等体发起的TCP连接，
- 将状态切换为Connect。

如果本地系统收到DelayOpenTimer_Expires事件（事件12），则：

- 将ConnectRetryTimer设置为零，
- 停止并重置DelayOpenTimer（设置为零），
- 完成BGP初始化，
- 向远程对等体发送OPEN消息，
- 将保持计时器（HoldTimer）设置为较大值，
- 将状态切换为OpenSent。

建议此状态转换中的HoldTimer值为4分钟。

如果本地系统收到TcpConnection_Valid事件（事件14），则处理TCP连接标志后仍保持在活动状态。

如果收到Tcp_CR_Invalid事件（事件15），则拒绝TCP连接并保持在活动状态。

当TCP连接成功（事件16或17）时，本地系统会在处理前检查DelayOpen可选属性：

- 如果DelayOpen属性被设置为TRUE，则：
  - 停止ConnectRetryTimer并将其设置为零，
  - 将DelayOpenTimer设置为初始值（DelayOpenTime），
  - 仍保持在活动状态。

- 如果DelayOpen属性被设置为FALSE，则：
  - 将ConnectRetryTimer设置为零，
  - 完成BGP初始化，
  - 向对等体发送OPEN消息，
  - 将HoldTimer设置为较大值，
  - 将状态切换为OpenSent。

建议此“较大值”为4分钟。

如果收到TcpConnectionFails事件（事件18），则：

- 重新启动ConnectRetryTimer（使用初始值），
- 停止并重置DelayOpenTimer（设置为零），
- 释放所有BGP资源，
- 将ConnectRetryCounter加一，
- 如果DampPeerOscillations属性被设置为TRUE，则执行对等体振荡抑制，
- 将状态切换为Idle。

如果收到OPEN消息且DelayOpenTimer正在运行（事件20），则：

- 停止（如果正在运行的话）ConnectRetryTimer并将其设置为零，
- 停止并重置DelayOpenTimer（设置为零），
- 完成BGP初始化，
- 发送OPEN消息，
- 发送KEEPALIVE消息，
- 如果HoldTimer值非零：
  - 启动KeepaliveTimer（使用初始值），
  - 将HoldTimer重置为协商值，
- 否则（HoldTimer为零）：
  - 重置KeepaliveTimer（设置为零），
  - 将HoldTimer重置为零，
- 将状态切换为OpenConfirm。

建议HoldTimer的“较大值”为4分钟。

如果收到TcpConnectionFails事件（事件18），则：

- 重新启动ConnectRetryTimer（使用初始值），
- 停止并重置DelayOpenTimer（设置为零），
- 释放所有BGP资源，
- 将ConnectRetryCounter加一，
- 如果DampPeerOscillations属性被设置为TRUE，则执行对等体振荡抑制，
- 将状态切换为Idle。

当收到OPEN消息且DelayOpenTimer正在运行时（事件20），本地系统将：

- 停止（如果正在运行的话）ConnectRetryTimer并将其设置为零，
- 停止并重置DelayOpenTimer（设置为零），
- 完成BGP初始化，
- 发送OPEN消息，
- 发送KEEPALIVE消息，
- 如果HoldTimer值非零：
  - 启动KeepaliveTimer（使用初始值），
  - 将HoldTimer重置为协商值，
- 否则（HoldTimer为零）：
  - 重置KeepaliveTimer（设置为零），
  - 将HoldTimer重置为零，
- 将状态切换为OpenConfirm。

如果自治系统字段的值与本地自治系统号相同，则连接状态为内部连接，否则为外部连接（这会影响后续的UPDATE处理）。

如果在检查BGP消息头（事件21）或OPEN消息（事件22）时检测到错误（详见第6.2节），本地系统将：

- （可选）如果SendNOTIFICATIONwithoutOPEN属性被设置为TRUE，则发送带有相应错误代码的NOTIFICATION，
- 将ConnectRetryTimer设置为零，
- 释放所有BGP资源，
- 断开TCP连接，
- 将ConnectRetryCounter加一，
- （可选）如果DampPeerOscillations属性被设置为TRUE，则执行对等体振荡抑制，
- 将状态切换为Idle。

如果收到带有版本错误的NOTIFICATION消息（事件24），本地系统会检查DelayOpenTimer。如果DelayOpenTimer正在运行，则：

- 停止（如果正在运行的话）ConnectRetryTimer并将其设置为零，
- 停止并重置DelayOpenTimer（设置为零），
- 释放所有BGP资源，
- 断开TCP连接，
- 将状态切换为Idle。

如果DelayOpenTimer未在运行中，本地系统会：

- 将ConnectRetryTimer设置为零，
- 释放所有BGP资源，
- 断开TCP连接，
- 将ConnectRetryCounter加一，
- （可选）如果DampPeerOscillations属性被设置为TRUE，则执行对等体振荡抑制，
- 将状态切换为Idle。

对于其他任何事件（事件8、10-11、13、19、23、25-28），本地系统将：

- 将ConnectRetryTimer设置为零，
- 释放所有BGP资源，
- 断开TCP连接，
- 将ConnectRetryCounter加一，
- （可选）如果DampPeerOscillations属性被设置为TRUE，则执行对等体振荡抑制，
- 将状态切换为Idle。

- （可选）如果将DampPeerOscillations属性设置为TRUE，则执行对等体振荡抑制，

- 将其状态更改为空闲（Idle）。

开放确认状态（OpenConfirm State）：

在此状态下，BGP等待KEEPALIVE或NOTIFICATION消息。

在开放确认状态（OpenConfirm）中，任何启动事件（事件1、3-7）都被忽略。

对于由操作员发起的手动停止事件（Event 2），本地系统会：

- 发送带有停止（Cease）的通知消息，

- 释放所有BGP资源，

- 断开TCP连接，

- 将ConnectRetryCounter重置为零，

- 将ConnectRetryTimer重置为零，

- 将状态更改为空闲（Idle）。

对于由系统自动发起的停止事件（Event 8），本地系统会：

- 发送带有停止（Cease）的通知消息，

- 将ConnectRetryTimer重置为零，

- 释放所有BGP资源，

- 断开TCP连接，

- 将ConnectRetryCounter加一，

- （可选）如果DampPeerOscillations属性设置为TRUE，则执行对等体振荡抑制，

- 将状态更改为空闲（Idle）。

如果在收到KEEPALIVE消息之前发生HoldTimer_Expires事件（Event 10），本地系统会：

- 发送带有错误代码“Hold Timer Expired”的通知消息，

- 将ConnectRetryTimer重置为零，

- 释放所有BGP资源，

- 断开TCP连接，

- 将ConnectRetryCounter加一，

- （可选）如果DampPeerOscillations属性设置为TRUE，则执行对等体振荡抑制，

- 将状态更改为空闲（Idle）。

如果本地系统收到KeepaliveTimer_Expires事件（Event 11），则：

- 发送KEEPALIVE消息，

- 重新启动KeepaliveTimer，

- 保持在OpenConfirmed状态。

在TcpConnection_Valid事件（Event 14）或在OpenConfirm状态下TCP连接成功（事件16或17）时，本地系统需要跟踪第二个连接。

如果尝试在无效端口建立TCP连接（事件15），本地系统将忽略第二次连接尝试。

如果本地系统收到来自底层TCP的TcpConnectionFails事件（Event 18）或NOTIFICATION消息（事件25），则：

- 将ConnectRetryTimer重置为零，

- 释放所有BGP资源，

- 断开TCP连接，

- 将ConnectRetryCounter加一，

- （可选）如果DampPeerOscillations属性设置为TRUE，则执行对等体振荡抑制，

- 将状态更改为空闲（Idle）。

如果本地系统收到带有版本错误的NOTIFICATION消息（NotifMsgVerErr，事件24），则：

- 将ConnectRetryTimer重置为零，

- 释放所有BGP资源，

- 断开TCP连接，

- 将状态更改为空闲（Idle）。

如果收到有效的OPEN消息（BGPOpen，事件19），则根据第6.8节处理碰撞检测功能。如果由于连接碰撞需要断开此连接，本地系统会：

- 发送带有停止（Cease）的NOTIFICATION，

- 将ConnectRetryTimer重置为零，

- 释放所有BGP资源，

- 断开TCP连接（发送TCP FIN），

- 将ConnectRetryCounter加一，

- （可选）如果DampPeerOscillations属性设置为TRUE，则执行对等体振荡抑制，

- 将状态更改为空闲（Idle）。

如果收到OPEN消息，所有字段都将被检查其正确性。如果BGP消息头检查（BGPHeaderErr，事件21）或OPEN消息检查（BGPOpenMsgErr，事件22）检测到错误（详见第6.2节），则本地系统会：

- 发送带有相应错误代码的NOTIFICATION消息，

- 将ConnectRetryTimer重置为零，

- 释放所有BGP资源，

- 断开TCP连接，

- 将ConnectRetryCounter加一，

- （可选）如果DampPeerOscillations属性设置为TRUE，则执行对等体振荡抑制，

- 将状态更改为空闲（Idle）。

在处理另一个OPEN消息的过程中，如果BGP实现通过本文件未涵盖的手段判断发生了连接碰撞且需要关闭此连接，本地系统会发出OpenCollisionDump事件（事件23）。当本地系统收到OpenCollisionDump事件（事件23）时，会：

- 发送带有停止（Cease）的NOTIFICATION，

- 将ConnectRetryTimer重置为零，

- 释放所有BGP资源，

- 断开TCP连接，

- 将ConnectRetryCounter加一，

- （可选）如果DampPeerOscillations属性设置为TRUE，则执行对等体振荡抑制，

- 将状态更改为空闲（Idle）。

如果本地系统收到KEEPALIVE消息（KeepAliveMsg，事件26），则：

- 重新启动HoldTimer，

- 将状态更改为已建立（Established）。

对于任何其他事件（事件9、12-13、20、27-28），本地系统会：

- 发送带有有限状态机错误（Finite State Machine Error）代码的NOTIFICATION消息，

- 将ConnectRetryTimer重置为零，

- 释放所有BGP资源，

- 断开TCP连接，

- 将ConnectRetryCounter加一，

- （可选）如果DampPeerOscillations属性设置为TRUE，则执行对等体振荡抑制，

- 将状态更改为空闲（Idle）。

已建立状态（Established State）：

在已建立状态下，BGP有限状态机可以与对等体交换UPDATE、NOTIFICATION和KEEPALIVE消息。

在已建立状态（Established）中，任何启动事件（事件1、3-7）都被忽略。

对于由操作员发起的手动停止事件（Event 2），本地系统会：

- 发送带有停止（Cease）的通知消息，

- 将ConnectRetryTimer重置为零，

- 删除与此连接相关的所有路由，

- 释放BGP资源，

- 断开TCP连接，

- 将ConnectRetryCounter重置为零，

- 将状态更改为空闲（Idle）。

对于由系统自动发起的停止事件（Event 8），本地系统会：

- 发送带有停止（Cease）的通知消息，

- 将ConnectRetryTimer重置为零，

- 删除与此连接相关的所有路由，

- 释放所有BGP资源，

- 断开TCP连接，

- 将ConnectRetryCounter加一，

- （可选）如果DampPeerOscillations属性设置为TRUE，则执行对等体振荡抑制，

- 将状态更改为空闲（Idle）。

自动停止事件的一个原因是：BGP收到的UPDATE消息中包含的前缀数量超过了配置的最大前缀数，导致本地系统自动断开对等体连接。

如果发生HoldTimer_Expires事件（事件10），本地系统会：

- 发送带有错误代码“Hold Timer Expired”的NOTIFICATION消息，

- 将ConnectRetryTimer重置为零，

- 释放所有BGP资源，

- 断开TCP连接，

- 将ConnectRetryCounter加一，

- （可选）如果DampPeerOscillations属性设置为TRUE，则执行对等体振荡抑制，

- 将状态更改为空闲（Idle）。

如果发生KeepaliveTimer_Expires事件（事件11），本地系统会：

- 发送KEEPALIVE消息，

- 重新启动KeepaliveTimer，除非协商的HoldTime值为零。

每次本地系统发送KEEPALIVE或UPDATE消息时，都会重新启动KeepaliveTimer，除非协商的HoldTime值为零。

收到有效端口的TcpConnection_Valid事件（事件14）会导致跟踪第二个连接。

无效的TCP连接（Tcp_CR_Invalid事件，事件15）将被忽略。

当TCP连接成功建立的指示（事件16或17）被接收时，第二个连接应持续跟踪，直到它发送OPEN消息。

如果收到有效的OPEN消息（BGPOpen，事件19），且CollisionDetectEstablishedState（碰撞检测已建立状态）可选属性为TRUE，则会检查OPEN消息是否与其他连接发生碰撞（第6.8节）。如果BGP实现判断需要终止此连接，则会处理OpenCollisionDump事件（事件23）。如果需要终止此连接，本地系统会：

- 发送带有停止（Cease）的NOTIFICATION，

- 将ConnectRetryTimer重置为零，

- 删除与此连接相关的所有路由，

- 释放所有BGP资源，

- 断开TCP连接，

- 将ConnectRetryCounter加一，

- （可选）如果DampPeerOscillations设置为TRUE，则执行对等体振荡抑制，

- 将状态更改为空闲（Idle）。

如果本地系统收到NOTIFICATION消息（事件24或25）或底层TCP的TcpConnectionFails（事件18），则：

- 将ConnectRetryTimer重置为零，

- 删除与此连接相关的所有路由，

- 释放所有BGP资源，

- 断开TCP连接，

- 将ConnectRetryCounter加一，

- 将状态更改为空闲（Idle）。

如果收到KEEPALIVE消息（事件26），则：

- 重新启动HoldTimer（如果协商的HoldTime非零），

- 保持在已建立（Established）状态。

如果收到UPDATE消息（事件27），则：

- 处理该消息，

- 重新启动HoldTimer（如果协商的HoldTime非零），

- 保持在已建立（Established）状态。

如果收到UPDATE消息，并且UPDATE消息错误处理程序（第6.3节）检测到错误（事件28），则：

- 发送带有更新错误的NOTIFICATION消息，

- 将ConnectRetryTimer重置为零，

- 删除与此连接相关的所有路由，

- 释放所有BGP资源，

- 断开TCP连接，

- 将ConnectRetryCounter加一，

- （可选）如果DampPeerOscillations属性设置为TRUE，则执行对等体振荡抑制，

- 将状态更改为空闲（Idle）。

对于任何其他事件（事件9、12-13、20-22），本地系统会：

- 发送带有有限状态机错误（Finite State Machine Error）代码的NOTIFICATION消息，

- 删除与此连接相关的所有路由，

- 将ConnectRetryTimer重置为零，

- 释放所有BGP资源，

- 断开TCP连接，

- 将ConnectRetryCounter加一，

- （可选）如果DampPeerOscillations属性设置为TRUE，则执行对等体振荡抑制，

- 将状态更改为空闲（Idle）。

9.  UPDATE消息处理

UPDATE消息只能在已建立（Established）状态下接收。在其他任何状态下接收UPDATE消息都是错误的。当接收到UPDATE消息时，将按照第6.3节的规定检查每个字段的有效性。

如果未识别的可选非传递性属性，则会被静默忽略。如果未识别的可选传递性属性，则在属性标志字节（octet）中的第三个高位（Partial位）将被设置为1，并且该属性会被保留以便传播到其他BGP对等体。

如果识别到的可选属性具有有效值，则根据该属性的类型进行本地处理、保留，并在必要时更新，以便可能传播到其他BGP对等体。

如果UPDATE消息包含非空的WITHDRAWN ROUTES字段，则之前广告的路由（其目的地以IP前缀表示）应从Adj-RIB-In中移除。此时，BGP对等体应运行其决策过程，因为之前广告的路由不再可用。

如果UPDATE消息包含可行路由，则Adj-RIB-In将用此路由更新：如果新路由的NLRI与当前存储在Adj-RIB-In中的路由相同，则新路由将取代旧路由，隐式撤销旧路由的服务；否则，如果Adj-RIB-In中没有NLRI与新路由相同的路由，则新路由将被加入到Adj-RIB-In中。

一旦BGP对等体更新了Adj-RIB-In，它应运行其决策过程。

决策过程通过将本地策略信息库（PIB）中的策略应用于存储在其邻接路由信息库（Adj-RIBs-In）中的路由，选择后续要广告的路由。决策过程的输出是将要向对等体广告的路由集；被选中的路由将根据策略存储在本地发言人的Adj-RIBs-Out中。

这里描述的BGP决策过程是概念性的，并不要求严格按照描述实现，只要实现支持所述功能并表现出相同的外部可见行为即可。

选择过程通过定义一个函数来形式化，该函数以某个路由的属性作为参数，返回以下值之一：(a) 表示对该路由偏好程度的非负整数，或 (b) 表示该路由不符合安装到本地路由信息库（Loc-RIB）条件、将在下一阶段路由选择中被排除的值。

计算某个路由偏好程度的函数不得使用以下任何作为输入：其他路由的存在与否、其他路由的非存在性、或其他路由的路径属性。路由选择包括对每个可行路由单独应用偏好程度函数，然后选择偏好程度最高的路由。

决策过程在邻接路由信息库（Adj-RIBs-In）中的路由上操作，负责：

- 选择本地发言人将使用的路由
- 选择要广告给其他BGP对等体的路由
- 路由聚合和信息简化

决策过程分为三个不同的阶段，每个阶段由不同事件触发：

a) 阶段1：负责计算每个从对等体接收的路由的偏好程度。

b) 阶段2：在阶段1完成后调用，负责从所有可用的不同目的地的路由中选择最佳路由，并将每个选中的路由安装到本地路由信息库（Loc-RIB）。

c) 阶段3：在本地路由信息库被修改后调用，负责根据PIB中的策略，将Loc-RIB中的路由传播到每个对等体。此阶段可以选择性地进行路由聚合和信息简化。

9.1.1 阶段1：偏好程度的计算

每当本地BGP发言人从对等体接收到广告新路由、替换路由或撤销路由的UPDATE消息时，都会调用阶段1的决策函数。该函数是一个独立的过程，完成时表示没有更多工作。

在操作任何包含在Adj-RIB-In中的路由之前，阶段1的决策函数会锁定该邻接路由信息库，操作完成后再解锁。

对于每个新接收或替换的可行路由，本地BGP发言人会按如下方式确定偏好程度：

- 如果路由来自内部对等体，则偏好值为LOCAL_PREF属性的值，或由本地系统根据预配置的策略信息计算得出。注意，后者可能导致持久性路由环的形成。

- 如果路由来自外部对等体，则偏好值由本地BGP发言人根据预配置策略信息计算。如果返回值表明该路由不符合条件（不合格），则该路由不能作为下一阶段路由选择的输入；否则，该偏好值必须作为IBGP重新广告时的LOCAL_PREF值。

此策略信息的具体性质和计算方式由本地实现决定。

9.1.2 阶段2：路由选择

阶段2的决策函数在阶段1完成后调用，是一个独立的过程，完成时表示没有更多工作。它会考虑所有在Adj-RIBs-In中符合条件的路由。

在阶段3的决策过程中，阶段2被阻止运行。它在开始前锁定所有Adj-RIBs-In，完成后解锁。

如果某个BGP路由的NEXT_HOP属性指向的地址无法解析，或者如果将该路由安装到路由表中会导致地址变得无法解析，则该路由必须从阶段2的决策中排除。

如果BGP路由的AS_PATH属性中包含AS环路，则该路由也应从阶段2中排除。AS环路检测通过扫描完整的AS路径（在AS_PATH属性中指定），确认本地系统的自治系统编号不出现在路径中。配置为接受包含自身自治系统编号的路由的BGP发言人的操作超出本文范围。

确保AS内的BGP发言人不会做出导致转发环路的冲突决策至关重要。

对于每个在Adj-RIBs-In中存在可行路由的目的地集，本地BGP发言人会识别出具有以下特征的路由：

a) 对同一目的地集，偏好程度最高的路由，或

b) 该目的地唯一的路由，或

c) 根据第9.1.2.2节中规定的阶段2打破平局的规则所选的路由。

然后，发言人应将该路由安装到Loc-RIB中，替换掉当前存放在Loc-RIB中的任何到相同目的地的路由。在将新BGP路由安装到路由表时，必须确保将那些现在被视为无效的到相同目的地的旧路由从路由表中删除。新BGP路由是否替换路由表中的非BGP路由，取决于BGP发言人配置的策略。

发言人必须根据所选路由的NEXT_HOP属性（参见第5.1.3节）确定下一跳地址。如果立即下一跳或到NEXT_HOP的IGP路径成本发生变化，则必须重新执行阶段2的路由选择。

注意，尽管BGP路由不一定要在路由表中安装其立即下一跳地址，实施者必须确保在转发任何数据包之前，将其关联的NEXT_HOP地址解析为直接连接的下一跳地址，并最终使用该地址（或多个地址）进行实际的数据包转发。

不可解析的路由应从Loc-RIB和路由表中删除，但相应的不可解析路由应保留在Adj-RIBs-In中，以备将来可能变得可解析。

9.1.2.1 路由可解析性条件

如第9.1.2节所述，BGP发言人应排除不可解析的路由，以确保只在Loc-RIB和路由表中安装有效的路由。

路由可解析性条件定义如下：

1) 仅引用中间网络地址的路由Rte1，如果路由表中存在至少一条可解析的路由Rte2，且Rte2匹配Rte1的中间网络地址，且Rte2不是通过Rte1递归解析（直接或间接）得出，则Rte1被视为可解析的。如果有多条匹配的路由，只考虑最长匹配的那一条。

2) 引用接口（有或没有中间地址）的路由，如果被引用的接口状态为up且启用了IP处理，则视为可解析。

BGP路由不直接引用接口，但可以通过路由表中的路由（既可以指定接口，也可以不指定）进行解析。预期中，IGP路由和直接连接网络的路由会指定出接口。静态路由可以指定出接口、中间地址或两者。

注意：当BGP发言人的路由表中没有匹配的NEXT_HOP路由时，BGP路由被视为不可解析。相互递归的路由（互相解析或自我解析）也会导致不可解析。

此外，实施者不应将那些在当前路由表内容下看似可解析，但若安装到路由表中会变得不可解析的路由（如互相递归的路由）视为可行路由。此检查确保发言人不会安装将被删除且不被使用的路由，从而维护路由表的稳定性，也改善协议在网络中的表现。

每当发言人发现因相互递归而导致不可解析的路由时，应记录错误信息。

9.1.2.2 打破平局（阶段2）

在邻接路由信息库（Adj-RIBs-In）中，发言人可能拥有多个到同一目的地、偏好程度相同的路由。发言人只能将其中一条路由选入相关的Loc-RIB。发言人会考虑所有偏好程度相同的路由，包括来自内部对等体和外部对等体的。

以下的打破平局规则假设：每个候选路由的路径成本（内部距离）对同一自治系统内的所有BGP发言人都是可知的，并遵循相同的路由选择算法。

打破平局的算法从考虑所有偏好相等的路由开始，然后逐步排除不符合条件的路由，直到只剩下一条路由。必须按指定的顺序应用这些标准。

部分标准用伪代码描述。注意，所示伪代码为清晰起见而非效率优先，并非特定实现的规范。BGP实现可以使用任何产生相同结果的算法。

a) 排除所有AS_PATH属性中AS编号最少的路由（即，去除所有AS_PATH中AS数量不最少的路由）。在计数时，AS_SET算作1，无论其中有多少个AS。

b) 排除所有Origin属性中具有非最低值的路由。

c) 排除具有较低优先级的MULTI_EXIT_DISC属性的路由。MULTI_EXIT_DISC只在来自同一邻居AS的路由间比较（邻居AS由AS_PATH属性确定）。没有该属性的路由视为具有最低的MULTI_EXIT_DISC值（即0）。

对应的伪代码示例如下：

```
for m = 所有仍在考虑中的路由
    for n = 所有仍在考虑中的路由
        if (neighborAS(m) == neighborAS(n)) 且 (MED(n) < MED(m))
            移除路由m
```

其中，MED(n)是返回路由n的MULTI_EXIT_DISC属性值的函数。如果路由n没有该属性，函数返回最低值（0）。

类似地，neighborAS(n) 是一个函数，返回接收该路由的邻居自治系统（AS）。如果该路由是通过 IBGP 学习到的，并且其他 IBGP 端没有发起该路由，则 neighborAS(n) 表示其他 IBGP 端学习到该路由的邻居 AS。如果该路由是通过 IBGP 学习到的，并且其他 IBGP 端要么（a）自己发起了该路由，要么（b）通过聚合创建了该路由，并且该聚合路由的 AS_PATH 属性为空或以 AS_SET 开头，则该邻居 AS 为本地 AS。

如果在将路由重新广告到 IBGP 之前移除了 MULTI_EXIT_DISC 属性，则仍可以基于接收的 EBGP MULTI_EXIT_DISC 属性进行比较。如果实现选择移除 MULTI_EXIT_DISC，则对 MULTI_EXIT_DISC 的可选比较（如果进行）必须仅在 EBGP 学习的路由之间进行。然后，可以将最优的 EBGP 学习路由与 IBGP 学习的路由进行比较，前提是移除了 MULTI_EXIT_DISC 属性。如果从一部分 EBGP 学习的路由中移除了 MULTI_EXIT_DISC，而所选的“最佳”EBGP 路由未被移除 MULTI_EXIT_DISC，则必须在与 IBGP 学习路由的比较中使用 MULTI_EXIT_DISC。对于 IBGP 学习的路由，必须在决策流程的此步骤中使用 MULTI_EXIT_DISC 进行路由比较。将 EBGP 学习路由的 MULTI_EXIT_DISC 属性包含在与 IBGP 路由的比较中，然后移除该属性，且广告该路由，已被证明会导致路由环路。

d) 如果至少有一条候选路由是通过 EBGP 接收的，则应排除所有通过 IBGP 接收的路由。

e) 排除所有内部成本较低的路由。路由的内部成本通过使用路由表计算到下一跳（NEXT_HOP）的度量值来确定。如果某条路由的下一跳可达，但无法确定成本，则应跳过此步骤（等同于认为所有路由具有相等的成本）。

这也在以下伪代码中描述：

```
for m = 所有仍在考虑中的路由
    for n = 所有仍在考虑中的路由
        if (cost(n) 比 cost(m) 低)
            移除 m
```

其中，cost(n) 是一个函数，返回到路由的 NEXT_HOP 属性所指地址的路径（内部距离）的成本。

f) 排除所有除由 BGP 端点（BGP speaker）以最低 BGP 标识符（BGP Identifier）广告的路由之外的所有路由。

g) 优先选择来自最低对等体地址的路由。

9.1.3  阶段 3：路由传播

阶段 3 的决策函数在完成阶段 2 后调用，或在发生以下任何事件时调用：

a) 本地目的地的路由在本地路由信息库（Loc-RIB）中发生变化

b) 通过非 BGP 方式学习的本地生成路由发生变化

c) 建立了新的 BGP 端点连接

阶段 3 的函数是一个独立的过程，完成时没有更多工作要做。在阶段 2 的决策函数运行期间，阶段 3 的路由决策被阻止。

所有在 Loc-RIB 中的路由都根据配置策略被处理成 Adj-RIBs-Out。该策略可以排除某些路由在特定的 Adj-RIBs-Out 中被安装。除非目的地和由该路由描述的下一跳可以由路由表正确转发，否则不应将路由安装到 Adj-RIBs-Out 中。如果在某个特定的 Adj-RIBs-Out 中排除了 Loc-RIB 中的路由，则必须通过 UPDATE 消息撤销之前在该 Adj-RIBs-Out 中广告的路由（详见 9.2）。

可以选择应用路由聚合和信息简化技术（见第 9.2.2.1 节）。

任何导致路由被添加到 Adj-RIBs-Out 而未同时添加到本地 BGP 端点的转发表的本地策略，超出了本文档的范围。

当更新完毕后，BGP 端点会运行第 9.2 节中的 Update-Send 过程。

9.1.4  重叠路由

BGP 端点可能向另一端点传输具有重叠网络层可达信息（NLRI）的路由。当一组目的地在多个路由中被识别但不匹配时，就发生了 NLRI 重叠。由于 BGP 使用 IP 前缀编码 NLRI，重叠关系总是表现为子集关系。描述较小目的地集（较长前缀）的路由被认为比描述较大目的地集（较短前缀）的路由更具体；反之，描述较大目的地集的路由被认为不如描述较小目的地集的路由具体。

优先级关系实际上将较不具体的路由拆分为两部分：

- 仅由较不具体路由描述的目的地集；
- 由较不具体和较具体路由的重叠部分描述的目的地集。

重叠部分描述的目的地集代表了较不具体路由中可行但未使用的部分。如果后来更具体的路由被撤销，重叠部分描述的目的地集仍然可以通过较不具体的路由到达。

如果 BGP 端点收到重叠路由，决策流程必须根据配置的接受策略同时考虑这两条路由。如果接受了较不具体和较具体的路由，则必须在 Loc-RIB 中同时安装这两条路由，或将两者聚合后安装（前提是两条路由的 NEXT_HOP 属性值相同）。

如果选择聚合，端点应将所有用于形成聚合的 AS 编入 AS_SET，或在路由中添加 ATOMIC_AGGREGATE 属性。该属性目前主要用于信息传递。随着不支持无类路由的 IP 路由协议的淘汰，以及不支持无类路由的路由器和主机实现的减少，不再需要进行去聚合。路由不应被去聚合，特别是带有 ATOMIC_AGGREGATE 属性的路由，不能被去聚合。也就是说，此类路由的 NLRI 不能更具体。沿此类路由转发时，并不能保证 IP 包只经过路由中的 AS_PATH 所列的 AS。

9.2  更新发送过程

更新发送过程负责向所有对等端广告 UPDATE 消息。例如，它将由决策流程选择的路由分发给其他 BGP 端点，这些端点可能位于同一自治系统或邻近的自治系统中。

当 BGP 端点从内部对等端收到 UPDATE 消息时，除非该端点作为 BGP 路由反射器（RFC2796），否则不得将该 UPDATE 中包含的路由信息重新分发给其他内部对等端。

作为路由选择过程的第 3 阶段的一部分，BGP 端点已更新其 Adj-RIBs-Out。所有新安装的路由和所有没有替代路由的不可行路由，必须通过 UPDATE 消息广告给对等端。

如果某个可行的 BGP 路由在其 Adj-RIBs-Out 中已存在，且广告的内容与之前已广告的路由相同，则不应再次广告该路由。

所有标记为不可行的 Loc-RIB 中的路由都应被移除。对其自治系统内可达目的地的变化也应通过 UPDATE 广播。

由于最大 UPDATE 消息大小限制（见第 4 节），如果单一路由无法放入消息中，BGP 端点不得向对等端广告该路由，可以选择在本地记录错误。

9.2.1  控制路由流量开销

BGP 协议限制路由流量（即 UPDATE 消息）的数量，以减少广告 UPDATE 消息所需的链路带宽和决策流程处理信息的负担。

9.2.1.1  路由广告频率

参数 MinRouteAdvertisementIntervalTimer 决定 BGP 端点向对等端广告或撤销某个目的地路由的最小时间间隔。此速率限制在每个目的地基础上应用，但 MinRouteAdvertisementIntervalTimer 的值是为每个 BGP 对等端单独设置的。

两个由 BGP 端点向同一对等端发送的、广告可行路由和/或撤销不可行路由的 UPDATE 消息，必须至少相隔 MinRouteAdvertisementIntervalTimer 时间。这只能通过为每个共同目的地集维护单独的定时器实现。这会带来不必要的开销。任何确保从 BGP 端点到对等端发送的两个广告消息之间的间隔至少为 MinRouteAdvertisementIntervalTimer 的技术，都是可接受的，并且可以接受该间隔的上限。

由于在自治系统内需要快速收敛，内部对等端使用的 MinRouteAdvertisementIntervalTimer 应短于外部对等端使用的，或者（b）本节描述的程序不适用于内部对等端的路由。

此程序不限制路由的选择速率，只限制路由的广告速率。如果在等待 MinRouteAdvertisementIntervalTimer 过期期间多次选择新路由，则应在该定时器结束时广告最后一次选择的路由。

9.2.1.2  路由发起频率

参数 MinASOriginationIntervalTimer 决定 BGP 端点在连续广告其自治系统内变化的 UPDATE 消息之间必须经过的最小时间。

9.2.2  高效组织路由信息

在选择了要广告的路由信息后，BGP 端点可以采用多种方法高效组织这些信息。

9.2.2.1  信息简化

信息简化可能意味着策略控制粒度的降低——信息合并后，所有在等价类中的目的地和路径都将应用相同的策略。

决策流程可以选择通过以下任一方法减少在 Adj-RIBs-Out 中放置的信息量：

a) 网络层可达信息（NLRI）：
目的地 IP 地址可以用 IP 前缀表示。在地址结构与自治系统管理员控制的系统之间存在对应关系的情况下，可以减少在 UPDATE 消息中携带的 NLRI 大小。

b) AS_PATH：
AS 路径信息可以用有序的 AS_SEQUENCE 或无序的 AS_SET 表示。AS_SET 用于第 9.2.2.2 节描述的路由聚合算法。它通过只列出每个 AS 一次，减少了 AS_PATH 信息的大小，无论该 AS 在多个被聚合的 AS_PATH 中出现了多少次。

AS_SET 表示 NLRI 中列出的目的地可以通过经过部分组成自治系统的路径到达。AS_SET 提供足够信息以避免路由环路，但其使用可能会剪裁潜在的可行路径，因为这些路径不再以 AS_SEQUENCE 形式单独列出。在实际中，这通常不是问题，因为 IP 包到达一组自治系统的边缘时，BGP 端点可能拥有更详细的路径信息，能够区分不同的路径。

9.2.2.2  路由信息聚合

聚合是将多个不同路由的特征结合起来，以便只对外发布一条单一的路由的过程。聚合可以作为决策过程的一部分发生，以减少将要放入Adj-RIBs-Out中的路由信息量。

聚合减少了BGP发起者必须存储和与其他BGP发起者交换的信息量。路由可以通过对相同类型的路径属性和网络层可达信息分别应用以下程序进行聚合。

具有不同MULTI_EXIT_DISC属性的路由不得进行聚合。

如果聚合后的路由在AS_PATH属性中第一个元素是AS_SET，则发起该路由的路由器不应在此路由中广告MULTI_EXIT_DISC属性。

不同类型代码的路径属性不能一起聚合。同一类型代码的路径属性可以按照以下规则进行聚合：

- NEXT_HOP：
  聚合具有不同NEXT_HOP属性的路由时，聚合路由的NEXT_HOP属性应标识执行聚合的BGP发起者的某个接口。

- ORIGIN属性：
  如果被聚合的路由中至少有一条的ORIGIN值为INCOMPLETE，则聚合后的路由的ORIGIN也必须为INCOMPLETE。
  否则，如果被聚合的路由中至少有一条的ORIGIN值为EGP，则聚合后的路由的ORIGIN必须为EGP。
  在所有其他情况下，聚合路由的ORIGIN值为IGP。

- AS_PATH属性：
  如果待聚合的路由具有相同的AS_PATH属性，则聚合后的路由具有相同的AS_PATH属性。
  在聚合AS_PATH属性时，将AS路径中的每个AS视为一个元组<type, value>，其中“type”标识路径段的类型（如AS_SEQUENCE或AS_SET），而“value”标识AS编号。
  如果待聚合的路由具有不同的AS_PATH属性，则聚合后的AS_PATH必须满足以下所有条件：
  
  1. 聚合后AS_PATH中所有类型为AS_SEQUENCE的元组都必须出现在所有待聚合路由的AS_PATH中。
  2. 聚合后AS_PATH中所有类型为AS_SET的元组至少出现在待聚合路由中的一个AS_PATH中（可以是AS_SET或AS_SEQUENCE类型）。
  3. 对于聚合后AS_PATH中任何类型为AS_SEQUENCE的元组X（在X之前有元组Y），Y在所有包含Y的初始路由的AS_PATH中都必须在X之前，无论Y的类型如何。
  4. 聚合后AS_PATH中具有相同值的AS_SET元组不得出现多次。
  5. 具有相同值的AS_SEQUENCE元组在聚合路径中只有在相邻且类型相同的情况下才可以多次出现。

  实现可以选择任何符合这些规则的算法。至少，符合规则的实现应能执行以下算法，满足上述所有条件：
  
  - 找出所有待聚合路由的AS_PATH属性中最长的公共前缀（由多个元组组成），并将其作为聚合路径的前缀。
  - 将待聚合路由的AS_PATH属性中剩余的元组的类型设为AS_SET，并附加到聚合路径中。
  - 如果聚合路径中有多个相同值的元组（无论类型如何），则删除除一个之外的所有此类元组（即删除AS_SET类型的重复元组）。
  - 对聚合路径中相邻的两个元组，如果它们类型相同，则合并它们，只要合并不会导致路径段长度超过255。

  另见附录F第F.6节，提供了满足这些条件且支持更复杂策略配置的另一算法。

- ATOMIC_AGGREGATE：
  如果待聚合的路由中至少有一条具有ATOMIC_AGGREGATE路径属性，则聚合后的路由也必须具有此属性。

- AGGREGATOR：
  不应在聚合路由中包含待聚合路由的任何AGGREGATOR属性。执行路由聚合的BGP发起者可以附加一个新的AGGREGATOR属性（参见第5.1.7节）。

9.3 路由选择标准

通常，比较多个备选路由的附加规则超出本文范围。这里列出两个例外：

- 如果新考虑的路由的AS路径中出现本地AS，则该路由不能被视为优于其他路由（前提是配置的BGP发起者接受此类路由）。如果使用此类路由，可能会导致路由环路。

- 为实现成功的分布式操作，只能选择具有较高稳定性可能性的路由。因此，AS应避免使用不稳定的路由，也不应快速、随意地更改路由选择。对“非稳定”和“快速”这两个术语的量化需要经验，但原则很明确。不稳定的路由可以通过[RFC2439]中描述的程序“惩罚”。

9.4 BGP路由的发起

BGP发起者可以通过将通过其他方式（如IGP）获得的路由信息注入到BGP中，来发起BGP路由。发起BGP路由的BGP发起者会根据本地配置，将偏好程度（如优先级）赋予这些路由，并通过决策过程（见第9.1节）确定其优先级。这些路由也可以作为更新的一部分，分发给本地AS内的其他BGP发起者（见第9.2节）。是否通过BGP在AS内分发非BGP获取的路由，取决于AS内的环境（如IGP类型），应通过配置控制。

10. BGP定时器

BGP使用五个定时器：ConnectRetryTimer（见第8节）、HoldTimer（见第4.2节）、KeepaliveTimer（见第8节）、MinASOriginationIntervalTimer（见第9.2.1.2节）和MinRouteAdvertisementIntervalTimer（见第9.2.1.1节）。

还可以支持两个可选定时器：DelayOpenTimer和IdleHoldTimer（见第8节）。它们的使用在第8节中描述。这些可选定时器的完整操作超出本文范围。

ConnectRetryTime是一个强制的有限状态机（FSM）属性，存储ConnectRetryTimer的初始值。建议的默认值为120秒。

HoldTime是一个强制的FSM属性，存储HoldTimer的初始值。建议的默认值为90秒。

在状态机的某些阶段（见第8节），HoldTimer会被设置为较大值。建议的默认值为4分钟。

KeepaliveTime是一个强制的FSM属性，存储KeepaliveTimer的初始值。建议的默认值为HoldTime的1/3。

MinASOriginationIntervalTimer的建议默认值为15秒。

EBGP连接的MinRouteAdvertisementIntervalTimer建议默认值为30秒。

IBGP连接的MinRouteAdvertisementIntervalTimer建议默认值为5秒。

BGP实现必须允许对每个对等体配置HoldTimer，也可以允许配置其他定时器。

为了减少某个BGP发起者分发的BGP消息出现峰值的可能性，应对与MinASOriginationIntervalTimer、KeepaliveTimer、MinRouteAdvertisementIntervalTimer和ConnectRetryTimer相关的定时器应用抖动（jitter）。一个BGP发起者可以对这些定时器应用相同的抖动，无论消息的目的地如何；也就是说，不必为每个对等体单独配置抖动。

建议的抖动量为：将相应定时器的基础值乘以一个在0.75到1.0范围内均匀分布的随机因子。每次设置定时器时，应重新随机选择一个值。抖动的随机值范围可以配置。

（以下内容为附录，内容较多，已省略详细翻译，若需要完整附录内容的翻译，请告知。）

2. BGP头中的版本字段已被移除，并添加到OPEN消息中。

3. OPEN消息中的链路类型字段已被移除。

4. OPEN确认消息已被废除，取而代之的是由KEEPALIVE消息提供的隐式确认。

5. UPDATE消息的格式发生了重大变化。为支持多路径属性，向UPDATE消息中添加了新的字段。

6. Marker字段已被扩展，其作用也得到了拓宽，以支持认证功能。

请注意，通常将RFC 1105中定义的BGP称为BGP-1；将[RFC1163]中定义的BGP称为BGP-2；将RFC 1267中定义的BGP称为BGP-3；而本文档中定义的BGP则称为BGP-4。

附录E. 可能与BGP一起使用的TCP选项

如果本地系统的TCP用户界面支持TCP推送（PUSH）功能，则每个BGP消息应设置PUSH标志进行传输。设置PUSH标志可以促使BGP消息及时传送给接收方。

如果本地系统的TCP用户界面支持为TCP连接设置DSCP字段[RFC2474]，则BGP使用的TCP连接应在建立时将DSCP字段的0-2位设置为110（二进制）。

实现必须支持TCP MD5选项[RFC2385]。

第94页

RFC 4271                         BGP-4                      2006年1月

附录F. 实现建议

本节提出一些实现方面的建议。

F.1. 每条消息支持多个网络

BGP协议允许在一条消息中指定多个具有相同路径属性的地址前缀。强烈建议使用此功能。每个地址前缀单独一条消息会显著增加接收端的开销。不仅因为接收多条消息会增加系统负担，还因为扫描路由表以更新BGP对等体和其他路由协议（以及发送相关消息）时的开销会多次发生。

一种构建包含多个地址前缀的消息的方法是，在扫描路由表时，针对每个路径属性集建立多条消息。每当处理一个地址前缀时，如果对应的路径属性集的消息不存在，则分配一条新消息并添加该前缀；如果已存在，则将前缀附加到该消息中。如果该消息空间不足以容纳新前缀，则先传输该消息，分配一条新消息，并插入新前缀。扫描完所有路由条目后，所有已分配的消息将被发送，资源被释放。当所有地址前缀共享一组相同的路径属性时，可以在一条4096字节的消息中一次性发送多个地址前缀，从而实现最大压缩。

如果与不支持将多个地址前缀压缩到一条消息的BGP实现对等，可能需要采取措施减少在建立对等关系或网络拓扑发生重大变化时收到大量数据的开销。一种方法是限制更新速率，以避免重复扫描路由表，从而减少对等体和其他路由协议的闪速更新。这种方法的缺点是会增加路由信息的传播延迟。通过选择一个不远远超过处理多条消息所需时间的最小闪速更新间隔，可以尽量减小延迟。更好的做法是，在发送更新前，先读取所有接收的消息。

第95页

RFC 4271                         BGP-4                      2006年1月

F.2. 减少路由波动

为了避免过度的路由波动，BGP对等体在撤销某个目的地和发送关于更具体或更不具体路由的更新时，应将它们合并到同一条UPDATE消息中。

F.3. 路径属性排序

实现中，如果采用上述第6.1节描述的合并更新消息的方法，可能会偏好以已知顺序呈现所有路径属性。这可以帮助快速识别不同更新消息中语义相同的属性集。为此，将路径属性按类型代码排序是一种有用的优化，但此优化完全是可选的。

F.4. AS_SET排序

另一种简化处理的优化是对AS_SET中的AS编号进行排序。这也是一种可选措施。

F.5. 版本协商控制

由于BGP-4能够携带在BGP-3中无法正确表示的聚合路由，支持BGP-4的实现应提供按对等体区分仅使用BGP-4的能力。

F.6. 复杂的AS_PATH聚合

如果实现选择采用保留大量路径信息的路径聚合算法，可能会采用以下流程：

为了聚合两个路由的AS_PATH属性，将每个AS建模为一个<类型,值>的元组，其中“类型”标识该AS所属的路径段类型（如AS_SEQUENCE、AS_SET），而“值”是AS编号。当两个AS的<类型,值>元组相同时，认为它们是相同的。

聚合两个AS_PATH属性的算法如下：

a) 识别每个AS_PATH中相同的AS（定义如上），且它们在两个路径中的相对顺序相同。两个AS X和Y在相同顺序中，如果：

- X在两个路径中都先于Y，或
- Y在两个路径中都先于X。

b) 聚合后的AS_PATH由在(a)中识别的AS组成，顺序与原路径中的顺序完全一致。如果两个连续的AS在(a)中被识别为相同，但在待聚合的两个路径中不紧邻，则将两者之间的中间AS（在两个路径中都在这两个AS之间的AS）合并成一个AS_SET路径段，包含这两个路径中的中间AS。该段放置在两个AS之间。如果两个连续AS在一个路径中紧邻，但在另一个路径中不紧邻，则将后者路径中的中间AS合并成AS_SET段，并放在两个AS之间。

c) 对于聚合后AS_PATH中每对相邻的元组，如果它们类型相同，且合并不会导致段长度超过255，则将它们合并。

如果上述过程导致某个AS编号在聚合后的AS_PATH中出现多次，则应删除除最后一次（最右边）之外的所有重复出现。

安全注意事项

实现必须支持RFC 2385 [RFC2385]中定义的认证机制。该机制可以按对等体单独配置。

BGP使用TCP作为可靠传输手段，确保路由器间通信的完整性和数据源认证。为实现点对点连接的完整性，BGP采用RFC 2385定义的机制。这些服务旨在检测并拒绝针对路由器间TCP连接的主动窃听攻击。如果不使用这些安全机制，攻击者可能会中断TCP连接或冒充合法对等体。由于RFC定义的机制不提供对等实体的认证，连接可能受到重放攻击等威胁，而这些攻击在TCP层可能无法检测到，可能导致“损坏”或“伪造”的BGP消息被传递。

RFC 2385在TCP校验和基础上增加了一个16字节的消息认证码（MAC），该MAC基于相同数据（即TCP校验和所用数据）计算，采用单向哈希函数（MD5）和共享的秘密密钥。密钥在对等体间共享，用于生成难以被攻击者计算的MAC值。符合标准的实现必须支持此机制，并允许网络管理员为每个对等体启用。

RFC 2385未规定密钥的管理（生成、分发、更新）方式。RFC 3562 [RFC3562]提供了相关指导，建议每个受保护的对等体使用不同的密钥，以增强安全性。若多个对等体共用同一密钥，安全性可能会降低，例如某个路由器的密钥被攻破可能影响其他对等体。

用于MAC的密钥应定期更换，以减小密钥泄露或成功密码分析攻击的影响。RFC 3562建议的密钥周期最长为90天。更频繁的密钥更换可以降低重放攻击的可能性。然而，若没有标准化的机制在对等体间协调密钥更换，不能保证所有支持此RFC的BGP-4实现都能频繁更换密钥。

显然，每个密钥还应难以被攻击者猜测。RFC 1750中关于随机数生成的技术可作为密钥生成的参考。RFC 2385要求实现支持由最多80个可打印ASCII字符组成的密钥。RFC 3562建议密钥长度为12到24字节的随机（伪随机）比特，类似的MAC算法通常使用16到20字节的密钥。为了在较低端提供足够的随机比特，RFC 3562还指出，典型的ASCII文本字符串接近RFC 2385规定的最大密钥长度。

关于BGP漏洞的分析详见[RFC4272]。

第98页

IANA考虑事项

所有BGP消息都包含一个8位的消息类型字段，IANA已建立并维护名为“BGP消息类型”的注册表。本文件定义了以下消息类型：

| 名称             | 值 | 说明                     |
|------------------|-----|--------------------------|
| OPEN             | 1   | 见第4.2节               |
| UPDATE           | 2   | 见第4.3节               |
| NOTIFICATION     | 3   | 见第4.5节               |
| KEEPALIVE        | 4   | 见第4.4节               |

未来的分配将通过[RFC2434]中的标准行动流程或[RFC4020]中的早期IANA分配流程进行。分配内容包括名称和对应值。

BGP UPDATE消息可以携带一个或多个路径属性，每个属性包含一个8位的属性类型代码。IANA已维护名为“BGP路径属性”的注册表。本文件定义了以下路径属性类型代码：

| 名称               | 值 | 说明                     |
|--------------------|-----|--------------------------|
| ORIGIN             | 1   | 见第5.1.1节              |
| AS_PATH            | 2   | 见第5.1.2节              |
| NEXT_HOP           | 3   | 见第5.1.3节              |
| MULTI_EXIT_DISC    | 4   | 见第5.1.4节              |
| LOCAL_PREF         | 5   | 见第5.1.5节              |
| ATOMIC_AGGREGATE   | 6   | 见第5.1.6节              |
| AGGREGATOR         | 7   | 见第5.1.7节              |

未来的分配将通过[RFC2434]中定义的标准行动流程或[RFC4020]中定义的早期IANA分配流程进行。分配内容包括名称和对应的值。

BGP通知消息携带一个8位的错误代码，IANA已创建并维护了一个名为“BGP错误代码”的注册表。本文件定义了以下错误代码：

| 名称                     | 值 | 定义                     |
|------------------------|-----|------------------------|
| 消息头错误               | 1   | 见第6.1节               |
| OPEN消息错误             | 2   | 见第6.2节               |
| UPDATE消息错误           | 3   | 见第6.3节               |
| 保持计时器已过期         | 4   | 见第6.5节               |
| 有限状态机错误           | 5   | 见第6.6节               |
| 终止                     | 6   | 见第6.7节               |

Rekhter 等人             标准轨迹                    [第99页]

RFC 4271                         BGP-4                      2006年1月

未来的分配将通过[RFC2434]中定义的标准行动流程或[RFC4020]中定义的早期IANA分配流程进行。分配内容包括名称和对应的值。

BGP通知消息携带一个8位的错误子代码，每个子代码必须在特定错误代码的上下文中定义，因此在该上下文内必须唯一。

IANA已创建并维护一组注册表，“错误子代码”，每个BGP错误代码都有一个单独的注册表。未来的分配将通过[RFC2434]中的标准行动流程或[RFC4020]中的早期IANA分配流程进行。分配内容包括名称和对应的值。

本文件定义了以下消息头错误子代码：

| 名称                         | 值 | 定义                     |
|----------------------------|-----|------------------------|
| 连接未同步                   | 1   | 见第6.1节               |
| 消息长度错误                 | 2   | 见第6.1节               |
| 消息类型错误                 | 3   | 见第6.1节               |

本文件定义了以下OPEN消息错误子代码：

| 名称                         | 值 | 定义                     |
|----------------------------|-----|------------------------|
| 不支持的版本号               | 1   | 见第6.2节               |
| 不正确的对等AS               | 2   | 见第6.2节               |
| 不正确的BGP标识符            | 3   | 见第6.2节               |
| 不支持的可选参数             | 4   | 见第6.2节               |
| [已废弃]                     | 5   | 见附录A                |
| 不可接受的保持时间           | 6   | 见第6.2节               |

本文件定义了以下UPDATE消息错误子代码：

| 名称                               | 值 | 定义                     |
|----------------------------------|-----|------------------------|
| 格式错误的属性列表               | 1   | 见第6.3节               |
| 未识别的已知属性                 | 2   | 见第6.3节               |
| 缺少已知属性                     | 3   | 见第6.3节               |
| 属性标志错误                     | 4   | 见第6.3节               |
| 属性长度错误                     | 5   | 见第6.3节               |
| 无效的ORIGIN属性                 | 6   | 见第6.3节               |
| [已废弃]                         | 7   | 见附录A                |
| 无效的NEXT_HOP属性               | 8   | 见第6.3节               |
| 可选属性错误                     | 9   | 见第6.3节               |
| 无效的网络字段                   | 10  | 见第6.3节               |
| 格式错误的AS_PATH                | 11  | 见第6.3节               |

Rekhter 等人             标准轨迹                    [第100页]

RFC 4271                         BGP-4                      2006年1月

规范性参考文献

[RFC791]  Postel, J.，“互联网协议”，STD 5，RFC 791，1981年9月。

[RFC793]  Postel, J.，“传输控制协议”，STD 7，RFC 793，1981年9月。

[RFC2119] Bradner, S.，“在RFC中使用的关键词以指示需求级别”，BCP 14，RFC 2119，1997年3月。

[RFC2385] Heffernan, A.，“通过TCP MD5签名选项保护BGP会话”，RFC 2385，1998年8月。

[RFC2434] Narten, T. 和 H. Alvestrand，“在RFC中撰写IANA考虑事项部分的指南”，BCP 26，RFC 2434，1998年10月。

补充性参考文献

[RFC904]  Mills, D.，“外部网关协议的正式规范”，RFC 904，1984年4月。

[RFC1092] Rekhter, J.，“NSFNET骨干网中的EGP和策略路由”，RFC 1092，1989年2月。

[RFC1093] Braun, H.，“NSFNET路由架构”，RFC 1093，1989年2月。

[RFC1105] Lougheed, K. 和 Y. Rekhter，“边界网关协议（BGP）”，RFC 1105，1989年6月。

[RFC1163] Lougheed, K. 和 Y. Rekhter，“边界网关协议（BGP）”，RFC 1163，1990年6月。

[RFC1267] Lougheed, K. 和 Y. Rekhter，“边界网关协议3（BGP-3）”，RFC 1267，1991年10月。

[RFC1771] Rekhter, Y. 和 T. Li，“边界网关协议4（BGP-4）”，RFC 1771，1995年3月。

[RFC1772] Rekhter, Y. 和 P. Gross，“互联网中边界网关协议的应用”，RFC 1772，1995年3月。

[RFC1518] Rekhter, Y. 和 T. Li，“CIDR的IP地址分配架构”，RFC 1518，1993年9月。

[RFC1519] Fuller, V.，Li, T.，Yu, J. 和 K. Varadhan，“无类域间路由（CIDR）：地址分配与聚合策略”，RFC 1519，1993年9月。

[RFC1930] Hawkinson, J. 和 T. Bates，“创建、选择和注册自治系统（AS）的指南”，BCP 6，RFC 1930，1996年3月。

[RFC1997] Chandra, R.，Traina, P. 和 T. Li，“BGP社区属性”，RFC 1997，1996年8月。

[RFC2439] Villamizar, C.，Chandra, R. 和 R. Govindan，“BGP路由抖动抑制”，RFC 2439，1998年11月。

[RFC2474] Nichols, K.，Blake, S.，Baker, F. 和 D. Black，“IPv4和IPv6头中的差异服务字段（DS字段）定义”，RFC 2474，1998年12月。

[RFC2796] Bates, T.，Chandra, R. 和 E. Chen，“BGP路由反射——全网IBGP的替代方案”，RFC 2796，2000年4月。

[RFC2858] Bates, T.，Rekhter, Y.，Chandra, R. 和 D. Katz，“BGP-4的多协议扩展”，RFC 2858，2000年6月。

[RFC3392] Chandra, R. 和 J. Scudder，“通过BGP-4进行能力广告”，RFC 3392，2002年11月。

[RFC2918] Chen, E.，“BGP-4的路由刷新能力”，RFC 2918，2000年9月。

[RFC3065] Traina, P.，McPherson, D. 和 J. Scudder，“BGP的自治系统联盟”，RFC 3065，2001年2月。

[RFC3562] Leech, M.，“TCP MD5签名选项的密钥管理考虑事项”，RFC 3562，2003年7月。

[ISO/IEC IS10747] “信息处理系统——电信和系统间信息交换——用于支持ISO 8473 PDU转发的中间系统间路由信息交换协议”，ISO/IEC IS10747，1993年。

[RFC4272] Murphy, S.，“BGP安全漏洞分析”，RFC 4272，2006年1月。

[RFC4020] Kompella, K. 和 A. Zinin，“标准轨迹代码点的早期IANA分配”，BCP 100，RFC 4020，2005年2月。

编辑地址

Yakov Rekhter  
Juniper Networks  
电子邮箱：yakov@juniper.net

Tony Li  
电子邮箱：tony.li@tony.li

Susan Hares  
NextHop Technologies, Inc.  
825 Victors Way  
安娜堡，MI 48108  
电话：(734)222-1610  
电子邮箱：skh@nexthop.com

全文版权声明

版权所有 (C) 互联网协会（2006年）。

本文件受BCP 78中的权利、许可证和限制的约束，除非另有说明，作者保留所有权利。

本文件及其中包含的信息按“原样”提供，贡献者、其代表的组织或其赞助的组织（如有）、互联网协会和互联网工程任务组均不对其作任何明示或暗示的保证，包括但不限于不侵犯任何权利或对其适销性或特定用途适用性的任何保证。

知识产权

IETF不对本文件所述技术的实现或使用可能涉及的任何知识产权或其他权利的有效性或范围发表任何立场，也不保证已进行任何独立努力以识别此类权利。关于RFC文件中权利的程序信息，请参见BCP 78和BCP 79。

可以通过IETF在线知识产权存储库（http://www.ietf.org/ipr）获取向IETF秘书处提交的知识产权披露副本、任何保证的许可证或为实现或使用本规范而尝试获得的通用许可证或许可的结果。

IETF欢迎任何相关方就可能涉及实现本标准的技术的版权、专利或专利申请或其他所有权提出关注。请将相关信息发送至IETF：ietf-ipr@ietf.org。

致谢

RFC编辑工作由IETF行政支持活动（IASA）提供资金支持。