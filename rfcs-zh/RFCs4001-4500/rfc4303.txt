# RFC 4303 中文翻译 (stub)
# 原文文件: ../../rfcs/RFCs4001-4500/rfc4303.txt

网络工作组                                            S. Kent
评论请求编号：4303                              BBN技术公司
废止：2406                                            2005年12月
类别：标准轨道


                IP封装安全负载（ESP）

本备忘录的状态

   本文件为互联网社区制定的互联网标准轨道协议，旨在征求讨论和改进建议。请参阅最新版本的《互联网官方协议标准》（STD 1），了解该协议的标准化状态和现行状态。本备忘录的分发不受限制。

版权声明

   版权所有（C）互联网协会（2005年）。

摘要

   本文档描述了封装安全负载（ESP）协议的更新版本，旨在为IPv4和IPv6提供多种安全服务。ESP用于提供机密性、数据来源认证、无连接完整性、防重放服务（部分序列完整性的一种形式）以及有限的流量隐私保护。本标准取代RFC 2406（1998年11月）。

目录

   1. 引言 ....................................................3
   2. 封装安全负载包格式 ....................................5
      2.1. 安全参数索引（SPI） ................................10
      2.2. 序列号 ..............................................12
           2.2.1. 扩展（64位）序列号 ..........................12
      2.3. 负载数据 ............................................13
      2.4. 填充（用于加密） ....................................14
      2.5. 填充长度 ............................................15
      2.6. 下一头部 ............................................16
      2.7. 流量流隐私（TFC）填充 ..............................17
      2.8. 完整性检验值（ICV） ................................17
   3. 封装安全协议处理 ........................................18
      3.1. ESP头部位置 .........................................18
           3.1.1. 传输模式处理 ..................................18
           3.1.2. 隧道模式处理 ..................................19
      3.2. 算法 .................................................20
           3.2.1. 加密算法 ......................................21
           3.2.2. 完整性算法 ....................................21
           3.2.3. 组合模式算法 ..................................22
      3.3. 出站数据包处理 .......................................22
           3.3.1. 安全关联查找 ..................................22
           3.3.2. 数据包加密与完整性检验值（ICV）计算 ..........22
                  3.3.2.1. 分离的机密性和完整性算法 ............23
                  3.3.2.2. 组合的机密性和完整性算法 ............24
           3.3.3. 序列号生成 ....................................25
           3.3.4. 分片 ............................................26
      3.4. 入站数据包处理 .......................................27
           3.4.1. 重组 ............................................27
           3.4.2. 安全关联查找 ..................................27
           3.4.3. 序列号验证 ....................................28
           3.4.4. 完整性检验值验证 ..............................30
                  3.4.4.1. 分离的机密性和完整性算法 ............30
                  3.4.4.2. 组合的机密性和完整性算法 ............32
   4. 审计 .....................................................33
   5. 一致性要求 ...............................................34
   6. 安全注意事项 .............................................34
   7. 与RFC 2406的差异 ........................................34
   8. 向后兼容性考虑 .........................................35
   9. 致谢 .....................................................36
   10. 参考文献 ...............................................36
      10.1. 标准性参考 ........................................36
      10.2. 资料性参考 ........................................37
   附录A：扩展（64位）序列号 ..................................38
      A1. 概述 .................................................38
      A2. 反重放窗口 ...........................................38
          A2.1. 管理和使用反重放窗口 ..........................39
          A2.2. 确定序列号的高阶位（Seqh） ....................40
          A2.3. 伪代码示例 ......................................41
      A3. 由于大量丢包引起的同步丢失处理 ......................42
          A3.1. 触发重新同步 ....................................43
          A3.2. 重新同步过程 ....................................43

1. 引言

   本文档假设读者已熟悉“互联网协议安全架构”[Ken-Arch]中描述的术语和概念，以下简称“安全架构文档”。特别是，读者应熟悉封装安全负载（ESP）和IP认证头（AH）提供的安全服务定义、安全关联的概念、ESP与AH的联合使用方式，以及ESP和AH的不同密钥管理选项。

   本文中出现的关键词“必须”（MUST）、“不得”（MUST NOT）、“需要”（REQUIRED）、“应”（SHALL）、“不得应”（SHALL NOT）、“建议”（SHOULD）、“不建议”（SHOULD NOT）、“推荐”（RECOMMENDED）、“可以”（MAY）和“可选”（OPTIONAL），应按照RFC 2119 [Bra97]中的定义理解。

   封装安全负载（ESP）头部旨在在IPv4和IPv6中提供多种安全服务[DH98]。ESP可以单独使用，也可以与AH结合使用[Ken-AH]，或以嵌套方式（参见安全架构文档[Ken-Arch]）。安全服务可以在两个通信主机之间、两个安全网关之间，或一个安全网关与主机之间提供。关于在不同网络环境中使用ESP和AH的详细信息，请参阅安全架构文档。

   ESP头部插入在IP头部之后，下一层协议头（传输模式）之前，或在封装的IP头部（隧道模式）之前。这些模式将在后文中详细描述。

   ESP可用于提供机密性、数据来源认证、无连接完整性、防重放服务（部分序列完整性）以及有限的流量隐私保护。提供的服务集取决于安全关联（SA）建立时选择的选项，以及实现所在的网络拓扑位置。

   仅使用加密实现机密性是允许的，但应注意，这通常只能防御被动攻击者。未在ESP或AH上配备强完整性机制的加密，可能使机密性服务在某些主动攻击下变得不安全[Bel96, Kra01]。此外，在加密前应用的底层完整性服务（如AH）并不一定能保护加密的机密性免受主动攻击[Kra01]。ESP允许仅加密的SA，因为这可能显著提升性能，同时仍能提供足够的安全性，例如在更高层提供认证/完整性保护时。然而，本标准不要求ESP实现必须提供仅加密的服务。

   数据来源认证和无连接完整性是联合服务，统称为“完整性”。（此术语使用是因为，按每个数据包计算，所执行的操作直接提供无连接完整性；数据来源认证则通过将验证所用密钥与IPsec对等体的身份绑定间接实现。通常，这种绑定通过共享对称密钥完成。）仅完整性ESP必须作为服务选项提供，例如，在SA管理协议中可协商，且必须通过管理接口配置。许多场景中，完整性ESP是AH的有吸引力的替代方案，因为它处理速度更快，更适合流水线处理。

   虽然机密性和完整性可以单独提供，但ESP通常会同时使用两者，即保护数据的机密性和完整性。因此，涉及这两项服务的ESP安全服务组合有三种可能：

            - 仅机密性（支持可能性）
            - 仅完整性（必须支持）
            - 机密性和完整性（必须支持）

   反重放服务只能在选择了完整性服务的SA中启用。该服务的选择由接收方自主决定，无需协商。然而，为了实现扩展序列号功能的互操作性，ESP对SA管理协议提出了要求，必须支持协商此功能（见下文第2.2.1节）。

   流量流隐私（TFC）服务通常只有在ESP以隐藏通信双方最终源和目的地址的方式使用时才有效，例如在安全网关之间的隧道模式中，且只有在IPsec对等体之间有足够的流量（自然产生或通过生成掩码流量）以隐藏特定、单个订阅者流量特征时才有效。（ESP可以作为更高层TFC系统的一部分使用，例如洋葱路由[Syverson]，但此类系统超出本标准范围。）ESP中的新TFC特性有助于高效生成和丢弃虚假流量，以及更好地填充真实流量，以实现向后兼容。

第7节简要回顾了本文件与RFC 2406的差异。

2. 封装安全负载包格式

   紧接在ESP头部之前的（外层）协议头（IPv4、IPv6或扩展头）必须在其协议字段（IPv4）或下一头部字段（IPv6、扩展头）中包含值50（详见IANA网页：http://www.iana.org/assignments/protocol-numbers）。图1展示了ESP包的顶层格式。该包以两个4字节字段（安全参数索引SPI和序列号）开始。紧随其后的是负载数据，其结构依赖于所选的加密算法和模式，以及TFC填充的使用情况（后续将详细说明）。负载数据之后是填充和填充长度字段，以及下一头部字段。可选的完整性检验值（ICV）字段完成整个包。

图1. ESP包的顶层格式

（注：如果在负载字段中包含加密同步数据，例如初始化向量（IV，见第2.3节），通常不对其进行加密，尽管它常被称为密文的一部分。）

传输的ESP尾部由填充、填充长度和下一头部字段组成。附加的、隐含的ESP尾部数据（未传输）在完整性计算中也会被考虑，如下所述。

如果选择了完整性服务，完整性计算涵盖SPI、序列号、负载数据和ESP尾部（显式和隐式）。

如果选择了机密性服务，密文由负载数据（除可能包含的任何同步数据）和（显式的）ESP尾部组成。

如前所述，负载数据可能具有子结构。需要显式初始化向量（IV）的加密算法（如CBC模式）通常会在保护的负载数据前加上该值。一些算法模式将加密和完整性结合为单一操作；本文档将此类算法模式称为“组合模式算法”。采用组合模式算法时，必须明确描述用于传递完整性数据的负载子结构。

一些组合模式算法仅对加密的数据提供完整性，而另一些则能对未加密的部分数据提供完整性（用于传输）。由于SPI和序列号字段需要作为完整性服务的一部分保持完整性，且它们未加密，因此无论采用何种组合算法模式，都必须确保它们在提供完整性时得到保护。

当使用任何组合模式算法时，算法本身应返回解密后的明文和完整性验证的成功/失败指示。对于组合模式算法，通常在ESP包末端（当选择完整性时）出现的ICV可以省略。当省略ICV且选择完整性时，必须由组合模式算法在负载数据中编码一种等同于ICV的验证方式，以验证包的完整性。

如果某个组合模式算法仅对加密数据提供完整性，则必须在负载数据中复制SPI和序列号。

最后，新增了在负载数据之后、ESP尾部之前插入流量流隐私填充的功能。图2展示了负载数据的子结构（注意：此图显示的是在网络线上传输的比特流，即使使用扩展序列号，也只会传输序列号的32位（详见第2.2.1节））。

以下是该英文内容的中文翻译：

```
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |               安全参数索引（SPI）                                |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                      序列号                                    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+---
   |                    初始化向量（IV，可选）                        | ^ p
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | a
   |                    其余有效载荷数据（可变）                        | | y
   ~                                                               ~ | l
   |                                                               | | o
   +               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | a
   |               |         TFC 填充（可选，可变）                     | v d
   +-+-+-+-+-+-+-+-+         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+---
   |                         |        填充（0-255字节）               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                               |  填充长度   |  下一头部   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         完整性检查值（ICV，可变）                                |
   ~                                                               ~
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

               图2. 有效载荷数据的子结构

         * 如果使用隧道模式，则IPsec实现可以在有效载荷数据之后、填充（0-255字节）字段之前添加流量流机密性（TFC）填充（详见第2.4节）。

   如果采用组合算法模式，则图1和图2中显示的显式ICV可以省略（详见第3.3.2.2节）。由于在建立安全关联（SA）时算法和模式是固定的，因此对于给定SA的ESP数据包的详细格式（包括有效载荷数据子结构）在整个SA的所有流量中都是固定的。

   下表中的字段对应前述图示，说明不同类别的算法选项（每种具有不同的处理模型）如何影响上述字段。具体的处理细节将在后续章节中描述。





Kent                        标准轨迹                     [第7页]


RFC 4303        IP封装安全载荷（ESP）             2005年12月


          表1. 独立加密和完整性算法

                                            需要    需要    是否
                          字节数     [1]   覆盖  覆盖  省略
                          ------   ------  ------  ------  ------
   SPI                       4        必须   -      是     明文
   序列号（低位）           4        必须   -      是     明文       p
                                                                ------ a
   初始化向量（IV）          变长     可选   -      是     明文     | y
   IP数据报[2]               变长     必须或可选  是  是     密文[3] |-l
   TFC 填充[4]               变长     可选   -      是     密文[3] | o
                                                                ------ a
   填充                     0-255      必须   是     是     密文[3]   d
   填充长度                  1        必须   是     是     密文[3]
   下一头部                  1        必须   是     是     密文[3]
   序列号（高位）            4     如果使用ESN[5]  是  不省略
   ICV 填充                变长（需要时）  -     是  不省略
   ICV                     变长     必须[6]             明文

           [1] 必须=必需；可选=可选；虚拟=虚拟
           [2] 如果是隧道模式 -> IP数据报
               如果是传输模式 -> 下一头部和数据
           [3] 如果选择加密，则为密文
           [4] 仅当有效载荷指定其“实际”长度时可用
           [5] 见第2.2.1节
           [6] 如果使用单独的完整性算法，则为必需





Kent                        标准轨迹                     [第8页]


RFC 4303        IP封装安全载荷（ESP）             2005年12月


                  表2. 组合模式算法

                                             需要    需要    是否
                            字节数     [1]   覆盖  覆盖  省略
                            ------   ------  ------  ------  ------
    SPI                        4        必须   -      明文
    序列号（低位）           4        必须   -      明文    p
                                                                  --- a
    初始化向量（IV）          变长     可选   -      是     明文  | y
    IP数据报[2]               变长     必须或可选  是  是     密文 |-l
    TFC 填充[3]               变长     可选   -      是     密文 | o
                                                                  --- a
    填充                     0-255      必须   是     是     密文   d
    填充长度                  1        必须   是     是     密文
    下一头部                  1        必须   是     是     密文
    序列号（高位）            4     如果使用ESN[4]  是  [5]
    ICV 填充                变长（需要时）  -     是  [5]
    ICV                     变长     可选[6]             明文

            [1] 必须=必需；可选=可选；虚拟=虚拟
            [2] 如果是隧道模式 -> IP数据报
                如果是传输模式 -> 下一头部和数据
            [3] 仅当有效载荷指定其“实际”长度时可用
            [4] 见第2.2.1节
            [5] 算法选择决定是否传输这些字段，但无论如何，结果对ESP是不可见的
            [6] 算法规范决定此字段是否存在

   以下子节将描述头部格式中的字段。“可选”意味着如果未选择该选项，则该字段将被省略，即在传输的包中不存在，也不会在计算ICV时出现（详见第2.7节）。是否选择某个选项在安全关联（SA）建立时确定。因此，给定SA的ESP包格式在整个SA期间是固定的。相比之下，“必需”字段在所有SA的ESP包格式中始终存在。

   注意：IPsec中使用的所有加密算法都期望其输入为规范的网络字节序（参见RFC 791附录[Pos81]），并以规范的网络字节序生成输出。IP数据包也以网络字节序传输。

ESP没有版本号，因此如果存在向后兼容性的问题，必须通过在两个IPsec端点之间使用信令机制（如互联网密钥交换IKEv2 [Kau05]）或带外配置机制来解决。

2.1. 安全参数索引（SPI）

   SPI是一个任意的32位值，接收方用它来识别入站数据包所绑定的SA。SPI字段是必需的。

   对于单播SA，SPI可以单独用来指定一个SA，也可以与IPsec协议类型（在本例中为ESP）结合使用。由于SPI值由接收方为单播SA生成，是否仅凭SPI值就能识别SA，或是否必须结合IPsec协议类型一起使用，是由本地实现决定的。所有ESP实现必须支持这种将入站流量映射到单播SA的机制。

   如果IPsec实现支持多播，则必须支持多播SA，使用下面的算法将入站IPsec数据报映射到SA。只支持单播的实现不需要实现此多路复用算法。

   在许多安全多播架构中（如[RFC3740]），中央组控制器/密钥服务器单方面分配组安全关联的SPI。此SPI分配不与各端系统中的密钥管理（如IKE）协商或协调。因此，组安全关联和单播安全关联可能会使用相同的SPI。支持多播的IPsec实现必须能正确区分入站流量，即使发生SPI冲突。

   安全关联数据库（SAD）[Ken-Arch]中的每个条目必须指明在进行SA查找时是否使用目标地址，或目标和源地址，除了SPI之外。对于多播SA，不使用协议字段进行SA查找。对于每个入站的IPsec保护包，必须按照“最长匹配”原则在SAD中查找匹配的条目。如果有多个条目匹配SPI值，则匹配目标地址（或目标和源地址）更长的条目为“最长匹配”。这意味着SAD的搜索顺序如下：





Kent                        标准轨迹                    [第10页]


RFC 4303        IP封装安全载荷（ESP）             2005年12月


         1. 在SAD中搜索匹配{SPI，目标地址，源地址}。如果找到匹配的条目，则用该条目处理入站ESP包，否则进入第2步。

         2. 在SAD中搜索匹配{SPI，目标地址}。如果找到匹配的条目，则用该条目处理，否则进入第3步。

         3. 在SAD中只搜索{SPI}（如果接收端选择为AH和ESP维护单一SPI空间），否则搜索{SPI，协议}。如果找到匹配的条目，则用该条目处理，否则丢弃包并记录事件。

   实现可以选择任何方法加快搜索，但其对外表现必须与上述顺序的搜索功能等效。例如，软件实现可以通过SPI索引到哈希表中。每个哈希桶中的链表保持按最长SA标识符排序，最长的在前，最短的在后。硬件实现可能利用常见的三元内容可寻址存储器（TCAM）实现最长匹配搜索。

   是否需要根据源地址和目标地址匹配入站IPsec流量以映射到SA，必须通过手动配置SA或使用SA管理协议（如IKE或GDOI [RFC3547]）协商确定。通常，源特定多播（SSM）[HC03]组使用由SPI、目标多播地址和源地址组成的三元组SA标识符。任何源多播组SA只需SPI和目标多播地址作为标识符。

   SPI值范围1至255由互联网号码分配局（IANA）保留以备将来使用；除非在RFC中明确规定，否则IANA通常不会分配已保留的SPI值。值0（零）保留用于本地实现，不能在网络上传输（“在线”）。例如，密钥管理实现可能使用SPI值0表示“没有安全关联”。

2.2. 序列号

   这是一个无符号的32位字段，包含一个计数器值，每发出一个包，计数器值增加1，即每个SA的包序列号。对于单播SA或单发多播SA，发送方必须为每个发出的包递增此字段。允许多个发件人共享一个SA，但通常不推荐。ESP不提供在多个发件人之间同步包计数器或管理接收端包计数器和窗口的机制。因此，对于多发者SA，ESP的防重放功能不可用（详见第3.3.3节和第3.4.3节）。

   该字段是必需的，即使接收端未启用特定SA的防重放服务，处理序列号的责任由接收端决定，但所有ESP实现必须能够执行第3.3.3节和第3.4.3节中的处理。因此，发送方必须始终传输此字段，但接收方不必对其采取行动（详见“入站包处理”部分（3.4.3）中关于序列号验证的讨论）。

   发送方和接收方的计数器在建立SA时初始化为0。（使用给定SA发送的第一个包的序列号为1；详见第3.3.3节关于序列号生成的细节。）如果启用防重放（默认），则传输的序列号绝不能循环。因此，必须在SA上第2^32个包发出之前，通过建立新SA（即新密钥）重置发送方和接收方的计数器。

2.2.1. 扩展（64位）序列号

   为支持高速IPsec实现，应实现扩展序列号（ESN），作为当前32位序列号字段的扩展。ESN的使用必须通过SA管理协议协商。注意，在IKEv2中，此协商是隐式的；默认启用ESN，除非明确协商使用32位序列号。（ESN功能同样适用于多播和单播SA。）






Kent                        标准轨迹                    [第12页]
```

RFC 4303 IP封装安全有效载荷（ESP） 2005年12月

ESN（扩展序列号）功能允许为安全关联（SA）使用64位序列号。（详见附录A，“扩展（64位）序列号”部分。）在每个数据包的明文ESP头中，只传输序列号的低32位，从而最大限度地减少包头开销。高32位由发射端和接收端作为序列号计数器的一部分维护，并在计算完整性验证值（ICV）时（如果选择了完整性服务）包含在内。如果采用单独的完整性算法，则高位部分包含在隐式的ESP尾部中，但不会被传输，类似于完整性算法的填充位。如果采用组合模式算法，则算法的选择决定是否传输高位的ESN位或在计算中隐式包含。处理细节请参见第3.3.2.2节。

2.3. 有效载荷数据

有效载荷数据是一个变长字段，包含由“下一头部”字段描述的原始IP包中的数据。有效载荷数据字段是必需的，且长度必须为字节的整数倍。如果用于加密有效载荷的算法需要密码同步数据，例如初始化向量（IV），则此数据在有效载荷字段中显式携带，但在ESP中不作为单独字段出现，即传输显式IV对ESP来说是不可见的（见图2）。任何需要此类显式、每包同步数据的加密算法，必须在相关的RFC中指明其长度、结构以及此数据的位置，以说明如何与ESP配合使用。（通常，IV紧跟在密文之前，详见图2。）如果同步数据是隐式的，则必须在算法定义的RFC中说明如何推导此数据。（如果包含在有效载荷字段中，密码同步数据如IV，通常不会被加密（见表1和表2），尽管有时也被称为密文的一部分。）

请注意，下一个层协议头的起始位置必须相对于ESP头的起始位置对齐，具体如下：IPv4的对齐要求为4字节的倍数，IPv6的对齐要求为8字节的倍数。

关于在存在IV的情况下确保（真实）密文对齐的问题，注意以下几点：

- 对于某些基于IV的操作模式，接收端将IV视为密文的起点，直接输入算法。在这些模式中，密文起点的对齐不是问题。
- 在某些情况下，接收端会单独读取IV和密文。在这种情况下，算法规范必须说明如何实现密文的对齐。

2.4. 填充（用于加密）

使用填充字段的主要原因有两个：

- 如果采用的加密算法要求明文长度为某个字节数的倍数（例如块密码的块大小），则用填充字段填充明文（包括有效载荷数据、填充、填充长度和下一头部字段），以满足算法的要求。
- 无论加密算法是否有此要求，为确保密文在4字节边界终止，也可能需要填充。具体来说，Pad Length和Next Header字段必须在4字节字内右对齐（如前述ESP包格式图所示），以确保ICV字段（如果存在）在4字节边界上对齐。

超出算法或对齐需求的填充可以用来隐藏有效载荷的实际长度，以支持TFC（流量特征隐藏）。但上述描述的填充字段过于有限，不适合用于TFC，因此不应将其用于此目的。需要TFC时，应使用下面描述的单独机制（见第2.7节）。

发件人可以添加0到255字节的填充。是否在ESP包中包含填充字段是可选的，符合上述要求，但所有实现都必须支持生成和处理填充。

- 为确保待加密的比特数为算法块大小的整数倍（第一点），填充计算应作用于除IV外的有效载荷数据，但包括ESP尾部字段。如果采用组合算法模式，且需要传输SPI和序列号以实现完整性（例如在有效载荷数据中复制SPI和序列号），则复制的版本及任何相关的ICV等价数据也应计入填充长度的计算中。（如果选择了ESN选项，ESN的高32位也会参与计算，前提是组合模式算法需要传输它们以保证完整性。）

- 为确保ICV在4字节边界对齐（第二点），填充计算应作用于包括IV、填充长度和下一头部字段在内的有效载荷数据。如果采用组合算法，任何复制的数据和ICV等价数据也应包含在填充计算中。

如果需要填充字节，但加密算法未指定填充内容，则必须采用以下默认处理：用一系列（无符号、1字节）整数值初始化填充字节。第一个填充字节编号为1，后续填充字节形成递增序列：1、2、3……。采用此方案时，接收端应检查填充字段。（选择此方案是因为其相对简单、硬件实现容易，并且在没有其他完整性措施的情况下，对某些“剪切粘贴”攻击提供有限保护，前提是接收端在解密后检查填充值。）

如果加密或组合算法对填充字节的值有限制，则必须在定义该算法与ESP配合使用的RFC中说明。如果算法要求检查填充字节的值，这也必须在RFC中说明。

2.5. 填充长度（Pad Length）

Pad Length字段指示紧接在其前的填充字节数（在填充字段中）。有效值范围为0到255，值为0表示没有填充字节。如上所述，此值不包括任何TFC填充字节。Pad Length字段是必需的。

2.6. 下一头部（Next Header）

Next Header是一个必需的8位字段，用于标识有效载荷数据字段中包含的数据类型，例如IPv4或IPv6包，或下一层协议头和数据。该字段的值由IANA定义的IP协议号集选择，例如值4表示IPv4，41表示IPv6，6表示TCP。

为了支持流量特征隐藏（TFC）中的快速生成和丢弃填充流量（详见第2.4节），必须使用协议值59（表示“无下一头部”）来标识“虚拟”包。发射端必须能够生成标记有此值的虚拟包，接收端也必须能丢弃此类包，且不报告错误。所有其他ESP头部和尾部字段（SPI、序列号、填充、填充长度、下一头部和ICV）必须在虚拟包中存在，但除下一头部字段外，载荷的明文部分可以不符合格式，例如其余的有效载荷数据可以仅由随机字节组成。虚拟包应被无偏见地丢弃。

实现应提供本地管理控制，以便在每个SA基础上启用此功能。控制应允许用户指定是否启用此功能，并提供参数控制，例如允许管理员生成随机长度或固定长度的虚拟包。

讨论：虚拟包可以随机插入，以掩盖实际流量的缺失。也可以“塑造”实际流量，使其符合某个分布，然后根据分布参数添加虚拟流量。与TFS（流量特征隐藏）中的包长度填充类似，最安全的方法是在保持SA恒定比特率的情况下，按所需速率生成虚拟包。如果所有包大小相同，SA就表现为一个恒定比特率的数据流，类似于链路加密在第1层或第2层提供的效果。然而，在多SA同时活动的许多场景中，这可能不切实际，因为这意味着要根据SA数量限制站点的带宽，从而削弱包交换的优势。实现应提供控制，允许本地管理员管理TFC虚拟包的生成。

2.7. 流量特征隐藏（TFC）填充

如上所述，填充字段长度最多为255字节，通常不足以隐藏流量特征以满足TFC要求。为此，专门提供了一个可选字段，位于有效载荷数据中，用于满足TFC需求。

IPsec实现应能够在有效载荷数据末尾、填充字段之前添加字节进行填充（称为TFC填充）。但只有在有效载荷字段中包含IP数据报长度的说明时，才能添加此类填充（TFC填充）。在隧道模式下，这一条件总是成立；在传输模式下，是否成立取决于下一层协议（如IP、UDP、ICMP）是否包含明确的长度信息。此长度信息使接收端能识别并丢弃TFC填充，因为可以知道有效载荷的真实长度（ESP尾部字段通过从ESP包末端倒数计数定位）。因此，如果添加TFC填充，必须确保包含IP数据报长度说明的字段不被修改，以反映此填充。此标准未规定此填充的具体值。

原则上，现有的IPsec实现以前可能已以透明方式使用此功能。然而，由于接收端可能未准备好处理此类填充，SA管理协议必须在发射端使用此功能前协商此服务，以确保向后兼容。结合第2.6节关于协议ID 59的用法，ESP实现可以生成具有更大长度变化的虚拟和真实包，以支持TFC。

实现应提供本地管理控制，以便在每个SA基础上启用此功能，并允许用户指定是否启用及提供参数控制。

2.8. 完整性验证值（ICV）

完整性检查值（ICV）是一个可变长度的字段，其计算范围包括ESP头、有效载荷和ESP尾部字段。隐含的ESP尾部字段（如完整性填充和高阶ESN位（如适用））也包含在ICV的计算中。ICV字段是可选的，仅在选择了完整性服务时才存在，并由单独的完整性算法或使用ICV的组合模式算法提供。该字段的长度由所选的完整性算法及其关联的安全关联（SA）规定。完整性算法的规范必须明确ICV的长度以及验证时的比较规则和处理步骤。

3. 封装安全协议处理

3.1 ESP头部位置

ESP可以以两种方式使用：传输模式或隧道模式。

3.1.1 传输模式处理

在传输模式中，ESP插入在IP头之后、下一层协议（如TCP、UDP、ICMP等）之前。在IPv4的上下文中，这意味着将ESP放在IP头（及其包含的任何选项）之后，但在下一层协议之前。（如果还应用AH，则AH会应用于ESP头、有效载荷、ESP尾部和ICV（如果存在））（注意，“传输”模式一词不应被误解为仅限于TCP和UDP的使用。）以下图示说明了典型IPv4包中ESP传输模式的定位，采用“前后”示意。

（图示略）

在IPv6的上下文中，ESP被视为端到端的有效载荷，因此应出现在跳到跳、路由和分段扩展头之后。目的地选项扩展头可以出现在ESP头之前、之后或两者皆有，具体取决于所需的语义。然而，由于ESP只保护ESP头之后的字段，通常建议将目的地选项头放在ESP头之后。以下图示说明了IPv6包中ESP传输模式的定位。

（图示略）

注意：在传输模式中，对于“堆叠内”或“线缆内”实现（根据安全架构文档定义），入站和出站的IP碎片可能需要额外的IP重组/分段操作，以符合规范并提供透明的IPsec支持。在使用多个接口时，执行此类操作时需格外小心。

3.1.2 隧道模式处理

在隧道模式中，“内部”IP头携带最终的（IP）源和目的地址，而“外部”IP头包含IPsec“对等体”的地址，例如安全网关的地址。允许混合使用不同版本的内外IP（如IPv6 over IPv4或IPv4 over IPv6）。在隧道模式中，ESP保护整个内部IP数据包，包括整个内部IP头。ESP在隧道模式中的位置相对于外部IP头与传输模式相同。以下图示说明了IPv4和IPv6包中ESP隧道模式的定位。

（图示略）

3.2 算法

用于ESP的必备算法在单独的RFC中描述，以便可以独立于协议本身更新算法要求。除了强制的算法外，还可以支持其他算法。注意，虽然保密性和完整性是可选的，但必须至少选择其中一项服务，因此两者都不应同时为空。

3.2.1 加密算法

保护ESP包的加密算法由传输该包的SA指定。由于IP包可能乱序到达，且可能存在包丢失，每个包必须携带任何必要的数据，以使接收方能够建立解密的密码同步。这些数据可以在有效载荷字段中显式携带（如IV），也可以从外部IP或ESP包头的明文部分推导得出。（注意：如果使用明文头信息推导IV，该信息可能变得安全关键，从而扩大加密过程的保护边界。例如，若用ESP序列号推导IV，则序列号的生成逻辑（硬件或软件）必须作为加密算法的一部分进行评估。在FIPS 140-2标准中，这可能会显著扩大密码模块评估的范围。）由于ESP支持填充，所用的加密算法可能表现为块模式或流模式。请注意，鉴于加密（保密性）是可选服务（如仅提供完整性ESP），此算法可以是“NULL”。

为了使ESP实现能够计算块模式加密算法所需的填充长度，以及评估算法对MTU的影响，每个使用的加密算法的RFC必须规定其填充模数。

3.2.2 完整性算法

用于ICV计算的完整性算法由传输该包的SA指定。与加密算法类似，任何用于ESP的完整性算法都必须考虑包的乱序到达和包丢失问题。上述关于明文数据的注意事项同样适用。由于完整性服务可能是可选的，此算法也可以是“NULL”。

为了使ESP实现能够计算所用完整性算法所需的隐式填充，相关RFC必须规定该算法的填充模数。

3.2.3 组合模式算法

如果采用组合模式算法，则同时提供保密性和完整性服务。与加密算法一样，组合模式算法必须考虑每个包的密码同步，以允许乱序到达的包被正确解密和处理。不同算法在提供payload、SPI和（扩展）序列号字段的完整性方面可能采用不同的方法。为了实现统一的、与算法无关的调用方式，不定义payload的子结构。例如，SPI和序列号字段可能在密文封包中复制，ICV也可能附加在ESP尾部，但这些细节不应对外部可见。

为了使ESP实现能够评估组合模式算法对MTU的影响，每个使用的算法的RFC必须规定一个（简单的）公式，描述加密后有效载荷的大小，作为明文有效载荷和序列号大小的函数。

3.3 出站包处理

在传输模式中，发送方在ESP头和ESP尾字段之间封装下一层协议的信息，并保留原始IP头（在IPv6中还包括任何IP扩展头）。在隧道模式中，外部和内部IP头/扩展头可以以多种方式关联。封装过程中外部IP头/扩展头的构造在安全架构文档中描述。

3.3.1 安全关联查找

只有在IPsec实现确定某个包关联的SA需要ESP处理后，ESP才会应用于出站包。关于如何确定出站流量是否应用IPsec处理的过程，详见安全架构文档。

3.3.2 包的加密和ICV计算

在此部分，我们假设始终应用加密（出于格式考虑），理解“无保密性”时使用NULL加密算法（RFC 2410）。支持多种算法选项。

3.3.2.1 分离的保密性和完整性算法

如果采用分离的保密性和完整性算法，发送方的处理步骤如下：

1. 将下一层协议信息封装到ESP有效载荷字段中：
   - 传输模式——仅原始下一层协议信息；
   - 隧道模式——整个原始IP数据报。

2. 添加必要的填充——可选的TFC填充和（加密用的）填充。

3. 使用SA指定的密钥、加密算法和模式，以及任何必要的密码同步数据，对结果进行加密：
   - 如果指示有显式的密码同步数据（如IV），则按算法规范输入到加密算法中，并放入有效载荷字段；
   - 如果使用隐式密码同步数据，则按算法规范构造并输入到加密算法中；
   - 如果选择完整性，先进行加密（不包括ICV字段），再应用完整性算法。这种顺序有助于接收方快速检测和拒绝重放或伪造的包，避免在解密前处理，从而可能减轻拒绝服务（DoS）攻击的影响。也允许在接收端实现包的并行处理（解密与完整性验证同时进行）。注意：由于ICV未被加密保护，必须使用带密钥的完整性算法计算ICV。

4. 计算ESP包（不包括ICV字段）的ICV。ICV的计算范围包括SPI、序列号、有效载荷数据、填充（如有）、填充长度和下一个头字段。（注意：最后4个字段将以密文形式出现，因为先进行加密。）如果SA启用了ESN选项，序列号的高阶32位会在“下一个头”字段后附加，用于此计算，但不会传输。

（全文完）

对于某些完整性算法，进行ICV计算所使用的字节串必须是由算法指定的块大小的整数倍。如果ESP数据包的长度（如上所述）不符合该算法的块大小要求，则必须在ESP数据包的末尾添加隐式填充（padding）。这段填充是在“下一个头部”字段之后添加的，或者在启用ESN（扩展序列号）时，在序列号的高位32位之后添加。块大小（因此填充的长度）由完整性算法的规范规定。这段填充不会与数据包一同传输。定义完整性算法的文档必须被查阅，以确定是否需要如上所述的隐式填充。如果该文档未对这一问题作出说明，则默认假设需要隐式填充（以使数据包长度匹配算法的块大小）。如果需要填充字节，但算法未规定填充内容，则填充的八位组必须为零。

3.3.2.2. 结合机密性与完整性算法

如果采用组合的机密性/完整性算法，发送方的操作如下：

1. 将数据封装到ESP载荷数据字段中：
   - 传输模式——仅包含原始下一层协议的信息。
   - 隧道模式——包含整个原始IP数据报。

2. 添加必要的填充——包括可选的TFC填充和（加密的）Padding。

3. 使用为安全关联（SA）指定的密钥和组合模式算法，以及任何必需的密码同步数据，对结果进行加密和完整性保护。
   - 如果指示使用显式密码同步数据（如IV），则根据算法规范将其输入到组合模式算法中，并放在载荷字段中。
   - 如果采用隐式密码同步数据，则根据算法规范构造并输入到加密算法中。
   - 序列号（或扩展序列号，视情况而定）和SPI是算法的输入，因为它们必须包含在完整性校验计算中。这些值如何被包含在计算中，取决于所用的组合模式算法，因此在本标准中未作规定。
   - 当采用组合模式算法时，(显式的)ICV字段可以成为ESP包格式的一部分。如果未使用此字段，通常会在密文载荷中包含类似字段。任何完整性字段的位置，以及序列号和SPI如何包含在完整性计算中，必须在定义组合模式算法与ESP一起使用的RFC中明确。

3.3.3. 序列号生成

当建立安全关联（SA）时，发送方的计数器初始化为0。发送方为该SA递增序列号（或ESN）计数器，并将其低32位插入到序列号字段中。因此，使用某个SA发送的第一个数据包的序列号为1。

如果启用防重放（默认设置），发送方会在插入新值之前检查计数器是否已循环。换句话说，除非这样会导致序列号循环，否则不能在SA上发送数据包。试图传输会导致序列号溢出的数据包是可审计的事件。对此事件的审计日志应包括SPI值、接收的日期/时间、源地址、目标地址，以及（在IPv6中）明文Flow ID。

除非收到方另行通知（见第3.4.3节），发送方默认启用防重放。因此，ESP实现的典型行为是在序列号（或ESN）循环时，建立新的SA，或提前准备好。

如果用于计算ICV的密钥是手动分发的，符合规范的实现应不提供防重放服务。如果用户选择在手动密钥的SA中使用防重放，发送方的序列号计数器必须在本地重启等情况下正确维护，直到密钥被更换（见第5节）。

如果禁用防重放（如上所述），发送方无需监控或重置计数器，但仍会递增计数器，当达到最大值时，计数器会回绕到零（此行为建议用于多发方、多播SA，除非在发件人和收件人之间协商了标准之外的防重放机制）。

如果选择使用ESN（见附录），则只在序列号字段中传输低32位，发件人和收件人都维护完整的64位ESN计数器。高32位在完整性校验中以算法/模式特定的方式包含，例如，在使用单独完整性算法时，高位可能在“下一个头部”字段之后附加。

注意：如果接收方选择不启用某个SA的防重放，则不应在SA管理协议中协商ESN。使用ESN会要求接收方管理防重放窗口（以确定ESN高位的正确值，用于ICV计算），这通常与禁用SA的防重放机制的理念相悖。

3.3.4. 分片

在IPsec实现中，必要时在ESP处理之后进行分片。因此，传输模式的ESP仅应用于完整的IP数据报（不对IP分片应用）。已应用ESP的IP包本身可能在路由途中被分片，接收端在进行ESP处理前必须将这些分片重新组装。在隧道模式下，ESP应用于IP包，可能是IP数据报的分片。例如，安全网关或“堆栈内插”或“线内插”IPsec实现（如安全架构文档中定义）可能对这些分片应用隧道模式ESP。

注意：对于传输模式——如第3.1.1节末所述，堆栈内插和线内插实现可能需要先重新组装由本地IP层分片的包，然后再应用IPsec，最后再进行分片。

注意：对于IPv6——对于堆栈内插和线内插实现，必须检查所有扩展头，以确定是否存在分片头，从而判断是否需要在IPsec处理前重新组装包。

无论由IPsec实现还是由路径中的路由器进行的分片，都会显著降低性能。此外，ESP接收端接受分片进行重组的要求也会带来拒绝服务的风险。因此，ESP实现可以选择不支持分片，并在传输的包上标记“不要分片”位（DF位），以便进行路径MTU（PMTU）发现。无论如何，ESP实现必须支持生成ICMP PMTU消息（或本地主机实现的等效内部信令），以最大程度减少分片的可能性。关于MTU管理支持的详细信息，请参阅安全架构文档。

3.4. 入站数据包处理

3.4.1. 重组

如有需要，重组在ESP处理之前进行。如果接收到的包在ESP处理时表现为IP分片（即OFFSET字段非零或设置了“更多分片”标志），接收方必须丢弃该包；此为可审计事件。对此事件的审计日志应包括SPI值、接收的日期/时间、源地址、目标地址、序列号，以及（在IPv6中）明文Flow ID。

注意：关于包的重组，当前IPv4规范并不要求将OFFSET字段清零或“更多分片”标志清除。为了让重组后的包能被IPsec处理（而非作为明显的分片丢弃），IP代码在重组后必须执行这两项操作。

3.4.2. 安全关联查找

当收到包含ESP头的包时，接收方通过在安全关联数据库（SAD）中查找，确定相应的（单向）SA。对于单播SA，此查找基于SPI或SPI加协议字段（见第2.1节）。如果实现支持多播流量，还会用到目标地址（除了SPI之外），以及可能用到发件人地址（见第2.1节）（此过程在安全架构文档中有更详细描述）。SA的SAD条目还指示是否检查序列号字段、SA使用的序列号是32位还是64位，以及是否应存在（显式的）ICV字段（以及其大小）。此外，SAD还会指定用于解密和ICV计算的算法和密钥（如适用）。

如果没有有效的安全关联对应此包，接收方必须丢弃该包；此为可审计事件。对此事件的审计日志应包括SPI值、接收的日期/时间、源地址、目标地址、序列号，以及（在IPv6中）明文Flow ID。

（注意：如IKE等SA管理流量，不必根据SPI处理，可以通过“下一协议”和端口字段单独多路复用。）

3.4.3. 序列号验证

所有ESP实现必须支持防重放服务，且其启用与否由接收方在每个SA上决定。除非ESP完整性服务也启用，否则不得启用此服务，因为否则序列号字段未受到完整性保护。防重放适用于单播和多播SA。然而，本标准未规定多发方SA（单播或多播）的防重放机制。在未协商（或手动配置）此类SA的防重放机制的情况下，建议禁用发件人和收件人对序列号的检查（通过协商或手动配置），如下所述。

如果接收方未启用某个SA的防重放，则不会对入站序列号进行任何检查。但从发件方角度看，默认假设接收方启用了防重放。为了避免发件方进行不必要的序列号监控和SA建立（见第3.3.3节），如果采用SA建立协议，接收方应在建立期间通知发件方其不会提供防重放保护。

如果接收方启用了该SA的防重放服务，则在建立SA时，必须将该SA的接收包计数器初始化为零。每收到一个包，接收方必须验证该包的序列号不与该SA生命周期内已接收的其他包的序列号重复。这应是匹配到SA后对包进行的第一个ESP检查，以加快对重复包的拒绝。

ESP支持两阶段的序列号验证。这在ESP实现（通常是加密模块部分）不能以与未保护网络接口相同的速率进行解密和/或完整性检查时尤为重要。如果实现能够实现“线速”操作，则无需执行下述的预检阶段。

初步的序列号检查是利用ESP头中的序列号值在进行完整性验证和解密之前进行的。如果这个初步检查失败，数据包将被丢弃，从而避免接收方进行任何加密操作。如果初步检查成功，接收方尚不能修改其本地计数器，因为此时还未验证序列号的完整性。

重复包通过使用滑动接收窗口来拒绝。窗口的实现方式是本地的，但以下内容描述了实现必须具备的功能。

“右”边界代表在此安全关联（SA）上已验证的最高序列号值。包含比“左”边界低的序列号的数据包将被拒绝。落在窗口范围内的数据包会与窗口内已接收的数据包列表进行比对。如果为启用了ESN（扩展序列号）选项的SA，只会显式传输序列号的低32位，但接收方在检查接收的序列号是否在接收窗口内时，会使用由其本地计数器计算的完整序列号（包括高32位）。在构建完整序列号时，如果包中携带的低32位比接收方序列号的低32位还要小，接收方会假设高32位已被递增，进入新的序列号子空间。（该算法允许单个SA的接收出现最大为2^32-1包的间隙。如果出现更大的间隙，可以采用附录中描述的启发式方法进行重新同步。）

如果接收的包在窗口范围内且不是重复包，或者包在窗口右侧，并且使用了单独的完整性算法，则接收方会进行完整性验证。如果采用的是联合模式算法，则完整性验证与解密同时进行。无论哪种情况，如果完整性验证失败，接收方必须将该IP数据报视为无效并丢弃，这是一个可审计的事件。该事件的审计日志应包括SPI值、接收的日期/时间、源地址、目的地址、序列号，以及（IPv6时）流ID。只有在完整性验证成功后，接收窗口才会更新。（如果使用联合模式算法，保护完整性的序列号还必须与用于抗重放的序列号一致。）

当使用32位序列号时，最小窗口大小必须支持为32个包；优选且应作为默认值采用64个包。接收方也可以选择更大的窗口（大于最小值）。(接收方不会通知发送方窗口大小。)在高速环境中，无论安全保证如何，接收窗口都应增大。对于超高速设备（如多吉比特/秒级），最小和推荐的接收窗口大小未在本标准中规定。

3.4.4. 完整性检验值验证

与出站处理类似，入站处理也有多种选项，取决于所用算法的特性。

3.4.4.1. 分离的机密性和完整性算法

如果采用分离的机密性和完整性算法，处理流程如下：

1. 如果选择了完整性，接收方会用指定的完整性算法对除ICV外的ESP包进行计算，并验证其是否与包中携带的ICV相同。具体计算细节如下。

   如果计算出的ICV与接收的ICV匹配，则数据报有效，接受之；否则，必须将该IP数据报视为无效并丢弃，这是一个可审计事件。审计日志应包括SPI值、接收的日期/时间、源地址、目的地址、序列号，以及（IPv6时）明文流ID。

   实现提示：实现可以采用任何步骤，只要结果与以下步骤相同。首先移除并保存ICV字段，然后检查ESP包的总长度（减去ICV字段）。如果需要隐式填充（根据完整性算法的块大小），在Next Header字段之后或（如果启用了ESN）在序列号高32位之后，追加零填充字节。然后执行ICV计算，并用定义的比较规则与保存的值进行比对。

2. 接收方用密钥、加密算法、模式和同步数据（如有）对ESP载荷数据、填充、填充长度和下一头字段进行解密。这里假设总是进行加密（因为格式要求），但也可以使用NULL加密算法（RFC 2410）实现“无机密性”。

   - 如果指示了显式的同步数据（如IV），则从载荷字段取出并输入到解密算法中。
   - 如果指示了隐式同步数据，则构造本地版本的IV并输入到解密算法中。

3. 按照加密算法规范处理任何填充。如果采用了默认的填充方案（见第2.4节），则应在解密后检查填充字段，然后再去除填充，传递给下一层。

4. 检查Next Header字段。如果值为“59”（无下一头），则丢弃该（虚拟）包，不再处理。

5. 从ESP载荷字段重建原始IP数据报（传输模式）或传输层帧（隧道模式）。具体步骤依模式而定，详见安全架构文档。在IPv6环境中，接收方应确保解密后数据是8字节对齐，以便下一层协议处理。此处理会“丢弃”任何为流量隐私添加的（可选）TFC填充。

如果同时进行完整性验证和加密，必须在解密后完成完整性验证，才能将包传递给后续处理。这种顺序有助于快速检测和拒绝重放或伪造的包，避免在解密前进行验证，从而减少拒绝服务攻击的影响。

注意：如果解密和完整性验证是并行进行的，应注意避免在访问包和提取解密包时出现竞态条件。

3.4.4.2. 联合的机密性和完整性算法

如果采用联合的算法，接收方流程如下：

1. 使用密钥、算法、模式和同步数据（如有）对ESP载荷数据、填充、填充长度和下一头进行解密和完整性验证。SPI和（接收方的）包计数器（根据第3.4.3节的处理调整）作为输入，用于完整性验证。

   - 如果指示了显式同步数据（如IV），则从载荷字段取出并输入到解密算法中。
   - 如果指示了隐式同步数据（如IV），则构造本地版本的IV并输入到解密算法中。

2. 如果联合算法的完整性验证失败，必须将该IP数据报视为无效并丢弃，这是一个可审计事件。审计日志应包括SPI值、接收的日期/时间、源地址、目的地址、序列号，以及（IPv6时）明文流ID。

3. 按照加密算法规范处理任何填充（如果尚未处理）。

4. 检查Next Header字段。如果值为“59”，则丢弃该包。

5. 从ESP载荷字段提取原始IP数据报（隧道模式）或传输层帧（传输模式）。此操作会“丢弃”任何为流量隐私添加的（可选）TFC填充（见第2.4节）。

4. 审计

并非所有实现ESP的系统都支持审计功能，但如果在支持审计的系统中集成了ESP，则必须支持审计，并允许系统管理员启用或禁用ESP的审计功能。大部分审计的粒度是本地决定的，但本规范中已列出若干可审计事件，以及每个事件应包含的最少信息。

- 没有有效的安全关联（SA）存在。此事件的审计日志应包括SPI值、接收的日期/时间、源地址、目的地址、序列号，以及（IPv6时）明文流ID。

- 提交给ESP处理的包表现为IP片段（即OFFSET字段非零或设置了MORE FRAGMENTS标志）。审计日志应包括SPI值、接收的日期/时间、源地址、目的地址、序列号，以及（IPv6时）流ID。

- 试图传输会导致序列号溢出的包。审计日志应包括SPI值、当前日期/时间、源地址、目的地址、序列号，以及（IPv6时）明文流ID。

- 接收的包未通过抗重放检查。审计日志应包括SPI值、接收的日期/时间、源地址、目的地址、序列号，以及（IPv6时）流ID。

- 完整性验证失败。审计日志应包括SPI值、接收的日期/时间、源地址、目的地址、序列号，以及（IPv6时）流ID。

此外，还可以在审计日志中加入其他信息，未在本规范中明确列出的事件也可能引发审计记录。接收方无需向潜在的发件人发送任何消息以响应审计事件的检测，以避免引发拒绝服务攻击。

5. 合规性要求

实现声称符合或遵守本规范的实现必须为单播流量实现本文所描述的ESP语法和处理方式，并且必须遵守安全架构文档[Ken-Arch]所规定的所有额外的数据包处理要求。此外，如果某个实现声称支持多播流量，则必须符合支持此类流量的附加要求。如果用于计算ICV的密钥是手动分发的，为了正确提供防重放服务，必须在发送端正确维护计数器状态（包括在本地重启等情况下），直到密钥被更换为止，并且在计数器溢出即将发生时，可能没有自动恢复机制。因此，符合规范的实现不应在手动设置密钥的安全关联（SA）中提供防重放服务。

用于ESP的强制性算法在一份单独的文档[Eas04]中描述，以便可以独立于协议本身更新算法要求。除了强制要求的算法之外，还可以支持其他算法。

由于在ESP中使用加密是可选的，因此也需要支持“NULL”加密算法，以保持ESP服务协商方式的一致性。仅提供机密性服务的ESP版本是可选的。如果实现提供此服务，则必须同时支持“NULL”完整性算法的协商。注意，虽然在上述情况下完整性和加密都可以是“NULL”，但两者都不应同时为“NULL”。

6. 安全注意事项

安全性是该协议设计的核心，因此安全性考虑贯穿于整个规范。关于使用IPsec协议的其他安全相关方面，详见安全架构文档。

7. 与RFC 2406的差异

本文件与RFC 2406在多个重要方面存在差异。

- 机密性仅服务——现在为“可选”（MAY），而非“必须”（MUST）。
- SPI（安全参数索引）——已修改为为单播和多播SA的SAD查找指定统一算法，涵盖更广泛的多播技术。对于单播，SPI可以单独用来选择SA，也可以与协议结合使用（由接收方选择）。对于多播SA，SPI与目标地址（以及可选的源地址）结合，用于选择SA。
- 扩展序列号——新增了64位序列号的选项，适用于高速通信。明确了多播SA和多源多播SA的发送和接收端处理要求。
- 载荷数据——模型已扩展以支持组合模式算法。
- 填充以改善流量隐私——增加了在IP载荷末尾添加字节的要求，位于Padding字段之前。
- 下一头部——增加了生成和丢弃虚拟填充包（Next Header=59）的要求。
- ICV（完整性验证值）——模型已扩展以支持组合模式算法。
- 算法——新增了组合机密性模式算法。
- 强制算法的引用已移至单独的文档。
- 入站和出站数据包处理——现有两条路径：(1) 分别使用机密性和完整性算法，以及(2) 组合机密性模式算法。由于增加了组合模式算法，入站和出站的数据包处理中的加密/解密和完整性部分已合并。

8. 向后兼容性考虑

ESP中没有版本号，也没有机制让IPsec对等体发现或协商所使用的ESP版本。本节讨论由此带来的向后兼容性问题。

首先，如果未使用ESP v3中的任何新特性，则ESP v2和v3的数据包格式相同。如果使用仅在ESP v3中支持的组合模式加密算法，则生成的数据包格式可能与ESP v2规范不同。然而，只实现ESP v2的对等体不会协商此类算法，因为它们仅在ESP v3中定义。

IKE v2支持扩展序列号（ESN）协商，IKE v1则由IKE v1域解释的ESN附录处理。

在新版本的ESP（v3）中，为了更好地支持流量隐私（TFC），做出了两项规定：

- 在IP包末尾添加任意填充
- 使用Next Header=59的丢弃约定

第一个特性不应对接收方造成问题，因为IP总长度字段指示了IP包的结束。因此，任何在包末的TFC填充字节应在IP包处理（包括ESP处理）过程中被移除，即使IPsec软件未主动移除这些填充。因此，这是ESP v3的特性，发送方可以使用，无论接收方是否实现ESP v2或v3。

第二个特性允许发送方在隧道中发送一串任意字节（不一定是完整的IP包）作为TFC用途。对于ESP v2的接收方来说，遇到Next Header字段值为59的包时会做何反应尚未明确。它可能会丢弃此包并记录事件，但绝不能崩溃，因为这可能成为针对已认证对等体的拒绝服务（DoS）漏洞。因此，这一特性是ESP v3的优化，发送方可以使用，无论接收方是否实现ESP v2或v3。

9. 致谢

作者感谢Ran Atkinson的贡献，他在早期IPsec活动中发挥了关键作用，并撰写了首批IPsec标准：RFC 1825-1827。特别感谢Karen Seo在编辑本规范及其前一版本时提供的帮助。还感谢IPSEC和MSEC工作组的成员们，为本协议规范的制定做出的贡献。

10. 参考文献

10.1. 必要性参考文献

[Bra97] Bradner, S.，“用于RFC中的关键词以指示需求级别”，BCP 14，RFC 2119，1997年3月。

[DH98] Deering, S. 和 R. Hinden，“互联网协议，第6版（IPv6）规范”，RFC 2460，1998年12月。

[Eas04] 3rd Eastlake, D.，“封装安全载荷（ESP）和认证头（AH）加密算法实现要求”，RFC 4305，2005年12月。

[Ken-Arch] Kent, S. 和 K. Seo，“互联网协议的安全架构”，RFC 4301，2005年12月。

[Pos81] Postel, J.，“互联网协议”，STD 5，RFC 791，1981年9月。

10.2. 说明性参考文献

[Bel96] Steven M. Bellovin，“IP安全协议的问题领域”，第六届Usenix Unix安全研讨会论文集，1996年7月。

[HC03] Holbrook, H. 和 B. Cain，“IP的源特定多播”，进行中，2002年11月3日。

[Kau05] Kaufman, C.，编辑，“互联网密钥交换（IKEv2）协议”，RFC 4306，2005年12月。

[Ken-AH] Kent, S.，“IP认证头”，RFC 4302，2005年12月。

[Kra01] Krawczyk, H.，“保护通信的加密和认证顺序（或者：SSL有多安全？）”，CRYPTO 2001。

[NIST01] 联邦信息处理标准出版物140-2（FIPS PUB 140-2），“加密模块的安全要求”，国家标准与技术研究院，2001年5月25日。

[RFC3547] Baugher, M.，Weis, B.，Hardjono, T. 和 H. Harney，“解释域的组”，RFC 3547，2003年7月。

[RFC3740] Hardjono, T. 和 B. Weis，“多播组安全架构”，RFC 3740，2004年3月。

[Syverson] P. Syverson, D. Goldschlag 和 M. Reed，“匿名连接与洋葱路由”，安全与隐私研讨会论文集，奥克兰，加利福尼亚，1997年5月，第44-54页。

附录A：扩展（64位）序列号

A1. 概述

本附录描述一种用于IPsec（ESP和AH）的扩展序列号（ESN）方案，采用64位序列号，但每个包只传输低位的32位。内容包括检测重放包的窗口机制，以及用于重放拒绝和ICV计算的高位序列号的确定方法，还讨论了与未传输的高位序列号同步丢失的处理机制。

A2. 防重放窗口

接收端将维护一个大小为W的防重放窗口。该窗口限制包的乱序程度，限制在已验证的最高序列号包的相对位置内（即允许的乱序范围）。（除了已建立的32和64包大小的窗口外，没有强制的最小或推荐值，但建议实现者根据支持的接口速度调整这些值。以下算法假设窗口宽度不超过2^31个包。）所有与某个固定高位（Seqh）值相关的2^32个序列号（即序列号子空间）将被称为一个序列号子空间。下表列出相关变量及其定义。

变量名 | 位数 | 含义
--------|--------|------------------------------
W       | 32     | 窗口大小
T       | 64     | 当前已验证的最高序列号（窗口上界）
  Tl    | 32     | T的低32位
  Th    | 32     | T的高32位
B       | 64     | 窗口下界
  Bl    | 32     | B的低32位
  Bh    | 32     | B的高32位
Seq     | 64     | 接收包的序列号
  Seql  | 32     | Seq的低32位
  Seqh  | 32     | Seq的高32位

在进行防重放检查或确定用于验证的高位序列号时，有两种情况：

- 案例A：Tl >= (W - 1)。此时，窗口在一个序列号子空间内（见图1）。
- 案例B：Tl < (W - 1)。此时，窗口跨越两个序列号子空间（见图2）。

图示中，“----”表示连续的两个序列号子空间，零点表示每个子空间的起始位置。上方的较短线显示高位比特，"===="表示窗口，“****”代表未来的序列号（即超过当前最高验证序列号ThTl）。

A2.1. 管理和使用防重放窗口

防重放窗口可以视为一串比特位，长度为W。W = T - B + 1，且不应超过2^32 - 1。最低位对应B，最高位对应T，序列号范围从Bl到Tl的每个值由对应的比特表示。比特值指示是否已接收并验证了对应序列号的包，从而检测和拒绝重放包。

当接收到一个序列号为Seq（64位）且大于T的包时，验证通过后，应更新窗口状态。

+ B值会增加（Seq - T）
+ （Seq - T）比特会从窗口的低端丢弃
+ （Seq - T）比特会被添加到窗口的高端
+ 最高位会被设置，用以指示已收到并验证了具有该序列号的数据包
+ 在T和最高位之间的新比特会被设置，用以表示尚未收到具有这些序列号的数据包
+ T会被设置为新的序列号

在检查重放包时，

+ 在情况A中：如果Seql ≥ Bl（其中Bl = Tl - W + 1）且Seql ≤ Tl，则检查窗口中对应的比特，查看该Seql是否已被检测到。如果已检测到，则拒绝该数据包；如果未检测到，则进行完整性验证（详见附录A2.2中关于Seqh的确定方法）。

+ 在情况B中：如果Seql ≥ Bl（其中Bl = Tl - W + 1）或Seql ≤ Tl，则检查窗口中对应的比特，查看该Seql是否已被检测到。如果已检测到，则拒绝该数据包；如果未检测到，则进行完整性验证（详见附录A2.2中关于Seqh的确定方法）。

A2.2. 确定序列号的高阶比特（Seqh）

由于只会传输`Seql`，接收端必须推断并追踪每个数据包所属的序列号子空间，即确定Seqh的值。以下方程定义了在“正常”情况下如何选择Seqh；关于如何从极端丢包中恢复的讨论，请参见A3节。

+ 在情况A（图1）中：
  如果Seql ≥ Bl（其中Bl = Tl - W + 1），则Seqh = Th
  如果Seql <  Bl（其中Bl = Tl - W + 1），则Seqh = Th + 1

+ 在情况B（图2）中：
  如果Seql ≥ Bl（其中Bl = Tl - W + 1），则Seqh = Th - 1
  如果Seql <  Bl（其中Bl = Tl - W + 1），则Seqh = Th

A2.3. 伪代码示例

以下伪代码演示了上述反重放和完整性检查算法。`Seql`、`Tl`、`Th`和`W`的值都是32位无符号整数。算术运算采用模2^32。

```
如果 (Tl >= W - 1)                            情况A
    如果 (Seql >= Tl - W + 1)
        Seqh = Th
        如果 (Seql ≤ Tl)
            如果 (通过重放检测)
                如果 (通过完整性验证)
                    设置对应Seql的比特
                    允许数据包通过
                否则拒绝数据包
            否则拒绝数据包
        否则
            如果 (通过完整性验证)
                Tl = Seql（移位比特）
                设置对应Seql的比特
                允许数据包通过
            否则拒绝数据包
    否则
        Seqh = Th + 1
        如果 (通过完整性验证)
            Tl = Seql（移位比特）
            Th = Th + 1
            设置对应Seql的比特
            允许数据包通过
        否则拒绝数据包
否则                                    情况B
    如果 (Seql >= Tl - W + 1)
        Seqh = Th - 1
        如果 (通过重放检测)
            如果 (通过完整性验证)
                设置对应Seql的比特
                允许数据包通过
            否则拒绝数据包
        否则拒绝数据包
    否则
        Seqh = Th
        如果 (Seql ≤ Tl)
            如果 (通过重放检测)
                如果 (通过完整性验证)
                    设置对应Seql的比特
                    允许数据包通过
                否则拒绝数据包
            否则拒绝数据包
        否则
            如果 (通过完整性验证)
                Tl = Seql（移位比特）
                设置对应Seql的比特
                允许数据包通过
            否则拒绝数据包
```

A3. 由于大量数据包丢失引起的同步丢失处理

如果在单一安全关联（SA）上发生连续2^32个或更多未检测到的数据包丢失，传输端和接收端将失去高阶比特的同步，即A2.2节中的方程将无法正确计算出值。除非检测到并解决此问题，否则后续在该SA上的数据包将无法通过验证，且会被丢弃。任何支持ESN选项的IPsec（ESP或AH）实现都应采用以下方案。

注意，这种长时间的流量丢失在大多数情况下会在更高层检测到，IPsec无需调用A3.1和A3.2中描述的重同步机制。如果该SA上的流量中有大量TCP，源端会因未收到ACK而提前停止发送，远在丢失了2^32个包之前。此外，对于任何双向应用（即使在UDP之上），如此长时间的中断也可能触发超时机制。然而，单向应用（在UDP上运行）可能缺乏反馈机制，无法自动检测到如此大规模的丢失，因此需要开发相应的恢复方法。上述方案适用于安全网关之间、主机之间或主机与安全网关之间的SA。

我们选择的解决方案旨在：

+ 最小化对正常流量处理的影响
+ 避免引入新的拒绝服务攻击途径，例如攻击者通过强制触发重同步过程来占用资源
+ 将恢复机制限制在接收端——因为反重放服务仅由接收端提供，且传输端通常不知晓接收端是否启用序列号支持，故优先在接收端实现恢复机制。这也确保了向后兼容性。

A3.1. 触发重同步

每个SA，接收端会记录连续验证失败的数据包数。该计数用于触发重同步过程，建议在后台或由专用处理器执行。收到有效数据包后，计数会重置为零。触发重同步的阈值由本地参数设定。支持不同SA的不同触发值不是强制要求，但实现者可以选择支持。

A3.2. 重同步过程

当达到上述触发点时，会选择一个“异常”数据包，尝试用逐渐增大的Seqh值进行验证。每次重试，Seqh值递增1。重试次数应有限制，以避免处理“过去”的包或伪造包。限制值由本地参数设定。（由于Seqh值隐含在ESP（或AH）负载之后，可能可以通过在负载范围内执行完整性算法，然后变更Seqh值，计算不同的ICV候选值，从而优化此过程。）成功验证一个包后，会重置连续失败计数，并将T设置为该包的序列号。

此方案只需接收端支持，确保向后兼容。由于重同步操作可以在后台或由额外处理器完成，不会影响正常流量，也不会被拒绝服务攻击用来占用资源。

作者联系方式

Stephen Kent  
BBN Technologies  
10 Moulton Street  
Cambridge, MA 02138  
美国

电话：+1 (617) 873-3988  
电子邮箱：kent@bbn.com