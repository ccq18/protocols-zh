# RFC 5905 中文翻译 (stub)
# 原文文件: ../../rfcs/RFCs5501-6000/rfc5905.txt

互联网工程任务组（IETF）                          D. Mills
意见征求稿：5905                                   特拉华大学
废止：1305, 4330                                    J. Martin，主编
标准轨道类别                                              ISC
ISSN：2070-1721                                              J. Burbank
                                                               W. Kasch
                                                               JHU/APL
                                                               2010年6月


网络时间协议第4版：协议与算法规范

摘要

   网络时间协议（NTP）广泛用于同步互联网中的计算机时钟。本文档描述了NTP第4版（NTPv4），该版本与RFC 1305中描述的第3版（NTPv3）以及之前的协议版本向后兼容。NTPv4包括对协议头的修改，以适应互联网协议第6版（IPv6）地址族。NTPv4在缓解和校准算法方面进行了根本性改进，使得在现代工作站和高速局域网中，潜在的时间精度可达数十微秒。它引入了动态服务器发现机制，因此在许多情况下无需特定的服务器配置。它还修正了NTPv3设计和实现中的某些错误，并包含可选的扩展机制。

本备忘录的状态

   这是一个互联网标准轨道的文档。

   本文档由互联网工程任务组（IETF）制定，代表了IETF社区的共识。它经过公开审查，并已获互联网工程指导组（IESG）批准发布。关于互联网标准的更多信息，请参见RFC 5741的第2节。

   有关本文件当前状态、任何勘误以及反馈方式的信息，可在 http://www.rfc-editor.org/info/rfc5905 获取。

（以下为正文内容的翻译略，全文较长，建议根据需要逐段翻译。）

版权声明

   本文件的版权归2010年IETF信托及文档作者所有。保留所有权利。

   本文件受BCP 78和IETF信托关于IETF文档的法律规定（http://trustee.ietf.org/license-info）约束，适用于本文件发布之日。请仔细阅读这些文件，它们描述了您对本文件的权利和限制。从本文件中提取的代码组件必须包含简化BSD许可证文本（详见信托法律规定第4.e节），且提供时不附带任何担保。

   本文件可能包含在2008年11月10日之前发布或公开的IETF文档或贡献的内容。这些内容中某些部分的版权控制人可能未授权IETF信托在IETF标准流程之外修改这些内容。未经获得版权控制人的充分授权，不得在IETF标准流程之外修改本文件，也不得在IETF标准流程之外创建其派生作品，除非是为了将其格式化为RFC或翻译成非英语语言。

目录

   1. 引言 ....................................................4
      1.1. 需求符号 ..........................................5
   2. 操作模式 ..............................................6
   3. 协议模式 ..............................................6
      3.1. 动态服务器发现 ....................................7
   4. 定义 ....................................................8
   5. 实现模型 ..............................................10
   6. 数据类型 ..............................................12
   7. 数据结构 ..............................................16
      7.1. 结构约定 .........................................16
      7.2. 全局参数 .........................................16
      7.3. 数据包头变量 .....................................17
      7.4. Kiss-o'-Death包 ..................................24
      7.5. NTP扩展字段格式 ..................................25
   8. 线上传输协议 ..........................................26
   9. 对等进程 ..............................................30
      9.1. 对等进程变量 .....................................31
      9.2. 对等进程操作 .....................................33
   10. 时钟过滤算法 .........................................37
   11. 系统进程 .............................................39
      11.1. 系统进程变量 ....................................40
      11.2. 系统进程操作 ....................................41
           11.2.1. 选择算法 ..................................43
           11.2.2. 集群算法 ..................................44
           11.2.3. 组合算法 ..................................45
      11.3. 时钟校准算法 ....................................47
   12. 时钟调整过程 .........................................51
   13. 轮询过程 .............................................51
      13.1. 轮询过程变量 ....................................51
      13.2. 轮询过程操作 ....................................52
   14. 简单网络时间协议（SNTP） ............................54
   15. 安全考虑 .............................................55
   16. IANA考虑 .............................................58
   17. 致谢 ..................................................59
   18. 参考文献 .............................................59
      18.1. 标准引用 ........................................59
      18.2. 资料性引用 ......................................59
   附录A. 代码框架 ..........................................61
     A.1. 全局定义 ..........................................61
       A.1.1. 定义、常量、参数 ..............................61
       A.1.2. 数据包数据结构 ................................65
       A.1.3. 关联数据结构 ..................................66
       A.1.4. 系统数据结构 ..................................68
       A.1.5. 本地时钟数据结构 ..............................69
       A.1.6. 函数原型 ......................................69
     A.2. 主程序与实用例程 ................................70
     A.3. 内核输入/输出接口 ................................73
     A.4. 内核系统时钟接口 ................................74
     A.5. 对等进程 ..........................................76
       A.5.1. 接收函数 ......................................77
       A.5.2. 时钟过滤函数 ..................................85
       A.5.3. 快速传输函数 ..................................88
       A.5.4. 访问函数 ......................................89
       A.5.5. 系统进程 ......................................90
       A.5.6. 时钟调整进程 ................................103
       A.5.7. 轮询进程 ....................................104

（正文内容的详细翻译请根据需要逐段进行，以上为全文的概览和部分重点内容的翻译。）

在广播变体中，持久的广播服务器关联会定期发送广播服务器（模式5）数据包，多个客户端可以接收这些数据包。当接收到没有匹配关联的广播服务器数据包时，会临时建立一个广播客户端（模式6）关联，并持续存在直到出现错误或超时。这样做的目的是提供一个初始的“炮火”，让以客户端模式运行的客户端与服务器交换多次数据包，以校准传播延迟并运行Autokey安全协议，之后客户端会恢复到广播客户端模式。广播服务器会向客户端和其他服务器推送同步信息。

大致沿用电信行业的惯例，层级中每个服务器的级别由一个层级编号（stratum number）定义。主服务器被赋予第一层（stratum one）；每个较低层级的次级服务器的层级编号比上一层高一。随着层级编号的增加，其精度会因网络路径和系统时钟稳定性而逐渐降低。通过同步距离测量的平均误差大致与层级编号和往返延迟成正比。

作为标准做法，时钟网络拓扑应避免形成环路，并尽量减少同步距离。在NTP中，子网拓扑通过一种变体的Bellman-Ford分布式路由算法确定，该算法计算以主服务器为根的最短路径生成树。由于这种设计，即使出现故障，算法也会自动重新组织子网，以提供最准确、最可靠的时间。

3.1 动态服务器发现

有两种特殊的关联：多播客户端和多播服务器，它们提供动态服务器发现功能。多播客户端关联分为持久和临时两种。持久多播客户端会向指定的IPv4或IPv6广播或多播组地址发送客户端（模式3）数据包。范围内的指定多播服务器会监听带有该地址的包。如果某个服务器适合同步，它会用客户端的单播地址返回普通服务器（模式4）数据包。客户端收到后，会建立一个临时客户端（模式3）关联。该临时关联会持续直到出现错误或超时。

多播客户端会持续发送数据包，搜索最少数量的关联。它从TTL（生存时间）值为1开始，不断增加TTL，直到达到最小关联数或TTL达到最大值。如果TTL达到最大值仍未建立足够的关联，客户端会暂停一段时间以清除所有关联，然后重新开始搜索周期。一旦建立了最小数量的关联，客户端会每个超时周期发送一个数据包以维持关联。字段限制将TTL的最小值设为1，最大值设为255，这些限制可以根据具体应用需求调整。

临时关联之间会相互竞争。当新建立的临时关联出现时，客户端会运行第10节和11.2节描述的缓解算法，从中筛选出最优候选，其他临时关联会超时并被取消。这样，关联池中只保留最近响应过NTP数据包、最优的候选，从而用以校准系统时钟。

4. 定义

本节定义了许多技术术语。时间尺度是一个参考框架，其中时间以单调递增的二进制计数器的值表示，计数器可以有无限多位。它以秒和秒的小数部分计数，使用十进制点。协调世界时（UTC）时间尺度由ITU-R TF.460定义。在1865年的米制公约框架下，1975年国际计量局（CGPM）强烈支持以UTC作为民用时间的基础。

UTC时间尺度代表由国家标准实验室传播的平均太阳时。系统时间由硬件和操作系统维护的系统时钟表示。NTP算法的目标是尽量减小UTC与系统时钟之间的时间差和频率差。当这些差异降低到名义容差以下时，系统时钟被认为已同步到UTC。

事件的日期是事件发生的UTC时间。日期是瞬时值，用大写T表示。运行时间是与NTP程序的同步功能一致的另一时间尺度。

时间戳T(t)表示在运行时间t时的UTC日期或UTC偏移量。具体含义应根据上下文判断。定义T(t)为UTC偏移，R(t)为频率偏移，D(t)为老化速率（R(t)对t的导数）。如果在t=t_0时，T(t_0)是已确定的UTC偏移，则在时间t的UTC偏移为：

T(t) = T(t_0) + R(t_0)(t - t_0) + 1/2 * D(t_0)(t - t_0)^2 + e，

其中e是后文讨论的随机误差项。虽然D(t)在表征高精度振荡器时很重要，但在计算机振荡器中通常忽略。在本文中，所有时间值以秒（s）为单位，所有频率值以秒每秒（s/s）为单位。有时为了方便，会用百万分之一（ppm）表示频率偏移，其中1 ppm等于10^(-6) s/s。

在计算机时间管理中，评估时间函数的性能非常重要。NTP性能模型包括四个统计量，每次客户端与服务器测量时更新。偏移（theta）表示服务器时钟相对于系统时钟的最大似然偏差；延迟（delta）表示客户端与服务器之间的往返延迟；色散（epsilon）表示测量固有的最大误差，随系统时钟最大频率容差（PHI，通常为15 ppm）线性增加。抖动（psi）定义为最近偏差差值的均方根（RMS）平均，代表估算偏差的名义误差。

虽然theta、delta、epsilon和psi统计量分别反映系统时钟相对于各个服务器的测量，但NTP协议还包括机制，将多个服务器的统计信息结合起来，更准确地校准系统时钟。系统偏差（THETA）代表对服务器群体的最大似然偏差估计；系统抖动（PSI）代表估算系统偏差的名义误差。根延迟（DELTA）和根色散（EPSILON）由每个层级从参考时钟累积而来，反映根延迟和色散。同步距离（LAMBDA）等于EPSILON + DELTA/2，代表由各种原因引起的最大误差。这些统计量的详细计算方法在第11.2节中给出，供相关应用评估同步性能。

5. 实现模型

图2展示了典型的多线程实现架构。它包括两个专用进程：一是对等（peer）进程，用于接收来自服务器或参考时钟的消息；二是轮询（poll）进程，用于向服务器或参考时钟发送消息。

.....................................................................
. 远程   .   对等/轮询  .              系统          .  时钟   .
. 服务器  .   进程      .              进程          . 调节   .
.          .              .                              . 过程  .
. +--------+. +-----------+. +------------+               .      .
. |        |->|           |. |            |               .      .
. | 服务器1 |  |对等/轮询1|->|            |               .      .
. |        |<-|           |. |            |               .      .
. +--------+. +-----------+. |            |               .      .
.          .       ^      . |            |               .      .
.          .       |      . |            |               .      .
. +--------+. +-----------+. |            |  +-----------+.      .
. |        |->|           |. | 选择和     |->|           |. +----+ .
. | 服务器2 |  |对等/轮询2|->| 集群算法   |  |合并算法   |->| 循环 | .
. |        |<-|           |. |            |  |           |. |滤波| .
. +--------+. +-----------+. |            |->|           |. +----+ .
.          .       ^      . |            |  +-----------+.    |   .
.          .       |      . |            |               .    |   .
. +--------+. +-----------+. |            |               .    |   .
. |        |->|           |. |            |               .    |   .
. | 服务器3 |  |对等/轮询3|->|            |               .    |   .
. |        |<-|           |. |            |               .    |   .
. +--------+. +-----------+. +------------+               .    |   .
....................^.........................................|......
                       |                                    .    V   .
                       |                                    . +-----+ .
                       +------------------------------------| VFO | .
                                                            . +-----+ .
                                                            .  时钟   .
                                                            .  调整   .
                                                            .  过程   .
                                                            ............

图2：实现模型

这些进程在一个公共数据结构——关联（association）中操作，该结构包含上述统计信息以及第9节描述的其他数据。客户端向一个或多个服务器发送数据包，并在收到响应后进行处理。服务器会交换源和目标地址及端口，覆盖某些字段后立即返回（在客户端/服务器模式下）或在稍后时间返回（在对称模式下）。每接收一条NTP消息，就会计算出对等时钟与系统时钟之间的偏差theta，以及相关的统计量delta、epsilon和psi。

系统进程包括选择、集群和合并算法，用于在多个服务器和参考时钟之间进行缓解，选出最准确、最可靠的候选对象以同步系统时钟。选择算法利用拜占庭容错原理，剔除假设不正确的“虚假计时器”（falsetickers），只保留“真信号器”（truechimers）。真信号器是指能保持已公布且可信标准时间的时钟，而虚假计时器则显示误导或不一致的时间。集群算法利用统计原理找到最优的真信号器集合。合并算法通过对存活的真信号器的偏差进行统计平均，计算出最终的时钟偏差。

时钟调节过程是一个控制系统，调节系统时钟的时间和频率（由可变频振荡器VFO实现）。从VFO产生的时间戳闭合反馈回路，维持系统时钟的时间。相关的时钟调节过程每秒运行一次，注入计算得出的时间偏差，保持频率恒定。过去时间偏差的均方根（RMS）平均值代表系统时钟的名义误差或抖动；过去频率偏差的RMS平均值代表振荡器的频率稳定性或频率漂移。这些定义在第11.3节中有详细说明。

客户端以poll指数tau确定的间隔（2^tau秒）向每个服务器发送消息。在NTPv4中，tau的范围是4（16秒）到17（36小时）。tau值由时钟调节算法确定，以匹配环路时间常数T_c = 2^tau。在客户端/服务器模式下，服务器会立即响应；而在对称模式下，两个对等点会根据当前系统偏差和抖动动态调整tau值，可能不同。为了保持大规模NTP子网的稳定性，必须仔细控制时钟调节算法的动态行为。这要求双方在协商中达成一致，选择一个共同的tau值，通常为两个对等点的最小轮询指数。NTP协议提供了相应的协商机制以确保这一点。

实现模型包括一些设置和调整系统时钟的方法。假设操作系统提供两个函数：一个用于直接设置时间，例如Unix的settimeofday()函数，另一个用于以小的增量调整时间，使时间前进或后退一定的量，例如Unix的adjtime()函数。在本文及后续参考中，函数名后面的括号表示引用该函数，而非简单变量。在预期的设计中，时钟控制进程在调整量小于某个阈值时使用adjtime()函数，否则使用settimeofday()函数。具体的实现方式以及阈值的数值将在第10节中描述。

6. 数据类型

所有的NTP时间值都采用二补数格式表示，位的编号采用大端序（详见[RFC0791]附录A的描述），从左侧（高位）开始编号为零。有三种NTP时间格式：128位日期格式、64位时间戳格式和32位短格式，如图3所示。当存储空间和字长允许时，采用128位日期格式。该格式包括一个64位有符号秒数字段，跨度达5840亿年，以及一个64位的分数字段，分辨率达到0.05阿秒（即0.5×10^(-18)秒）。为了方便在不同格式之间映射，秒数字段被划分为一个32位的时代编号（Era Number）和一个32位的时代偏移（Era Offset）字段。NTP不能直接生成时代（Eras），也没有必要这样做。当需要时，可以通过外部手段（如文件系统或专用硬件）派生出它们。

（此处为图示，展示不同时间格式的二进制布局）

图3：NTP时间格式

64位时间戳格式用于数据包头和其他字长有限的场合。它包括一个32位无符号秒数字段，跨度136年，以及一个32位的分数字段，分辨率达到2^(-232)皮秒。32位短格式用于延迟和色散头字段中，此时不需要完整的分辨率和范围。它包括一个16位无符号秒数字段和一个16位分数字段。

在日期和时间戳格式中，原点（prime epoch）或第0时代的基准日期为1900年1月1日UTC，所有位均为零。应注意，严格来说，UTC在1972年1月1日之前并不存在，但为了方便起见，假设它自古以来就存在，即使所有关于历史闰秒的知识已丢失。日期相对于原点，值大于零表示该日期之后的时间，值小于零表示之前的时间。注意，日期格式的Era Offset字段和时间戳格式的Seconds字段具有相同的解释。

时间戳为无符号值，对其的操作产生的结果仍在同一或相邻的时代内。时代0包括从原点到2036年某个时间的日期，当时间戳字段溢出时，进入下一时代（Era 1）的基准日期被建立。在任何格式中，值为零是特殊值，表示未知或未同步的时间。图4列出一些具有代表性的历史NTP日期，以及它们对应的修正儒略日（MJD）、NTP时代和时间戳。

（此处为示意表格，列出重要的历史日期）

图4：有趣的历史NTP日期

令p为秒分数部分的有效位数，时钟的分辨率定义为2^(-p)秒。为了减少偏差并使时间戳难以被入侵者预测，非有效位应设置为无偏的随机比特串。时钟的精度定义为读取系统时钟所需的时间（秒）。注意，这种定义的精度可能大于或小于分辨率。协议中使用的精度（rho）取两个中的较大值。

对日期和时间戳的唯一允许算术操作是二补数减法，结果为127位或63位有符号数。确保两个日期的一阶差异保持完整的128位精度，两个时间戳的一阶差异保持完整的64位精度非常重要。然而，差异通常比秒数跨度小，可以转换为浮点双精度格式进行进一步处理，而不会损失精度。

需要注意的是，二补数算术不区分有符号和无符号值（尽管比较操作可以考虑符号）；只有条件跳转指令会考虑符号。因此，虽然对有符号日期和无符号时间戳进行了区分，但它们的处理方式相同。可能存在的风险是，跨越2036年等时代的64位时间戳计算可能会溢出。实际上，如果客户端在协议启动前与服务器相差不超过68年，即使客户端和服务器处于相邻的时代，也能获得正确的值。

一些时间值采用指数格式表示，包括精度、时间常数和轮询间隔。这些值以8位有符号整数的对数（以2为底的对数）秒为单位。允许的算术操作只有递增和递减。为了简化表达，本文中对这些变量的引用若是变量名，表示指数值，例如轮询间隔为1024秒；若是变量名和指数同时出现，则表示实际值，例如轮询指数为10。

将任何格式的系统时间转换为NTP日期和时间戳格式，需先确定从原点到系统时间的秒数s。给定s，计算对应的时代（era）和时间戳（timestamp）的方法为：

era = s / 2^32，  
timestamp = s - era * 2^32。

此方法适用于正负日期。反之，给定时代和时间戳，计算s的方法为：

s = era * 2^32 + timestamp。

在NTP和系统时间之间转换可能较为复杂，超出本文范围。注意，时代0中的天数比大多数其他时代多1天，直到2400年时代3才会再次出现这种情况。

在后续的状态变量描述中，明确提到的整数类型意味着32位无符号整数。这简化了边界检查，因为只需定义上限。未特别说明时，默认类型为64位浮点双精度数。必要时会注明例外。

7. 数据结构

以下章节定义了NTP状态机。状态变量根据其在数据包头、对等体和轮询过程、系统进程以及时钟控制过程中的功能被划分为不同类别。数据包变量代表传输和接收数据包中的NTP头值。对等体和轮询变量代表每个服务器的关联内容。系统变量代表由其依赖的客户端观察到的服务器状态。时钟控制变量代表时钟控制算法的内部工作机制。附录A中有示例。

7.1 结构命名约定

为了区分同名但在不同进程中使用的变量，采用如下命名规则（见图5）：接收数据包变量v在数据包结构中的完整限定名为r.v；类似地，x.v表示发射数据包变量，p.v表示对等体变量，s.v表示系统变量，c.v表示时钟控制变量。每个关联（对等体）有一组对等体变量；系统和时钟变量只有一组。

（此处为示意表格，列出前缀及其含义）

图5：前缀命名规则

7.2 全局参数

除了变量类别外，本文还定义了一些全局参数，包括图6所示的值。

（此处为示意表格，列出参数名、值和描述）

虽然这些是实现互操作性所需的唯一全局参数，但在任何实现中都需要更大范围的参数集合。附录A.1.1列出了用于骨架（skeleton）中的缓解算法、时钟控制算法以及相关的依赖实现函数所使用的参数。这些参数中的一些是固定不变的，比如由IANA分配的NTP端口号和NTPv4本身的版本号。另一些参数，如频率容差（也称为PHI），则涉及对系统时钟在同步后以及在源不可达时允许漂移的最坏情况行为的假设。最小值和最大值参数定义了本文后续章节中描述的状态变量的界限。

虽然本文中显示的参数值是固定的，但某些实现可能允许通过配置命令将其设为可调变量。例如，参考实现会通过多次读取系统时钟的最小时间的对数值来计算PRECISION。

7.3. 数据包头变量

从外部角度来看，最重要的状态变量是图7及以下部分描述的包头变量。NTP数据包头由若干个32位（4字节）字组成，采用网络字节序。数据包格式由三个部分组成：包头本身、一个或多个可选的扩展字段，以及一个可选的消息认证码（MAC）。包头部分与NTPv3及之前版本的包头相同。可选的扩展字段由[RFC5906]中描述的Autokey公钥密码算法使用。可选的MAC则被Autokey和本文所述的对称密钥密码算法共同使用。

图7：包头变量

NTP数据包是一个UDP数据报[RFC0768]。某些字段使用多个字，而其他字段则在一个字内以较小的字段打包。图8所示的NTP包头由12个字组成，后跟可选的扩展字段，最后是由密钥标识符字段和消息摘要字段组成的可选消息认证码（MAC）。

（此处为包头格式的ASCII示意图）

扩展字段用于添加可选功能，例如Autokey安全协议[RFC5906]。扩展字段的格式设计是为了使数据包可以在不了解扩展字段具体功能的情况下进行解析。MAC则由Autokey和对称密钥认证方案共同使用。

包头变量列表见图7，详细描述如下。除在使用IPv6地址族时有少许变化外，这些字段与NTPv3兼容。包头字段适用于传输中的数据包（前缀为x）和接收的数据包（前缀为r）。在图8中，某些多字字段的大小以比特为单位显示（如果不是默认的32比特）。基本包头从数据包开始到传输时间戳字段结束。

字段及其对应的包头变量（括号内为字段名）解释如下：

- LI（leap）：2位整数，表示即将插入或删除闰秒的警告，值定义见图9。
  
  +-------+------------------------------+
  | 值    | 含义                         |
  +-------+------------------------------+
  | 0     | 无警告                       |
  | 1     | 当日最后一分钟有61秒         |
  | 2     | 当日最后一分钟有59秒         |
  | 3     | 未知（时钟未同步）             |
  +-------+------------------------------+

- VN（version）：3位整数，表示NTP版本号，目前为4。

- mode（模式）：3位整数，表示工作模式，值定义见图10。

  +-------+--------------------------+
  | 值    | 含义                     |
  +-------+--------------------------+
  | 0     | 保留                     |
  | 1     | 对称主动                 |
  | 2     | 对称被动                 |
  | 3     | 客户端                   |
  | 4     | 服务器                   |
  | 5     | 广播                     |
  | 6     | NTP控制消息              |
  | 7     | 保留（私用）             |
  +-------+--------------------------+

- stratum（层级）：8位整数，表示层级，值定义见图11。

  +--------+--------------------------------------------------+
  | 值     | 含义                                             |
  +--------+--------------------------------------------------+
  | 0      | 未指定或无效                                     |
  | 1      | 主要服务器（如配备GPS接收器）                     |
  | 2-15   | 次级服务器（通过NTP）                              |
  | 16     | 未同步                                           |
  | 17-255 | 保留                                             |
  +--------+--------------------------------------------------+

通常将接收包中的层级值0映射为p.stratum的最大值（16），并将p.stratum值大于等于最大值的映射为0（在发出包时）。这样可以方便地用相同的时钟选择算法处理参考时钟（通常在层级0）。

- poll（轮询）：8位有符号整数，表示连续消息之间的最大间隔（以log2秒为单位）。建议的最小和最大轮询间隔为6和10。

- precision（精度）：8位有符号整数，表示系统时钟的精度（以log2秒为单位）。例如，值-18大约对应一微秒的精度。系统首次启动时，可以通过多次读取系统时钟的最小时间来确定。

- rootdelay（根延迟）：到参考时钟的总往返延迟，采用NTP短格式。

- rootdisp（根色散）：到参考时钟的总色散，采用NTP短格式。

- refid（参考ID）：32位代码，标识特定的服务器或参考时钟。其解释依赖于stratum字段的值。对于层级0（未指定或无效）包，使用四字符ASCII字符串（“kiss code”）用于调试和监控。对于层级1（参考时钟），则为分配给参考时钟的四字节、左对齐、零填充的ASCII字符串。IANA维护着权威的参考标识符列表，但以“X”开头的字符串保留用于未注册的试验和开发。图12列出了常用的ASCII标识符。

（此处为图12：参考标识符列表）

在层级1以上（次级服务器和客户端），该字段为服务器的参考标识符，用于检测时间环路。如果使用IPv4地址族，则为四字节IPv4地址；如果使用IPv6地址族，则为IPv6地址的MD5哈希的前四个字节。注意，在NTPv4服务器上使用IPv6地址族而客户端为NTPv3时，参考标识符字段可能显示为随机值，可能无法检测到时间环路。

- reftime（参考时间戳）：系统上次设置或校正时间的时间点，采用NTP时间戳格式。

- org（起始时间戳）：客户端发出请求时的时间，采用NTP时间戳格式。

- rec（接收时间戳）：服务器收到请求的时间，采用NTP时间戳格式。

- xmt（传输时间戳）：服务器发出响应的时间，采用NTP时间戳格式。

- dst（目的时间戳）：客户端收到响应的时间，采用NTP时间戳格式。

注意：目的时间戳字段未作为包头字段包含，而是在包到达时由接收端测得，并存放在包缓冲区数据结构中。

如果NTP访问物理层，则时间戳与帧开始符号之后的符号起始时间相关，否则实现应尽量将时间戳关联到帧中最早可访问的点。

MAC由密钥标识符（Key Identifier）和消息摘要（Message Digest）组成。消息摘要（或加密和）按照[RFC1321]中的方法计算，覆盖所有NTP包头和可选扩展字段，但不包括MAC本身。

扩展字段n：详见第7.5节，描述该字段的格式。

Key Identifier（keyid）：32位无符号整数，客户端和服务器用其标识一个秘密的128位MD5密钥。

Message Digest（digest）：128位MD5哈希值，计算方式为先对密钥和NTP包头及扩展字段（不包括Key Identifier和Digest字段）进行哈希。

应注意，此处使用的MAC计算方式与[RFC1305]和[RFC4330]中定义的不同，但与现有实现生成MAC的方式一致。

7.4. 拒绝包（Kiss-o'-Death Packet）

如果Stratum字段为0，意味着未指定或无效，此时可以使用参考标识符字段传达对状态报告和访问控制有用的信息。这些被称为“吻别包”（Kiss-o'-Death，简称KoD包），它们传达的ASCII消息被称为“kiss代码”。KoD包得名于早期的用途，即通知客户端停止发送违反服务器访问控制的包。kiss代码可以为智能客户端（无论是NTPv4还是SNTPv4）提供有用的信息。kiss代码以四字符ASCII字符串编码，左对齐并用零填充。这些字符串设计用于字符显示和日志文件。当前定义的kiss代码列表见图13。接收方必须检查kiss代码，并在以下情况下采取相应措施：

a. 对于kiss代码DENY和RSTR，客户端必须解除与该服务器的所有关联，并停止向该服务器发送包；

b. 对于kiss代码RATE，客户端必须立即降低对该服务器的轮询间隔，并在每次收到RATE kiss代码时持续减小；

c. 以ASCII字符“X”开头的kiss代码用于未注册的试验和开发，未被识别的应予忽略；

d. 除上述情况外，KoD包没有协议意义，接收后应予以丢弃。

| 代码 | 含义 |
|--------|--------------------------------------------------------------|
| ACST  | 该关联属于单播服务器。                                       |
| AUTH  | 服务器认证失败。                                             |
| AUTO  | 自动密钥序列失败。                                             |
| BCST  | 该关联属于广播服务器。                                         |
| CRYP  | 密码学认证或识别失败。                                         |
| DENY  | 远程服务器拒绝访问。                                           |
| DROP  | 在对称模式中失去对等方。                                       |
| RSTR  | 由于本地策略拒绝访问。                                         |
| INIT  | 该关联尚未同步首次时间。                                         |
| MCST  | 该关联属于动态发现的服务器。                                     |
| NKEY  | 未找到密钥。可能是密钥未安装或不受信任。                         |
| RATE  | 超出速率。服务器暂时拒绝访问，因为客户端超出速率阈值。           |
| RMOT  | 由运行ntpdc的远程主机更改了关联。                               |
| STEP  | 系统时间发生跳变，但关联尚未重新同步。                           |

图13：kiss代码

在KoD包中，接收时间戳和传输时间戳（由服务器设置）未定义，不能依赖其有效值，必须丢弃。

7.5 NTP扩展字段格式

在NTPv4中，可以在头部之后、MAC之前插入一个或多个扩展字段，当存在扩展字段时，MAC始终存在。除了定义字段格式外，本文件未使用扩展字段内容。扩展字段包含请求或响应消息，其格式如图14所示。

图14：扩展字段格式

所有扩展字段都用零填充至字（四个八位字节）边界。字段类型（Field Type）字段特定于定义的功能，此处不详述。虽然包含必需字段的最小字段长度为四个字（16字节），但最大字段长度尚未确定。

长度（Length）字段是一个16位无符号整数，表示整个扩展字段的长度（以八位字节为单位），包括填充字段。

8  线协议

NTP线协议的核心机制在于服务器、对等点和客户端之间交换时间值的过程。该机制本质上能抵抗包的丢失或重复。数据完整性由IP和UDP校验和提供。没有流控制或重传机制，也不需要。协议使用时间戳，这些时间戳要么从包头提取，要么在包到达或离开时由系统时钟生成。时间戳是高精度数据，在链路层重传时应重新生成，并在传输时校正以计算MAC。

NTP消息使用两种不同的通信模式：点对点（单播）和一对多（广播），通常称为单播和广播。本文中，广播一词被解释为任何可用的一对多机制。对于IPv4，这包括IPv4广播或IPv4多播；对于IPv6，则是IPv6多播。为此，IANA已分配IPv4多播地址224.0.1.1和IPv6多播地址以“：101”结尾，前缀由作用域规则确定。除这些已分配的多播地址外，还可以使用其他未分配的多播地址。

线协议使用编号为t1到t4的四个时间戳和三个状态变量org、rec和xmt（见图15）。该图展示了最一般的情况，即两个对等点A和B各自独立测量相对于对方的偏移和延迟。为了说明，包中的时间戳用小写字母表示，状态变量用大写字母。状态变量在包到达或离开时从对应的时间戳复制而来。

（此处省略部分图示描述，详见原文）

在图中，A发出的第一个包只包含起始时间戳t1，随后复制到T1。B在t2时收到包，将t1复制到T1，将接收时间戳t2复制到T2。此时或稍后在t3，B向A发送一个包，包含t1、t2和传输时间戳t3。所有三个时间戳复制到相应的状态变量中。A在t4时收到包，包中含有t1、t2、t3和目的时间戳t4。这四个时间戳用来计算B相对于A的偏移和延迟，具体如下。

在更新xmt和org状态变量之前，会进行两个合理性检查，以防止重复、伪造或重放包。在上述交换中，如果包中的传输时间戳t3与org状态变量T3相匹配，则为重复或重放包；如果包中的起始时间戳t1与xmt状态变量T1不符，则为伪造包。在任何一种情况下，都会更新状态变量，然后丢弃该包。为了防止重放最后一次传输的包，成功进行伪造检查后，立即将xmt状态变量设为零。

最近的四个时间戳T1到T4用于计算B相对于A的偏移：

θ = T(B) - T(A) = 1/2 * [(T2 - T1) + (T3 - T4)]

以及往返延迟：

δ = T(ABA) = (T4 - T1) - (T3 - T2)

注意，括号内的量由64位无符号时间戳计算，结果为带符号值，具有63个有效位和符号位。这些值可以表示从68年前到68年后的日期。然而，偏移和延迟是这些值的和差，包含62个有效位和两个符号位，因此可以表示从34年前到34年后的无歧义值。换句话说，客户端的时间必须在服务器时间的34年范围内才能正常启动服务。这是64位整数运算的根本限制。

在支持浮点双精度运算的实现中，一级差分可以转换为浮点双精度，然后在该运算中计算二级和差分。由于二级项通常相对于时间戳的量级非常小，精度不会丢失，但无歧义范围从34年恢复到68年。

在某些情况下，如果客户端的初始频率偏差较大且传播时间较短，延迟计算可能变为负值。例如，频率差为100 ppm，T4-T1间隔为64秒，则表观延迟为-6.4毫秒。由于负值在后续计算中具有误导性，应将δ的值夹紧（clamp）在系统精度s.rho（在第11.1节中描述，以秒为单位）之上。

上述讨论假设最一般的情况，即两个对等点各自独立测量偏移和延迟。在无状态服务器的情况下，协议可以简化。无状态服务器会将客户端包中的T3和T4复制到服务器包的T1和T2，并在发送前附加传输时间戳T3。关于填写剩余协议字段的详细信息，见第9节及后续章节和附录。

请注意，所述线协议能抵抗服务器响应包的重放，但不能抵抗客户端请求包的重放，后者可能导致服务器回复包中的T2和T3值更新，从而产生错误的偏移和延迟。为避免此漏洞，应在计算偏移和延迟后，将xmt状态变量设为零。

以下是对该英文内容的中文流畅翻译：

---

接下来的过程描述包括重要状态变量的列出，以及作为例程实现的过程操作的概述。文中频繁提及附录中的框架（skeleton）。该框架包含用C语言编写的片段，详细描述了各个函数。它包括实现符合NTPv4标准所需的参数、变量和声明。然而，在实际工作中，可能还需要许多额外的变量和例程。

当收到服务器或对等点（peer）数据包时，会调用对等点（peer）进程。它执行在线协议（on-wire protocol），以确定时钟偏差和往返延迟，并计算系统和轮询（poll）进程使用的统计信息。对等变量在关联数据结构初始化时被实例化，并由到达的数据包更新。每个服务器都对应有一个对等点进程、轮询进程和关联进程。

---

**9.1 对等点（Peer）进程变量**

图16、17、18和19总结了对等点变量的常用名称、公式名称及简要描述。常用名称和公式名称可以互换；公式名称旨在增强本规范中方程的可读性。除非另有说明，所有对等变量都假定有前缀p。

| 名称      | 公式名   | 描述                     |
|-----------|----------|--------------------------|
| srcaddr   | srcaddr  | 源地址                   |
| srcport   | srcport  | 源端口                   |
| dstaddr   | dstaddr  | 目的地址                 |
| dstport   | destport | 目的端口                 |
| keyid     | keyid    | 密钥标识符（Key ID）     |

图16：对等点进程配置变量

| 名称      | 公式名   | 描述                     |
|-----------|----------|--------------------------|
| leap      | leap     | 跳跃指示器               |
| version   | version  | 版本号                   |
| mode      | mode     | 模式                     |
| stratum   | stratum  | 层级                     |
| ppoll     | ppoll    | 对等点轮询指数           |
| rootdelay | delta_r  | 根延迟                   |
| rootdisp  | epsilon_r| 根色散（分散）           |
| refid     | refid    | 参考ID                   |
| reftime   | reftime  | 参考时间戳               |

图17：对等点进程数据包变量

| 名称  | 公式名 | 描述                     |
|--------|--------|--------------------------|
| org    | T1     | 起始时间戳               |
| rec    | T2     | 接收时间戳               |
| xmt    | T3     | 传输时间戳               |
| t      | t      | 数据包时间               |

图18：对等点进程时间戳变量

| 名称    | 公式名   | 描述                     |
|---------|----------|--------------------------|
| offset  | theta    | 时钟偏差                 |
| delay   | delta    | 往返延迟                 |
| disp    | epsilon  | 色散（分散）             |
| jitter  | psi      |抖动                     |
| filter  | filter   | 时钟滤波器               |
| tp      | t_p      | 滤波时间                 |

图19：对等点进程统计变量

以下配置变量通常在关联启动时初始化，可能来自配置文件或在首次收到未知关联的数据包时设置。

- **srcaddr**：远程服务器或参考时钟的IP地址。此地址成为从该关联发出的数据包的目标IP地址。
- **srcport**：服务器或参考时钟的UDP端口号。此端口成为从该关联发出的数据包的目标端口号。在对称模式（1和2）下，必须包含由IANA分配的NTP端口（123）；在其他模式下，可以根据本地策略使用任何数字。
- **dstaddr**：客户端的IP地址。此地址成为从该关联发出的数据包的源IP地址。
- **dstport**：客户端的UDP端口号，通常为IANA分配的NTP端口（123）。此端口成为发出数据包的源端口。
- **keyid**：用于生成和验证MAC的128位MD5密钥的对称密钥ID。客户端和服务器或对等点可以使用不同的值，但必须映射到相同的密钥。

图17中的变量在每个数据包到达时会从包头中更新。它们的解释方式与同名的数据包变量相同。为了后续处理的便利，将NTP短格式的包值（如r.rootdelay和r.rootdisp）转换为浮点数（double）作为对等变量。

图18中的变量包括第8节中交换的时间戳。变量t是与这些值相关的秒数计数器c.t。c.t由第12节描述的时钟调整进程维护，表示自服务启动以来的秒数。图19中的变量包括由第10节描述的clock_filter()例程计算的统计信息。tp变量是与这些值相关的秒数计数器。

---

**9.2 对等点（Peer）进程操作**

接收例程定义了数据包到达时的处理流程。示例可参见附录A.5.1中的receive()例程。没有特定的访问控制方法，但建议实现中包含类似于现有广泛使用的方案的机制。附录A.5.4中的access()例程描述了使用访问控制列表（ACL）实现访问限制的方法。格式检查要求字段长度和对齐正确，版本号在1到4之间，扩展字段（如果存在）语法正确。

没有强制的认证要求；但如果实现了认证，则必须支持[RFC1321]中描述的MD5密钥哈希算法。

接下来，系统会在关联表中搜索匹配的源地址和源端口，例如使用附录A.5.1中的find_assoc()例程。图20为调度表，列对应数据包模式，行对应关联模式。关联模式与数据包模式的交叉点决定了处理流程。

| 关联模式/数据包模式 | 1     | 2     | 3     | 4     | 5     |
|---------------------|--------|--------|--------|--------|--------|
| 无关联（0）        | NEWPS  | DSCRD | FXMIT  | MANY   | NEWBC  |
| 对称主动（1）       | PROC   | PROC   | DSCRD  | DSCRD  | DSCRD  |
| 对称被动（2）       | PROC   | ERR    | DSCRD  | DSCRD  | DSCRD  |
| 客户端（3）         | DSCRD  | DSCRD  | DSCRD  | PROC   | DSCRD  |
| 服务器（4）         | DSCRD  | DSCRD  | DSCRD  | DSCRD  | DSCRD  |
| 广播（5）           | DSCRD  | DSCRD  | DSCRD  | DSCRD  | DSCRD  |
| 广播客户端（6）     | DSCRD  | DSCRD  | DSCRD  | DSCRD  | PROC   |

图20：对等点调度表

- **DSCRD**：表示协议的非致命性违规，可能由程序错误、长延迟包或重放包引起。对等点进程会丢弃该包并退出。
- **ERR**：表示协议的致命性违规，可能由程序错误、长延迟包或重放包引起。对等点进程会丢弃包，取消对称被动关联，并退出。
- **FXMIT**：表示客户端（模式3）包未匹配任何关联（模式0）。如果目标地址不是广播地址，服务器会构造一个服务器（模式4）包并返回给客户端，不保留状态。服务器包头由构造。示例见附录A.5.3中的fast_xmit()例程。包头由接收包和系统变量组成，如图21所示。如果系统变量s.rootdelay和s.rootdisp以浮点数存储，必须先转换为NTP短格式。

图21：接收包头部

| 包变量  | 变量对应 | 描述                     |
|---------|-----------|--------------------------|
| r.leap  | p.leap    | 跳跃指示器               |
| r.mode  | p.mode    | 模式                     |
| r.stratum | p.stratum | 层级                   |
| r.poll  | p.ppoll   | 轮询指数                 |
| r.rootdelay | p.rootdelay | 根延迟             |
| r.rootdisp  | p.rootdisp  | 根色散             |
| r.refid | p.refid   | 参考ID                   |
| r.reftime | p.reftime | 参考时间戳             |
| r.keyid | p.keyid   | 密钥ID                   |

注意：如果认证失败，服务器会返回特殊消息“crypto-NAK”。该消息包含图8所示的正常NTP头部数据，但MAC由四个零字节组成。客户端可以接受或拒绝该消息中的数据。处理完毕后，对等点进程退出。

如果目标地址为多播地址，发送端处于多播客户端（manycast）模式。如果数据包有效且服务器层级低于客户端层级，服务器会发送普通的服务器（模式4）包，但使用其单播目标地址。如果认证失败，不会发送crypto-NAK。处理完毕后，对等点进程退出。

- **MANY**：表示匹配不到任何关联的服务器（模式4）包。通常，这只会作为对先前发送的多播客户端包的多播服务器回复出现。

如果数据包有效，将启动普通客户端（模式3）关联，操作将继续，就像通过配置文件启动的关联一样。

- **NEWBC**：表示匹配不到任何关联的广播（模式5）包。客户端会启动客户端（模式3）或广播客户端（模式6）关联。示例见附录A.2中的mobilize()和clear()例程。之后，验证包并初始化对等变量。示例见附录A.5.1.1中的packet()例程。

如果实现不支持额外的安全或校准功能，关联模式设为广播客户端（模式6），对等点进程退出。支持公钥认证的实现可以运行Autokey或等效的安全协议。建议将关联模式设为3，并进行简短的客户端/服务器交换以确定传播延迟。交换完成后，将关联模式设为6，对等点进程进入只监听模式。注意，模式6的包（用于NTP监控和控制功能）与模式6的关联不同。

- **NEWPS**：表示匹配不到任何关联的对称主动（模式1）包。客户端会启动对称被动（模式2）关联。示例见附录A.2中的mobilize()和clear()例程。处理继续在下文的PROC部分。

- **PROC**：表示匹配已有关联的包。会仔细检查包中的时间戳，避免无效、重复或伪造的包。额外的检查总结在图22中。注意，所有包（包括crypto-NAK）只有在通过这些检查后才被视为有效。

---

图22：数据包错误检查

| 包类型             | 描述                                              |
|-------------------|---------------------------------------------------|
| 1 重复包          | 该包最多是旧的重复包，或可能是黑客重放的包。        在对称模式下，如果轮询间隔不均，可能发生。  |
| 2 虚假包          |                                                   |
| 3 无效            | 一个或多个时间戳字段无效。通常在对称模式中发生，原因是一个对等点先发包给另一个对等点，而后者尚未收到其第一个回复。 |
| 4 访问被拒绝      | 访问控制已将源地址列入黑名单。                     |
| 5 认证失败        | 密码学消息摘要（MAC）不匹配。                       |
| 6 未同步          | 服务器未同步到有效的源。                             |
| 7 错误的头部数据  | 一个或多个头部字段无效。                             |

---

以上内容为原文的完整中文翻译，确保表达流畅、准确。

处理过程通过将数据包变量复制到对等变量中继续进行，如图21所示。一个示例在附录A.5.1.1中的packet()例程中描述。接收()例程实现了图22中的测试1-5；packet()例程实现了测试6-7。如果发现错误，数据包将被丢弃，对等进程也会退出。

在线路上传输的协议根据第8节所述，从最近的四个时间戳计算时钟偏差θ和往返延迟δ。原则上，除了一级时间戳差值的所有计算都可以用定点运算完成，但将一级差值转换为浮点双精度数并用浮点运算完成剩余计算要简单得多，以下描述中将采用此假设。

接下来，图13中描述的8位p.reach移位寄存器用于判断服务器是否可达以及数据是否新鲜。当发送数据包时，寄存器左移一位，最右边的位设为零。随着有效数据包的到达，最右边的位被设置为一。如果寄存器中任何非零位存在，则认为服务器可达；否则，认为不可达。由于自上次数据包以来，主机轮询间隔可能已变化，因此会重新审查主机轮询间隔。附录A.5.7.2中的poll_update()例程提供了一个示例。

色散统计量ε(t)表示由频率容差和自上次发送数据包以来的时间所引起的最大误差。它在t_0时初始化为：

ε(t_0) = r.ρ + s.ρ + PHI * (T4 - T1)

其中，r.ρ是第7.3节描述的包的精度，s.ρ是第11.1节描述的系统精度，二者都以秒为单位。这些项用于考虑在服务器和客户端读取系统时钟的不确定性。

然后，色散以恒定速率PHI增长；换句话说，在时间t，ε(t) = ε(t_0) + PHI * (t - t_0)。默认值PHI为15 ppm，相当于每天约1.3秒。有了这个理解，参数t将被省略，色散用ε表示。其余统计量由下一节描述的时钟过滤算法计算。

10. 时钟过滤算法

时钟过滤算法是对等进程的一部分。它对线路上的数据流进行整理，选择最可能代表准确时间的样本。该算法产生图19所示的变量，包括偏差（θ）、延迟（δ）、色散（ε）、抖动（ψ）和到达时间（t）。这些数据被缓解算法用来确定最佳且最终的偏移值，以调节系统时钟。它们也用于判断服务器的健康状况以及是否适合同步。

时钟过滤算法将最新的样本元组（θ、δ、ε、t）存储在过滤器结构中，该结构充当一个8级移位寄存器。元组按包到达的顺序存储。这里的t是根据秒计数器的到达时间，不应与对等变量tp混淆。

为确保过滤器中有足够的样本，并丢弃旧的过时数据，采用以下方案：最初，所有阶段的元组都设为虚拟元组（0，MAXDISP，MAXDISP，0）。随着有效包的到达，元组被移入过滤器，旧的元组被丢弃，最终只剩有效元组。

如果reach寄存器的低三位为零，表示已经过三个轮询间隔且未收到有效包，轮询过程会用虚拟元组调用时钟过滤算法，就像虚拟元组已从网络中到达一样。如果这种情况持续八个轮询间隔，寄存器会返回到初始状态。

下一步，将移位寄存器中的阶段复制到临时列表，并按δ值递增排序。用i索引阶段，从最小δ开始。如果第一个元组的时间t_0不晚于最后一个有效样本的时间tp，例程退出，不影响当前对等变量。否则，设ε_i为第i个条目的色散，则

ε = (∑_{i=0}^{n-1} ε_i^2)^{1/2} / (n - 1)

这是对等体的色散p.disp。注意，ε的重载——无论是输入到时钟过滤器还是输出——其含义应根据上下文理解。

观察者应注意：(a) 如果所有阶段都包含虚拟元组且色散为MAXDISP，则计算得出的色散略小于16秒；(b) 每次有效元组移入寄存器，色散会下降不到一半，具体取决于有效元组的色散；(c) 在第四个有效包之后，色散通常略小于1秒，这是选择算法用来判断对等变量是否可接受的MAXDIST参数的预设值。

假设排序列表中的第一个阶段偏差为θ_0，则其他阶段的抖动（ψ）为其均方根（RMS）平均值，计算公式为：

ψ = √[ (1/(n-1)) * ∑_{j=1}^{n-1} (θ_0 - θ_j)^2 ]

其中n为过滤器中的有效元组数（n > 1）。为了确保一致性并避免在其他计算中出现除零异常，ψ的下界由系统精度s.ρ（以秒为单位）限制。虽然抖动通常不是衡量服务器质量的主要因素，但它是时间保持性能和网络拥塞状态的重要指标。对缓解算法尤为重要的是对等同步距离，它由延迟和色散计算得出。

λ = (δ / 2) + ε

注意，ε和λ都随PHI速率增长。λ不是状态变量，因为每次使用时都会重新计算。它是根同步距离的组成部分，用作缓解算法评估每个服务器时间质量的指标。

值得注意的是，与NTPv3不同，NTPv4的关联不会通过将层数设为16和闰秒指示器设为3来显示超时条件。关联变量在最后一个包到达时保持其值。在NTPv4中，λ会随时间增加，最终超过距离阈值MAXDIST，此时关联被视为不适合同步。

时钟过滤算法的示例实现见附录A.5.2中的clock_filter()例程。

11. 系统进程

每当时钟过滤算法产生新的样本（θ、δ、ε、ψ、t）时，系统中的所有对等进程会被扫描，缓解算法（包括选择、簇、合并和时钟调节算法）在系统进程中运行。选择算法扫描所有关联，剔除明显时间错误的假信号（falsetickers），留下真实的时间源（truechimers）。在多轮中，簇算法剔除统计上偏离质心最远的关联，直到剩余的候选数达到预设的最小值CMIN。合并算法基于加权平均产生最优的最终统计值。最终偏移值传递给时钟调节算法，用以调整系统时钟到正确时间。

簇算法会从存活的候选中选择一个作为系统对等体。相关的统计量（θ、δ、ε、ψ、t）被用来构建系统变量，这些变量会被依赖的服务器和客户端继承，并提供给在同一台机器上运行的其他应用程序使用。

11.1 系统进程变量

图23总结了常用名称、公式名称及每个系统变量的简要描述。除非另有说明，所有变量都以前缀s开头。

+-----------+------------+------------------------+
| 名称      | 公式       | 描述                   |
+-----------+------------+------------------------+
| t         | t          | 更新时间               |
| p         | p          | 系统对等体标识符       |
| leap      | leap       | 闰秒指示器             |
| stratum   | stratum    | 层级                   |
| precision | ρ          | 精度                   |
| offset    | THETA      | 综合偏移               |
| jitter    | PSI        | 综合抖动               |
| rootdelay | DELTA      | 根延迟                 |
| rootdisp  | EPSILON    | 根色散                 |
| v         | v          | 存活列表               |
| refid     | refid      | 参考ID                 |
| reftime   | reftime    | 参考时间               |
| NMIN      | 3          | 最小存活数             |
| CMIN      | 1          | 最小候选数             |
+-----------+------------+------------------------+

图23：系统进程变量

除t、p、偏移和抖动变量以及NMIN和CMIN常量外，其他变量的格式和含义与同名的对等变量相同。NMIN和CMIN参数由下一节描述的选择和簇算法使用。

t变量是最后一次更新时的秒计数器。示例见附录A.5.5.4中的clock_update()例程。p变量是由第11.2.2节中的cluster()例程确定的系统对等体标识符。精度变量的格式与同名的数据包变量相同。精度定义为分辨率和读取时钟所需时间的较大者，以log2单位表示。例如，60 Hz的交流电频率的时钟递增的精度为16毫秒，即使系统硬件表示精度为纳秒。

偏移和抖动变量由第11.2.3节中的合并算法确定。这些值代表用于调节系统时钟的最佳最终偏移和抖动。

最初，所有变量都被清零，然后将闰秒设置为3（未同步），层级设置为MAXSTRAT（16）。请注意，MAXSTRAT在传输的数据包中映射为零。

11.2 系统进程操作

图24总结了由时钟选择例程执行的系统进程操作。第11.2.1节中的选择算法基于一致性原则，产生一个假定正确候选（truechimers）的多数团（majority clique）。第11.2.2节中的簇算法剔除异常值，产生最准确的存活者。第11.2.3节中的合并算法提供用于时钟调节的最佳最终偏移。示例见附录A.5.5.6。

如果选择算法无法产生多数团，或不能产生至少CMIN个存活者，系统进程将退出，不调节系统时钟。如果成功，簇算法会选择统计上最优的候选作为系统对等体，其变量会被继承为系统变量。

以下是英文内容的中文翻译：

```

                          +-----------------+
                          | clock_select()  |
                          +-----------------+
   ................................|...........
   .                               V          .
   .      是 +---------+ +-----------------+ .
   .       +--| accept? | | scan candidates | .
   .       |  +---------+ |                 | .
   .       V        否 |  |                 | .
   .  +---------+      |  |                 | .
   .  | add peer|      |  |                 | .
   .  +----------      |  |                 | .
   .       |           V  |                 | .
   .       +---------->-->|                 | .
   .                      |                 | .
   .  选择算法            +-----------------+ .
   .................................|..........
                                    V
                       否 +-------------------+
            +-------------|     survivors?    |
            |             +-------------------+
            |                       | 是
            |                       V
            |             +-------------------+
            |             |  集群算法         |
            |             +-------------------+
            |                       |
            |                       V
            V         是 +-------------------+
            |<------------|    n < CMIN?      |
            |             +-------------------+
            V                       |
     +-----------------+            否
     |   s.p = NULL    |  +-------------------+
     +-----------------+  |  s.p = v_0.p      |
            |             +-------------------+
            V                       |
     +-----------------+            V
     | return (UNSYNC) |  +-------------------+
     +-----------------+  | return (SYNC)     |
                          +-------------------+

图24：时钟选择例程





米尔斯等人，标准轨道 [第42页]

RFC 5905：NTPv4规范 2010年6月

11.2.1.  选择算法

   注意，选择算法和集群算法在描述上是分开的，但在代码框架中是结合的。选择算法的目标是找到一个交集区间，包含一个由多数组成的“多数团体”，这些“真时钟”遵循拜占庭协议原则，最初由Marzullo提出[参考6]，但经过改进以提高准确性。算法的概述如下，并在附录A.5.5.1的clock_select()例程的前半部分中详细描述。

   首先，检测并丢弃不符合协议规则的服务器，如附录A.5.5.3中的accept()例程所示。接下来，为剩余候选者生成一组三元组(p, type, edge)。其中，p是关联标识符，type标识该候选的正确区间的上（+1）、中（0）和下（-1）端点，这个区间以θ为中心。这样会得到三个三元组：低点(lowpoint, p, -1, θ - λ)、中点(midpoint, p, 0, θ)和高点(highpoint, p, +1, θ + λ)，其中λ是根同步距离。此计算示例由附录A.5.1.1中的rootdist()例程演示。算法步骤如下：

   1. 对每个关联（共m个），在候选列表中放置上述定义的三个三元组。

   2. 按edge值对三元组排序，将这些区间的低点、中点和高点从最低到最高排序。设假时钟数f=0。

   3. 设中点数d=0，计数器c=0。从最低端点扫描到最高端点。每遇到一个低点，c加一；每遇到一个高点，c减一；每遇到一个中点，d加一。当c >= m - f时停止，此时l为当前的低点。

   4. 设c=0。从最高端点扫描到最低端点。每遇到一个高点，c加一；每遇到一个低点，c减一；每遇到一个中点，d加一。当c >= m - f时停止，此时u为当前的高点。

   5. 若d=f且l<u，则执行步骤5A；否则执行步骤5B。

   5A. 成功：交集区间为[l, u]。

   5B. 假设f+1。若f< m/2，则返回步骤3；否则，算法失败。

   6. 失败：未能找到多数团体，没有合适的候选者来校准系统时钟。

该算法在附录A.5.5.1中有详细描述。起始假设f=0，试图找到包含所有正确服务器（即“真时钟”）中点的非空交集区间。如果找不到非空区间，则增加假设的假时钟数f，再试一次。当找到非空区间且f小于真时钟数时，说明已找到多数团体，其每个真时钟的中点θ代表可用的候选者，供集群算法使用。

如果未找到多数团体，或真时钟数少于CMIN，则系统没有足够的候选者来校准时钟。CMIN定义了满足正确性要求的最小服务器数。出于安全考虑，操作者会设置较高的CMIN值以确保有多个冗余服务器，但出于历史原因，默认值为1。

11.2.2.  集群算法

   多数团体的候选者被放入存活列表v，形式为元组(p, θ_p, ψ_p, λ_p)，其中p是关联标识符，θ_p、ψ_p和stratum_p分别是关联p的偏移、抖动和层级，λ_p是一个优值，等于stratum_p * MAXDIST + λ（λ为关联p的根同步距离）。该列表由下述集群算法处理，示例在附录A.5.5.1的clock_select()后半部分中。

   1.  令(p, θ_p, ψ_p, λ_p)代表一个存活候选者。

   2.  按λ_p递增排序候选者。设n为候选者数，NMIN为所需的最小存活数。

   3.  对每个候选者，计算选择抖动ψ_s：

             +-----                       -----+^1/2
             |        n-1                      |
             |        ---                      |
             |   1    \                     2  |
     ψ_s = | ---- * /  (θ_s - θ_j)             |
             |  n-1   ---                      |
             |        j=1                      |
             +-----                       -----+

   4.  选择ψ_max为使ψ_s最大者。

   5.  选择ψ_min为候选者中ψ_p的最小值。

   6.  若ψ_max<ψ_min或n≤NMIN，则执行步骤6A；否则，执行步骤6B。

   6A. 完成。剩余的存活候选者按偏好顺序排序。列表第一个代表系统对等点，其变量将在后续用于更新系统变量。

   6B. 删除ψ_max的异常值候选者；n减一，返回步骤3。

   该算法在多轮中运行，每轮会丢弃最大选择抖动ψ_s的统计异常值。若ψ_s小于最小对等点抖动ψ_p，则无法通过丢弃异常值改善。算法终止条件为：剩余候选者少于NMIN或满足条件。终止时，保存最终的ψ_max作为系统选择抖动PSI_s。

11.2.3.  合并算法

   时钟合并路由处理剩余的存活者，生成最终的系统偏移值（THETA）和系统对等点抖动（PSI_p），每个服务器的统计量按根同步距离的倒数加权，结果归一化。示例在附录A.5.5.5的clock_combine()中。

   合并得到的THETA传递给时钟更新例程。存活列表中的第一个候选者被指定为系统对等点p。系统对等点抖动PSI_p是系统抖动PSI的组成部分，用于计算系统抖动：

   PSI = [(PSI_s)^2 + (PSI_p)^2]^1/2

   每次从系统对等点接收更新时，调用时钟更新例程。若更新的到达时间p.t不严格晚于上次使用的时间，则该更新会被丢弃。返回码包括IGNOR（忽略异常值）、PANIC（偏移超过恐慌阈值1000秒，应退出并记录日志）、ADJ（偏移小于阈值且有效，更新系统变量）和STEP（偏移大于阈值，直接步进调整，重置所有关联）。

   具体系统变量的更新如下（见图25）：

                  +-------------------------------------------+
                  | 系统变量 <-- 系统对等点变量             | 
                  +-------------------------------------------+
                  | s.leap      <-- p.leap                   |
                  | s.stratum   <-- p.stratum + 1            |
                  | s.offset    <-- THETA                    |
                  | s.jitter    <-- PSI                      |
                  | s.rootdelay <-- p.delta_r + delta        |
                  | s.rootdisp  <-- p.epsilon_r + p.epsilon + |
                  |                 p.psi + PHI * (s.t - p.t) |
                  |                 + |THETA|                |
                  | s.refid     <-- p.refid                  |
                  | s.reftime   <-- p.reftime                |
                  | s.t         <-- p.t                      |
                  +-------------------------------------------+

图25：系统变量更新

   还有一个未显示的重要细节：色散增量（p.epsilon + p.psi + PHI * (s.t - p.t) + |THETA|）有下界MINDISP。在高速处理器和网络、延迟极小的子网中，这会导致s.rootdisp（EPSILON）单调递增，避免在同一层级的对等点之间形成环路。

   系统变量作为名义性能统计信息提供给依赖的应用程序。系统偏移THETA是相对于同步源的时钟偏移，系统抖动PSI是估计的误差（即预期误差），根延迟DELTA是相对于主服务器的总往返延迟，根色散EPSILON是从主服务器到本地的网络色散。最后，根同步距离定义为：

   LAMBDA = EPSILON + DELTA / 2

   表示所有原因引起的最大误差，称为根同步距离。

   时钟更新例程的示例在附录A.5.5.4中。

11.3.  时钟校准算法

   NTPv4的时钟校准算法（简称“校准”）结合了两种哲学上不同的反馈控制系统。在相位锁定环（PLL）设计中，周期性在mu秒的相位更新直接用以最小化时间误差，间接减少频率误差；在频率锁定环（FLL）设计中，周期性在mu秒的频率更新直接用以最小化频率误差，间接减少时间误差。如[参考7]所示，PLL在网络抖动占主导时效果更佳，而FLL在振荡器漂移占优时表现更好。以下简要介绍NTPv4的设计原理，详细讨论请参见[参考7]。

校准作为反馈控制系统实现，示意图见图26。变量θ_r代表合成算法的偏移（参考相位），θ_c代表VFO偏移（控制相位）。每次更新产生信号V_d，表示θ_r - θ_c的瞬时相位差。每个服务器的时钟滤波器类似一个抽头延迟线，输出由时钟滤波器算法选择的抽头采样。选择、集群和合并算法结合多个滤波器的数据，产生信号V_s。环路滤波器（冲激响应为F(t)）产生信号V_c，控制VFO频率ω_c，从而积分相位θ_c，闭合环路。V_c由第12节中的时钟调节过程生成。实现这些功能的详细方程在附录A.5.5.6和A.5.6.1中给出。





```

下图为时钟纪律反馈回路

通常，以上描述的伪线性反馈回路用于调节系统时钟。然而，在某些情况下，非线性算法能带来显著改进。例如，当调节开始时对内在时钟频率一无所知时，伪线性回路需要数小时才能获得准确的测量，而在此期间，轮询间隔不能增加。下面描述的非线性回路可以在15分钟内完成此任务。另一个例子是在网络链路繁忙时，偶尔出现大量抖动的突发情况。下面描述的状态机能抵抗持续不到15分钟的误差突发。

图27总结了变量和参数，包括变量（小写）或参数（大写）名称、公式名称和简短描述。除非另有说明，所有变量都带有前缀c。变量t、tc、state、hyster和count是整数，其余变量为浮点型双精度数。每个变量的功能将在下方的算法描述中详细说明。

| 名称   | 公式名   | 描述                     |
|--------|----------|--------------------------|
| t      | timer    | 秒计数器                |
| offset | theta    | 综合偏差                |
| resid  | theta_r  | 残差偏差                |
| freq   | phi      | 时钟频率                |
| jitter | psi      | 时钟偏差抖动            |
| wander | omega    | 时钟频率漂移            |
| tc     | tau      | 时间常数（以log2表示）  |
| state  | state    | 状态                    |
| adj    | adj      | 频率调整                |
| hyster | hyster   | 滞后计数器              |
| STEPT  | 125      | 步进阈值（0.125秒）     |
| WATCH  | 900      | 步进超时阈值（秒）      |
| PANICT | 1000     | 紧急阈值（秒）          |
| LIMIT  | 30       | 滞后限制                |
| PGATE  | 4        | 滞后门控                |
| TC     | 16       | 时间常数比例            |
| AVG    | 8        | 平均常数                |

图28显示了状态转移函数。若偏差超出紧急阈值PANICT（1000秒），过程立即终止。状态转移由附录A.5.5.7中的rstclock()函数描述。表中四列分别显示状态名、偏差小于步进阈值时的判定条件和动作、偏差大于阈值时的判定条件和动作，以及一些备注。

| 状态 | theta < STEP | theta > STEP | 备注 |
|-------|----------------|--------------|-------|
| NSET  | ->FREQ        | ->FREQ      | 无频率文件 |
| FSET  | ->SYNC        | ->SYNC      | 频率文件   |
| SPIK  | ->SYNC        | 若<900秒 ->SPIK | 异常值检测 |
| FREQ  | 若<900秒 ->FREQ | 若<900秒 ->FREQ | 初始频率 |
|       | 步频调整      | 步频调整    |       |
| SYNC  | ->SYNC        | 若<900秒 ->SPIK | 正常操作 |
|       | 频率调整      | 频率调整    |       |

在表中，箭头“->”后面标示下一状态，动作列列出相应操作。调整时间和频率由本地时钟()中的PLL/FLL反馈回路实现。步进时钟操作通过直接设置时钟实现，但仅在偏差超过步进阈值STEPT（0.125秒）且偏差超过步进超时WATCH（900秒）时进行，以抵抗极端网络拥塞条件下的时钟跳变。

偏差（psi）和漂移（omega）统计值通过指数平均（权重为AVG）计算。时间常数指数（tau）由psi与当前偏差theta的大小关系决定。如果偏差大于PGATE（4）倍的时钟抖动，则滞后计数器hyster减二，否则加一。当hyster达到上限LIMIT（30）时，tau增加一；当hyster降至下限-LIMIT（-30）时，tau减一。通常，tau接近MAXPOLL，但在温度突变引起频率突升时会迅速下降。

12. 时钟调整过程

实际的时钟调整每秒运行一次，加入频率修正和残差偏差theta_r的固定比例。theta_r实际上是由环路滤波器在每次更新时指数衰减的偏差值。参数TC用来缩放时间常数以匹配轮询间隔。注意，色散EPSILON每秒随PHI增加。

时钟调整过程包括一个定时中断，用于驱动秒计数器c.t。服务启动时，计数器归零，每秒递增一次。每次中断调用clock_adjust()例程，进行时钟纪律调整，然后扫描关联，判断秒计数器是否达到或超过下一状态变量p.next。如果达到，则调用轮询过程发送数据包并计算下一p.next值。

示例见附录A.5.6.1中的clock_adjust()。

13. 轮询过程

每个关联支持定期运行的轮询过程，用于构造和发送对称、客户端和广播服务器关联的数据包。它持续运行，无论服务器是否可达，以管理时钟滤波器和到达寄存器。

13.1 轮询变量

图29总结了轮询变量（小写）和参数（大写）的常用名称、公式名称及简短描述。除非另有说明，所有变量都带有前缀p。

| 名称   | 公式名   | 描述                     |
|--------|----------|--------------------------|
| hpoll  | hpoll    | 主机轮询指数            |
| last   | last     | 上次轮询时间（秒）      |
| next   | next     | 下次轮询时间（秒）      |
| reach  | reach    | 到达寄存器              |
| unreach| unreach  | 服务器不可达时间（秒）  |
| UNREACH | 24      | 不可达阈值              |
| BCOUNT | 8        | 突发包数                |
| BURST  | flag     | 突发启用                |
| IBURST | flag     | 立即突发启用            |

图30显示了轮询数据包头部各字段的值来源。某些字段从对端变量复制，其他从系统变量复制。使用浮点数存储根延迟和根色散时，必须转换为NTP短格式。其余字段要么直接复制，要么从系统时钟截取时间戳。

| 变量名 | 复制自 | 说明 |
|---------|---------|-------|
| x.leap | s.leap | 跳跃信息 |
| x.version | s.version | 版本号 |
| x.mode | s.mode | 模式 |
| x.stratum | s.stratum | 层级 |
| x.poll | s.poll | 轮询间隔 |
| x.precision | s.precision | 精度 |
| x.rootdelay | s.rootdelay | 根延迟 |
| x.rootdisp | s.rootdisp | 根色散 |
| x.refid | s.refid | 参考ID |
| x.reftime | s.reftime | 参考时间 |
| x.org | p.xmt | 发送时间戳 |
| x.rec | p.dst | 接收时间戳 |
| x.xmt | clock | 发送的系统时间 |
| x.keyid | p.keyid | 密钥ID |
| x.digest | md5 digest | MD5摘要 |

当接收到有效的数据包或在发送轮询消息后立即调用轮询更新程序。如果是在突发模式下，轮询间隔固定为2秒；否则，主机轮询指数（hpoll）被设置为上一次接收的数据包中的ppoll值与轮询程序中的hpoll值的较小值，但不低于MINPOLL，也不高于MAXPOLL。因此，时钟校准可以被过采样，但不能被欠采样。这对于保持子网的动态行为和防止协议错误是必要的。

轮询指数被转换为一个时间间隔，将其加到上一次轮询的时间变量中，从而确定下一次轮询的时间。最后，将上一次轮询时间变量设置为当前的秒数计数。

14. 简单网络时间协议（SNTP）

符合NTP子集的主要服务器和客户端，称为简单网络时间协议（SNTPv4）[RFC4330]，无需实现第9节及之后章节中描述的缓解算法。SNTP主要面向配备单一参考时钟的主服务器，以及只连接一个上游服务器且没有依赖客户端的客户端。完整的NTPv4实现则面向具有多个上游服务器和多个下游服务器或客户端的次级服务器。除了这些考虑之外，NTP和SNTP的服务器与客户端完全互通，可以在NTP子网中混合使用。

实现第8节中描述的在线协议的SNTP主服务器没有除单一参考时钟之外的上游服务器。原则上，它与具有缓解算法、能够在多个参考时钟之间进行调节的NTP主服务器没有区别。

当接收到客户端请求时，SNTP主服务器会按照图31所示构造并发送应答包。注意，数据包头中的色散字段必须按照第5节的描述进行更新。

```
                   +-----------------------------------+
                   | 数据包变量 <--   变量             |
                   +-----------------------------------+
                   | x.leap        <--     s.leap      |
                   | x.version     <--     r.version   |
                   | x.mode        <--     4           |
                   | x.stratum     <--     s.stratum   |
                   | x.poll        <--     r.poll      |
                   | x.precision   <--     s.precision |
                   | x.rootdelay   <--     s.rootdelay |
                   | x.rootdisp    <--     s.rootdisp  |
                   | x.refid       <--     s.refid     |
                   | x.reftime     <--     s.reftime   |
                   | x.org         <--     r.xmt       |
                   | x.rec         <--     r.dst       |
                   | x.xmt         <--     clock       |
                   | x.keyid       <--     r.keyid     |
                   | x.digest      <--     md5摘要     |
                   +-----------------------------------+
```

图31：fast_xmit数据包头

实现线协议的SNTP客户端只有一个服务器，没有依赖的客户端。它可以使用任何子集的线协议，最简单的方法是只使用服务器包中的传输时间戳，忽略其他字段。然而，完整实现线协议的复杂性很低，因此鼓励实现完整的协议。

15. 安全性考虑

NTP的安全要求比大多数分布式服务更为严格。首先，认证机制和时间同步机制密不可分。可靠的时间同步需要在特定时间段内有效的加密密钥；但只有当参与的服务器和客户端可靠同步到UTC时，才能强制执行时间段。此外，NTP子网本质上是层级结构的，时间和信任从根部的主服务器流向次级服务器，再到终端的客户端。

只有当通向主服务器的所有服务器都经过认证时，NTP客户端才能向依赖应用程序声称拥有真实的时间。在NTP中，每个服务器会验证下一层的次级服务器，并通过归纳验证最低层（主）服务器。需要注意的是，NTP中的认证并不一定意味着时间是正确的。NTP客户端会与多个不同的服务器建立并发连接，使用精心设计的协议从中筛选出可信的时间源。

NTP规范假设攻击者的目标是注入虚假时间、破坏协议或通过大量伪造包耗尽资源，导致服务中断。NTP架构、协议和算法中已内置多种防御机制。线上的时间戳交换方案天生抗欺骗、包丢失和重放攻击。经过设计的时钟过滤、选择和聚类算法旨在抵御拜占庭式的恶意节点。虽然这些算法未必能击败有决心的入侵者，但多年来在防止误操作和假设为友好的场景中表现良好。然而，这些机制不能安全地识别和验证服务器的身份。没有额外保护措施，攻击者可能实施以下攻击：

1. 攻击者可以截获并长期存储所有包及其传输的公共值。

2. 攻击者可以比服务器、网络或客户端处理速度更快地生成包，尤其是在需要复杂加密计算时。

3. 在窃听攻击中，攻击者可以截获、修改和重放包，但不能永久阻止原始包的转发，也就是说不能破坏通信线路，只能欺骗和制造拥堵。通常，修改后的包不能在原始包到达前到达受害者，也没有服务器的私钥或身份参数。

4. 在中间人或伪装攻击中，攻击者位于服务器和客户端之间，可以截获、修改和重放包，阻止原始包的转发，但没有服务器的私钥。

NTP的安全模型假设以下潜在限制：

1. 公钥算法的运行时间较长且变化大。如果每个NTP包都使用这些算法，时间同步性能会严重下降。

2. 在某些操作模式下，服务器不可能为每个客户端保存状态变量，但可以在收到客户端包时为其重新生成。

3. 必须强制执行加密值的有效期，这需要可靠的系统时钟。然而，同步系统时钟的源必须可信。这种时间和认证功能的循环依赖关系需要特殊处理。

4. 客户端的安全功能只能涉及通过网络传输的公共值。私有值绝不应在创建它们的机器之外泄露，除非由专门的可信代理（TA）处理。

与需要客户端安全认证的安全外壳（SSH）模型不同，NTP要求服务器对客户端进行安全认证。在SSH中，不同接口地址可以绑定不同的名称（通过反向DNS查询返回）。在此设计中，每个接口地址可能需要一对不同的公私钥对。此设计的一个优点是安全隔离可以针对不同接口实现。例如，防火墙可以要求某些接口进行客户端认证，而其他接口则不需要。

根据本文的NTP规范，NTP广播客户端容易受到其他互联网中行为不端或敌对的SNTP或NTP广播服务器的干扰。可以通过多种方法减轻这种干扰。例如，过滤可以限制NTP客户端访问已知或可信的NTP广播服务器，从而阻止恶意流量到达客户端。客户端的加密认证（如使用Autokey机制[RFC5906]）也能确保只使用经过签名的NTP消息中的时间信息进行同步。

第8节提到的客户端请求重放的潜在安全问题，遵循该节建议可以提供防护。

需要指出的是，本规范描述的是现有的实现。虽然MD5算法的安全性已广为人知，但在NTP规范中使用MD5符合在互联网社区的广泛部署。

16. IANA考虑事项

UDP/TCP端口123此前由IANA分配用于此协议。IANA已为NTP分配了IPv4多播组地址224.0.1.1和IPv6多播地址（以：101结尾）。本文引入了NTP扩展字段，允许未来对协议进行扩展，扩展字段通过字段类型子字段进行识别。IANA已建立并将维护一个与此协议相关的扩展字段类型注册表，初始为空。未来需要时，可以定义新的扩展字段类型。按照[RFC5226]中的政策，新的值由IETF评审决定。

IANA还为NTP参考标识符（Reference Identifier）代码建立了新注册表，包括第7.3节中定义的当前代码，并可按先到先得（FCFS）原则扩展。注册表格式如下：

```
     +--------+--------------------------------------------------+
     | ID     | 时钟源                                           |
     +--------+--------------------------------------------------+
     | GOES   | 地球同步轨道环境卫星                              |
     | GPS    | 全球定位系统                                    |
     | ...    | ...                                              |
     +--------+--------------------------------------------------+
```

图32：参考标识符代码

IANA还为NTP的Kiss-o'-Death（KOD）代码建立了新注册表，包括第7.4节中定义的当前代码，并可按先到先得原则扩展。注册表格式如下：

（此处省略具体表格内容）

对于参考标识符和Kiss-o'-Death代码，IANA被要求不要分配以“X”字符开头的代码，因为该字符保留用于试验和开发。

17. 致谢

编辑团队感谢Karen O'Donoghue、Brian Haberman、Greg Dowd、Mark Elliot、Harlan Stenn、Yaakov Stein、Stewart Bryant和Danny Mayer的技术审查及对本文档的具体贡献。

18. 参考文献

18.1. 必要性参考文献

[RFC0768] Postel, J.，“用户数据报协议”，STD 6，RFC 768，1980年8月。

[RFC0791] Postel, J.，“互联网协议”，STD 5，RFC 791，1981年9月。

[RFC0793] Postel, J.，“传输控制协议”，STD 7，RFC 793，1981年9月。

[RFC1321] Rivest, R.，“MD5消息摘要算法”，RFC 1321，1992年4月。

[RFC2119] Bradner, S.，“在RFC中使用的关键词以指示需求级别”，BCP 14，RFC 2119，1997年3月。

18.2. 资料性参考文献

[CGPM] 国际度量衡局，“第15届国际计量大会会议记录”，1976年。

[ITU-R_TF.460] 国际电信联盟，“ITU-R TF.460标准频率和时间信号发射”，2002年2月。

[RFC1305] Mills, D.，“网络时间协议（版本3）规范、实现与分析”，RFC 1305，1992年3月。

[RFC1345] Simonsen, K.，“字符助记符和字符集”，RFC 1345，1992年6月。

[RFC4330] Mills, D.，“IPv4、IPv6和OSI的简易网络时间协议（SNTP）版本4”，RFC 4330，2006年1月。

[RFC5226] Narten, T. 和 H. Alvestrand，“在RFC中撰写IANA考虑节的指南”，BCP 26，RFC 5226，2008年5月。

[RFC5906] Haberman, B.（编辑）和D. Mills，“网络时间协议第4版：Autokey规范”，RFC 5906，2010年6月。

[ref6] Marzullo和S. Owicki，“在分布式系统中维护时间”，ACM操作系统评论，19，1985年7月。

[ref7] Mills, D.L.，“计算机网络时间同步——网络时间协议”，CRC出版社，304页，2006年。

[参考文献9]： Mills, D.L.，电气与计算机工程技术报告06-6-1，NDSS，2006年6月，“网络时间协议第4版参考与实现指南”，2006年。

Mills 等人，标准轨迹 [第60页]

RFC 5905：NTPv4规范，2010年6月

附录A：代码框架

本附录旨在以一种通用的方式描述协议和算法，采用所谓的“代码框架程序”。该程序由一组定义、结构和代码片段组成，用以说明协议操作，而不涉及实际协议实现的复杂性。此程序不是可执行文件，也不打算在普通环境中运行。

这里包含了大部分参考实现的特性，唯一的例外是：没有参考时钟或公钥（Autokey）加密的相关内容，也没有huff-n'-puff过滤器、反时钟跳跃的滞后机制或监控机制。许多在参考实现中可以调节的参数在此被视为常数。对于kiss-o'-death包的处理也仅提供了最基本的支持，没有响应代码。

该程序的目的不是追求速度或紧凑性，而是用以演示算法，确保足够的保真度以帮助理解其工作原理。代码框架由八个部分组成：每个部分都包含一个头部段（由其他段引入），以及主程序、内核I/O和系统时钟接口、以及对等体、系统、时钟调整和轮询进程的代码段。这些部分按顺序列出，并附有各自的定义和特定变量。

A.1. 全局定义

A.1.1. 定义、常量和参数

```c
#include <math.h>               /* 避免sqrt()函数的警告 */
#include <sys/time.h>           /* 用于gettimeofday()等函数 */
#include <stdlib.h>             /* 用于malloc()等函数 */
#include <string.h>             /* 用于memset() */

 /*
  * 数据类型
  *
  * 本程序假设int类型为32位，long类型为64位。大部分计算使用的本地数据类型是
  * 浮点双精度（double）。某些包头字段需要在此表示与其他类型之间转换。
  * 一些头字段涉及将一个八位字节（octet）划分为多个部分，这里用单个字节表示。
  *
  * 时间戳的64位格式采用无符号秒数和分数，十进制点在第32位左侧。
  * 这些值唯一允许的操作是相减，结果为有符号的31位差值。
  * 用于延迟和色散计算的短格式（16位十六进制）采用秒和分数，十进制点在第16位左侧。
  * 这些值只允许相加和乘以常数。
  *
  * IPv4地址为32位，IPv6地址为128位。消息摘要字段为128位，由MD5算法生成。
  * 精度和轮询间隔字段为带符号的log2秒数。
  */
typedef unsigned long long tstamp;   /* NTP时间戳格式 */
typedef unsigned int tdist;          /* NTP短格式 */
typedef unsigned long ipaddr;        /* IPv4或IPv6地址 */
typedef unsigned long digest;        /* MD5摘要 */
typedef signed char s_char;          /* 精度和轮询间隔（log2） */

/*
 * 时间戳转换宏
 */
#define FRIC        65536.0                /* 2^16，作为双精度浮点数 */
#define D2FP(r)     ((tdist)((r) * FRIC))   /* 转换为NTP短格式 */
#define FP2D(r)     ((double)(r) / FRIC)    /* 转换为双精度浮点数 */

#define FRAC       4294967296.0             /* 2^32，作为双精度浮点数 */
#define D2LFP(a)   ((tstamp)((a) * FRAC))   /* 转换为NTP时间戳 */
#define LFP2D(a)   ((double)(a) / FRAC)     /* 转换为双精度浮点数 */
#define U2LFP(a)   (((unsigned long long) \
                       ((a).tv_sec + JAN_1970) << 32) + \
                       (unsigned long long) \
                       ((a).tv_usec / 1e6 * FRAC))
/* 说明：JAN_1970代表1970年1月1日的秒数偏移，未在此定义中列出 */

 /*
  * 算术转换宏
  */
#define LOG2D(a)        ((a) < 0 ? 1.0 / (1L << -(a)) : \
                            1L << (a))          /* 轮询等参数 */
#define SQUARE(x)       ((x) * (x))
#define SQRT(x)         (sqrt(x))
```

（以下定义的常量和宏继续列出，内容包括最大最小值、状态码、协议模式、时钟状态、返回值、系统和对等体标志、认证码、关联状态码、协议模式、时钟状态、以及一些辅助宏。）

A.1.2. 包数据结构

```c
/*
 * 收发包可能包含一个可选的消息认证码（MAC），由密钥ID（keyid）和消息摘要（mac在接收结构中，dgst在发送结构中）组成。
 * NTPv4支持在包头后、MAC之前插入扩展字段，但此处未描述。
 *
 * 接收包
 *
 * 注意：dst时间戳不是包本身的一部分。它在到达时捕获，并与缓冲区长度和数据一起存放在接收缓冲区中。
 * 需要注意的是，某些字符字段在实际包头中是打包在一起的，细节此处省略。
 */
struct r {
        ipaddr  srcaddr;        /* 源（远程）地址 */
        ipaddr  dstaddr;        /* 目的（本地）地址 */
        char    version;        /* 版本号 */
        char    leap;           /* 跳跃指示 */
        char    mode;           /* 模式 */
        char    stratum;        /* 层级 */
        char    poll;           /* 轮询间隔 */
        s_char  precision;      /* 精度 */
        tdist   rootdelay;      /* 根延迟 */
        tdist   rootdisp;       /* 根色散 */
        char    refid;          /* 参考ID */
        tstamp  reftime;        /* 参考时间 */
        tstamp  org;            /* 原始时间戳 */
        tstamp  rec;            /* 接收时间戳 */
        tstamp  xmt;            /* 发送时间戳 */
        int     keyid;          /* 密钥ID */
        digest  mac;            /* 消息摘要 */
        tstamp  dst;            /* 目的时间戳 */
} r;

/*
 * 发送包
 */
struct x {
        ipaddr  dstaddr;        /* 目的（远程）地址 */
        ipaddr  srcaddr;        /* 源（本地）地址 */
        char    version;        /* 版本号 */
        char    leap;           /* 跳跃指示 */
        char    mode;           /* 模式 */
        char    stratum;        /* 层级 */
        char    poll;           /* 轮询间隔 */
        s_char  precision;      /* 精度 */
        tdist   rootdelay;      /* 根延迟 */
        tdist   rootdisp;       /* 根色散 */
        char    refid;          /* 参考ID */
        tstamp  reftime;        /* 参考时间 */
        tstamp  org;            /* 原始时间戳 */
        tstamp  rec;            /* 接收时间戳 */
        tstamp  xmt;            /* 发送时间戳 */
        int     keyid;          /* 密钥ID */
        digest  dgst;           /* 消息摘要 */
} x;
```

A.1.3. 关联数据结构

```c
/*
 * 过滤阶段结构。注意：此处的t成员指的是处理时间（process time），而非实际时间。
 * 处理时间每经过一秒，增加一秒。
 */
struct f {
        tstamp  t;              /* 更新时间 */
        double  offset;         /* 时钟偏差 */
        double  delay;          /* 往返延迟 */
        double  disp;           /* 色散 */
} f;

/*
 * 关联结构。此结构在对等体进程和轮询进程之间共享。
 */
struct p {
        /*
         * 配置设置的变量
         */
        ipaddr  srcaddr;        /* 源（远程）地址 */
        ipaddr  dstaddr;        /* 目的（本地）地址 */
        char    version;        /* 版本号 */
        char    hmode;          /* 主机模式 */
        int     keyid;          /* 密钥ID */
        int     flags;          /* 选项标志 */

        /*
         * 接收包设置的变量
         */
        char    leap;           /* 跳跃指示 */
        char    pmode;          /* 对等体模式 */
        char    stratum;        /* 层级 */
        char    ppoll;          /* 对等体轮询间隔 */
        double  rootdelay;      /* 根延迟 */
        double  rootdisp;       /* 根色散 */
        char    refid;          /* 参考ID */
        tstamp  reftime;        /* 参考时间 */
        #define begin_clear org /* 清除区起点 */
        tstamp  org;            /* 起始时间戳 */
        tstamp  rec;            /* 接收时间戳 */
        tstamp  xmt;            /* 发送时间戳 */

        /*
         * 计算得出的数据
         */
        double  t;              /* 更新时间 */
        struct f f[NSTAGE];     /* 时钟滤波器 */
        double  offset;         /* 对等体偏差 */
        double  delay;          /* 对等体延迟 */
        double  disp;           /* 对等体色散 */
        double  jitter;         /* RMS抖动 */

        /*
         * 轮询进程变量
         */
        char    hpoll;          /* 主机轮询间隔 */
        int     burst;          /* 突发计数 */
        int     reach;          /* reach寄存器 */
        int     ttl;            /* TTL（多播） */
        #define end_clear unreach /* 清除区终点 */
        int     unreach;        /* 不达标计数 */
        int     outdate;        /* 上次轮询时间 */
        int     nextdate;       /* 下次轮询时间 */
} p;
```

（后续还包括系统数据结构等内容，结构定义详见原文。）

—— 以上为主要内容的翻译，全文结构和内容保持一致，确保专业性和准确性。

系统结构
*/
结构体 s {
        tstamp t;              /* 更新时间 */
        char leap;             /* 闰秒指示器 */
        char stratum;          /* 层级 */
        char poll;             /*轮询间隔 */
        char precision;        /* 精度 */
        double rootdelay;      /* 根延迟 */
        double rootdisp;       /* 根散布 */
        char refid;            /* 参考ID */
        tstamp reftime;        /* 参考时间 */
        struct m m[NMAX];      /* 校正列表 */
        struct v v[NMAX];      /* 存活列表 */
        struct p *p;           /* 关联ID */
        double offset;         /* 综合偏移 */
        double jitter;         /* 综合抖动 */
        int flags;             /* 选项标志 */
        int n;                 /* 存活数 */
} s;











Mills 等人                标准追踪                   [第68页]


RFC 5905                   NTPv4 规范                 2010年6月


A.1.5.  本地时钟数据结构

   /*
    * 本地时钟结构
    */
   结构体 c {
           tstamp t;              /* 更新时间 */
           int state;             /* 当前状态 */
           double offset;         /* 当前偏移 */
           double last;           /* 上一次偏移 */
           int count;             /* 抖动计数器 */
           double freq;           /* 频率 */
           double jitter;         /* 均方根抖动 */
           double wander;         /* 均方根漂移 */
   } c;

A.1.6.  函数原型声明

  /*
   * 对等进程
   */
  void    receive(struct r *);    /* 接收数据包 */
  void    packet(struct p *, struct r *); /* 处理数据包 */
  void    clock_filter(struct p *, double, double, double); /* 过滤 */
  double  root_dist(struct p *);  /* 计算根距离 */
  int     fit(struct p *);        /* 判断服务器适配性 */
  void    clear(struct p *, int); /* 清除关联 */
  int     access(struct r *);     /* 判断访问限制 */

  /*
   * 系统进程
   */
  int     main();                 /* 主程序 */
  void    clock_select();         /* 选择最佳时钟 */
  void    clock_update(struct p *); /* 更新系统时钟 */
  void    clock_combine();        /* 合并偏移 */

  /*
   * 本地时钟进程
   */
  int     local_clock(struct p *, double); /* 时钟调节 */
  void    rstclock(int, double, double); /* 时钟状态转换 */

  /*
   * 时钟调整进程
   */
  void    clock_adjust();         /* 一秒定时器处理 */




Mills 等人                标准追踪                   [第69页]


RFC 5905                   NTPv4 规范                 2010年6月


  /*
   * 轮询进程
   */
  void    poll(struct p *);               /* 轮询处理 */
  void    poll_update(struct p *, int); /* 更新轮询间隔 */
  void    peer_xmit(struct p *);  /* 传输数据包 */
  void    fast_xmit(struct r *, int, int); /* 快速应答传输 */

  /*
   * 工具函数
   */
  digest  md5(int);               /* 生成消息摘要 */
  struct p *mobilize(ipaddr, ipaddr, int, int, int, int); /* 关联激活 */
  struct p *find_assoc(struct r *); /* 查找关联表 */

  /*
   * 内核接口
   */
  struct r *recv_packet();        /* 等待接收数据包 */
  void    xmit_packet(struct x *); /* 发送数据包 */
  void    step_time(double);      /* 时间推进 */
  void    adjust_time(double);    /* 时间调整（平移） */
  tstamp  get_time();             /* 读取时间 */

A.2.  主程序与工具函数

/*
 * 定义
 */
#define PRECISION       -18     /* 精度（以log2秒为单位） */
#define IPADDR          0       /* 任意IP地址 */
#define MODE            0       /* 任意NTP模式 */
#define KEYID           0       /* 任意密钥ID */

/*
 * main() - 主程序
 */
int
main()
{
        struct p *p;            /* 对等结构指针 */
        struct r *r;            /* 接收包指针 */









Mills 等人                标准追踪                   [第70页]


RFC 5905                   NTPv4 规范                 2010年6月


        /*
         * 读取命令行参数并初始化系统变量。
         * 参考实现通过测量时钟递增值来获取每台机器的精度。
         */
        memset(&s, sizeof(s), 0);
        s.leap = NOSYNC;
        s.stratum = MAXSTRAT;
        s.poll = MINPOLL;
        s.precision = PRECISION;
        s.p = NULL;

        /*
         * 初始化本地时钟变量
         */
        memset(&c, sizeof(c), 0);
        if (/* 频率文件存在 */ 0) {
                c.freq = /* 频率值 */ 0;
                rstclock(FSET, 0, 0);
        } else {
                rstclock(NSET, 0, 0);
        }
        c.jitter = LOG2D(s.precision);

        /*
         * 读取配置文件，激活持久关联
         * 关联的地址、版本、模式、密钥ID和标志由配置文件指定。
         */
        while (/* 激活配置的关联 */ 0) {
                p = mobilize(IPADDR, IPADDR, VERSION, MODE, KEYID,
                    P_FLAGS);
        }

        /*
         * 启动系统定时器，每秒钟触发一次。然后，
         * 读取到达的数据包，记录接收时间戳，并调用 receive()。
         */
        while (0) {
                r = recv_packet();
                r->dst = get_time();
                receive(r);
        }

        return(0);
}



Mills 等人                标准追踪                   [第71页]


RFC 5905                   NTPv4 规范                 2010年6月


/*
 * mobilize() - 激活并初始化一个关联
 */
struct p
*mobilize(
        ipaddr  srcaddr,        /* 源IP地址 */
        ipaddr  dstaddr,        /* 目的IP地址 */
        int     version,        /* 版本 */
        int     mode,           /* 主机模式 */
        int     keyid,          /* 密钥ID */
        int     flags           /* 对等标志 */
        )
{
        struct p *p;            /* 对等进程指针 */

        /*
         * 分配并初始化关联内存
         */
        p = malloc(sizeof(struct p));
        p->srcaddr = srcaddr;
        p->dstaddr = dstaddr;
        p->version = version;
        p->hmode = mode;
        p->keyid = keyid;
        p->hpoll = MINPOLL;
        clear(p, X_INIT);
        p->flags = flags;
        return (p);
}

/*
 * find_assoc() - 查找匹配的关联
 */
struct p                        /* 对等结构指针或NULL */
*find_assoc(
        struct r *r             /* 接收包指针 */
        )
{
        struct p *p;            /* 临时对等结构指针 */

        /*
         * 在关联表中搜索匹配的源地址、源端口和模式。
         */
        while (/* 所有关联 */ 0) {
                if (r->srcaddr == p->srcaddr && r->mode == p->hmode)
                        return(p);
        }



Mills 等人                标准追踪                   [第72页]


RFC 5905                   NTPv4 规范                 2010年6月


        return (NULL);
}

/*
 * md5() - 计算消息摘要
 */
digest
md5(
       int     keyid           /* 密钥ID */
       )
{
       /*
        * 计算带有密钥的加密消息摘要。密钥ID与本地密钥缓存中的密钥相关联。
        * 密钥会被添加到数据包头和扩展字段中，然后用MD5算法进行哈希。
        * 结果为一个MAC，由32位密钥ID和128位摘要拼接而成。
        */
       return (/* MD5摘要 */ 0);
}

A.3.  内核输入/输出接口

   /*
    * 内核接口，用于传输和接收数据包。细节故意模糊，依赖于操作系统。
    *
    * recv_packet - 从网络接收数据包
    */
   struct r                        /* 接收包指针 */
   *recv_packet() {
           return (/* 接收包 r */ 0);
   }


   /*
    * xmit_packet - 传输数据包到网络
    */
   void
   xmit_packet(
           struct x *x             /* 传输包指针 */
           )
   {
           /* 发送数据包 x */
   }





Mills 等人                标准追踪                   [第73页]


RFC 5905                   NTPv4 规范                 2010年6月


A.4.  内核系统时钟接口

/*
 * 系统时钟工具函数
 *
 * 有三种时间格式：原生（Unix）、NTP和浮点数。
 * get_time() 返回NTP长整型格式的时间。
 * Unix相关函数接受以两个有符号32位字（秒和微秒，timeval）或纳秒（timespec）组成的结构体作为参数。
 * step_time()和adjust_time()函数接受浮点数类型的有符号参数。
 * 这里的简化代码仅用于示意，未经过验证。
 */
#define JAN_1970        2208988800UL /* 1970-1900秒数 */

/*
 * get_time - 读取系统时间并转换为NTP格式
 */
tstamp
get_time()
{
        struct timeval unix_time;

        /*
         * 该函数在程序中只调用两次：一次在数据包到达时，一次在数据包放入发送队列时。
         * 调用内核的获取时间（如gettimeofday()），并转换为NTP格式。
         */
        gettimeofday(&unix_time, NULL);
        return (U2LFP(unix_time));
}


















Mills 等人                标准追踪                   [第74页]


RFC 5905                   NTPv4 规范                 2010年6月


/*
 * step_time() - 将系统时间调整到给定偏移值
 */
void
step_time(
        double  offset          /* 时钟偏移 */
        )
{
        struct timeval unix_time;
        tstamp  ntp_time;

        /*
         * 将偏移值从double转换为原生格式（有符号），并加到当前时间。
         * 转换在原生格式中进行，以避免溢出或精度损失。
         */
        gettimeofday(&unix_time, NULL);
        ntp_time = D2LFP(offset) + U2LFP(unix_time);
        unix_time.tv_sec = ntp_time >> 32;
        unix_time.tv_usec = (long)(((ntp_time - unix_time.tv_sec) <<
            32) / FRAC * 1e6);
        settimeofday(&unix_time, NULL);
}


/*
 * adjust_time() - 以给定偏移值平移系统时间
 */
void
adjust_time(
        double  offset          /* 时钟偏移 */
        )
{
        struct timeval unix_time;
        tstamp  ntp_time;

        /*
         * 将偏移值从double转换为原生格式（有符号），并加到当前时间。
         */
        ntp_time = D2LFP(offset);
        unix_time.tv_sec = ntp_time >> 32;
        unix_time.tv_usec = (long)(((ntp_time - unix_time.tv_sec) <<
            32) / FRAC * 1e6);
        adjtime(&unix_time, NULL);
}





Mills 等人                标准追踪                   [第75页]


RFC 5905                   NTPv4 规范                 2010年6月


A.5.  对等进程

   /*
    * 一个带有密钥的NAK包包括NTP头部，后跟一个MAC
    * 仅由值为零的密钥ID组成。它告诉接收方，之前的请求未能正确
    * 认证，但NTP头字段是正确的。
    *
    * 一个kiss-o'-死亡包是一个NTP头，闰秒为0x3（NOSYNC），
    * 层级为16（MAXSTRAT）。它告诉接收方，发生了重大事件，
    * 由refid字段中的kiss码揭示。NTP头字段可能正确，也可能不正确。
    */
   /*
    * 对等进程参数和常量
    */
   #define SGATE           3       /* 峰值门限（时钟过滤） */
   #define BDELAY          .004    /* 广播延迟（秒） */

   /*
    * 分发代码
    */
   #define ERR             -1      /* 错误 */
   #define DSCRD           0       /* 丢弃数据包 */
   #define PROC            1       /* 处理数据包 */
   #define BCST            2       /* 广播数据包 */
   #define FXMIT           3       /* 客户端数据包 */
   #define MANY            4       /* 多播数据包 */
   #define NEWPS           5       /* 新的对称被动客户端 */
   #define NEWBC           6       /* 新的广播客户端 */

   /*
    * 分发矩阵
    *              active  passv  client server bcast */
   int table[7][5] = {
   /* nopeer  */   { NEWPS, DSCRD, FXMIT, MANY, NEWBC },
   /* active  */   { PROC,  PROC,  DSCRD, DSCRD, DSCRD },
   /* passv   */   { PROC,  ERR,   DSCRD, DSCRD, DSCRD },
   /* client  */   { DSCRD, DSCRD, DSCRD, PROC,  DSCRD },
   /* server  */   { DSCRD, DSCRD, DSCRD, DSCRD, DSCRD },
   /* bcast   */   { DSCRD, DSCRD, DSCRD, DSCRD, DSCRD },
   /* bclient */   { DSCRD, DSCRD, DSCRD, DSCRD, PROC}
   };








Mills 等人                标准追踪                   [第76页]


RFC 5905                   NTPv4 规范                 2010年6月


   /*
    * 其他宏定义
    *
    * 该宏定义了认证状态。如果x为0，则认证为可选；
    * 否则，认证为必需。
    */
   #define AUTH(x, y)      ((x) ? (y) == A_OK : (y) == A_OK || \
                               (y) == A_NONE)

   /*
    * 这些宏由clear()函数使用
    */
   #define BEGIN_CLEAR(p)  ((char *)&((p)->begin_clear))
   #define END_CLEAR(p)    ((char *)&((p)->end_clear))
   #define LEN_CLEAR       (END_CLEAR((struct p *)0) - \
                               BEGIN_CLEAR((struct p *)0))

A.5.1.  receive()

/*
 * receive() - 接收数据包并解码模式
 */
void
receive(
        struct r *r             /* 接收包指针 */
        )
{
        struct p *p;            /* 对等结构指针 */
        int auth;               /* 认证码 */
        int has_mac;            /* MAC大小 */
        int synch;              /* 同步开关 */

        /*
         * 检查访问控制列表。这里的目的是实现
         * 一个白名单，列出被特别接受的IP地址，
         * 和/或一个黑名单，列出被特别拒绝的IP地址。
         * 可能会为认证客户端和未认证客户端设置不同的列表。
         */
        if (!access(r))
                return;                 /* 访问被拒绝 */

        /*
         * 版本号不能在未来。格式检查包括
         * 数据包长度、MAC长度和扩展字段长度（如果存在）。
         */




Mills 等人                标准追踪                   [第77页]


RFC 5905                   NTPv4 规范                 2010年6月


        if (r->version > VERSION /* 或格式错误 */)
                return;                 /* 格式错误 */

以下是该英文内容的中文翻译：

```
        /*
         * 认证由两个开关条件控制，可以在每个客户端单独设置。
         *
         * P_NOPEER     除非已认证，否则不建立关联。
         * P_NOTRUST  不允许访问，除非已认证（包含 P_NOPEER）。
         *
         * 共有四种结果：
         *
         * A_NONE       数据包没有MAC（消息认证码）。
         * A_OK         数据包有MAC且认证成功。
         * A_ERROR      数据包有MAC但认证失败。
         * A_CRYPTO     加密-NAK（消息认证码只有四个字节）。
         *
         * 注意：宏 AUTH (x, y) 用于过滤结果。如果 x 为零，则 y 的可接受结果为 NONE 和 OK。如果 x 为一，y 的唯一可接受结果为 OK。
         */

        has_mac = /* MAC字段长度 */ 0;
        if (has_mac == 0) {
                auth = A_NONE;          /* 不需要认证 */
        } else if (has_mac == 4) {
                auth = A_CRYPTO;       /* 加密-NAK */
        } else {
                if (r->mac != md5(r->keyid))
                        auth = A_ERROR; /* 认证错误 */
                else
                        auth = A_OK;    /* 认证成功 */
        }

        /*
         * 查找关联并派发处理。若没有匹配的关联，则假设 p->hmode 为 NULL。
         */
        p = find_assoc(r);
        switch(table[(unsigned int)(p->hmode)][(unsigned int)(r->mode)])
        {







Mills 等人                标准追踪                   [第78页]


RFC 5905                   NTPv4 规范                 2010年6月


        /*
         * 客户端数据包且无关联。向服务器发送应答，不保存状态。
         */
        case FXMIT:

                /*
                 * 如果是单播目标地址，发送服务器数据包。
                 * 如果认证失败，发送加密-NAK包。
                 */

                /* 非多播目标地址 */
                if (0) {
                        if (AUTH(p->flags & P_NOTRUST, auth))
                                fast_xmit(r, M_SERV, auth);
                        else if (auth == A_ERROR)
                                fast_xmit(r, M_SERV, A_CRYPTO);
                        return;         /* M_SERV数据包已发送 */
                }

                /*
                 * 这必须是多播。若不同步或本层级高于多播源，则不响应。
                 */
                if (s.leap == NOSYNC || s.stratum > r->stratum)
                        return;

                /*
                 * 仅在认证成功时响应。注意使用的是单播地址，而非多播。
                 */
                if (AUTH(p->flags & P_NOTRUST, auth))
                        fast_xmit(r, M_SERV, auth);
                return;

        /*
         * 新的多播客户端临时关联。以数据包中的版本号为准建立关联。
         * 若认证失败，则忽略该数据包。通过比较数据包中的 r->org 时间戳与多播客户端关联中的 p->xmt 时间戳，验证数据包的真实性。若匹配，则数据包真实。细节省略。
         */







Mills 等人                标准追踪                   [第79页]


RFC 5905                   NTPv4 规范                 2010年6月


        case MANY:
                if (!AUTH(p->flags & (P_NOTRUST | P_NOPEER), auth))
                        return;         /* 认证错误 */

                p = mobilize(r->srcaddr, r->dstaddr, r->version, M_CLNT,
                    r->keyid, P_EPHEM);
                break;

       /*
        * 新的对称被动关联。以数据包中的版本建立关联。
        * 若认证失败，发送加密-NAK包。若限制不允许建立关联，则改为发送对称主动包。
        */
        case NEWPS:
                if (!AUTH(p->flags & P_NOTRUST, auth)) {
                        if (auth == A_ERROR)
                                fast_xmit(r, M_SACT, A_CRYPTO);
                        return;         /* 已发送加密-NAK包 */
                }
                if (!AUTH(p->flags & P_NOPEER, auth)) {
                        fast_xmit(r, M_SACT, auth);
                        return;         /* 已发送 M_SACT包 */
                }
                p = mobilize(r->srcaddr, r->dstaddr, r->version, M_PASV,
                    r->keyid, P_EPHEM);
                break;

        /*
         * 新的广播客户端关联。以数据包中的版本建立关联。
         * 若认证失败，则忽略该数据包。注意此代码不支持参考实现中的初始投放功能。
         */
        case NEWBC:
                if (!AUTH(p->flags & (P_NOTRUST | P_NOPEER), auth))
                        return;         /* 认证错误 */

                if (!(s.flags & S_BCSTENAB))
                        return;         /* 广播未启用 */

                p = mobilize(r->srcaddr, r->dstaddr, r->version, M_BCLN,
                    r->keyid, P_EPHEM);
                break;                  /* 处理继续进行 */







Mills 等人                标准追踪                   [第80页]


RFC 5905                   NTPv4 规范                 2010年6月


        /*
         * 处理数据包。仅占位符。
         */
        case PROC:
                break;                  /* 处理继续 */

        /*
         * 无效的模式组合。仅在临时关联情况下出现，因此正确的做法是直接丢弃。
         */
        case ERR:
                clear(p, X_ERROR);
                return;                 /* 模式组合无效 */

        /*
         * 无匹配，直接丢弃数据包。
         */
        case DSCRD:
                return;                 /* 孤儿，已放弃 */
        }

        /*
         * 接下来是严格的时间戳检查。如果传输时间戳为零，说明服务器严重出错。
         */
        if (r->xmt == 0)
                return;                 /* 时间戳无效 */

        /*
         * 如果传输时间戳与之前的相同，说明是重放攻击。
         */
        if (r->xmt == p->xmt)
                return;                 /* 重放包 */

        /*
         * 如果是广播模式的数据包，则跳过进一步检查。
         * 如果起始时间戳为零，说明发件人尚未收到我们的响应。
         * 否则，如果起始时间戳不匹配，则数据包为伪造。
         */









Mills 等人                标准追踪                   [第81页]


RFC 5905                   NTPv4 规范                 2010年6月


        synch = TRUE;
        if (r->mode != M_BCST) {
                if (r->org == 0)
                        synch = FALSE;  /* 未同步 */

                else if (r->org != p->xmt)
                        synch = FALSE;  /* 伪造包 */
        }

        /*
         * 更新起始和目标时间戳。如果未同步或数据包伪造，则放弃。
         */
        p->org = r->xmt;
        p->rec = r->dst;
        if (!synch)
                return;                 /* 未同步 */

        /*
         * 时间戳有效，接收的数据包与上次发送的匹配。
         * 如果是加密-NAK，说明服务器可能刚更换了密钥。我们解除关联，等待更好的时机。
         */
        if (auth == A_CRYPTO) {
                clear(p, X_CRYPTO);
                return;                 /* 加密-NAK */
        }

        /*
         * 若关联已认证，密钥ID非零，且接收的数据包必须经过认证。
         * 这是为了避免“钓鱼攻击”，在过去的版本中曾存在此漏洞。
         */
        if (!AUTH(p->keyid || (p->flags & P_NOTRUST), auth))
                return;                 /* 认证失败 */














Mills 等人                标准追踪                   [第82页]


RFC 5905                   NTPv4 规范                 2010年6月


        /*
         * 已尽一切努力验证时间戳，防止恶意破坏协议或注入伪造数据。
         * 争取获得一些收益。
         */
        packet(p, r);
}

A.5.1.1.  packet()

/*
 * packet() - 处理数据包，计算偏移、延迟和扩散。
 */
void
packet(
        struct p *p,            /* 对等体结构指针 */
        struct r *r             /* 接收数据包指针 */
        )
{
        double  offset;         /* 样本偏移 */
        double  delay;          /* 样本延迟 */
        double  disp;           /* 样本扩散 */

        /*
         * 数据包有效。填充剩余头部字段。
         * 注意：将层级0（未指定）映射为 MAXSTRAT，以简化层级比较，并为操作在层级0的无线电时钟驱动提供自然接口。
         */
        p->leap = r->leap;
        if (r->stratum == 0)
                p->stratum = MAXSTRAT;
        else
                p->stratum = r->stratum;
        p->pmode = r->mode;
        p->ppoll = r->poll;
        p->rootdelay = FP2D(r->rootdelay);
        p->rootdisp = FP2D(r->rootdisp);
        p->refid = r->refid;
        p->reftime = r->reftime;

        /*
         * 验证服务器是否同步，且参考时间不晚于传输时间。
         */




Mills 等人                标准追踪                   [第83页]


RFC 5905                   NTPv4 规范                 2010年6月


        if (p->leap == NOSYNC || p->stratum >= MAXSTRAT)
                return;                 /* 未同步 */

        /*
         * 验证根距离的有效性。
         */
        if (r->rootdelay / 2 + r->rootdisp >= MAXDISP || p->reftime > r->xmt)
                return;                 /* 头部值无效 */

        poll_update(p, p->hpoll);
        p->reach |= 1;

        /*
         * 计算偏移、延迟和扩散，然后传递给时钟滤波器。
         * 注意隐含的处理方式。一次差分直接用64位算术完成，然后将结果转换为浮点双精度。
         * 后续所有处理都在浮点双精度中进行，硬件进行舍入。这是为了避免溢出并保持精度。
         *
         * 延迟的计算是特殊情况。在服务器和客户端时钟速率不同且网络非常快的情况下，延迟可能显示为负值。
         * 为避免违反“最少惊讶原则”，延迟被限制在系统精度范围内。
         */
        if (p->pmode == M_BCST) {
                offset = LFP2D(r->xmt - r->dst);
                delay = BDELAY;
                disp = LOG2D(r->precision) + LOG2D(s.precision) + PHI * 2 * BDELAY;
        } else {
                offset = (LFP2D(r->rec - r->org) + LFP2D(r->dst - r->xmt)) / 2;
                delay = max(LFP2D(r->dst - r->org) - LFP2D(r->rec - r->xmt), LOG2D(s.precision));
                disp = LOG2D(r->precision) + LOG2D(s.precision) + PHI * LFP2D(r->dst - r->org);
        }
        clock_filter(p, offset, delay, disp);
}








Mills 等人                标准追踪                   [第84页]


RFC 5905                   NTPv4 规范                 2010年6月


A.5.2.  clock_filter()

/*
 * clock_filter(p, offset, delay, dispersion) - 从最新的八个延迟/偏移样本中选择最佳的一个。
 */
void
clock_filter(
        struct p *p,            /* 对等体结构指针 */
        double  offset,         /* 时钟偏移 */
        double  delay,          /* 往返延迟 */
        double  disp            /* 扩散 */
        )
{
        struct f f[NSTAGE];     /* 排序列表 */
        double  dtemp;
        int     i;

        /*
         * 时钟滤波器内容由八个元组组成（偏移、延迟、扩散、时间）。
         * 将每个元组向左移动，丢弃最左边的一个。在移动过程中，扩散值会增加，因为上次滤波器更新后。
         * 同时，将每个元组复制到临时列表中。之后，将（偏移、延迟、扩散、时间）放入空出的位置的最右端元组中。
         */
        for (i = 1; i < NSTAGE; i++) {
                p->f[i] = p->f[i - 1];
                p->f[i].disp += PHI * (c.t - p->t);
                f[i] = p->f[i];
        }
        p->f[0].t = c.t;
        p->f[0].offset = offset;
        p->f[0].delay = delay;
        p->f[0].disp = disp;
        f[0] = p->f[0];

        /*
         * 按照增加的延迟值对临时元组列表进行排序。
         * 排序后第一个元素代表最佳样本，但可能是旧的。
         */
        dtemp = p->offset;
        p->offset = f[0].offset;
        p->delay = f[0].delay;
        for (i = 0; i < NSTAGE; i++) {
                p->disp += f[i].disp / (2 ^ (i + 1));



Mills 等人                标准追踪                   [第85页]


RFC 5905                   NTPv4 规范                 2010年6月


                p->jitter += SQUARE(f[i].offset - f[0].offset);
        }
        p->jitter = max(SQRT(p->jitter), LOG2D(s.precision));

        /*
         * 基本原则：只使用一次样本，且不使用比最新样本更旧的样本。
         * 在首次同步前，任何样本都可以使用。
         */
        if (f[0].t - p->t <= 0 && s.leap != NOSYNC)
                return;

        /*
         * 爆发抑制器。比较最后一个和当前偏移的差值与当前抖动值。
         * 若大于 SGATE（3）且自上次偏移以来的间隔小于系统轮询间隔的两倍，则丢弃该突发。
         * 否则，在非突发状态下，筛选出真正的时间同步器。
         */
        if (fabs(p->offset - dtemp) > SGATE * p->jitter && (f[0].t - p->t) < 2 * s.poll)
                return;

        p->t = f[0].t;
        if (p->burst == 0)
                clock_select();
        return;
}

/*
 * fit() - 测试关联 p 是否适合同步
 */
int
fit(
        struct p *p             /* 对等体结构指针 */
        )
{
        /*
         * 层级错误发生在（1）服务器从未同步，或（2）服务器层级无效时。
         */
        if (p->leap == NOSYNC || p->stratum >= MAXSTRAT)
                return (FALSE);








Mills 等人                标准追踪                   [第86页]


RFC 5905                   NTPv4 规范                 2010年6月


        /*
         * 距离错误发生在根距离超过阈值加上一个轮询间隔的增量时。
         */
        if (root_dist(p) > MAXDIST + PHI * LOG2D(s.poll))
                return (FALSE);

        /*
         * 循环错误发生在远端对等体同步到本地对等体，或同步到当前系统对等体时。
         * 注意这是IPv4的行为；对于IPv6，则使用MD5哈希。
         */
        if (p->refid == p->dstaddr || p->refid == s.refid)
                return (FALSE);

        /*
         * 无法到达错误发生在服务器不可达时。
         */
        if (p->reach == 0)
                return (FALSE);

        return (TRUE);
}
```

以下是您提供的英文内容的中文流畅翻译：

```c
/*
 * clear() - 重新初始化以实现持久关联，取消临时关联
 *          （ephemeral association）的激活。
 */
void
clear(
        struct p *p,            /* 对等体结构指针 */
        int     kiss            /* kiss码 */
        )
{
        int i;

        /*
         * 首先要做的是将所有资源归还给资源管理池。
         * 典型资源未在此详细列出，但包括
         * 用于密钥、证书等的动态分配结构。
         * 如果是临时关联且不是初始化状态，则也要归还
         * 关联的内存。
         */
        /* 归还资源 */
        if (s.p == p)
                s.p = NULL;

        if (kiss != X_INIT && (p->flags & P_EPHEM)) {
                free(p);
                return;
        }

        /*
         * 为一般重置初始化关联字段。
         */
        memset(BEGIN_CLEAR(p), LEN_CLEAR, 0);
        p->leap = NOSYNC;
        p->stratum = MAXSTRAT;
        p->ppoll = MAXPOLL;
        p->hpoll = MINPOLL;
        p->disp = MAXDISP;
        p->jitter = LOG2D(s.precision);
        p->refid = kiss;
        for (i = 0; i < NSTAGE; i++)
                p->f[i].disp = MAXDISP;

        /*
         * 为了避免广播服务器长时间未响应后，数千个广播客户端
         * 被突然唤醒，随机化第一次轮询时间。
         */
        p->outdate = p->t = c.t;
        p->nextdate = p->outdate + (random() & ((1 << MINPOLL) - 1));
}

A.5.3.  fast_xmit()

/*
 * fast_xmit() - 传输对接收包r的应答包
 */
void
fast_xmit(
        struct r *r,            /* 接收包指针 */
        int     mode,           /* 关联模式 */
        int     auth            /* 认证码 */
        )
{
        struct x x;

        /*
         * 初始化头部信息和传输时间戳。注意，传输版本
         * 从接收版本复制而来，为了向后兼容。
         */

        x.version = r->version;
        x.srcaddr = r->dstaddr;
        x.dstaddr = r->srcaddr;
        x.leap = s.leap;
        x.mode = mode;
        if (s.stratum == MAXSTRAT)
                x.stratum = 0;
        else
                x.stratum = s.stratum;
        x.poll = r->poll;
        x.precision = s.precision;
        x.rootdelay = D2FP(s.rootdelay);
        x.rootdisp = D2FP(s.rootdisp);
        x.refid = s.refid;
        x.reftime = s.reftime;
        x.org = r->xmt;
        x.rec = r->dst;
        x.xmt = get_time();

        /*
         * 如果认证码为A.NONE，则只包含头部信息；
         * 如果为A.CRYPTO，则发送crypto-NAK；
         * 如果为A.OK，则发送有效的MAC。
         * 使用接收包中的密钥ID和本地密钥缓存中的密钥。
         */
        if (auth != A_NONE) {
                if (auth == A_CRYPTO) {
                        x.keyid = 0;
                } else {
                        x.keyid = r->keyid;
                        x.dgst = md5(x.keyid);
                }
        }
        xmit_packet(&x);
}

A.5.4.  access()

/*
 * access() - 判断访问限制
 */
int
access(
        struct r *r             /* 接收包指针 */
        )
{
        /*
         * 访问控制列表是一个有序的元组集合，
         * 包含地址、掩码和限制字（restrict word），
         * 其中定义了相应的位。搜索列表，找到第一个匹配
         * 源地址（r->srcaddr）的位置，并返回对应的限制字。
         */
        return (/* 访问位 */ 0);
}

A.5.5.  系统进程

A.5.5.1.  clock_select()

/*
 * clock_select() - 选择最佳时钟
 */
void
clock_select() {
       struct p *p, *osys;     /* 对等体结构指针 */
       double  low, high;      /* 正确性区间范围 */
       int     allow, found, chime; /* 交集算法用变量 */
       int     n, i, j;

        /*
         * 首先筛除伪信号源，只保留真正的信号源。
         * 关联p的正确性区间为偏移量减去根距离（root_dist()）
         * 到偏移量加上根距离的区间。目标是找到一个
         * 多数团体（majority clique）；即，正确性区间的
         * 交集超过服务器总数的一半。
         *
         * 首先构建（p，类型，边界）元组的信号列表，然后
         * 按边界从低到高排序。
         */
        osys = s.p;
        s.p = NULL;
        n = 0;
        while (fit(p)) {
                s.m[n].p = p;
                s.m[n].type = +1;
                s.m[n].edge = p->offset + root_dist(p);
                n++;
                s.m[n].p = p;
                s.m[n].type = 0;
                s.m[n].edge = p->offset;
                n++;
                s.m[n].p = p;
                s.m[n].type = -1;
                s.m[n].edge = p->offset - root_dist(p);
                n++;
        }

        /*
         * 寻找正确性区间的最大连续交集。
         * allow为允许的伪信号源数；
         * found为中点数。注意，边界值在时间戳计算中
         * 被限制在±(2^30)范围内，即±20亿。
         */
        low = 2e9; high = -2e9;
        for (allow = 0; 2 * allow < n; allow++) {

                /*
                 * 从最低到最高扫描信号列表，找到下界。
                 */
                found = 0;
                chime = 0;
                for (i = 0; i < n; i++) {
                        chime -= s.m[i].type;
                        if (chime >= n - found) {
                                low = s.m[i].edge;
                                break;
                        }
                        if (s.m[i].type == 0)
                                found++;
                }

                /*
                 * 从最高到最低扫描信号列表，找到上界。
                 */
                chime = 0;
                for (i = n - 1; i >= 0; i--) {
                        chime += s.m[i].type;
                        if (chime >= n - found) {
                                high = s.m[i].edge;
                                break;
                        }
                        if (s.m[i].type == 0)
                                found++;
                }

                /*
                 * 如果中点数大于允许的伪信号源数，则
                 * 交集包含至少一个真实信号源（truechimer）
                 * 且没有中点。此时增加允许的伪信号源数
                 * 并继续循环。否则，如果交集非空，则
                 * 表示成功。
                 */
                if (found > allow)
                        continue;

                if (high > low)
                        break;
        }

        /*
         * 聚类算法。构建存活的（p，指标）列表，
         * 其中指标由层级（stratum）优先，然后由根距离（root distance）决定。
         * 在其他条件相同时，这是偏好的顺序。
         */
        s.n = 0;
        for (i = 0; i < n; i++) {
                if (s.m[i].edge < low || s.m[i].edge > high)
                        continue;

                p = s.m[i].p;
                s.v[n].p = p;
                s.v[n].metric = MAXDIST * p->stratum + root_dist(p);
                s.n++;
        }

        /*
         * 必须有至少NSANE个存活体，才能满足正确性断言。
         * 通常，拜占庭容错标准要求至少四个存活体，
         * 但在此演示中，允许只有一个。
         */
        if (s.n < NSANE)
                return;

        /*
         * 依次为每个关联p计算选择抖动（jitter）p->sjitter，
         * 其为所有q关联中（p->offset - q->offset）平方和的平方根。
         * 目标是反复剔除最大抖动的存活体，直到满足终止条件。
         */
        while (1) {
                struct p *p, *q, *qmax; /* 对等体结构指针 */
                double max, min, dtemp;

                max = -2e9; min = 2e9;
                for (i = 0; i < s.n; i++) {
                        p = s.v[i].p;
                        if (p->jitter < min)
                                min = p->jitter;
                        dtemp = 0;
                        for (j = 0; j < n; j++) {
                                q = s.v[j].p;
                                dtemp += SQUARE(p->offset - q->offset);
                        }
                        dtemp = SQRT(dtemp);
                        if (dtemp > max) {
                                max = dtemp;
                                qmax = q;
                        }
                }

                /*
                 * 如果最大选择抖动小于最小对等体抖动，
                 * 则剔除更多存活体不会降低最小抖动，
                 * 可以停止。为了确保剩余一些存活体
                 * 供聚类算法处理，也在此停止（n <= NMIN）。
                 */
                if (max < min || n <= NMIN)
                        break;

                /*
                 * 从列表中删除qmax存活体，继续循环。
                 */
                s.n--;
        }

        /*
         * 选择最佳时钟。如果旧系统对等体在列表中
         * 且与第一个存活体的层级相同，则不进行时钟跳变。
         * 否则，将第一个存活体作为新的系统对等体。
         */
        if (osys->stratum == s.v[0].p->stratum)
                s.p = osys;
        else
                s.p = s.v[0].p;
        clock_update(s.p);
}

A.5.5.2.  root_dist()

/*
 * root_dist() - 计算根距离
 */
double
root_dist(
        struct p *p             /* 对等体结构指针 */
        )
{
        /*
         * 根同步距离是由所有原因引起的本地时钟误差的最大值。
         * 它定义为总延迟的一半，加上总离散度，
         * 以及对等体抖动。
         */
        return (max(MINDISP, p->rootdelay + p->delay) / 2 +
            p->rootdisp + p->disp + PHI * (c.t - p->t) + p->jitter);
}

A.5.5.3.  accept()

/*
 * accept() - 判断关联p是否可接受用于同步
 */
int
accept(
        struct p *p             /* 对等体结构指针 */
        )
{
        /*
         * 如果（1）服务器从未同步过，或（2）服务器层级无效，
         * 则发生层级错误（stratum error）。
         */
        if (p->leap == NOSYNC || p->stratum >= MAXSTRAT)
                return (FALSE);

        /*
         * 如果根距离超过最大距离阈值（MAXDIST）加上
         * 一个轮询间隔的增量（PHI * LOG2D(s.poll)），
         * 则发生距离错误（distance error）。
         */

        if (root_dist(p) > MAXDIST + PHI * LOG2D(s.poll))
                return (FALSE);

        /*
         * 如果远程对等体同步到本地对等体，或同步到当前系统对等体，
         * 则发生环路错误（loop error）。注意这是IPv4的行为；
         * 对于IPv6，则使用MD5哈希。
         */
        if (p->refid == p->dstaddr || p->refid == s.refid)
                return (FALSE);

        /*
         * 如果服务器无法访问，则发生不可达错误（unreachable error）。
         */
        if (p->reach == 0)
                return (FALSE);

        return (TRUE);
}

A.5.5.4.  clock_update()

/*
 * clock_update() - 更新系统时钟
 */
void
clock_update(
        struct p *p             /* 对等体结构指针 */
        )
{
        double dtemp;

        /*
         * 如果这是旧的更新（例如，由于系统对等体变化引起），
         * 则避免使用。我们绝不使用旧样本或重复使用相同样本。
         */
        if (s.t >= p->t)
                return;

        /*
         * 合并存活体偏移，更新系统时钟；
         * local_clock()函数会告诉我们好消息或坏消息。
         */
        s.t = p->t;
        clock_combine();
        switch (local_clock(p, s.offset)) {

        /*
         * 偏移值过大，可能是虚假的。向系统日志报告，
         * 并指示操作员手动设置时钟，范围在PANIC阈值内。
         * 参考实现中可以通过命令行选项禁用此检查，
         * 并调整PANIC阈值（默认为1000秒）。
         */
        case PANIC:
                exit (0);

        /*
         * 偏移值超过步进阈值（默认为0.125秒）。
         * 步进后，所有关联的时间值变得不一致，
         * 需要重置并重新开始。可以在参考实现中调整
         * 步进阈值，以减少时钟倒退的可能性。
         * 但可能会带来严重后果，详见NTP项目白皮书。
         */
        case STEP:
                while (/* 所有关联 */ 0)
                        clear(p, X_STEP);
                s.stratum = MAXSTRAT;
                s.poll = MINPOLL;
                break;
```

以下是英文内容的中文翻译：

```
        /*
         * 偏移量小于步进阈值，这是正常情况。 从对等变量更新系统变量。  dispersion 增加的下限夹紧是为了避免在使用高精度源时出现时序环路和时钟跳变。 夹紧值可以从参考实现中的默认值0.01秒进行调整。
         */
        case SLEW:
                s.leap = p->leap;
                s.stratum = p->stratum + 1;
                s.refid = p->refid;
                s.reftime = p->reftime;
                s.rootdelay = p->rootdelay + p->delay;
                dtemp = SQRT(SQUARE(p->jitter) + SQUARE(s.jitter));
                dtemp += max(p->disp + PHI * (c.t - p->t) +
                    fabs(p->offset), MINDISP);
                s.rootdisp = p->rootdisp + dtemp;
                break;





米尔斯等人  标准轨道  [第96页]


RFC 5905  NTPv4 规范  2010年6月


        /*
         * 在某些采样被丢弃的情况下，例如正在进行直接频率测量时。
         */
        case IGNORE:
                break;
        }
}

A.5.5.5.  clock_combine()

/*
 * clock_combine() - 合并偏移
 */
void
clock_combine()
{
        struct p *p;            /* 对等结构指针 */
        double x, y, z, w;
        int i;

        /*
         * 使用根距离的加权平均值，合并聚类算法幸存者的偏移量。
         * 计算选择的抖动为第一个幸存者与其余幸存者之间的加权均方根差异。
         * 在某些情况下，固有的时钟抖动可以通过不使用此算法来减少，尤其是在频繁时钟跳变的情况下。
         * 参考实现可以通过指定偏好对等体来避免此算法。
         */
        y = z = w = 0;
        for (i = 0; s.v[i].p != NULL; i++) {
                p = s.v[i].p;
                x = root_dist(p);
                y += 1 / x;
                z += p->offset / x;
                w += SQUARE(p->offset - s.v[0].p->offset) / x;
        }
        s.offset = z / y;
        s.jitter = SQRT(w / y);
}








米尔斯等人  标准轨道  [第97页]


RFC 5905  NTPv4 规范  2010年6月


A.5.5.6.  local_clock()

/*
 * Clock discipline parameters and constants
 */
#define STEPT           .128    /* 步进阈值（秒） */
#define WATCH           900     /* 步出阈值（秒） */
#define PANICT          1000    /* 恐慌阈值（秒） */
#define PLL             65536   /* PLL环路增益 */
#define FLL             MAXPOLL + 1 /* FLL环路增益 */
#define AVG             4       /* 参数平均常数 */
#define ALLAN           1500    /* 折衷的Allan截距（秒） */
#define LIMIT           30      /* 轮询调整阈值 */
#define MAXFREQ         500e-6  /* 频率容差（500 ppm） */
#define PGATE           4       /* 轮询调整门限 */

/*
 * local_clock() - 约束本地时钟
 */
int                             /* 返回码 */
local_clock(
        struct p *p,            /* 对等结构指针 */
        double  offset          /* 来自combine()的偏移量 */
        )
{
        int     state;          /* 时钟约束状态 */
        double  freq;           /* 频率 */
        double  mu;             /* 自上次更新以来的间隔 */
        int     rval;
        double  etemp, dtemp;

        /*
         * 如果偏移量过大，则放弃并退出。
         */
        if (fabs(offset) > PANICT)
                return (PANIC);

        /*
         * 时钟状态机转换函数。 这是关键部分，定义系统如何应对大的时间
         * 和频率误差。主要有两种状态：偏移超过步进阈值和未超过。
         */
        rval = SLEW;
        mu = p->t - s.t;
        freq = 0;
        if (fabs(offset) > STEPT) {
                switch (c.state) {



米尔斯等人  标准轨道  [第98页]


RFC 5905  NTPv4 规范  2010年6月


                /*
                 * 在S_SYNC状态下，我们忽略第一个异常值，并切换到S_SPIK状态。
                 */
                case SYNC:
                        state = SPIK;
                        return (rval);

                /*
                 * 在S_FREQ状态下，我们忽略异常值和正常值。
                 * 在偏移超过步出阈值的第一个异常值时，
                 * 计算表观频率校正并调整时间。
                 */
                case FREQ:
                        if (mu < WATCH)
                                return (IGNORE);

                        freq = (offset - c.offset) / mu;
                        /* 继续执行到S_SPIK */

                /*
                 * 在S_SPIK状态下，我们忽略后续的异常值，直到
                 * 发现正常值或偏移超过步出阈值。
                 */
                case SPIK:
                        if (mu < WATCH)
                                return (IGNORE);

                        /* 继续执行到默认 */

                /*
                 * 默认情况下，我们在S_NSET和S_FSET状态下到达此处，
                 * 以及在上面S_FREQ状态下到达。
                 * 调整时间并限制轮询间隔。
                 *
                 * 在S_NSET状态下，尚未获得初始频率校正，通常是因为频率文件尚未写入。
                 * 由于时间超出捕获范围，时钟会被步进。
                 * 步进后，频率将被直接设置。
                 *
                 * 在S_FSET状态下，初始频率已从频率文件中设置。
                 * 由于时间超出捕获范围，时钟会立即步进，而不是在偏移阈值后。
                 * 如果第一次设置时钟花费17分钟，可能会让人紧张。
                 *
                 * 在S_SPIK状态下，偏移阈值已过期，且相位仍高于步进阈值。
                 * 注意，任何大于步进阈值的单个突波都会被抑制，即使在较长的轮询间隔下也是如此。
                 */
                default:

                        /*
                         * 这是内核设置时间的函数，通常由Unix的settimeofday()系统调用实现。
                         */
                        step_time(offset);
                        c.count = 0;
                        s.poll = MINPOLL;
                        rval = STEP;
                        if (state == NSET) {
                                rstclock(FREQ, p->t, 0);
                                return (rval);
                        }
                        break;
                }
                rstclock(SYNC, p->t, 0);
        } else {

                /*
                 * 计算时钟抖动，作为指数加权偏移差异的均方根。
                 * 这被轮询调整代码使用。
                 */
                etemp = SQUARE(c.jitter);
                dtemp = SQUARE(max(fabs(offset - c.last),
                    LOG2D(s.precision)));
                c.jitter = SQRT(etemp + (dtemp - etemp) / AVG);
                switch (c.state) {

                /*
                 * 在S_NSET状态下，这是第一次收到更新，频率尚未初始化。
                 * 首要任务是直接测量振荡器频率。
                 */
                case NSET:
                        rstclock(FREQ, p->t, offset);
                        return (IGNORE);



米尔斯等人  标准轨道  [第100页]


RFC 5905  NTPv4 规范  2010年6月


                /*
                 * 在S_FSET状态下，这是第一次更新，频率已初始化。
                 * 调整相位，但不要在下一次更新前调整频率。
                 */
                case FSET:
                        rstclock(SYNC, p->t, offset);
                        break;

                /*
                 * 在S_FREQ状态下，忽略偏移超过步出阈值的更新。
                 * 之后，校正相位和频率，并切换到S_SYNC状态。
                 */
                case FREQ:
                        if (c.t - s.t < WATCH)
                                return (IGNORE);

                        freq = (offset - c.offset) / mu;
                        break;

                /*
                 * 默认情况下，我们在S_SYNC和S_SPIK状态下到达此处。
                 * 这里计算由PLL和FLL贡献引起的频率更新。
                 */
                default:

                        /*
                         * FLL和PLL的频率增益常数
                         * 取决于轮询间隔和Allan截距。
                         * 在Allan截距的一半以下不使用FLL。
                         * 超过该值，环路增益逐步增加到1 / AVG。
                         */
                        if (LOG2D(s.poll) > ALLAN / 2) {
                                etemp = FLL - s.poll;
                                if (etemp < AVG)
                                        etemp = AVG;
                                freq += (offset - c.offset) / (max(mu,
                                    ALLAN) * etemp);
                        }









米尔斯等人  标准轨道  [第101页]


RFC 5905  NTPv4 规范  2010年6月


                        /*
                         * 对于PLL，积分区间（分子）是更新间隔和轮询间隔的最小值。
                         * 这允许过采样，但不允许欠采样。
                         */
                        etemp = min(mu, LOG2D(s.poll));
                        dtemp = 4 * PLL * LOG2D(s.poll);
                        freq += offset * etemp / (dtemp * dtemp);
                        rstclock(SYNC, p->t, offset);
                        break;
                }
        }

        /*
         * 计算新的频率和频率稳定性（漂移）。
         * 将频率漂移作为指数加权频率差异的均方根。
         * 这不会直接使用，但可以与抖动一起，成为非常有用的监控和调试工具。
         */
        freq += c.freq;
        c.freq = max(min(MAXFREQ, freq), -MAXFREQ);
        etemp = SQUARE(c.wander);
        dtemp = SQUARE(freq);
        c.wander = SQRT(etemp + (dtemp - etemp) / AVG);

        /*
         * 这里通过比较当前偏移量与时钟抖动，调整轮询间隔。
         * 如果偏移量小于时钟抖动乘以常数，则增加平均间隔；
         * 否则，减少间隔。一定的滞后有助于平稳调整。
         * 最佳效果是在突发模式下。
         */
        if (fabs(c.offset) < PGATE * c.jitter) {
                c.count += s.poll;
                if (c.count > LIMIT) {
                        c.count = LIMIT;
                        if (s.poll < MAXPOLL) {
                                c.count = 0;
                                s.poll++;
                        }
                }
        } else {
                c.count -= s.poll << 1;
                if (c.count < -LIMIT) {
                        c.count = -LIMIT;
                        if (s.poll > MINPOLL) {



米尔斯等人  标准轨道  [第102页]


RFC 5905  NTPv4 规范  2010年6月


                                c.count = 0;
                                s.poll--;
                        }
                }
        }
        return (rval);
}

A.5.5.7.  rstclock()

  /*
   * rstclock() - 时钟状态机
   */
  void
  rstclock(
          int     state,          /* 新状态 */
          double  offset,         /* 新偏移 */
          double  t               /* 新更新时间 */
          )
  {
          /*
           * 进入新状态并设置状态变量。注意，我们使用上一次时钟滤波样本的时间，
           * 该时间必须早于当前时间。
           */
          c.state = state;
          c.last = c.offset = offset;
          s.t = t;
  }

A.5.6.  时钟调整过程

A.5.6.1.  clock_adjust()

 /*
  * clock_adjust() - 每秒运行一次
  */
 void
 clock_adjust() {
         double  dtemp;

         /*
          * 更新进程时间 c.t。同时增加自上次更新以来的散布。
          * 与NTPv3不同，NTPv4不会在一天后声明不同步，因为散布阈值起到此作用。
          * 当散布超过 MAXDIST（1秒）时，服务器被认为不适合同步。
          */
         c.t++;
         s.rootdisp += PHI;

         /*
          * 实现相位和频率调整。增益因子（分母）不允许超过Allan截距。
          * 这样可以避免在此点之后对相位噪声的平均，且有助于抑制在较长轮询间隔中的残余偏移。
          */
         dtemp = c.offset / (PLL * min(LOG2D(s.poll), ALLAN));
         c.offset -= dtemp;

         /*
          * 这是内核的时间调整函数，通常由Unix的adjtime()系统调用实现。
          */
         adjust_time(c.freq + dtemp);

         /*
          * 对等体定时器。到期时调用poll()例程。
          */
         while (/* 所有关联 */ 0) {
                 struct p *p;    /* 虚拟对等体结构指针 */

                 if (c.t >= p->nextdate)
                         poll(p);
         }

         /*
          * 每小时将时钟频率写入文件。
          */
         /*
          * if (c.t % 3600 == 3599)
          *   将c.freq写入文件
          */
 }

A.5.7.  轮询过程

   /*
    * 轮询参数和常量
    */
   #define UNREACH         12      /* 不达阈值 */
   #define BCOUNT          8       /* 一次突发包数 */
   #define BTIME           2       /* 突发间隔（秒） */



米尔斯等人  标准轨道  [第104页]


RFC 5905  NTPv4 规范  2010年6月


A.5.7.1.  poll()

/*
 * poll() - 确定何时向关联p->发送数据包
 */
void
poll(
        struct p *p             /* 对等结构指针 */
        )
{
        int     hpoll;
        int     oreach;

        /*
         * 当当前时间c.t赶上下次轮询时间p->nextdate时调用此例程。
         * p->outdate是此例程上次执行的时间。轮询更新()例程确定下一次执行时间p->nextdate。
         *
         * 如果是广播，只需执行，但前提是已同步。
         */
        hpoll = p->hpoll;
        if (p->hmode == M_BCST) {
                p->outdate = c.t;
                if (s.p != NULL)
                        peer_xmit(p);
                poll_update(p, hpoll);
                return;
        }
```

/*
 * 如果采用多播，起始时TTL设为1。每次轮询时TTL增加1，直到找到MAXCLOCK个服务器或TTL达到TTLMAX为止。
 * 如果达到MAXCLOCK，则停止轮询，直到服务器数量降至MINCLOCK以下，然后重新开始。
 */
if (p->hmode == M_CLNT && p->flags & P_MANY) {
    p->outdate = c.t;
    if (p->unreach > BEACON) {
        p->unreach = 0;
        p->ttl = 1;
        peer_xmit(p);
    } else if (s.n < MINCLOCK) {
        if (p->ttl < TTLMAX)
            p->ttl++;
        peer_xmit(p);
    }

    Mills 等人  标准追踪  [第105页]

RFC 5905  NTPv4 规范  2010年6月

    p->unreach++;
    poll_update(p, hpoll);
    return;
}
if (p->burst == 0) {

    /*
     * 我们不在突发状态。将可达性寄存器左移。
     * 希望在下一次轮询前，能有数据包到达并设置最右边的位。
     */
    oreach = p->reach;
    p->outdate = c.t;
    p->reach = p->reach << 1;
    if (!(p->reach & 0x7))
        clock_filter(p, 0, 0, MAXDISP);
    if (!p->reach) {

        /*
         * 服务器不可达，因此增加不可达计数器。
         * 如果达到不可达阈值，则将轮询间隔加倍，以减少网络流量浪费。
         * 仅在启用突发且未达到不可达阈值时，才发送突发包。
         */
        if (p->flags & P_IBURST && p->unreach == 0) {
            p->burst = BCOUNT;
        } else if (p->unreach < UNREACH)
            p->unreach++;
        else
            hpoll++;
        p->unreach++;
    } else {

        /*
         * 服务器可达。将轮询间隔设置为系统轮询间隔。
         * 仅在启用突发且对等体适合时，才设置突发。
         */
        p->unreach = 0;
        hpoll = s.poll;
        if (p->flags & P_BURST && fit(p))
            p->burst = BCOUNT;
    }
} else {

    /*
     * 如果在突发状态中，则递减计数。
     * 当回复到达时，clock_filter()会调用clock_select()处理突发结果。
     */
    p->burst--;
}
/*
 * 如果是广播客户端模式，则不进行传输。
 */
if (p->hmode != M_BCLN)
    peer_xmit(p);
poll_update(p, hpoll);
}

A.5.7.2.  poll_update()

/*
 * poll_update() - 更新关联p的轮询间隔
 *
 * 注意：此函数由packet()和poll()两个例程调用。
 * 由于packet()在网络包到达时执行，poll()在超时后执行，可能会出现竞态条件，
 * 导致下一次轮询的间隔不正确。但这种情况被认为极不可能发生，可以忽略。
 */
void
poll_update(
        struct p *p,            /* 对等体结构指针 */
        int     poll            /* 轮询间隔（以log2秒为单位） */
        )
{
    /*
     * 该函数由poll()和packet()调用，用于确定下一次轮询时间。
     * 如果在突发状态中，轮询间隔为2秒。
     * 否则，取主机轮询间隔和对等体轮询间隔的较小值，但不超过MAXPOLL，也不低于MINPOLL。
     * 设计确保较长的间隔可以被较短的间隔优先打断，以实现快速响应。
     */
    p->hpoll = max(min(MAXPOLL, poll), MINPOLL);
    if (p->burst > 0) {
        if (p->nextdate != c.t)
            return;
        else
            p->nextdate += BTIME;
    } else {

        /*
         * 虽未在此显示，但参考实现会用一个小因子随机化轮询间隔。
         */
        p->nextdate = p->outdate + (1 << max(min(p->ppoll,
            p->hpoll), MINPOLL));
    }

    /*
     * 可能会出现到期时间已过的情况。若已过，则将其设为未来一秒。
     */
    if (p->nextdate <= c.t)
        p->nextdate = c.t + 1;
}

A.5.7.3.  peer_xmit()

/*
 * transmit() - 传输关联p的数据包
 */
void
peer_xmit(
        struct p *p             /* 对等体结构指针 */
        )
{
    struct x x;             /* 传输数据包 */

    /*
     * 初始化头部和传输时间戳
     */
    x.srcaddr = p->dstaddr;
    x.dstaddr = p->srcaddr;
    x.leap = s.leap;
    x.version = p->version;
    x.mode = p->hmode;
    if (s.stratum == MAXSTRAT)
        x.stratum = 0;
    else
        x.stratum = s.stratum;
    x.poll = p->hpoll;
    x.precision = s.precision;
    x.rootdelay = D2FP(s.rootdelay);
    x.rootdisp = D2FP(s.rootdisp);
    x.refid = s.refid;
    x.reftime = s.reftime;
    x.org = p->org;
    x.rec = p->rec;

    x.xmt = get_time();
    p->xmt = x.xmt;

    /*
     * 如果密钥ID非零，则使用关联的密钥ID和本地密钥缓存中的密钥，发送有效的MAC。
     * 如果出现问题，比如缺少可信密钥，则不发送数据包，重置关联并停止，直到问题解决。
     */
    if (p->keyid)
        if (/* p->keyid 无效 */ 0) {
            clear(p, X_NKEY);
            return;
        }
        x.dgst = md5(p->keyid);
    xmit_packet(&x);
}