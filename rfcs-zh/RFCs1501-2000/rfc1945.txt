# RFC 1945 中文翻译 (stub)
# 原文文件: ../../rfcs/RFCs1501-2000/rfc1945.txt

网络工作组                                     T. 伯恩斯-李
意见征求稿：1945                                       麻省理工学院/实验室
类别：信息性                                              R. 费尔丁
                                                               加州大学欧文分校
                                                              H. 弗赖斯蒂克
                                                                 麻省理工学院/实验室
                                                                1996年5月


                超文本传输协议——HTTP/1.0

本备忘录的状态

   本备忘录为互联网社区提供信息。 本备忘录
   不规定任何类型的互联网标准。 本备忘录的分发
   不受限制。

互联网标准指导组（IESG）说明：

   IESG对该协议表示关切，并预期该文件
   将在不久的将来由一份标准轨道的文件取代。

摘要

   超文本传输协议（HTTP）是一种应用层协议，具有
   分布式、协作式超媒体信息系统所需的轻量级和高速
   特性。它是一种通用的、无状态的、面向对象的协议，
   可以通过扩展其请求方法（命令）用于多种任务，
   例如名称服务器和分布式对象管理系统。HTTP的一个特点
   是数据表示的类型化，允许系统在不依赖于传输数据的
   具体内容的情况下构建。

   自1990年以来，HTTP一直被全球信息网络计划——万维网
   使用。本规范反映了对该协议的常用称呼“HTTP/1.0”的
   一般用法。

目录

   1.  引言 ..............................................  4
       1.1  目的 ..............................................  4
       1.2  术语 ..............................................  4
       1.3  整体操作 ........................................  6
       1.4  HTTP与MIME ........................................  8
   2.  表示法约定与通用语法 ..............................  8
       2.1  增强BNF ...........................................  8
       2.2  基本规则 .......................................... 10
   3.  协议参数 .............................................. 12



伯恩斯-李等人           信息性文档                      [第1页]


RFC 1945                        HTTP/1.0                        1996年5月

3.1  HTTP 版本 ................................................. 12  
3.2  统一资源标识符（URI） .................................... 14  
  3.2.1  一般语法 ........................................... 14  
  3.2.2  HTTP URL ............................................ 15  
3.3  日期/时间格式 ............................................. 15  
3.4  字符集 ..................................................... 17  
3.5  内容编码 ................................................... 18  
3.6  媒体类型 ................................................... 19  
  3.6.1  规范化与文本默认值 ................................. 19  
  3.6.2  多部分类型 ......................................... 20  
3.7  产品标记 ................................................... 20  
4.  HTTP 消息 .................................................. 21  
4.1  消息类型 .................................................. 21  
4.2  消息头字段 ................................................ 22  
4.3  通用头字段 ................................................ 23  
5.  请求 ....................................................... 23  
5.1  请求行 .................................................... 23  
  5.1.1  方法 ............................................... 24  
  5.1.2  请求 URI ........................................... 24  
5.2  请求头字段 ................................................ 25  
6.  响应 ....................................................... 25  
6.1  状态行 .................................................... 26  
  6.1.1  状态码与原因短语 .................................. 26  
6.2  响应头字段 ................................................ 28  
7.  实体 ....................................................... 28  
7.1  实体头字段 ................................................ 29  
7.2  实体正文 .................................................. 29  
  7.2.1  类型 ............................................... 29  
  7.2.2  长度 ............................................... 30  
8.  方法定义 ................................................... 30  
8.1  GET ....................................................... 31  
8.2  HEAD ...................................................... 31  
8.3  POST ...................................................... 31  
9.  状态码定义 .................................................. 32  
9.1  信息性 1xx ............................................... 32  
9.2  成功 2xx .................................................. 32  
9.3  重定向 3xx ................................................ 34  
9.4  客户端错误 4xx ............................................ 35  
9.5  服务器错误 5xx ............................................ 37  
10. 头字段定义 ................................................. 37  
10.1  允许 .................................................... 38  
10.2  授权 .................................................... 38  
10.3  内容编码 .................................................

....... 39
       10.4  内容长度 .......................................... 39
       10.5  内容类型 .......................................... 40
       10.6  日期 .............................................. 40
       10.7  过期时间 .......................................... 41
       10.8  发件人 ............................................ 42

伯纳斯-李等人           信息性文档                      [第2页]

RFC 1945                        HTTP/1.0                        1996年5月

10.9  If-Modified-Since ................................... 42  
10.10 Last-Modified ....................................... 43  
10.11 Location ............................................ 44  
10.12 Pragma .............................................. 44  
10.13 Referer ............................................. 44  
10.14 Server .............................................. 45  
10.15 User-Agent .......................................... 46  
10.16 WWW-Authenticate .................................... 46  

11. 访问认证 .............................................. 47  
11.1 基本认证方案 ........................................ 48  

12. 安全考虑 .............................................. 49  
12.1 客户端认证 .......................................... 49  
12.2 安全方法 ............................................ 49  
12.3 滥用服务器日志信息 .................................. 50  
12.4 敏感信息传输 ........................................ 50  
12.5 基于文件名和路径名的攻击 ............................ 51  

13. 致谢 .................................................. 51  
14. 参考文献 .............................................. 52  
15. 作者联系方式 .......................................... 54  

附录A. 互联网媒体类型 message/http .................... 55  
附录B. 宽容性应用 ........................................ 55  
附录C. 与MIME的关系 ...................................... 56  
  C.1 转换为规范形式 .................................... 56  
  C.2 日期格式的转换 .................................... 57  
  C.3 引入内容编码 ........................................ 57  
  C.4 无内容传输编码 ...................................... 57  
  C.5 多部分正文中的HTTP头字段 ............................ 57  

附录D. 附加功能 .......................................... 57  
  D.1 附加请求方法 ........................................ 58  
    D.1.1 PUT ............................................... 58  
    D.1.2 DELETE ............................................ 58  
    D.1.3 LINK .............................................. 58  
    D.1.4 UNLINK ............................................ 58  
  D.2 附加头字段定义 ...................................... 58  
    D.2.1 Accept ............................................ 58  
    D.2.2 Accept-Charset .................................... 59  
    D.2.3 Accept-Encoding ................................... 59  
    D.2.4 Accept-Language ................................... 59  
    D.2.5 Content-Language .................................. 59  
    D.2.6 Link .............................................. 59  
    D.2.7 MIME-Version ...................................... 59  
    D.2.8 Retry-After ....................................... 60  
    D.2.9 Title .............................................

....... 60
            D.2.10 URI ........................................... 60

伯恩斯-李等人           信息性文档                      [第3页]


RFC 1945                        HTTP/1.0                        1996年5月


1. 引言

1.1  目的

超文本传输协议（HTTP）是一种应用层协议，具有分布式、协作式、超媒体信息系统所需的轻量性和高速性。自1990年以来，HTTP一直被全球信息网络计划——万维网所使用。本规范反映了被广泛采用的“HTTP/1.0”协议的通用用法。本文档描述了在大多数HTTP/1.0客户端和服务器中似乎被一致实现的功能。规范分为两个部分：主要部分描述了实现通常一致的HTTP功能；附录D列出了实现较少或不一致的功能。

实际的信息系统需要比简单检索更多的功能，包括搜索、前端更新和注释等。HTTP允许使用一组开放式的方法来指示请求的目的。它基于统一资源标识符（URI）[2]提供的规范性，URI可以作为位置（URL）[4]或名称（URN）[16]，用以指示要应用方法的资源。消息的传递格式类似于互联网邮件[7]和多用途互联网邮件扩展（MIME）[5]所使用的格式。

HTTP还被用作用户代理与代理/网关之间的通用通信协议，连接其他互联网协议，如SMTP[12]、NNTP[11]、FTP[14]、Gopher[1]和WAIS[8]，实现对多样化应用中资源的基本超媒体访问，并简化用户代理的实现。

1.2  术语

本规范使用一些术语来指代在HTTP通信中参与者的角色和对象。

连接（connection）

    在两个应用程序之间建立的传输层虚拟电路，用于通信。

消息（message）

    HTTP通信的基本单位，由一系列结构化的八位字节组成，符合第4节定义的语法，并通过连接传输。

请求（request）

    HTTP请求消息（定义见第5节）。

响应（response）

    HTTP响应消息（定义见第6节）。

资源（resource）

    可以通过URI（第3.2节）识别的网络数据对象或服务。

实体（entity）

以下是英文内容的中文翻译：

```
       数据资源的特定表示或呈现，或来自服务资源的响应，可以包含在请求或响应消息中。实体由实体头部的元信息和实体主体的内容组成。

   客户端

       一个建立连接以便发送请求的应用程序。

   用户代理

       发起请求的客户端。这些通常是浏览器、编辑器、爬虫（网页遍历机器人）或其他终端用户工具。

   服务器

       一个接受连接的应用程序，通过发送响应来处理请求。

   源服务器

       存放或将要创建特定资源的服务器。

   代理

       一个中间程序，既充当服务器又充当客户端，代表其他客户端发出请求。请求可以在内部处理，或通过转发（可能伴随转换）传递给其他服务器。代理必须在转发请求之前解释并（如有必要）重写请求消息。

   网关

       作为其他服务器中介的服务器。与代理不同，网关接收请求时，表现得就像是请求资源的源服务器；请求的客户端可能不知道它正在与网关通信。网关常用作通过网络防火墙的服务器端门户，以及作为协议转换器，用于访问存储在非HTTP系统上的资源。

   隧道

       一个中间程序，作为两个连接之间的盲转发中继。一旦激活，隧道不再被视为HTTP通信的一方，尽管隧道可能由HTTP请求启动。当两个中继连接的端点都关闭时，隧道就不存在了。隧道在需要门户且中间方不能或不应解释中继通信时使用。

   缓存

       程序的本地存储，用于存放响应消息，以及控制消息存储、检索和删除的子系统。缓存存储可缓存的响应，以减少未来相同请求的响应时间和网络带宽消耗。任何客户端或服务器都可以包含缓存，但在作为隧道时，服务器不能使用缓存。
```

任何给定的程序都可能同时充当客户端和服务器；我们使用这些术语仅指程序在特定连接中所扮演的角色，而非程序的整体功能。同样，任何服务器都可以作为源服务器、代理、网关或隧道，根据每个请求的性质切换其行为。

1.3 整体操作

HTTP协议基于请求/响应的范式。客户端与服务器建立连接，并以请求方法、URI和协议版本的形式向服务器发送请求，随后附带一个类似MIME的消息，包含请求修饰符、客户端信息以及可能的正文内容。服务器则以状态行作出响应，状态行包括消息的协议版本和成功或错误代码，接着是一个类似MIME的消息，包含服务器信息、实体元信息以及可能的正文内容。

大多数HTTP通信由用户代理发起，内容是对某个源服务器上资源的请求。最简单的情况是通过单一连接（v）实现的，即用户代理（UA）与源服务器（O）之间的连接。

          请求链 ------------------------>
       UA -------------------v------------------- O
          <----------------------- 响应链

当请求/响应链中存在一个或多个中间人时，情况会变得更复杂。常见的中间人类型有三种：代理、网关和隧道。代理是一个转发代理，接收针对其绝对URI的请求，重写请求的全部或部分内容，然后将重写后的请求转发到由URI标识的服务器。网关是一个接收代理，作为某些其他服务器之上的一层，如果必要，还会将请求转换为底层服务器的协议。隧道则作为两个连接之间的中继点，不改变消息内容；当通信需要通过中间人（如防火墙）传递，即使中间人无法理解消息内容，也会使用隧道。

上图显示了用户代理（User Agent）与源服务器（Origin Server）之间的三个中间实体（A、B 和 C）。一条请求或响应消息在整个链路上传输时，必须经过四个不同的连接。这一区分非常重要，因为某些HTTP通信选项可能只适用于与最近的非隧道邻居的连接、链路的端点，或适用于链路上的所有连接。虽然图中呈线性，但每个参与者可能同时参与多条通信。例如，B 可能同时接收来自除 A 之外的许多客户端的请求，或将请求转发给除 C 之外的其他服务器，同时处理 A 的请求。

任何非作为隧道的通信方都可以使用内部缓存来处理请求。缓存的作用在于，如果链路上的某个参与者拥有适用于该请求的缓存响应，则可以缩短请求/响应链。以下示意了如果 B 拥有来自 O（通过 C）的早期响应的缓存副本，而该请求未被 UA 或 A 缓存时，所形成的链路：

请求链 ---------->
UA -----v----- A -----v----- B - - - - - - C - - - - - - O
<--------- 响应链

并非所有响应都可以被缓存，一些请求可能包含特殊的修饰符，对缓存行为提出特殊要求。一些HTTP/1.0应用程序使用启发式方法来描述什么是“可缓存”的响应，但这些规则并未标准化。

在互联网中，HTTP通信通常通过TCP/IP连接进行。默认端口是TCP 80 [15]，但也可以使用其他端口。这并不排除在互联网或其他网络上，HTTP可以在任何其他协议之上实现。HTTP只假设传输是可靠的；任何提供此类保证的协议都可以使用，而将HTTP/1.0请求和响应结构映射到所用协议的传输数据单元的具体方式超出了本规范的范围。

除实验性应用外，当前的做法要求在每次请求前由客户端建立连接，响应后由服务器关闭连接。客户端和服务器都应意识到，任何一方都可能因用户操作、自动超时或程序故障而提前关闭连接，并应以可预测的方式处理这种关闭。无论由哪一方或双方关闭连接，都将终止当前请求，无论其状态如何。

1.4  HTTP与MIME

HTTP/1.0 使用了许多在 RFC 1521 [5] 中定义的 MIME 构造。附录 C 描述了 HTTP 的上下文如何允许对互联网媒体类型的不同使用方式，这些方式与互联网邮件中通常的用法不同，并提供了这些差异的理由。

2. 表示法约定与通用语法

2.1 增强的巴克斯-诺尔范式（BNF）

本文件中所有的机制都用文字说明和一种类似于 RFC 822 [7] 所用的增强型巴克斯-诺尔范式（BNF）进行描述。实现者需要熟悉这种符号表示，以便理解本规范。增强的BNF包括以下构造：

name = 定义

- 规则的名称就是该名称本身（不包括任何包围的“<”和“>”），并用等号“=”与其定义分隔。空白字符的作用仅在于，续行的缩进用来表示一个规则定义跨多行。某些基本规则用大写字母表示，例如 SP（空格）、LWS（空白字符）、HT（水平制表符）、CRLF（回车换行）、DIGIT（数字）、ALPHA（字母）等。在定义中，角括号的使用可以帮助识别规则名称的用途。

- “literal” （字面值）

用引号括起的文本为字面值。除非另有说明，否则文本不区分大小写。

- rule1 | rule2 （规则1 | 规则2）

用竖线（“|”）分隔的元素表示备选项，例如，“yes | no” 表示接受“yes”或“no”。

- (rule1 rule2) （规则1 规则2）

用括号括起来的元素视为一个整体。因此，"(elem (foo | bar) elem)" 允许的标记序列有“elem foo elem”和“elem bar elem”。

- *rule （星号规则）

前置的“*”字符表示重复。完整形式为“<n>*<m>元素”，表示元素至少出现<n>次，最多<m>次。默认值为0和无限大，因此“*(元素)”允许任何次数（包括零）；“1*元素”表示至少一次；“1*2元素”表示一次或两次。

- [rule] （方括号规则）

方括号内的元素为可选项；例如，“[foo bar]”等价于“*1(foo bar)”。

- N rule （特定重复次数规则）

特定重复次数："<n>(元素)"等价于"<n>*<n>(元素)"，即元素恰好出现<n>次。例如，2DIGIT 表示两位数字，3ALPHA 表示三个字母字符。

定义了一个符号“#”，类似于“*”，用于定义元素列表。其完整形式为“<n>#<m>element”，表示元素的数量至少为<n>，最多为<m>，每个元素之间用一个或多个逗号（“,”）和可选的线性空白（LWS）分隔。这使得列表的常用形式非常简便；例如，可以用规则“( *LWS element *( *LWS "," *LWS element ))”表示为“1#element”。在使用此结构时，允许空元素，但空元素不计入元素总数。也就是说，像“(element), , (element)”是允许的，但只算作两个元素。因此，当至少需要一个元素时，必须至少有一个非空元素。默认值为0和无穷大，因此“#(element)”允许任何数量的元素，包括零；“1#element”要求至少一个元素；而“1#2element”允许一到两个元素。

；注释

半角分号（“;”）在规则文本的右侧一定距离处开始，直到行尾为止，表示一段注释。这是一种在规范中加入有用说明的简便方式。

隐含的*LWS

本规范描述的语法是基于词的。除非另有说明，线性空白（LWS）可以在任何两个相邻的词（标记或引号字符串）之间，以及在相邻的标记和分隔符（tspecials）之间插入，而不会改变字段的解释。在任何两个标记之间，必须至少有一个分隔符（tspecials），否则它们会被解释为单一的标记。然而，应用程序在生成HTTP结构时应尽量遵循“常用形式”，因为存在一些实现不能接受超出常用形式的内容。

2.2 基本规则

以下规则在整个规范中用于描述基本的解析结构。US-ASCII字符集由[17]定义。

- OCTET = <任何8位数据序列>
- CHAR = <任何US-ASCII字符（0-127的八位字节）>
- UPALPHA = <任何US-ASCII大写字母“A”到“Z”>
- LOALPHA = <任何US-ASCII小写字母“a”到“z”>

Berners-Lee 等人，信息性文档 [第10页]

RFC 1945 HTTP/1.0 1996年5月

- ALPHA = UPALPHA | LOALPHA
- DIGIT = <任何US-ASCII数字“0”到“9”>
- CTL = <任何US-ASCII控制字符（0-31的八位字节）以及DEL（127）>
- CR = <US-ASCII回车符（13）>
- LF = <US-ASCII换行符（10）>
- SP = <US-ASCII空格（32）>
- HT = <US-ASCII水平制表符（9）>
- “"” = <US-ASCII双引号（34）>

HTTP/1.0定义了八个字节序列CR LF作为所有协议元素（除实体主体外）的行结束标志（有关容错应用，请参见附录B）。实体主体内的行结束标志由其相关的媒体类型定义，如第3.6节所述。

       CRLF           = CR LF

HTTP/1.0的头字段可以折叠成多行，只要每个续行以空格或水平制表符开头。所有线性空白字符，包括折叠，具有与空格相同的语义。

       LWS            = [CRLF] 1*( SP | HT )

然而，一些应用程序不期望头字段行的折叠，也不应由HTTP/1.0应用程序生成。

TEXT规则仅用于描述性字段内容和不打算由消息解析器解释的值。*TEXT中的单词可能包含除US-ASCII之外的字符集的字节。

       TEXT           = <任何非控制字符（CTL）的字节，但包括空白符LWS>

接收包含超出US-ASCII字符集的字节的头字段TEXT的接收方，可以假设它们代表ISO-8859-1字符。

在多个协议元素中使用十六进制数字字符。

       HEX            = "A" | "B" | "C" | "D" | "E" | "F"
                      | "a" | "b" | "c" | "d" | "e" | "f" | DIGIT

许多HTTP/1.0头字段值由由空白符或特殊字符分隔的单词组成。这些特殊字符必须用引号括起来，才能在参数值中使用。

       word           = token | quoted-string

Berners-Lee等人，信息性文档 [第11页]

RFC 1945                        HTTP/1.0                        1996年5月

在HTTP头字段中，包含超出US-ASCII字符集的字节的TEXT字段的接收方可以假设它们代表ISO-8859-1字符。

在多个协议元素中使用十六进制数字字符。

       HEX            = "A" | "B" | "C" | "D" | "E" | "F"
                      | "a" | "b" | "c" | "d" | "e" | "f" | DIGIT

许多HTTP/1.0头字段值由由空白符或特殊字符分隔的单词组成。这些特殊字符必须用引号括起来，才能在参数值中使用。

       word           = token | quoted-string

       token          = 1*<任何非CTL字符或tspecials字符>

       tspecials      = "(" | ")" | "<" | ">" | "@"
                      | "," | ";" | ":" | "\" | <">
                      | "/" | "[" | "]" | "?" | "="
                      | "{" | "}" | SP | HT

某些HTTP头字段可以通过用括号括起评论文本来包含评论。评论仅允许出现在包含“comment”字段值定义的字段中。在所有其他字段中，括号被视为字段值的一部分。

       comment        = "(" *( ctext | comment ) ")"
       ctext          = <任何TEXT，排除"("和")">

如果用双引号括起一段文本，则该文本被解析为单个单词。

       quoted-string  = ( <"> *(qdtext) <"> )

       qdtext         = <任何CHAR，排除<">和CTL字符，但包括LWS>

在HTTP/1.0中，不允许使用反斜杠（"\"）字符进行单字符转义。

3.  协议参数

3.1  HTTP版本

HTTP 使用 "<主版本>.<次版本>" 的编号方案来指示协议的版本。协议版本控制政策旨在允许发送方指示消息的格式及其理解后续 HTTP 通信的能力，而不是通过该通信获得的功能。对于不影响通信行为或仅增加可扩展字段值的消息组件的添加，不会更改版本号。当协议的更改添加了不会改变一般消息解析算法但可能增加消息语义并暗示发送方额外能力的功能时，<次版本>号会递增。当协议中消息的格式发生变化时，<主版本>号会递增。

HTTP 消息的版本由消息第一行中的 HTTP-Version 字段指示。如果未指定协议版本，接收方必须假设该消息采用简单的 HTTP/0.9 格式。

HTTP-Version 的格式为：
```
HTTP-Version = "HTTP" "/" 1*DIGIT "." 1*DIGIT
```
请注意，主版本号和次版本号应作为单独的整数处理，每个可能超过一位数。因此，HTTP/2.4 的版本低于 HTTP/2.13，而 HTTP/2.13 又低于 HTTP/12.3。接收方应忽略前导零，发送方也不应生成带有前导零的版本号。

本文档定义了 HTTP 协议的 0.9 和 1.0 版本。根据本规范，发送完整请求（Full-Request）或完整响应（Full-Response）消息的应用程序必须在 HTTP-Version 字段中包含 "HTTP/1.0"。

HTTP/1.0 服务器必须：

- 识别 HTTP/0.9 和 HTTP/1.0 请求的请求行（Request-Line）格式；
- 理解任何符合 HTTP/0.9 或 HTTP/1.0 格式的有效请求；
- 使用客户端所用的相同协议版本，适当地响应消息。

HTTP/1.0 客户端必须：

- 识别 HTTP/1.0 响应的状态行（Status-Line）格式；
- 理解任何符合 HTTP/0.9 或 HTTP/1.0 格式的有效响应。

代理和网关应用程序在转发接收到的请求时必须格外小心，尤其是当请求的格式与应用程序的原生HTTP版本不同。由于协议版本指示了发送方的协议能力，代理/网关绝不能发送版本号大于其自身原生版本的消息；如果收到的请求版本高于自身的版本，代理/网关必须要么将请求的版本降级，要么返回错误响应。版本低于应用程序原生格式的请求可以在转发前进行升级；对于此类请求，代理/网关的响应必须符合上述服务器的要求。

伯恩斯-李等人，信息性文档 [第13页]

RFC 1945 HTTP/1.0 1996年5月

3.2 统一资源标识符（URI）

URI（统一资源标识符）曾被称为多种名称：WWW地址、通用文档标识符、通用资源标识符 [2]，以及最终的统一资源定位符（URL） [4] 和名称（URN） [16] 的组合。就HTTP而言，统一资源标识符仅仅是格式化的字符串，用于通过名称、位置或其他特征标识网络资源。

3.2.1 一般语法

在HTTP中，URI可以用绝对形式或相对于某个已知基础URI的相对形式表示，具体取决于其使用的上下文。这两种形式的区别在于，绝对URI总是以方案名（scheme）开头，后跟冒号。

```
URI            = ( absoluteURI | relativeURI ) [ "#" fragment ]

absoluteURI    = scheme ":" *( uchar | reserved )

relativeURI    = net_path | abs_path | rel_path

net_path       = "//" net_loc [ abs_path ]
abs_path       = "/" rel_path
rel_path       = [ path ] [ ";" params ] [ "?" query ]

path           = fsegment *( "/" segment )
fsegment       = 1*pchar
segment        = *pchar

params         = param *( ";" param )
param          = *( pchar | "/" )

scheme         = 1*( ALPHA | DIGIT | "+" | "-" | "." )
net_loc        = *( pchar | ";" | "?" )
query          = *( uchar | reserved )
fragment       = *( uchar | reserved )

pchar          = uchar | ":" | "@" | "&" | "=" | "+"
uchar          = unreserved | escape
unreserved     = ALPHA | DIGIT | safe | extra | national

escape         = "%" HEX HEX
reserved       = ";" | "/" | "?" | ":" | "@" | "&" | "=" | "+"
extra          = "!" | "*" | "'" | "(" | ")" | ","
safe           = "$" | "-" | "_" | "."
unsafe         = CTL | SP | <"> | "#" | "%" | "<" | ">"
national       = <any OCTET excluding ALPHA, DIGIT, ...
```

以下是英文内容的中文翻译：

```
                        保留字符、额外字符、安全字符和不安全字符

有关URL语法和语义的权威信息，请参阅RFC 1738 [4]和RFC 1808 [9]。上述BNF（巴克斯-诺尔范式）包括一些在RFC 1738规定的有效URL中不允许的国家字符，因为HTTP服务器在表示地址的rel_path部分时不限制未保留字符的集合，而且HTTP代理可能会接收不由RFC 1738定义的URI请求。

3.2.2 http URL

   "http"方案用于通过HTTP协议定位网络资源。本节定义了http URL的方案特定语法和语义。

       http_URL       = "http:" "//" host [ ":" port ] [ abs_path ]

       host           = <合法的互联网主机域名或IP地址（点十进制形式），
                         如RFC 1123第2.1节所定义>

       port           = *DIGIT

   如果未指定端口或端口为空，则默认为端口80。其语义是，所标识的资源位于监听该主机的TCP端口的服务器上，资源的请求URI为abs_path。如果URL中没有提供abs_path，则在用作请求URI时必须写为“/”（第5.1.2节）。

      注意：虽然HTTP协议与传输层协议无关，但HTTP URL仅通过其TCP位置标识资源，因此非TCP资源必须通过其他URI方案进行标识。

   "http" URL的规范形式是将host中的任何UPALPHA字符转换为对应的LOALPHA字符（主机名不区分大小写），如果端口为80则省略“：端口”，并用“/”替换空的abs_path。

3.3  日期/时间格式

   HTTP/1.0应用程序历来允许用三种不同的格式表示日期/时间戳：

       Sun, 06 Nov 1994 08:49:37 GMT    ; RFC 822，RFC 1123更新
       Sunday, 06-Nov-94 08:49:37 GMT   ; RFC 850，已被RFC 1036废止
       Sun Nov  6 08:49:37 1994         ; ANSI C的asctime()格式

   第一种格式被优先作为互联网标准，代表RFC 1123（对RFC 822的更新）定义的固定长度子集。第二种格式虽然常用，但基于已废止的RFC 850日期格式，且年份为两位数。解析日期值的HTTP/1.0客户端和服务器应接受这三种格式，但它们绝不能生成第三种（asctime）格式。
```

注意：建议接收日期值的用户在接受可能由非HTTP应用程序生成的日期值时要保持弹性，因为在通过代理/网关向SMTP或NNTP检索或发布消息时，可能会遇到这种情况。

所有HTTP/1.0的日期/时间戳都必须以协调世界时（UT），也称格林威治标准时间（GMT）表示，且不得例外。在前两个格式中，这一点通过包含“GMT”作为时区的三字母缩写来表示，阅读asctime格式时也应假定为GMT。

HTTP日期格式定义为：
```
HTTP-date = rfc1123-date | rfc850-date | asctime-date
```

具体格式如下：
```
rfc1123-date = wkday "," SP date1 SP time SP "GMT"
rfc850-date  = weekday "," SP date2 SP time SP "GMT"
asctime-date = wkday SP date3 SP time SP 4DIGIT
```

日期部分的定义：
```
date1 = 2DIGIT SP month SP 4DIGIT
        ; 日 月 年，例如：02 Jun 1982
date2 = 2DIGIT "-" month "-" 2DIGIT
        ; 日-月-年，例如：02-Jun-82
date3 = month SP ( 2DIGIT | ( SP 1DIGIT ))
        ; 月 日，例如：Jun  2
```

时间部分的定义：
```
time = 2DIGIT ":" 2DIGIT ":" 2DIGIT
        ; 时间范围：00:00:00 到 23:59:59
```

星期几的缩写：
```
wkday = "Mon" | "Tue" | "Wed" | "Thu" | "Fri" | "Sat" | "Sun"
```

完整星期的名称：
```
weekday = "Monday" | "Tuesday" | "Wednesday" | "Thursday" | "Friday" | "Saturday" | "Sunday"
```

月份的缩写：
```
month = "Jan" | "Feb" | "Mar" | "Apr" | "May" | "Jun" | "Jul" | "Aug" | "Sep" | "Oct" | "Nov" | "Dec"
```

注意：HTTP对日期/时间戳格式的要求仅适用于协议流中的使用。客户端和服务器在用户展示、请求日志等方面并不必须使用这些格式。

---

Berners-Lee 等人，信息性文档，[第16页]

RFC 1945，HTTP/1.0，1996年5月

---

3.4 字符集

HTTP使用的“字符集”定义与MIME中描述的定义相同：

在本文档中，“字符集”一词指的是一种方法，该方法结合一个或多个表，将一系列八位字节转换为一系列字符。请注意，反向的无条件转换并非必须，因为并非所有字符都在某个特定字符集中可用，而且一个字符集可能为某一特定字符提供不止一种八位字节序列表示方式。此定义旨在涵盖各种字符编码方式，从简单的单表映射（如US-ASCII）到复杂的表切换方法（如使用ISO 2022技术的方法）。然而，必须完全指定从八位字节到字符的映射关系，不能依赖外部配置文件或信息来确定确切的映射。

注意：这里所用的“字符集”一词更常被称为“字符编码”。但由于HTTP和MIME共享同一注册表，为了保持术语一致，仍使用“字符集”。

HTTP中的字符集由不区分大小写的标记（token）标识。完整的标记集由IANA字符集注册表[15]定义。然而，由于该注册表未为每个字符集定义统一的标记，我们在此定义了最常用于HTTP实体的字符集的首选名称。这些字符集包括由RFC 1521[5]注册的字符集——如US-ASCII[17]和ISO-8859[18]——以及专门推荐用于MIME字符集参数的其他名称。

字符集的定义格式如下：
```
charset = "US-ASCII"
        | "ISO-8859-1" | "ISO-8859-2" | "ISO-8859-3"
        | "ISO-8859-4" | "ISO-8859-5" | "ISO-8859-6"
        | "ISO-8859-7" | "ISO-8859-8" | "ISO-8859-9"
        | "ISO-2022-JP" | "ISO-2022-JP-2" | "ISO-2022-KR"
        | "UNICODE-1-1" | "UNICODE-1-1-UTF-7" | "UNICODE-1-1-UTF-8"
        | token
```

虽然HTTP允许使用任意标记作为字符集值，但任何在IANA字符集注册表[15]中已有预定义值的标记，必须代表该注册表中定义的字符集。应用程序应限制其字符集的使用范围在IANA注册表中定义的字符集之内。

实体正文的字符集应标记为该正文中所用字符编码的最低公分母，但不应优先于US-ASCII或ISO-8859-1标签。

内容编码值用于指示已应用于资源的编码转换。内容编码主要用于允许对文档进行压缩或加密，而不会失去其底层媒体类型的身份。通常，资源会以这种编码存储，只有在渲染或类似用途之前才进行解码。

       content-coding = "x-gzip" | "x-compress" | token

       注意：为了未来的兼容性，HTTP/1.0应用程序应将“gzip”和“compress”视为等同于“x-gzip”和“x-compress”。

所有内容编码值都不区分大小写。HTTP/1.0在Content-Encoding（第10.3节）头字段中使用内容编码值。虽然该值描述了内容编码，但更重要的是它指示了解码机制，以便去除编码。请注意，一个程序可能能够解码多种内容编码格式。本规范定义了两个值：

x-gzip
    由“gzip”文件压缩程序（GNU zip）生成的编码格式，由Jean-loup Gailly开发。该格式通常是采用带有32位CRC的Lempel-Ziv编码（LZ77）。

x-compress
    由“compress”文件压缩程序生成的编码格式。这是一种自适应的Lempel-Ziv-Welch编码（LZW）。

注意：使用程序名称来识别编码格式是不理想的，未来应避免这样做。这里的用法仅代表历史实践，而非良好的设计。

---

Berners-Lee 等人，信息性文档 [第18页]

RFC 1945 HTTP/1.0 1996年5月

3.6 媒体类型

HTTP在Content-Type头字段（第10.5节）中使用互联网媒体类型 [13]，以提供开放且可扩展的数据类型定义。

       media-type     = type "/" subtype *( ";" parameter )
       type           = token
       subtype        = token

参数可以跟在类型/子类型之后，以属性/值对的形式出现。

       parameter      = attribute "=" value
       attribute      = token
       value          = token | quoted-string

类型、子类型和参数属性名不区分大小写。参数值可能区分或不区分大小写，取决于参数名的语义。在类型和子类型之间，以及属性与其值之间，不应生成空白字符（LWS）。当接收到带有未识别参数的媒体类型时，用户代理应将其视为未包含该未识别参数及其值。

一些较旧的HTTP应用程序不识别媒体类型参数。HTTP/1.0应用程序应仅在必要时使用媒体类型参数来定义消息的内容。

媒体类型的值由互联网号码注册局（IANA [15]）进行注册。媒体类型的注册流程在RFC 1590 [13]中有所说明。不建议使用未注册的媒体类型。

3.6.1 规范化与文本默认值

互联网媒体类型必须以规范形式注册。通常，经过HTTP传输的实体主体（Entity-Body）在传输前必须以相应的规范形式表示。如果主体已使用Content-Encoding进行了编码，则在编码之前，底层数据应为规范形式。

“text”类型的媒体子类型在规范形式下使用CRLF作为文本行的换行符。然而，HTTP允许在传输纯CR或LF作为换行符的文本媒体中，只要在实体主体中一致使用即可。HTTP应用程序必须接受CRLF、纯CR和纯LF作为HTTP传输的文本媒体中换行符的代表。

此外，如果文本媒体采用的字符集不使用字节13（CR）和10（LF）作为换行符（例如某些多字节字符集），HTTP允许使用该字符集定义的任何字节序列来表示换行符的等价物。关于换行符的这种灵活性仅适用于实体主体中的文本媒体；在任何HTTP控制结构（如头字段和多部分边界）中，不应用纯CR或LF替代CRLF。

“charset”参数用于某些媒体类型，定义数据的字符集（第3.4节）。当发送方未明确提供charset参数时，定义“text”类型的媒体子类型在通过HTTP接收时，默认字符集为“ISO-8859-1”。使用除“ISO-8859-1”及其子集之外的字符集的数据，必须用适当的charset值标注，以确保接收方能正确解释。

注意：许多现有的HTTP服务器在未正确标注的情况下，使用除“ISO-8859-1”之外的字符集提供数据。这种情况降低了互操作性，不推荐这样做。为此，一些HTTP用户代理提供配置选项，允许用户在未提供charset参数时，改变默认的媒体类型字符集解释。

3.6.2 多部分类型

MIME定义了多种“多部分”类型——在单个消息的实体主体中封装多个实体。由IANA注册的多部分类型[15]在HTTP/1.0中没有特殊含义，尽管用户代理可能需要理解每种类型，以正确解释每个主体部分的用途。HTTP用户代理在接收多部分类型时，应遵循与MIME用户代理类似的行为。HTTP服务器不应假设所有HTTP客户端都已准备好处理多部分类型。

所有多部分类型共享共同的语法，必须在媒体类型值中包含一个boundary参数。消息体本身是一个协议元素，因此只能使用CRLF（回车换行）来表示主体部分之间的换行。多部分主体可能包含对该部分意义重要的HTTP头字段。

3.7 产品标记

产品标记用于允许通信应用程序通过一个简单的产品标记（可选的斜杠和版本标识符）来识别自己。大多数使用产品标记的字段也允许列出子产品，这些子产品构成应用程序的重要部分，用空白字符分隔。按照惯例，产品按其在识别应用程序中的重要性顺序列出。

       product         = token ["/" product-version]
       product-version = token

示例：

       User-Agent: CERN-LineMode/2.15 libwww/2.17b3

       Server: Apache/0.8.4

产品标记应简洁明了——明确禁止将其用于广告或其他非必要信息。虽然任何标记字符都可以出现在产品版本中，但该标记应仅用于版本标识（即，同一产品的连续版本应仅在产品版本部分有所不同）。

4.  HTTP消息

4.1 消息类型

HTTP消息由客户端请求和服务器响应组成。

       HTTP-message   = 简单请求（Simple-Request）           ; HTTP/0.9消息
                      | 简单响应（Simple-Response）
                      | 完整请求（Full-Request）             ; HTTP/1.0消息
                      | 完整响应（Full-Response）

完整请求和完整响应采用RFC 822 [7]的通用消息格式传输实体。两者都可以包含可选的头字段（也称为“头部”）和实体主体。实体主体与头部之间由空行（即没有任何内容的行，只有CRLF）分隔。

完整请求（Full-Request） = 请求行（Request-Line） ; 第5.1节
                        *( 通用首部（General-Header） ; 第4.3节
                         | 请求首部（Request-Header） ; 第5.2节
                         | 实体首部（Entity-Header） ) ; 第7.1节
                        回车换行（CRLF）
                        [ 实体主体（Entity-Body） ] ; 第7.2节

完整响应（Full-Response） = 状态行（Status-Line） ; 第6.1节
                        *( 通用首部（General-Header） ; 第4.3节
                         | 响应首部（Response-Header） ; 第6.2节
                         | 实体首部（Entity-Header） ; 第7.1节
                        CRLF
                        [ 实体主体（Entity-Body） ] ; 第7.2节

伯纳斯-李等人（Berners-Lee, et al）  信息性（Informational） [第21页]

RFC 1945                        HTTP/1.0                        1996年5月

简易请求（Simple-Request）和简易响应（Simple-Response）不允许使用任何首部信息，并且仅限于单一请求方法（GET）。

简易请求（Simple-Request） = "GET" SP 请求URI（Request-URI） CRLF

简易响应（Simple-Response） = [ 实体主体（Entity-Body） ]

不建议使用简易请求格式，因为它阻止服务器识别返回实体的媒体类型。

4.2  消息首部（Message Headers）

HTTP首部字段，包括通用首部（Section 4.3）、请求首部（Section 5.2）、响应首部（Section 6.2）和实体首部（Section 7.1），遵循与RFC 822第3.1节中所述相同的通用格式。每个首部字段由字段名（field-name）紧跟一个冒号（":"）、一个空格（SP）字符和字段值（field-value）组成。字段名不区分大小写。首部字段可以通过在每个额外行前加至少一个空格或水平制表符（HT）来扩展多行，但不推荐这样做。

HTTP首部格式 = 字段名（field-name） ":" [ 字段值（field-value） ] CRLF

字段名（field-name） = 令牌（token）
字段值（field-value） = *( 字段内容（field-content） | 空白字符（LWS） )

字段内容（field-content） = <组成字段值的字节（OCTETs），由文本（TEXT）或令牌（token）、特殊字符（tspecials）和引号字符串（quoted-string）组合而成>

接收首部字段的顺序没有强制要求。然而，"良好的实践"是先发送通用首部字段，然后是请求首部或响应首部字段，最后是实体首部字段。

如果消息中存在多个具有相同字段名的HTTP首部字段，则只有当该字段的全部字段值（field-value）被定义为逗号分隔的列表（即 #(values)）时，才允许出现多个相同字段名的首部字段。必须能够将多个首部字段合并成一个"字段名：字段值"对，而不改变消息的语义，即通过在第一个字段值后依次添加每个后续字段值（用逗号分隔）来实现。

4.3 一般头字段

有一些头字段在请求和响应消息中具有通用适用性，但不适用于被传输的实体。这些头字段仅适用于正在传输的消息。

       General-Header = Date                     ; 第10.6节
                      | Pragma                   ; 第10.12节

一般头字段的字段名只能在协议版本变更的情况下可靠地扩展。然而，如果通信中的所有参与方都认可某些新或实验性的头字段具有一般头字段的语义，则可以赋予它们相应的含义。未被识别的头字段将被视为实体头字段。

5. 请求

客户端向服务器发出的请求消息在第一行中包含要对资源应用的方法、资源的标识符以及所使用的协议版本。为了与功能较有限的HTTP/0.9协议保持向后兼容，HTTP请求有两种有效格式：

       Request        = Simple-Request | Full-Request

       Simple-Request = "GET" SP Request-URI CRLF

       Full-Request   = Request-Line             ; 第5.1节
                        *( General-Header        ; 第4.3节
                         | Request-Header        ; 第5.2节
                         | Entity-Header )       ; 第7.1节
                        CRLF
                        [ Entity-Body ]          ; 第7.2节

如果HTTP/1.0服务器收到一个Simple-Request，它必须用HTTP/0.9的Simple-Response进行响应。能够接收Full-Response的HTTP/1.0客户端不应生成Simple-Request。

5.1 请求行

请求行以方法标记开始，后跟请求URI和协议版本，以CRLF结束。各元素之间用空格字符（SP）分隔。除了最后的CRLF序列外，不允许出现CR或LF。

       Request-Line = Method SP Request-URI SP HTTP-Version CRLF

请注意，Simple-Request与Full-Request的请求行的区别在于是否包含HTTP-Version字段，以及是否支持GET以外的其他方法。

5.1.1 方法

方法标记指示对由请求URI标识的资源执行的操作。该方法区分大小写。

       Method         = "GET"                    ; 第8.1节
                      | "HEAD"                   ; 第8.2节
                      | "POST"                   ; 第8.3节
                      | extension-method

       extension-method = token

以下是英文内容的中文翻译：

```
   资源允许的方法列表可能会动态变化；如果某个方法不被允许访问某个资源，客户端会通过响应的状态码得到通知。服务器应在方法未被识别或未实现时返回状态码 501（未实现）。

   HTTP/1.0 应用中常用的方法在第8节中已被完整定义。

5.1.2 请求URI

   请求URI是一个统一资源标识符（第3.2节），用于标识要对其应用请求的资源。

       请求URI = 绝对URI | 绝对路径

   请求URI的两种形式取决于请求的性质。

   仅在请求通过代理发出时，才允许使用绝对URI形式。请求被代理转发并返回响应。如果请求是GET或HEAD，并且之前的响应已被缓存，代理可以使用缓存的消息（前提是满足Expires头字段中的任何限制）。请注意，代理可能会将请求转发到另一个代理或直接转发到由绝对URI指定的服务器。为了避免请求循环，代理必须能够识别所有其服务器的名称，包括任何别名、本地变体和数字IP地址。一个请求行的示例为：

       GET http://www.w3.org/pub/WWW/TheProject.html HTTP/1.0

   最常用的请求URI形式是用来标识原始服务器或网关上的资源。在这种情况下，只传输URI的绝对路径（参见第3.2.1节，abs_path）。例如，客户端希望直接从原始服务器检索上述资源时，会建立一个到“www.w3.org”主机端口80的TCP连接，并发送如下行：

       GET /pub/WWW/TheProject.html HTTP/1.0

   接着是完整请求的其余部分。注意，绝对路径不能为空；如果原始URI中没有提供路径，则必须使用“/”（代表服务器根目录）。

   请求URI作为编码字符串传输，其中某些字符可能会使用RFC 1738 [4]定义的“% HEX HEX”编码进行转义。原始服务器必须对请求URI进行解码，以正确理解请求内容。

5.2 请求头字段

   请求头字段允许客户端向服务器传递关于请求的附加信息，以及关于客户端本身的信息。这些字段作为请求的修饰符，其语义等同于编程语言中方法（过程）调用的参数。
```

请求头 = 授权字段            ; 第10.2节
        | 来自字段             ; 第10.8节
        | 如果修改时间字段     ; 第10.9节
        | 引用者字段           ; 第10.13节
        | 用户代理字段         ; 第10.15节

请求头字段名只能在协议版本变更的情况下可靠地扩展。然而，如果通信中的所有参与方都认可某些新或试验性的请求头字段具有请求头字段的语义，则可以赋予它们请求头字段的含义。未被识别的请求头字段将被视为实体头字段。

6.  响应

在接收并解释请求消息后，服务器以HTTP响应消息的形式作出响应。

       响应 = 简单响应 | 完整响应

       简单响应 = [ 实体主体 ]

伯纳斯-李等人           信息性文档                     [第25页]

RFC 1945                        HTTP/1.0                        1996年5月

       完整响应   = 状态行             ; 第6.1节
                     *( 通用头部       ; 第4.3节
                      | 响应头部      ; 第6.2节
                      | 实体头部 )    ; 第7.1节
                     CRLF
                     [ 实体主体 ]     ; 第7.2节

只有在响应HTTP/0.9简单请求或服务器仅支持较有限的HTTP/0.9协议时，才应发送简单响应。如果客户端发送HTTP/1.0完整请求并收到的响应没有以状态行开头，则应假定该响应为简单响应并相应地解析。请注意，简单响应仅由实体主体组成，并由服务器关闭连接来终止。

6.1  状态行

完整响应消息的第一行是状态行，由协议版本、状态码及其相关的文本短语组成，各元素之间用空格（SP）分隔。除了最后的CRLF序列外，不允许出现CR或LF。

       状态行 = HTTP-版本 SP 状态码 SP 原因短语 CRLF

由于状态行总是以协议版本和状态码开头，

       "HTTP/" 1*DIGIT "." 1*DIGIT SP 3DIGIT SP

（例如，“HTTP/1.0 200 ”），该表达式的存在足以区分完整响应和简单响应。虽然简单响应格式可能允许在实体主体开头出现此类表达式，从而在响应完整请求时导致消息被误解，但大多数HTTP/0.9服务器仅支持“text/html”类型的响应，因此不会生成此类响应。

6.1.1  状态码与原因短语

状态码元素是一个由三位数字组成的结果代码，用于表示对请求的理解和满足情况。原因短语旨在提供对状态码的简短文本描述。状态码主要供自动机使用，而原因短语则面向人类用户。客户端无需检查或显示原因短语。

伯恩斯-李等人，信息性文档，[第26页]

RFC 1945 HTTP/1.0 1996年5月

状态码的第一位数字定义了响应的类别。最后两位数字没有分类作用。第一位数字有五个取值：

- 1xx：信息性 - 尚未使用，但为将来使用预留
- 2xx：成功 - 请求已成功接收、理解并接受
- 3xx：重定向 - 需要采取进一步措施以完成请求
- 4xx：客户端错误 - 请求存在语法错误或无法完成
- 5xx：服务器错误 - 服务器未能完成明显有效的请求

以下列出了为HTTP/1.0定义的各个数字状态码的具体值，以及相应的示例原因短语。这些原因短语仅为建议——它们可以被本地的等价短语取代，而不影响协议。这些代码在第9节中有完整定义。

状态码 = "200"   ; 正常
        | "201"   ; 已创建
        | "202"   ; 已接受
        | "204"   ; 无内容
        | "301"   ; 永久移动
        | "302"   ; 临时移动
        | "304"   ; 未修改
        | "400"   ; 错误请求
        | "401"   ; 未授权
        | "403"   ; 禁止访问
        | "404"   ; 未找到
        | "500"   ; 服务器内部错误
        | "501"   ; 未实现
        | "502"   ; 网关错误
        | "503"   ; 服务不可用
        | 扩展码

扩展码 = 3DIGIT

原因短语 = *<TEXT，排除CR、LF>

HTTP状态码是可扩展的，但上述代码是当前实践中普遍认可的唯一代码。HTTP应用程序不必理解所有注册状态码的含义。

伯恩斯-李等人，信息性文档，[第27页]

RFC 1945 HTTP/1.0 1996年5月

虽然理解这些状态码的具体含义显然是可取的，但应用程序必须理解任何状态码的类别（由首位数字指示），并将任何未识别的响应视为该类别的 x00 状态码，唯一例外是未识别的响应不得被缓存。例如，如果客户端收到一个未识别的状态码 431，它可以安全地假设请求存在问题，并将响应视为已收到 400 状态码。在这种情况下，用户代理应向用户展示响应中返回的实体，因为该实体很可能包含人类可读的信息，能够解释异常状态。

6.2 响应头字段

响应头字段允许服务器传递关于响应的额外信息，这些信息无法放在状态行中。这些头字段提供关于服务器以及对请求URI所标识资源的进一步访问信息。

响应头字段可以可靠地扩展，但只能在协议版本发生变化时进行扩展。然而，如果所有通信方都认可某些新或试验性的头字段具有响应头字段的语义，则可以赋予它们响应头字段的含义。未被识别的头字段将被视为实体头字段。

7. 实体

完整的请求和响应消息可能在某些请求和响应中传输实体。实体由实体头字段和（通常的）实体主体组成。在本节中，发送方和接收方都可以是客户端或服务器，具体取决于谁发送和谁接收实体。

7.1 实体头字段

实体头字段定义关于实体主体的可选元信息，或者如果没有实体主体，则关于请求所标识资源的元信息。

实体头字段包括：

- Allow（第10.1节）
- Content-Encoding（第10.3节）
- Content-Length（第10.4节）
- Content-Type（第10.5节）
- Expires（第10.7节）
- Last-Modified（第10.10节）
- extension-header（扩展头字段）

扩展头字段可以是HTTP头字段。

扩展头部机制允许定义额外的实体头字段，而无需更改协议，但这些字段不能被接收方假设为可识别。未被识别的头字段应由接收方忽略，并由代理转发。

7.2 实体主体

与HTTP请求或响应一起发送的实体主体（如果有）其格式和编码由实体头字段定义。

       实体主体 = *OCTET

只有当请求方法需要时，才会在请求消息中包含实体主体。请求中实体主体的存在通过在请求消息头中包含Content-Length头字段来表示。包含实体主体的HTTP/1.0请求必须包含有效的Content-Length头字段。

对于响应消息，是否包含实体主体取决于请求方法和响应状态码。所有对HEAD请求的方法的响应都不得包含实体主体，即使实体头字段的存在可能让人误以为有实体主体。所有1xx（信息性）、204（无内容）和304（未修改）响应都不得包含实体主体。其他所有响应必须包含实体主体，或包含一个值为零（0）的Content-Length头字段。

7.2.1 类型

当消息中包含实体主体时，该主体的数据类型由头字段Content-Type和Content-Encoding确定。这些定义了一个两层的有序编码模型：

entity-body := Content-Encoding( Content-Type( data ) )

Content-Type指定底层数据的媒体类型。Content-Encoding可以用来指示应用于该类型的任何附加内容编码，通常用于数据压缩，这是请求资源的属性。内容编码的默认值为无（即，恒等函数）。

任何包含实体主体的HTTP/1.0消息都应包含一个定义该主体媒体类型的Content-Type头字段。如果没有提供Content-Type头字段（如在简单响应消息中），接收方可以尝试通过检查内容和/或用于标识资源的URL的扩展名来猜测媒体类型。如果媒体类型仍然未知，接收方应将其视为“application/octet-stream”类型。

7.2.2 长度

当消息中包含实体主体时，可以通过两种方式确定其长度。如果存在Content-Length头字段，其值（以字节为单位）表示实体主体的长度；否则，主体长度由服务器关闭连接来确定。

关闭连接不能用来表示请求体的结束，因为这样会让服务器无法返回响应。因此，包含实体主体的HTTP/1.0请求必须包含有效的Content-Length头字段。如果请求中包含实体主体且未指定Content-Length，并且服务器无法识别或无法从其他字段计算出长度，那么服务器应返回一个400（错误请求）响应。

注意：一些较旧的服务器在发送包含动态插入的服务器端包含内容的文档时，会提供无效的Content-Length。必须强调的是，未来版本的HTTP将不再容忍这种做法。除非客户端知道它接收的是来自符合规范的服务器的响应，否则不应依赖Content-Length值的正确性。

8. 方法定义

以下定义了HTTP/1.0的常用方法。虽然这个集合可以扩展，但不能假设额外的方法在不同扩展的客户端和服务器中具有相同的语义。

伯纳斯-李等人，信息性文档 [第30页]

RFC 1945 HTTP/1.0 1996年5月

8.1 GET

GET方法意味着检索由请求URI标识的任何信息（以实体的形式）。如果请求URI指向一个数据生成过程，则应返回由该过程生成的数据作为响应中的实体，而不是该过程的源文本，除非该文本恰好是该过程的输出。

如果请求消息中包含If-Modified-Since头字段，则GET方法的语义会变成“条件GET”。条件GET请求只在资源自指定日期以来已被修改的情况下才会传输该资源，详见第10.9节。条件GET旨在通过允许缓存实体在不需要多次请求或传输不必要数据的情况下被刷新，从而减少网络使用。

8.2 HEAD

HEAD方法与GET相同，但服务器不得在响应中返回任何实体主体。响应中的HTTP头部信息应与响应GET请求时返回的信息相同。该方法可用于获取关于由请求URI标识的资源的元信息，而无需传输实体主体本身。常用于测试超文本链接的有效性、可访问性和最近的修改情况。

没有与条件GET类似的“条件HEAD”请求。如果在HEAD请求中包含If-Modified-Since头字段，应予以忽略。

8.3 POST

POST 方法用于请求目标服务器接受请求中包含的实体，将其作为请求行中的 Request-URI 所标识资源的一个新的子资源。POST 设计的目的是提供一种统一的方法，以涵盖以下功能：

- 对现有资源进行注释；
- 向公告栏、新闻组、邮件列表或类似的文章组发布消息；
- 向数据处理过程提供一块数据，例如提交表单的结果；
- 通过追加操作扩展数据库。

Berners-Lee 等人，信息性文档 [第31页]

RFC 1945 HTTP/1.0 1996年5月

POST 方法实际执行的功能由服务器决定，通常依赖于请求中的 Request-URI。提交的实体在结构上是该 URI 的子资源，就像文件是目录的子项、新闻文章是发布到的新闻组的子项、记录是数据库的子项一样。

成功的 POST 并不要求在源服务器上创建实体资源或使其可供未来引用。也就是说，POST 方法执行的操作可能不会产生一个可以通过 URI 识别的资源。在这种情况下，响应状态应为 200（成功）或 204（无内容），具体取决于响应是否包含描述结果的实体。

如果在源服务器上创建了资源，响应应为 201（已创建），并包含描述请求状态且指向新资源的实体（最好是“text/html”类型）。

所有 HTTP/1.0 POST 请求都必须包含有效的 Content-Length 头。如果 HTTP/1.0 服务器无法确定请求消息内容的长度，应返回 400（错误请求）状态。

应用程序不得缓存对 POST 请求的响应，因为应用程序无法确定服务器是否会在未来的请求中返回相同的响应。

9. 状态码定义

每个状态码的描述如下，包括它可以跟随的方法类型以及响应中所需的元信息。

9.1  信息性 1xx

此类状态码表示临时响应，仅由状态行和可选的头部组成，以空行结束。HTTP/1.0 不定义任何 1xx 状态码，也不将其视为对 HTTP/1.0 请求的有效响应。然而，它们可能对超出本规范范围的实验性应用有用。

9.2  成功 2xx

此类状态码表示客户端的请求已成功接收、理解并被接受。

伯恩斯-李等人           信息性内容                     [第32页]


RFC 1945                        HTTP/1.0                        1996年5月


200 OK

请求已成功。响应中返回的信息取决于请求中使用的方法，具体如下：

GET    服务器在响应中发送与请求资源对应的实体；

HEAD   响应只应包含头部信息，不包含实体主体；

POST   描述或包含操作结果的实体。

201 已创建

请求已被完成，并导致一个新资源的创建。新创建的资源可以通过响应实体中返回的URI进行引用。在使用此状态码之前，原始服务器应先创建资源。如果操作不能立即完成，服务器必须在响应体中说明资源何时可用；否则，服务器应返回202（已接受）。

在本规范定义的方法中，只有POST可以创建资源。

202 已接受

请求已被接受用于处理，但处理尚未完成。请求可能最终会被处理，也可能不会，因为在实际处理时可能会拒绝。没有机制可以从异步操作中重新发送状态码。

202响应是故意不作承诺的。其目的是允许服务器接受某些其他处理请求（也许是每天只运行一次的批处理过程），而不要求用户代理与服务器的连接持续到处理完成。此响应返回的实体应包括请求当前状态的指示，以及指向状态监控的指针或用户可以预期请求完成的时间估计。

204 无内容

服务器已完成请求，但没有新信息返回。如果客户端是用户代理，它不应改变引发请求的文档视图。此响应主要用于允许脚本或其他操作在不引起用户代理活动文档变化的情况下进行。响应可能包含以实体头形式提供的新元信息，这些信息应适用于当前在用户代理活动视图中的文档。

9.3 重定向 3xx

这类状态码表示用户代理需要采取进一步的行动以完成请求。所需的行动可以由用户代理在不与用户交互的情况下执行，前提是后续请求所使用的方法为GET或HEAD。用户代理不应自动重定向请求超过5次，因为这种重定向通常表示无限循环。

300 多重选择

此响应码在HTTP/1.0应用中并不直接使用，但作为解释3xx类响应的默认值。

请求的资源在一个或多个位置可用。除非是HEAD请求，否则响应应包含一个实体，列出资源的特性和位置，用户或用户代理可以从中选择最合适的一个。如果服务器有偏好的选择，应在Location字段中包含该URL；用户代理可以使用此字段的值进行自动重定向。

301 永久移动

请求的资源已被分配了一个新的永久URL，未来对该资源的所有引用都应使用该URL。具有链接编辑能力的客户端应在可能的情况下，自动将对请求URI的引用重新链接到服务器返回的新引用。

新URL必须在响应的Location字段中提供。除非是HEAD请求，否则响应的实体部分应包含一条简短的说明，并附有指向新URL的超链接。

如果对使用POST方法的请求收到301状态码，用户代理不得自动重定向该请求，除非得到用户确认，因为这可能会改变请求的条件。

注意：在收到301状态码后自动重定向POST请求时，一些现有的用户代理会错误地将其更改为GET请求。

302 临时移动

请求的资源暂时位于不同的URL下。由于重定向可能会被更改，客户端应继续使用原始请求的Request-URI进行未来的请求。

URL必须在响应的Location字段中提供。除非是HEAD请求，否则响应的实体部分应包含一条简短的说明，并附有指向新URI的超链接。

如果对使用POST方法的请求收到302状态码，用户代理不得自动重定向该请求，除非得到用户确认，因为这可能会改变请求的条件。

注意：在自动重定向一个POST请求（收到302状态码后）时，一些现有的用户代理会错误地将其转换为GET请求。

304 未修改

如果客户端执行了条件GET请求并且访问被允许，但自从在If-Modified-Since字段中指定的日期和时间之后，文档未被修改，服务器必须用此状态码进行响应，并且不向客户端发送实体主体。响应中包含的头字段应仅包括与缓存管理器相关或可能已独立于实体的Last-Modified日期而发生变化的信息。相关的头字段示例包括：Date、Server和Expires。缓存应更新其缓存的实体，以反映在304响应中提供的任何新字段值。

9.4 客户端错误 4xx

4xx类状态码旨在表示客户端似乎出现了错误。如果在收到4xx代码时，客户端尚未完成请求，它应立即停止向服务器发送数据。除非是在响应HEAD请求时，服务器应包含一个实体，说明错误情况，以及这是临时还是永久的状态。这些状态码适用于任何请求方法。

Berners-Lee等人，信息性，[第35页]

RFC 1945 HTTP/1.0 1996年5月

注意：如果客户端正在发送数据，基于TCP的服务器实现应确保在关闭输入连接之前，客户端已确认收到包含响应的数据包。如果客户端在连接关闭后继续向服务器发送数据，服务器的控制器将向客户端发送重置包，这可能会在HTTP应用程序读取和解释之前，清除客户端未确认的输入缓冲区。

400 错误请求

由于语法格式错误，服务器无法理解请求。客户端不应在未修改的情况下重复请求。

401 未授权

请求需要用户认证。响应必须包含一个 WWW-Authenticate 头字段（第10.16节），其中包含适用于请求资源的挑战。客户端可以使用合适的 Authorization 头字段（第10.2节）重复请求。如果请求已经包含了授权凭据，那么 401 响应表示这些凭据已被拒绝授权。如果 401 响应中包含与之前相同的挑战，并且用户代理已经至少尝试过一次认证，那么应向用户展示响应中提供的实体内容，因为该实体可能包含相关的诊断信息。HTTP 访问认证的详细内容请参见第11节。

403 禁止

服务器理解请求，但拒绝执行。授权不会有帮助，也不应重复请求。如果请求的方法不是 HEAD，并且服务器希望公开说明为何未能满足请求，应在实体主体中描述拒绝的原因。当服务器不希望向客户端披露具体拒绝原因，或者没有其他适用的响应时，通常会使用此状态码。

404 未找到

服务器未找到与请求 URI 匹配的任何内容。没有指明该状态是临时的还是永久的。如果服务器不希望将此信息提供给客户端，可以改用状态码 403（禁止）。

Berners-Lee 等人  信息性  [第36页]

RFC 1945                        HTTP/1.0                        1996年5月

9.5  服务器错误 5xx

以数字“5”开头的响应状态码表示服务器已意识到自己出错或无法完成请求。如果在收到 5xx 码时客户端尚未完成请求，应立即停止向服务器发送数据。除非响应 HEAD 请求外，服务器应包含一个实体，说明错误情况，以及这是临时还是永久的状态。这些响应码适用于任何请求方法，且没有强制要求的头字段。

500  内部服务器错误

   服务器遇到意外情况，导致无法完成请求。

501  未实现

   服务器不支持完成请求所需的功能。当服务器不识别请求方法，且无法支持任何资源的该方法时，应返回此响应。

502  错误的网关

   服务器在充当网关或代理时，从上游服务器收到无效响应，试图完成请求失败。

503  服务不可用

服务器目前无法处理请求，因为服务器暂时过载或正在维护中。意味着这是一个临时状态，经过一段时间后会得到缓解。

注意：存在503状态码并不意味着服务器在过载时必须使用它。有些服务器可能会选择直接拒绝连接。

10. 头字段定义

本节定义了所有常用HTTP/1.0头字段的语法和语义。对于通用头字段和实体头字段，发送方和接收方都可以是客户端或服务器，具体取决于消息的发送者和接收者。

Berners-Lee 等人，信息性文档，[第37页]

RFC 1945 HTTP/1.0 1996年5月

10.1  Allow（允许）

Allow实体头字段列出由请求URI标识的资源支持的方法集。此字段的目的是纯粹通知接收方与该资源相关的有效方法。Allow头字段不允许出现在使用POST方法的请求中，因此如果在POST实体中收到该字段，应予忽略。

允许的方法格式为：

Allow = "Allow" ":" 1#method

使用示例：

Allow: GET, HEAD

此字段不能阻止客户端尝试其他方法，但应遵循Allow头字段值所指示的方法。实际允许的方法集由源服务器在每次请求时定义。

代理服务器不得修改Allow头字段，即使它不理解所有列出的方法，因为用户代理可能有其他方式与源服务器通信。

Allow头字段并不表示服务器已实现哪些方法。

10.2  Authorization（授权）

希望向服务器进行身份验证的用户代理——通常是在收到401响应后，但不一定——可以在请求中包含Authorization请求头字段。Authorization字段的值由包含用户代理在请求资源的领域中的认证信息的凭据组成。

Authorization = "Authorization" ":" credentials

HTTP访问认证详见第11节。如果请求经过认证且指定了领域，则在该领域内的所有其他请求都应使用相同的凭据。

包含Authorization字段的请求的响应不可缓存。

10.3  Content-Encoding（内容编码）

内容编码（Content-Encoding）实体头字段用作媒体类型的修饰符。当存在时，其值指示已对资源应用了哪些额外的内容编码，因此必须应用何种解码机制以获取由内容类型（Content-Type）头字段引用的媒体类型。内容编码主要用于允许对文档进行压缩而不丢失其底层媒体类型的身份。

       Content-Encoding = "Content-Encoding" ":" content-coding

内容编码在第3.5节中有定义。其使用示例如下：

       Content-Encoding: x-gzip

内容编码是由请求的URI所标识资源的一个特性。通常，资源以此编码存储，只有在渲染或类似用途之前才进行解码。

10.4 内容长度（Content-Length）

内容长度实体头字段指示发送给接收方的实体主体（Entity-Body）的大小，以十进制的字节数表示，或者在HEAD方法的情况下，表示如果请求为GET时会发送的实体主体的大小。

       Content-Length = "Content-Length" ":" 1*DIGIT

示例：

       Content-Length: 3495

应用程序应使用此字段来指示要传输的实体主体的大小，无论实体的媒体类型如何。在所有包含实体主体的HTTP/1.0请求消息中，都需要提供有效的内容长度字段值。

任何大于或等于零的内容长度都是有效值。如果未提供内容长度，第7.2.2节描述了如何确定响应实体主体的长度。

注意：此字段的含义与MIME中的定义有显著不同，MIME中它是“message/external-body”内容类型中的一个可选字段。在HTTP中，只要在传输实体之前可以确定其长度，就应使用此字段。

Berners-Lee 等人，信息性文档 [第39页]

RFC 1945 HTTP/1.0 1996年5月

10.5 内容类型（Content-Type）

内容类型实体头字段指示发送给接收方的实体主体的媒体类型，或者在HEAD方法的情况下，指示如果请求为GET时会发送的媒体类型。

       Content-Type   = "Content-Type" ":" media-type

媒体类型在第3.6节中定义。字段示例如下：

       Content-Type: text/html

关于识别实体的媒体类型的方法的进一步讨论在第7.2.1节中提供。

10.6 日期（Date）

通用头字段日期（Date）表示消息的产生日期和时间，其语义与RFC 822中的orig-date相同。字段值为HTTP日期格式，详见第3.3节。

       Date           = "Date" ":" HTTP-date

示例：

       Date: Tue, 15 Nov 1994 08:12:31 GMT

如果通过与用户代理（在请求的情况下）或源服务器（在响应的情况下）建立直接连接接收到消息，那么可以假设该消息的日期为接收端的当前日期。然而，由于源服务器认为日期对于评估缓存响应非常重要，源服务器应始终包含一个Date头字段。客户端在发送包含实体主体的消息（如POST请求）时，应仅在必要时添加Date头字段，且该字段是可选的。接收到的消息如果没有Date头字段，接收方应在该消息将被缓存或通过需要Date的协议进行网关传输时，为其添加一个。

理论上，日期应代表实体生成之前的那一刻。实际上，日期可以在消息生成的任何时间点生成，而不会影响其语义价值。

注意：此文档的早期版本错误地规定该字段应包含所附实体主体的创建日期。现已更改为符合实际（且正确）的用法。

10.7 过期时间（Expires）

实体头字段Expires指示在此日期/时间之后，该实体应被视为过期。这允许信息提供者建议资源的易变性，或建议在某个日期之后信息可能不再有效。应用程序不得在该日期之后缓存此实体。Expires字段的存在并不意味着原始资源会在该时间点或之前或之后发生变化或不再存在。然而，知道或甚至怀疑某个资源会在某个日期之前发生变化的信息提供者，应在该日期包含一个Expires头字段。其格式为HTTP-date中定义的绝对日期和时间。

示例用法：

Expires: Thu, 01 Dec 1994 16:00:00 GMT

如果所给日期等于或早于Date头字段的值，接收方不得缓存该实体。对于本质上是动态的资源（如许多数据生成过程），应为该资源的实体提供一个反映其动态性的适当Expires值。

Expires字段不能用来强制用户代理刷新其显示或重新加载资源；其语义仅适用于缓存机制，且此类机制只在发起新请求时检查资源的过期状态。

用户代理通常具有历史机制，例如“后退”按钮和历史列表，可以用来重新显示在会话中早先检索的实体。默认情况下，Expires字段不适用于历史机制。如果实体仍然存储在缓存中，即使已过期，历史机制也应显示它，除非用户已特别配置代理以刷新过期的历史文档。

注意：鼓励应用程序容忍对Expires头的错误或误导性实现。值为零（0）或无效的日期格式应视为“立即过期”。虽然这些值在HTTP/1.0中不合法，但实现的健壮性总是值得追求。

伯恩斯-李等人，信息性，[第41页]

RFC 1945 HTTP/1.0 1996年5月

10.8  From（来源）

如果提供，From请求头字段应包含控制请求用户代理的人类用户的互联网电子邮件地址。该地址应为机器可用的，定义见RFC 822 [7]（由RFC 1123 [6]更新）：

    From = "From" ":" mailbox（邮箱）

示例：

    From: webmaster@w3.org

该头字段可用于日志记录，也可作为识别无效或不需要请求来源的手段。它不应被用作不安全的访问保护方式。对此字段的解释是，代表给定的人执行请求，该人对所执行的方法承担责任。特别是，机器人代理应包含此头，以便在接收端出现问题时可以联系负责运行机器人的人员。

该字段中的互联网电子邮件地址可以与发出请求的互联网主机不同。例如，当请求通过代理传递时，应使用原始发起者的地址。

注意：客户端不应在未经用户同意的情况下发送From头字段，因为这可能与用户的隐私利益或其站点的安全策略相冲突。强烈建议用户能够在发出请求前随时禁用、启用或修改此字段的值。

10.9  If-Modified-Since（如果修改时间）

If-Modified-Since请求头字段与GET方法一起使用，使请求具有条件性：如果请求的资源自该字段指定的时间以来未被修改，则不会从服务器返回资源的副本；相反，将返回一个304（未修改）响应，且不带实体主体。

格式：

    If-Modified-Since = "If-Modified-Since" ":" HTTP-date（HTTP日期）

示例：

    If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT

伯纳斯-李等人           信息性                     [第42页]

RFC 1945                        HTTP/1.0                        1996年5月

条件GET方法请求仅在所标识的资源自提供的If-Modified-Since头所给的日期以来已被修改时才传输该资源。判断这一点的算法包括以下几种情况：

a) 如果请求通常会导致除200（成功）状态码以外的响应，或者传递的If-Modified-Since日期无效，则响应与普通GET完全相同。晚于服务器当前时间的日期是无效的。

b) 如果资源自If-Modified-Since日期以来已被修改，则响应与普通GET完全相同。

c) 如果资源自有效的If-Modified-Since日期以来未被修改，服务器应返回304（未修改）响应。

此功能的目的是以最少的事务开销高效地更新缓存信息。

10.10  Last-Modified

Last-Modified实体头字段指示发件人认为资源最后被修改的日期和时间。该字段的确切语义定义了接收者应如何解释：如果接收者拥有的该资源副本早于Last-Modified字段所给的日期，则应视为过时。

       Last-Modified  = "Last-Modified" ":" HTTP-date

其使用示例如下：

       Last-Modified: Tue, 15 Nov 1994 12:45:26 GMT

该头字段的确切含义取决于发件人的实现和原始资源的性质。对于文件，它可能只是文件系统的最后修改时间。对于包含动态部分的实体，它可能是其组成部分的最后修改时间中的最新者。对于数据库网关，它可能是记录的最后更新时间戳。对于虚拟对象，它可能是内部状态最后变化的时间。

源服务器不得发送晚于消息发起时间的Last-Modified日期。在这种情况下，如果资源的最后修改时间显示在未来，服务器必须用消息发起时间替换该日期。

10.11  Location

Location响应头字段定义了由Request-URI标识的资源的确切位置。对于3xx响应，位置必须指示服务器首选的用于自动重定向到该资源的URL。只允许一个绝对URL。

       Location       = "Location" ":" absoluteURI

示例如下：

位置：http://www.w3.org/hypertext/WWW/NewLocation.html

10.12  Pragma（预处理）

   Pragma（预处理）通用首部字段用于包含可能适用于请求/响应链中任何接收方的特定于实现的指令。所有的Pragma指令都从协议的角度指定可选行为；然而，某些系统可能要求行为与指令保持一致。

       Pragma           = "Pragma" ":" 1#pragma-directive

       pragma-directive = "no-cache" | extension-pragma
       extension-pragma = token [ "=" word ]

   当请求消息中包含"no-cache"指令时，应用程序应将请求转发到源服务器，即使它已有所请求内容的缓存副本。这允许客户端坚持接收权威的响应。它也允许客户端刷新已知被破坏或过时的缓存副本。

   无论Pragma指令对应用程序的重要性如何，代理或网关应用程序都必须传递这些指令，因为它们可能适用于请求/响应链中的所有接收方。不能为特定接收方指定Pragma；然而，任何与接收方无关的Pragma指令应由该接收方忽略。

10.13  Referer（引用页）

   Referer（引用页）请求首部字段允许客户端为服务器的利益，指定获取请求URI的资源的地址（URI）。这使得服务器可以生成指向资源的反向链接列表，用于兴趣、日志、优化缓存等。它也允许追踪已过时或拼写错误的链接以进行维护。如果请求URI是从没有自己URI的来源（如用户键盘输入）获得的，则不得发送Referer字段。

       Referer        = "Referer" ":" ( absoluteURI | relativeURI )

   例子：

       Referer: http://www.w3.org/hypertext/DataSources/Overview.html

   如果提供的是部分URI，应将其相对于请求URI进行解释。URI中不得包含片段（fragment）。

      注意：由于链接的来源可能是私密信息，或可能揭示其他私密信息源，强烈建议用户能够选择是否发送Referer字段。例如，浏览器客户端可以设置一个切换开关，用于开启/关闭公开/匿名浏览，从而分别启用或禁用Referer和From信息的发送。

10.14  Server（服务器）

服务器响应头字段包含有关用于处理请求的原始服务器软件的信息。该字段可以包含多个产品标记（第3.7节）和注释，用于标识服务器及任何重要的子产品。按照惯例，产品标记按其在识别应用程序中的重要性顺序列出。

       Server = "Server" ":" 1*( product | comment )

示例：

       Server: CERN/3.0 libwww/2.17

如果响应通过代理转发，代理应用程序不得将其数据添加到产品列表中。

注意：披露服务器的具体软件版本可能会使服务器机器更容易受到已知存在安全漏洞的软件攻击。建议服务器实现者将此字段设为可配置选项。

伯纳斯-李等人，信息性文档 [第45页]

RFC 1945 HTTP/1.0 1996年5月

注意：一些现有的服务器未能限制自己在Server字段中使用产品标记的语法。

10.15 用户代理（User-Agent）

用户代理请求头字段包含关于发起请求的用户代理的信息。这主要用于统计、协议违规追踪，以及自动识别用户代理以便调整响应，避免特定用户代理的限制。虽然不是强制要求，用户代理应在请求中包含此字段。该字段可以包含多个产品标记（第3.7节）和注释，用于标识代理及其任何子产品，这些通常是用户代理的重要组成部分。按照惯例，产品标记按其在识别应用程序中的重要性顺序列出。

       User-Agent = "User-Agent" ":" 1*( product | comment )

示例：

       User-Agent: CERN-LineMode/2.15 libwww/2.17b3

注意：一些现有的代理应用会在User-Agent字段的列表中附加其产品信息。这样做不推荐，因为会使机器对这些字段的解释变得模糊。

注意：一些现有客户端未能限制自己在User-Agent字段中使用产品标记的语法。

10.16 WWW-Authenticate

WWW-Authenticate响应头字段必须在401（未授权）响应消息中包含。该字段的值至少包含一个挑战，指示适用于请求URI的认证方案及参数。

       WWW-Authenticate = "WWW-Authenticate" ":" 1#challenge

HTTP访问认证过程在第11节中进行了描述。
用户代理在解析WWW-Authenticate字段的值时必须格外小心，如果该字段包含多个挑战，或者提供了多个WWW-Authenticate头字段，因为挑战的内容本身可能包含用逗号分隔的认证参数列表。

伯恩斯-李等人           信息性文档                     [第46页]

RFC 1945                        HTTP/1.0                        1996年5月

11. 访问认证

HTTP提供了一种简单的挑战-响应认证机制，服务器可以用它向客户端请求认证信息，客户端也可以用它提供认证信息。该机制使用一个可扩展的、不区分大小写的标记（token）来标识认证方案，后跟用逗号分隔的属性-值对列表，这些参数携带实现该方案认证所需的参数。

       auth-scheme    = token

       auth-param     = token "=" quoted-string

当源服务器需要对用户代理进行授权时，会返回状态码为401（未授权）的响应消息。该响应必须包含一个WWW-Authenticate头字段，至少包含一个适用于请求资源的挑战。

       challenge      = auth-scheme 1*SP realm *( "," auth-param )

       realm          = "realm" "=" realm-value
       realm-value    = quoted-string

realm属性（不区分大小写）对于所有发出挑战的认证方案都是必需的。realm值（区分大小写）结合被访问服务器的规范根URL，共同定义了保护空间。这些保护空间允许将服务器上的受保护资源划分为一组保护空间，每个空间具有自己的认证方案和/或授权数据库。realm值是一个字符串，通常由源服务器分配，可能具有与认证方案相关的其他语义。

希望向服务器进行认证的用户代理——通常是在收到401响应后，但不一定如此——可以通过在请求中包含Authorization头字段来实现。Authorization字段的值由包含用户代理在请求资源的realm中的认证信息的凭据组成。

       credentials    = basic-credentials
                      | ( auth-scheme #auth-param )

用户代理可以自动应用凭据的域由保护空间决定。如果之前的请求已被授权，则在该保护空间内的所有其他请求中可以重复使用相同的凭据，使用期限由相关的机制决定。

根据认证方案、参数和/或用户偏好，单一的保护空间不能超出其服务器的范围，除非认证方案另有定义。

如果服务器不希望接受请求中提供的凭据，应返回一个 403（禁止访问）响应。

HTTP协议并不限制应用程序仅使用这种简单的挑战-响应机制进行访问认证。可以使用其他机制，例如在传输层进行加密或通过消息封装，以及使用附加的头字段来指定认证信息。然而，这些额外的机制未在本规范中定义。

代理服务器在用户代理认证方面必须完全透明。也就是说，它们必须原封不动地转发 WWW-Authenticate 和 Authorization 头字段，并且不得缓存包含 Authorization 的请求的响应。HTTP/1.0 不提供客户端与代理进行认证的方式。

11.1 基本认证方案

“基本”认证方案基于这样一种模型：用户代理必须为每个保护空间使用用户ID和密码进行自我认证。保护空间的 realm 值应被视为一个不透明的字符串，只能与该服务器上的其他 realm 进行相等性比较。服务器只有在能够验证请求URI的保护空间中的用户ID和密码时，才会授权该请求。没有可选的认证参数。

当收到针对保护空间内某个URI的未授权请求时，服务器应以如下挑战响应：

    WWW-Authenticate: Basic realm="WallyWorld"

其中，“WallyWorld”是由服务器分配用以标识请求URI的保护空间的字符串。

为了获得授权，客户端应在凭据中以 base64 编码的字符串内，发送用户ID和密码，二者之间用单个冒号（":"）分隔。

基本凭据的格式如下：

    basic-credentials = "Basic" SP basic-cookie

    basic-cookie = <base64 编码的用户ID-密码，且不限制每行76字符>

    用户ID-密码 = [ token ] ":" *TEXT

如果用户代理希望发送用户ID“Aladdin”和密码“open sesame”，它将使用以下头字段：

    Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==

基本认证方案是一种不安全的过滤未经授权访问HTTP服务器资源的方法。它基于假设客户端与服务器之间的连接可以被视为可信载体，但在开放网络环境中，这一假设通常不成立，因此应相应地谨慎使用基本认证方案。尽管如此，客户端仍应实现该方案，以便与使用它的服务器进行通信。

12. 安全注意事项

本节旨在告知应用程序开发者、信息提供者和用户关于HTTP/1.0在本文件中描述的安全限制。讨论内容不包括对所揭示问题的最终解决方案，但提供了一些减少安全风险的建议。

12.1 客户端的认证

如第11.1节所述，基本认证方案不是一种安全的用户认证方法，也不能防止实体主体（Entity-Body）在传输过程中以明文形式通过物理网络作为载体。HTTP/1.0没有阻止采用其他认证方案和加密机制以增强安全性的措施。

12.2 安全方法

客户端软件的开发者应意识到，软件代表用户在互联网中的交互，必须谨慎设计，确保用户了解其可能采取的行动及其对自己或他人可能产生的意外影响。

特别是，已建立的惯例是，GET和HEAD方法不应具有除检索以外的其他操作意义。这些方法应被视为“安全的”。这允许用户代理以特殊方式表示其他方法，例如POST，从而让用户意识到可能请求了不安全的操作。

当然，不可能确保服务器在执行GET请求时不会产生副作用；实际上，一些动态资源将其视为一项功能。这里的重要区别在于，用户并未请求这些副作用，因此不能为其承担责任。

12.3 滥用服务器日志信息

服务器有可能保存关于用户请求的个人数据，这些数据可能揭示用户的阅读习惯或兴趣主题。这些信息本质上是机密的，其处理可能受到某些国家法律的限制。使用HTTP协议提供数据的人员有责任确保未经任何可识别个人的许可，不会将此类资料随意传播。

12.4 敏感信息的传输

像任何通用的数据传输协议一样，HTTP无法控制传输数据的内容，也没有任何预先的方法可以在特定请求的上下文中判断某一信息的敏感程度。因此，应用程序应尽可能向信息提供者提供对这些信息的控制权。在此背景下，有三个请求头字段值得特别提及：Server（服务器）、Referer（引用页面）和From（发件人）。

披露服务器的具体软件版本可能会使服务器更容易受到已知存在安全漏洞的软件攻击。实现者应将Server头字段设为可配置选项。

Referer字段允许研究访问模式并绘制反向链接。虽然它非常有用，但如果用户的个人信息未与Referer中的信息分离，其滥用风险也很高。即使个人信息已被删除，Referer字段仍可能指示某个私密文档的URI，公开该URI可能是不合适的。

From字段中发送的信息可能与用户的隐私利益或其站点的安全策略相冲突，因此不应在用户无法禁用、启用或修改该字段内容的情况下传输。用户必须能够在用户偏好设置或应用程序默认配置中设置该字段的内容。

我们建议（但不强制）为用户提供一个便捷的切换界面，以启用或禁用From和Referer信息的发送。

Berners-Lee 等人           信息性文档                     [第50页]

RFC 1945                        HTTP/1.0                        1996年5月

12.5 基于文件名和路径名的攻击

HTTP源服务器的实现应谨慎限制通过HTTP请求返回的文档，仅限于服务器管理员预期的内容。如果HTTP服务器将HTTP URI直接转换为文件系统调用，必须特别注意不要提供未被授权的文件。例如，Unix、Microsoft Windows及其他操作系统使用“..”作为路径组件，表示上一级目录。在此类系统中，HTTP服务器必须禁止在Request-URI中使用此类构造，以免访问超出预期范围的资源。同样，旨在仅供服务器内部参考的文件（如访问控制文件、配置文件和脚本代码）也必须受到保护，避免被不当检索，因为它们可能包含敏感信息。经验表明，这类HTTP服务器实现中的细微漏洞可能演变成安全风险。

13. 致谢

本规范大量采用了由David H. Crocker为RFC 822 [7]定义的增强BNF和通用结构。同样，它也重用了Nathaniel Borenstein和Ned Freed为MIME [5]提供的许多定义。我们希望将它们纳入本规范，能够帮助减少过去关于HTTP/1.0与互联网邮件消息格式之间关系的混淆。

在过去四年中，HTTP协议经历了显著的发展。它得益于庞大且活跃的开发者社区——即参与www-talk邮件列表的众多人士——正是这个社区在HTTP以及万维网的成功中发挥了最大作用。Marc Andreessen、Robert Cailliau、Daniel W. Connolly、Bob Denny、Jean-Francois Groff、Phillip M. Hallam-Baker、Hakon W. Lie、Ari Luotonen、Rob McCool、Lou Montulli、Dave Raggett、Tony Sanders以及Marc VanHeyningen在定义本规范早期版本的协议方面做出了特别贡献，值得特别表彰。

Paul Hoffman为本文件的资讯状态以及附录C和D部分提供了贡献。

本文件在很大程度上受益于所有参与HTTP工作组（HTTP-WG）成员的意见反馈。除了前述人士外，以下个人也为本规范的完善做出了贡献：

- Gary Adams
- Harald Tveit Alvestrand
- Keith Ball
- Brian Behlendorf
- Paul Burchard
- Maurizio Codogno
- Mike Cowlishaw
- Roman Czyborra
- Michael A. Dolan
- John Franks
- Jim Gettys
- Marc Hedlund
- Koen Holtman
- Alex Hopmann
- Bob Jernigan
- Shel Kaphan
- Martijn Koster
- Dave Kristol
- Daniel LaLiberte
- Paul Leach
- Albert Lunde
- John C. Mallery
- Larry Masinter
- Mitra
- Jeffrey Mogul
- Gavin Nicol
- Bill Perry
- Jeffrey Perry
- Owen Rees
- Luigi Rizzo
- David Robinson
- Marc Salomon
- Rich Salz
- Jim Seidman
- Chuck Shotton
- Eric W. Sink
- Simon E. Spero
- Robert S. Thau
- Francois Yergeau
- Mary Ellen Zurko
- Jean-Philippe Martin-Flatin

14. 参考文献

[1] Anklesaria, F., McCahill, M., Lindner, P., Johnson, D., Torrey, D., 和 B. Alberti, 《互联网Gopher协议：一种分布式文档搜索与检索协议》, RFC 1436, 明尼苏达大学, 1993年3月。

[2] 伯恩斯-李，T.，“万维网中的通用资源标识符：一种统一的语法，用于表达网络上对象的名称和地址”，RFC 1630，欧洲核子研究中心（CERN），1994年6月。

[3] 伯恩斯-李，T.，与D. 康诺利，“超文本标记语言——2.0”，RFC 1866，麻省理工学院/万维网联盟（MIT/W3C），1995年11月。

[4] 伯恩斯-李，T.，马辛特，L.，与M. 麦卡希尔，“统一资源定位符（URL）”，RFC 1738，欧洲核子研究中心（CERN）、施乐帕洛阿尔托研究中心（Xerox PARC）、明尼苏达大学，1994年12月。

[5] 博恩斯坦，N.，与N. 弗里德，“多用途互联网邮件扩展（MIME）第一部分：互联网消息体格式的机制”，RFC 1521，贝尔实验室（Bellcore）、Innosoft，1993年9月。

[6] 布雷登，R.，“互联网主机的需求——应用与支持”，STD 3，RFC 1123，互联网工程任务组（IETF），1989年10月。

[7] 克罗克，D.，“ARPA互联网文本消息格式标准”，STD 11，RFC 822，特拉华大学（UDEL），1982年8月。

[8] F. 戴维斯，B. 卡勒，H. 莫里斯，J. 萨利姆，T. 沈，R. 王，J. 随，和M. 格林鲍姆。“WAIS接口协议原型功能规范”（版本1.5），思考机器公司，1990年4月。

[9] 费尔丁，R.，“相对统一资源定位符”，RFC 1808，加州大学欧文分校，1995年6月。

[10] 霍顿，M.，与R. 亚当斯，“USENET消息交换标准”，RFC 1036（取代RFC 850），美国贝尔实验室，地震研究中心，1987年12月。

[11] 坎托尔，B.，与P. 拉普斯利，“网络新闻传输协议：一种面向流的新闻传输提案标准”，RFC 977，加州大学圣地亚哥分校，加州大学伯克利分校，1986年2月。

[12] 波斯特尔，J.，“简单邮件传输协议”，STD 10，RFC 821，美国南加州大学信息科学研究所（USC/ISI），1982年8月。

[13] 波斯特尔，J.，“媒体类型注册程序”，RFC 1590，美国南加州大学信息科学研究所（USC/ISI），1994年3月。

[14] 波斯特尔，J.，与J. 雷诺兹，“文件传输协议（FTP）”，STD 9，RFC 959，美国南加州大学信息科学研究所（USC/ISI），1985年10月。

[15] 雷诺兹，J.，与J. 波斯特尔，“已分配号码”，STD 2，RFC 1700，美国南加州大学信息科学研究所（USC/ISI），1994年10月。

[16] 索林斯，K.，与L. 马辛特，“统一资源名称的功能需求”，RFC 1737，麻省理工学院/信息与计算科学系（MIT/LCS），施乐公司，1994年12月。

[17] US-ASCII。编码字符集——7位美国信息交换标准代码（American Standard Code for Information Interchange），标准ANSI X3.4-1986，ANSI，1986年。

[18] ISO-8859. 国际标准——信息处理——8位单字节编码图形字符集——第1部分：拉丁字母表第1号，ISO 8859-1：1987。第2部分：拉丁字母表第2号，ISO 8859-2，1987。第3部分：拉丁字母表第3号，ISO 8859-3，1988。第4部分：拉丁字母表第4号，ISO 8859-4，1988。第5部分：拉丁/西里尔字母表，ISO 8859-5，1988。第6部分：拉丁/阿拉伯字母表，ISO 8859-6，1987。第7部分：拉丁/希腊字母表，ISO 8859-7，1987。第8部分：拉丁/希伯来字母表，ISO 8859-8，1988。第9部分：拉丁字母表第5号，ISO 8859-9，1990。

15. 作者联系方式

蒂姆·伯纳斯-李（Tim Berners-Lee）  
W3联盟主管  
麻省理工学院计算机科学实验室  
技术广场545号  
剑桥，马萨诸塞州 02139，美国  

传真：+1 (617) 258 8682  
电子邮件：timbl@w3.org

罗伊·T·菲尔丁（Roy T. Fielding）  
加州大学信息与计算机科学系  
尔湾分校  
邮编：92717-3425  
美国  

传真：+1 (714) 824 4056  
电子邮件：fielding@ics.uci.edu

亨里克·弗雷斯蒂克·尼尔森（Henrik Frystyk Nielsen）  
W3联盟  
麻省理工学院计算机科学实验室  
技术广场545号  
剑桥，马萨诸塞州 02139，美国  

传真：+1 (617) 258 8682  
电子邮件：frystyk@w3.org

伯纳斯-李等人  信息性文件  [第54页]

RFC 1945  HTTP/1.0  1996年5月

附录

这些附录仅供参考——它们不构成HTTP/1.0规范的一部分。

A. 互联网媒体类型 message/http

除了定义HTTP/1.0协议外，本文件还作为“message/http”互联网媒体类型的规范。以下内容需向IANA [13]注册。

- 媒体类型名称：message  
- 媒体子类型名称：http  
- 必需参数：无  
- 可选参数：version，msgtype

  - version：所封装消息的HTTP版本号（例如，“1.0”）。如果未提供，可以从正文的第一行中确定。  
  - msgtype：消息类型——“request”或“response”。如果未提供，可以从正文的第一行中确定。

- 编码考虑：仅允许“7bit”、“8bit”或“binary”。  
- 安全考虑：无

B. 宽容的应用程序

虽然本文件规定了生成HTTP/1.0消息的要求，但并非所有应用程序的实现都将是正确的。因此，我们建议操作性应用程序在偏差可以被明确解释的情况下，应对偏差表现出宽容。

客户端在解析状态行时应表现出宽容，而服务器在解析请求行时也应表现出宽容。特别是，它们应接受字段之间任何数量的空格（SP）或水平制表符（HT），尽管只要求使用一个空格。

HTTP头字段的行终止符是序列CRLF（回车换行）。然而，我们建议在解析此类头部时，应用程序应将单个LF（换行符）识别为行终止符，并忽略前导的CR（回车符）。

Berners-Lee 等人           信息性文档                     [第55页]

RFC 1945                        HTTP/1.0                        1996年5月

C.  与MIME的关系

HTTP/1.0 使用了许多为互联网邮件（RFC 822 [7]）和多用途互联网邮件扩展（MIME [5]）定义的结构，以允许实体以多种开放的表现形式进行传输，并具有可扩展的机制。然而，RFC 1521 讨论的是邮件，而HTTP具有一些不同于RFC 1521的特性。这些差异经过精心选择，旨在优化二进制连接的性能，允许更大的自由度使用新的媒体类型，简化日期比较，并考虑到一些早期HTTP服务器和客户端的实践。

在撰写本文时，预计RFC 1521将会被修订。修订内容可能包括一些在HTTP/1.0中采用但未在RFC 1521中描述的做法。

本附录描述了HTTP与RFC 1521在某些方面的具体差异。对严格MIME环境中的代理和网关应了解这些差异，并在必要时提供相应的转换。由MIME环境到HTTP的代理和网关也需要了解这些差异，因为可能需要进行一些转换。

C.1 转换为规范形式

RFC 1521要求在传输前将互联网邮件实体转换为规范形式，具体描述见RFC 1521的附录G [5]。本文第3.6.1节描述了在HTTP传输中“text”媒体类型的子类型允许的形式。

RFC 1521要求内容类型为“text”的内容将换行符表示为CRLF，并禁止在换行符序列之外使用CR或LF。而HTTP允许在文本内容中使用CRLF、单独的CR或单独的LF作为换行符，用于HTTP传输。

在可能的情况下，从HTTP到严格RFC 1521环境的代理或网关应将第3.6.1节中描述的文本媒体类型中的所有换行符转换为RFC 1521的规范形式CRLF。然而，这可能会因内容编码（Content-Encoding）的存在以及HTTP允许使用某些字符集（其中某些多字节字符集不使用字节13和10来表示CR和LF）而变得复杂。

伯恩斯-李等人           信息性内容                     [第56页]


RFC 1945                        HTTP/1.0                        1996年5月


C.2  日期格式的转换

   HTTP/1.0 使用一组有限的日期格式（第3.3节）以简化日期比较的过程。来自其他协议的代理和网关应确保消息中的任何Date头字段符合HTTP/1.0的格式之一，并在必要时对其进行重写。

C.3  内容编码的引入

   RFC 1521 不包含与HTTP/1.0的Content-Encoding头字段等价的概念。由于它作为媒体类型的修饰符，来自HTTP到符合MIME协议的代理和网关必须要么更改Content-Type头字段的值，要么在转发消息之前解码实体主体。（一些互联网邮件中Content-Type的试验性应用曾使用";conversions=<content-coding>"的媒体类型参数来执行与Content-Encoding相同的功能。然而，这个参数并不属于RFC 1521。）

C.4  无内容传输编码

   HTTP 不使用RFC 1521中的Content-Transfer-Encoding（CTE）字段。来自符合MIME协议的代理和网关在向HTTP客户端传递响应消息之前，必须移除任何非标识的CTE（如“quoted-printable”或“base64”）编码。

   从HTTP到符合MIME协议的代理和网关负责确保消息采用正确的格式和编码，以便在该协议上安全传输，其中“安全传输”由所使用协议的限制定义。如果这样做能提高在目标协议上的安全传输可能性，代理或网关应为数据标记适当的Content-Transfer-Encoding。

C.5 多部分正文中的HTTP头字段

   在RFC 1521中，多部分正文中的大多数头字段通常会被忽略，除非字段名以“Content-”开头。在HTTP/1.0中，多部分正文可以包含任何对该部分意义重要的HTTP头字段。

D.  附加特性

   本附录记录了一些现有HTTP实现中使用的协议元素，但在大多数HTTP/1.0应用中并未始终如一或正确使用。实现者应了解这些特性，但不能依赖它们的存在或与其他HTTP/1.0应用的互操作性。

D.1  额外的请求方法

D.1.1  PUT

PUT 方法请求将包含的实体存储在提供的请求 URI 下。如果请求 URI 指向一个已存在的资源，则应将包含的实体视为该资源的修改版本。如果请求 URI 不指向任何现有资源，并且该 URI 可以由请求的用户代理定义为一个新资源，则源服务器可以用该 URI 创建新资源。

POST 和 PUT 请求的根本区别在于请求 URI 的不同含义。POST 请求中的 URI 指定处理包含实体的资源，该实体作为要处理的数据。该资源可能是一个接受数据的处理程序、通往其他协议的网关，或一个接受注释的独立实体。而在 PUT 请求中，URI 指定随请求一同提交的实体——用户代理知道意图的 URI，服务器不应将请求应用到其他资源上。

D.1.2 DELETE

DELETE 方法请求源服务器删除由请求 URI 标识的资源。

D.1.3 LINK

LINK 方法在由请求 URI 标识的现有资源与其他现有资源之间建立一个或多个链接关系。

D.1.4 UNLINK

UNLINK 方法从由请求 URI 标识的现有资源中移除一个或多个链接关系。

D.2 其他头字段定义

D.2.1 Accept

Accept 请求头字段用于指示客户端可接受的响应媒体类型范围。星号“*”字符用于将媒体类型归入范围，“*/*”表示所有媒体类型，“type/*”表示该类型的所有子类型。客户端提供的范围集应反映在特定请求上下文中可接受的媒体类型。

D.2.2 Accept-Charset

Accept-Charset 请求头字段用于指示客户端偏好的字符集，除了默认的 US-ASCII 和 ISO-8859-1 之外。该字段允许能够理解更全面或特殊用途字符集的客户端向支持在这些字符集中表示文档的服务器传达其能力。

D.2.3 Accept-Encoding

Accept-Encoding 请求头字段类似于 Accept，但限制响应中可接受的内容编码值。

D.2.4 Accept-Language

Accept-Language 请求头字段类似于 Accept，但限制响应中偏好的自然语言集合。

D.2.5 Content-Language

内容-语言（Content-Language）实体头字段描述了所包含实体的目标受众所使用的自然语言。请注意，这可能并不等同于实体中使用的所有语言。

D.2.6 链接（Link）

链接（Link）实体头字段提供了一种描述实体与其他资源之间关系的方式。一个实体可以包含多个链接值。在元信息层面的链接通常表示层级结构和导航路径等关系。

D.2.7 MIME版本（MIME-Version）

HTTP消息可以包含一个MIME-Version通用头字段，用于指示构建该消息所使用的MIME协议的版本。根据RFC 1521 [5]定义，使用MIME-Version头字段应表明该消息符合MIME标准。不幸的是，一些较旧的HTTP/1.0服务器会无差别地发送该字段，因此应忽略此字段。

Berners-Lee 等人           信息性文档                     [第59页]

RFC 1945                        HTTP/1.0                        1996年5月

D.2.8 重试后（Retry-After）

重试后（Retry-After）响应头字段可以与503（服务不可用）响应一起使用，指示预期服务将不可用多长时间。该字段的值可以是HTTP日期或响应时间之后的整数秒数（十进制）。

D.2.9 标题（Title）

标题（Title）实体头字段指示实体的标题。

D.2.10 URI

URI实体头字段可能包含一些或全部的统一资源标识符（第3.2节），用于标识请求的URI资源。不能保证可以通过指定的URI访问到该资源。