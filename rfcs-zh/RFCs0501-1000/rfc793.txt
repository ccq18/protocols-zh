# RFC 793 中文翻译 (stub)
# 原文文件: ../../rfcs/RFCs0501-1000/rfc793.txt

RFC：793

传输控制协议（TRANSMISSION CONTROL PROTOCOL）

DARPA互联网计划协议规范

1981年9月

由以下机构准备：

国防高级研究计划局（Defense Advanced Research Projects Agency）
信息处理技术办公室（Information Processing Techniques Office）
地址：弗吉尼亚州阿灵顿，威尔逊大道1400号（1400 Wilson Boulevard）

由以下机构编写：

南加州大学信息科学研究所（Information Sciences Institute）
地址：加利福尼亚州马里纳德雷，阿德米拉蒂大道4676号（4676 Admiralty Way）
邮编：90291

1981年9月
传输控制协议（Transmission Control Protocol）

目录

前言 ........................................................ iii

1. 引言 ......................................................... 1

  1.1  动机 .................................................... 1
  1.2  范围 .................................................... 2
  1.3  关于本文档 ............................................ 2
  1.4  接口 .................................................... 3
  1.5  操作 .................................................... 3

2. 哲学 ......................................................... 7

  2.1  互联网系统的要素 ...................................... 7
  2.2  操作模型 ................................................ 7
  2.3  主机环境 ................................................ 8
  2.4  接口 .................................................... 9
  2.5  与其他协议的关系 ...................................... 9
  2.6  可靠通信 ............................................... 9
  2.7  连接建立与终止 ........................................ 10
  2.8  数据通信 ............................................... 12
  2.9  优先级与安全 ........................................... 13
  2.10 鲁棒性原则 ............................................. 13

3. 功能规范 ..................................................... 15

3.1  头部格式 .................................................. 15  
3.2  术语 ......................................................... 19  
3.3  序列号 ....................................................... 24  
3.4  建立连接 ..................................................... 30  
3.5  关闭连接 ..................................................... 37  
3.6  优先级与安全 ................................................. 40  
3.7  数据通信 ..................................................... 40  
3.8  接口 ......................................................... 44  
3.9  事件处理 ..................................................... 52  

术语表 ............................................................ 79  

参考文献 .......................................................... 85  

[第 i 页]  

1981年9月  
传输控制协议  

[第 ii 页]  

1981年9月  
传输控制协议  

前言  

本文档描述了国防部标准传输控制协议（TCP）。此前已有九个版本的ARPA TCP规范，这些规范构成了本标准的基础，现行文本在很大程度上借鉴了它们。在这份工作中，许多贡献者在概念和文本方面都做出了贡献。本版本澄清了若干细节，删除了端字缓冲区大小的调整，并将字母机制重新描述为一种推送功能。

乔恩·波斯特尔  
编辑  

[第 iii 页]  

RFC：793  
取代：RFC 761  
相关信息：129、124、112、81、55、44、40、27、21、5  

传输控制协议  
DARPA互联网计划协议规范  

1. 引言  

传输控制协议（TCP）旨在作为一种高可靠性的主机到主机协议，用于分组交换计算机网络中的主机之间，以及这些网络互联系统中的通信。  

本文档描述了传输控制协议应执行的功能、实现该协议的程序，以及其与需要其服务的程序或用户的接口。  

1.1  动机

计算机通信系统在军事、政府和民用环境中扮演着日益重要的角色。本文件主要关注军事计算机通信的需求，特别是在通信不可靠时的鲁棒性以及在拥塞情况下的可用性，但这些问题在民用和政府部门也同样存在。

随着战略和战术计算机通信网络的开发与部署，提供互联手段以及支持广泛应用的标准进程间通信协议变得至关重要。为了满足这一需求，国防部研究与工程副部长宣布本文所述的传输控制协议（TCP）将作为国防部范围内进程间通信协议标准化的基础。

TCP是一种面向连接、端到端的可靠协议，设计用于融入支持多网络应用的分层协议体系中。TCP提供在连接到不同但互联的计算机通信网络的主机计算机中的进程对之间的可靠通信。对底层通信协议的可靠性几乎没有假设。TCP假设它可以从底层协议获得一种简单的、可能不可靠的数据报服务。原则上，TCP应能在从硬连线连接到分组交换或电路交换网络的各种通信系统上运行。

TCP的概念最早由Cerf和Kahn在[1]中提出。TCP位于一个分层协议架构中，紧接在提供在互联网数据报“信封”中传输变长信息段的基础互联网协议[2]之上。互联网数据报提供了在不同网络中标识源和目的地TCP的途径。互联网协议还处理为了实现跨多网络和互连网关的传输与传递所需的TCP段的碎片化与重组。此外，互联网协议还携带有关TCP段的优先级、安全等级和隔离信息，以便这些信息能够在多个网络之间端到端传递。

协议层次结构

+---------------------+
|     高层协议        |
+---------------------+
|        TCP          |
+---------------------+
|  互联网协议         |
+---------------------+
| 通信网络            |
+---------------------+

图 1

本文的大部分内容是在TCP实现与主机计算机中较高层协议共存的背景下撰写的。一些计算机系统将通过前端计算机连接到网络，这些前端计算机中包含TCP和互联网协议层，以及特定于网络的软件。TCP规范描述了一个面向更高层协议的接口，这个接口似乎可以在前端场景中实现，只要实现了合适的主机到前端的协议。

1.2 范围

TCP旨在在多网络环境中提供可靠的进程到进程的通信服务。TCP被设计为一种在多个网络中常用的主机到主机协议。

1.3 关于本文档

本文档定义了任何TCP实现所需的行为规范，包括其与更高层协议的交互以及与其他TCP的交互。接下来的部分将简要介绍协议接口和操作。第2节总结了TCP设计的哲学基础。第3节则详细描述了在各种事件发生时（如新段到达、用户调用、错误等）TCP所需采取的行动，以及TCP段的格式细节。

1.4 接口

TCP在一端与用户或应用进程相连，另一端与较低层协议（如互联网协议）相连。

应用进程与TCP之间的接口在此进行了较为详细的说明。该接口由一组调用组成，类似于操作系统为应用程序提供的文件操作调用。例如，有用于打开和关闭连接，以及在已建立连接上发送和接收数据的调用。还预期TCP可以与应用程序进行异步通信。虽然允许TCP实现者根据特定操作系统环境设计适合的接口，但任何有效的实现都必须至少具备基本的功能，以满足TCP/用户接口的最低要求。

TCP与底层协议之间的接口基本上没有明确规定，唯一假设是存在一种机制，使得两个层级可以异步地相互传递信息。通常，底层协议会定义这个接口。本协议设计的目标是在一个高度互联的网络环境中工作。本文所假设的底层协议是互联网协议（IP）[2]。

1.5. 操作

如前所述，TCP的主要目的是在一对进程之间提供可靠、安全的逻辑电路或连接服务。在较不可靠的互联网通信系统上提供此类服务，需要在以下几个方面具备相应的功能：

- 基本数据传输
- 可靠性
- 流量控制
- 多路复用
- 连接管理
- 优先级和安全性

以下段落将介绍TCP在这些方面的基本操作。

【第3页】

1981年9月
传输控制协议
引言

基本数据传输：

TCP能够在两个用户之间传输连续的八位字节流，通过将一定数量的八位字节打包成段，进行互联网系统的传输。一般来说，TCP会根据自己的方便决定何时阻塞和转发数据。

有时，用户需要确保自己提交给TCP的所有数据都已被传输。为此，定义了一个推送（push）功能。为了确保提交给TCP的数据实际上已被传输，发送方可以指示数据应立即推送到接收方。推送会促使TCP立即转发并将数据传递到接收端。具体的推送点可能对接收方不可见，且推送功能不提供记录边界标记。

可靠性：

TCP必须能够从因互联网通信系统造成的损坏、丢失、重复或乱序交付的数据中恢复。实现方法是为每个传输的八位字节分配一个序列号，并要求接收端发回一个确认（ACK）。如果在超时时间内未收到确认，数据将被重新传输。在接收端，序列号用于正确排序可能乱序到达的段，并消除重复。损坏的数据通过在每个段中加入校验和进行检测，接收端检查后，损坏的段会被丢弃。

只要TCP正常工作，互联网系统不发生完全分割，传输错误就不会影响数据的正确交付。TCP能够从互联网通信系统的错误中恢复。

流量控制：

TCP 提供了一种让接收方控制发送方数据量的方法。这是通过在每个确认（ACK）中返回一个“窗口”来实现的，该窗口指示在成功接收最后一个数据段之后，允许接受的序列号范围。窗口表示在接收方允许的范围内，发送方在获得进一步许可之前可以传输的字节数。

多路复用：

为了让单个主机中的多个进程能够同时使用 TCP 通信功能，TCP 在每个主机内提供了一组地址或端口。将这些端口与互联网通信层的网络地址和主机地址连接起来，就形成了一个套接字（socket）。一对套接字唯一标识一条连接。也就是说，一个套接字可以在多个连接中同时使用。

端口与进程的绑定由每个主机独立处理。然而，将常用的进程（例如“日志记录”或时间共享服务）绑定到固定的套接字上，并将这些套接字公开，通常是非常有用的。这样，用户可以通过已知的地址访问这些服务。建立和获取其他进程的端口地址可能涉及更为动态的机制。

连接：

上述的可靠性和流量控制机制要求 TCP 初始化并维护每个数据流的某些状态信息。这些信息的组合，包括套接字、序列号和窗口大小，被称为连接。每个连接由一对套接字唯一标识，代表连接的两端。

当两个进程希望通信时，它们的 TCP 必须首先建立连接（初始化每一端的状态信息）。当通信结束后，连接会被终止或关闭，以释放资源供其他用途。

由于连接必须在不可靠的主机之间以及通过不可靠的互联网通信系统建立，因此采用带有时钟序列号的握手机制，以避免错误地初始化连接。

优先级与安全：

TCP 的用户可以指示其通信的安全性和优先级。当这些功能不需要时，也提供了默认值的设置。

1981年9月
传输控制协议

2. 哲学

2.1 网络互联系统的要素

网络互联环境由连接到网络的主机组成，这些网络又通过网关相互连接。在这里假设网络可以是局域网（例如以太网）或大型网络（例如ARPANET），但无论如何都基于分组交换技术。产生和消费消息的主动实体是进程。网络、网关和主机中的各种协议层支持一种进程间通信系统，该系统在逻辑连接上为进程端口提供双向数据流。

这里“分组”一词泛指主机与其网络之间一次事务的数据。网络中交换的数据块的格式通常不在我们的关注范围内。

主机是连接到网络的计算机，从通信网络的角度来看，它们是数据包的源头和目的地。进程被视为主机计算机中的主动元素（根据较为普遍的定义，进程是正在执行的程序）。甚至终端、文件或其他输入/输出设备也被视为通过进程相互通信。因此，所有通信都被视为进程间通信。

由于一个进程可能需要区分自己与另一个进程（或多个进程）之间的多个通信流，我们假设每个进程可能有多个端口，通过这些端口与其他进程的端口进行通信。

2.2 操作模型

进程通过调用TCP并传递数据缓冲区作为参数来传输数据。TCP将这些缓冲区中的数据封装成段，并调用互联网模块将每个段传输到目标TCP。接收端的TCP将段中的数据放入接收用户的缓冲区，并通知接收用户。TCP在段中包含控制信息，用于确保可靠的有序数据传输。

互联网通信的模型是，每个TCP都关联有一个互联网协议模块，该模块提供与本地网络的接口。这个互联网模块将TCP段封装在互联网数据报中，并将这些数据报路由到目标互联网模块或中间网关。为了通过本地网络传输数据报，它会被嵌入到本地网络数据包中。

数据包交换机可能会进行进一步的封装、碎片化或其他处理。

1981年9月
传输控制协议
哲学

为了实现本地数据包到目的地互联网模块的传递，还需要其他操作。

在网络之间的网关处，互联网数据报会被“解包”出其本地数据包，并进行检查，以确定互联网数据报下一步应通过哪个网络传输。然后，互联网数据报会被“包裹”在适合下一网络的本地数据包中，并被路由到下一个网关，或直接到达最终目的地。

允许网关将互联网数据报拆分成更小的互联网数据报碎片（如果通过下一网络传输需要这样做）。为此，网关会生成一组互联网数据报，每个携带一个碎片。碎片可以在后续的网关处进一步拆分成更小的碎片。互联网数据报碎片的格式设计使得目的地的互联网模块能够将碎片重新组装成完整的互联网数据报。

目的地的互联网模块会解包数据报中的段（在必要时重新组装数据报），并将其传递给目标的TCP。

这个简单的操作模型省略了许多细节。其中一个重要特性是服务类型。这为网关（或互联网模块）提供信息，以指导其选择在穿越下一网络时使用的服务参数。服务类型信息中还包括数据报的优先级。数据报还可以携带安全信息，以便在多级安全环境中操作的主机和网关能够正确地对数据报进行安全隔离。

2.3. 主机环境

假设TCP是操作系统中的一个模块。用户访问TCP的方式类似于访问文件系统。TCP可以调用其他操作系统功能，例如管理数据结构。与网络的实际接口假定由设备驱动程序模块控制。TCP不会直接调用网络设备驱动，而是调用互联网数据报协议模块，该模块可能会进一步调用设备驱动。

TCP的机制并不排除在前端处理器中实现TCP的可能性。然而，在这种实现中，主机到前端的协议必须提供支持本文所描述的TCP用户界面所需的功能。

[第8页]

1981年9月
传输控制协议
哲学

2.4. 接口

TCP/用户界面提供用户通过TCP发起的调用，用于打开或关闭连接、发送或接收数据，或获取连接的状态。这些调用类似于操作系统中其他用户程序的调用，例如打开、读取和关闭文件的调用。

TCP/互联网接口提供用于发送和接收数据报的调用，这些数据报的目标是互联网系统中任何主机上的TCP模块。这些调用具有传递地址、服务类型、优先级、安全性及其他控制信息的参数。

2.5  与其他协议的关系

下图展示了TCP在协议层次中的位置：

```
       +------+ +-----+ +-----+       +-----+                    
       |Telnet| | FTP | |Voice|  ...  |     |  应用层 
       +------+ +-----+ +-----+       +-----+                    
             |   |         |             |                       
            +-----+     +-----+       +-----+                    
            | TCP |     | RTP |  ...  |     | 主机层        
            +-----+     +-----+       +-----+                    
               |           |             |                       
            +-------------------------------+                    
            |    互联网协议 & ICMP        |  网关层     
            +-------------------------------+                    
                           |                                     
              +---------------------------+                      
              |   本地网络协议             |    网络层     
              +---------------------------+                      

协议关系图

第2图。

预计TCP能够高效支持更高层的协议。将诸如ARPANET的Telnet或AUTODIN II的THP等更高层协议接口到TCP应该是容易的。

2.6  可靠通信

在TCP连接上传输的数据流会可靠且按顺序到达目的地。

[第9页]

1981年9月
传输控制协议
哲学思想

传输的可靠性通过使用序列号和确认应答得以保证。从概念上讲，每个数据字节都被赋予一个序列号。一个数据段中第一个字节的序列号会与该段一起传送，称为段序列号。段还携带一个确认号，表示期望接收的下一个数据字节的序列号，即反方向传输中的确认应答。当TCP传输包含数据的段时，它会将该段复制一份放入重传队列，并启动一个计时器；当收到该数据的确认应答时，该段会从队列中删除。如果在计时器到期之前未收到确认，应答，TCP会重新传输该段。

TCP的确认应答并不保证数据已成功送达最终用户，而仅表示接收端的TCP已承担起责任去完成此任务。

为了控制TCP之间的数据流，采用了流量控制机制。接收端TCP会向发送端报告一个“窗口”，该窗口指示从确认号开始，接收端当前准备接收的字节数。

2.7 连接的建立与终止

为了识别TCP可能处理的不同数据流，TCP提供了端口标识符。由于端口标识符由每个TCP独立选择，可能并不唯一。为了在每个TCP内部提供唯一的地址，我们将标识TCP的互联网地址与端口标识符连接起来，形成一个套接字（socket），这样在所有连接的网络中都能保证唯一。

一个连接由两端的套接字对完全确定。一个本地套接字可以参与多个与不同远端套接字的连接。连接可以双向传输数据，即为“全双工”。

TCP可以自由地将端口与进程关联，但任何实现都必须具备一些基本概念。必须有一些众所周知的套接字，TCP会通过某种方式将它们仅与“合适的”进程关联。我们设想，进程可能“拥有”端口，且只能在其拥有的端口上发起连接。（实现所有权的方法是一个本地问题，但我们设想可以通过请求端口用户命令，或通过将端口号的高位与特定进程关联的方式，唯一分配一组端口给某个进程。）

在OPEN调用中，连接由本地端口和远端套接字参数共同指定。作为回应，TCP会提供一个（简短的）本地端口。

连接名称是用户在后续调用中用来引用该连接的标识。关于连接，有几件事必须记住。为了存储这些信息，我们假设存在一个名为传输控制块（Transmission Control Block，TCB）的数据结构。一种实现策略是将本地连接名作为指向该连接的TCB的指针。OPEN调用还会指定连接的建立方式，是主动发起还是被动等待。

被动OPEN请求意味着该进程希望接受传入的连接请求，而不是试图主动建立连接。通常，发起被动OPEN的进程会接受任何调用者的连接请求。在这种情况下，使用全零的“外来套接字”来表示未指定的套接字。未指定的外来套接字仅在被动OPEN中允许。

希望为未知其他进程提供服务的服务进程会发出带有未指定外来套接字的被动OPEN请求。这样，任何请求连接到该本地套接字的进程都可以建立连接。如果能确认该本地套接字与该服务相关联，将会更有帮助。

知名套接字（well-known sockets）是一种便捷的机制，用于预先将套接字地址与标准服务关联。例如，“Telnet-Server”进程被永久分配到某个特定的套接字，其他套接字则保留用于文件传输、远程作业输入、文本生成、回显和接收（后面三个用于测试目的）。一个套接字地址也可能被保留用于访问“查找”服务，该服务会返回新创建的服务所在的具体套接字。知名套接字的概念是TCP规范的一部分，但将套接字分配给具体服务的细节不在此规范范围内。（参见[4]）

进程可以发出被动OPEN，并等待其他进程发出匹配的主动OPEN，TCP会在连接建立后通知它们。当两个进程同时向对方发出主动OPEN时，它们也能正确连接。这种灵活性对于支持异步操作的分布式计算至关重要。

在本地被动OPEN和外来主动OPEN匹配的情况下，有两种主要情况。第一种情况是本地被动OPEN已完全指定外来套接字，此时匹配必须完全一致。第二种情况是本地被动OPEN未指定外来套接字，此时任何外来套接字都可以，只要本地套接字匹配即可。其他可能性还包括部分限制的匹配。

1981年9月
传输控制协议
基本思想

如果有多个待处理的被动打开请求（记录在传输控制块TCB中）使用相同的本地套接字，那么在匹配到具有特定远程套接字的主动打开请求之前，会优先匹配具有未指定远程套接字的TCB。

建立连接的过程利用同步（SYN）控制标志，并涉及三次消息交换。这一交换过程被称为“三次握手”。

连接的建立是由一个包含SYN的到达段与由用户打开命令创建的等待中的TCB条目相遇而触发的。匹配本地和远程套接字决定了连接何时被视为已启动。当双方的序列号都已同步时，连接即被视为“已建立”。

断开连接也涉及段的交换，此时段中携带FIN控制标志。

2.8 数据通信

在连接上传输的数据可以被视为一串八位字节（octets）。发送方在每次调用SEND时，指示该次传输（以及之前的传输）中的数据是否应立即通过设置PUSH标志推送到接收方。

允许发送端的TCP从用户收集数据，并在其方便时将数据分段发送，直到收到推送信号，此时必须发送所有未发送的数据。当接收端的TCP看到PUSH标志时，不得等待更多来自发送端的数据，而应立即将数据传递给接收进程。

推送功能与段边界之间没有必然关系。任何特定段中的数据可能是单次SEND调用的全部或部分结果，也可能是多次SEND调用的结果。

推送功能和PUSH标志的目的是将数据从发送用户推送到接收用户，而不提供记录服务。

推送功能与跨越TCP/用户接口的数据缓冲区的使用有关联。每当PUSH标志与放入接收用户缓冲区的数据相关联时，即使缓冲区未满，也会将缓冲区返回给用户进行处理。如果在看到PUSH之前，数据已到达并填满了用户的缓冲区，则这些数据会以缓冲区大小为单位传递给用户。

TCP还提供一种机制，用于通知接收端在数据流的某个位置，远离接收端的某个点，后续的数据比当前接收的更远。

目前正在阅读的内容涉及紧急数据。TCP并不试图定义在通知到有待处理的紧急数据时用户具体会采取什么行动，但一般的理解是接收进程会采取措施，快速处理这些紧急数据。

2.9. 优先级与安全性

TCP利用互联网协议中的服务类型字段和安全选项，为TCP用户提供基于每个连接的优先级和安全性保障。并非所有的TCP模块都能在多级安全环境中正常工作；一些可能仅限于非机密用途，另一些可能只在单一安全级别和隔离区中操作。因此，某些TCP实现和面向用户的服务可能仅限于多级安全环境的子集。

在多级安全环境中运行的TCP模块必须正确标记出站段的安全级别、隔离区和优先级。这些TCP模块还必须为用户或更高层协议（如Telnet或THP）提供接口，允许它们指定连接的所需安全级别、隔离区和优先级。

2.10. 鲁棒性原则

TCP的实现将遵循一项通用的鲁棒性原则：在自己所做的事情上要保守，在接受他人提供的内容上要宽容。

（以下为页面编号和出版信息，不必翻译）

第13页

1981年9月
传输控制协议

（后续内容为标题和章节编号，不必翻译）

3. 功能规范

3.1. 头部格式

TCP段作为互联网数据报进行传输。互联网协议头部包含多个信息字段，包括源主机和目的主机地址[2]。TCP头部紧随互联网头部，提供特定于TCP协议的信息。这种划分允许存在除TCP之外的其他主机级协议。

TCP头部格式

以下是该英文内容的中文翻译：

```
                                    
    0                   1                   2                   3   
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |          源端口               |       目的端口               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        序列号                                |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    确认号                                    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  数据偏移 | 保留 |U|A|P|R|S|F|                            |
   |          |       |R|C|S|S|Y|I|            窗口             |
   |          |       |G|K|H|T|N|N|                            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |           校验和               |         紧急指针           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    选项                    |    填充        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                             数据                                |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                            TCP头部格式

          注意：一个“tick mark”代表一个比特位。

                               图3。

  源端口：  16位

    源端口号。

  目的端口：  16位

    目的端口号。

                                                               [第15页]



                                                          1981年9月
传输控制协议
功能规范



  序列号：  32位

    本段中第一个数据八位组的序列号（除非
    存在SYN）。如果存在SYN，则序列号为初始序列号（ISN），
    第一个数据八位组为ISN+1。

  确认号：  32位

    如果ACK控制位被设置，此字段包含
    发送段的发送方期望接收的下一个序列号的值。一旦连接建立，
    该字段总是被发送。

  数据偏移：  4位

    TCP头部中32位字的数量。指示数据的起始位置。即使包含选项，TCP头部
    长度也是32位的整数倍。

  保留：  6位

    保留供将来使用。必须为零。

  控制位：  6位（从左到右）：

    URG：  紧急指针字段有效
    ACK：  确认字段有效
    PSH：  推送功能
    RST：  重置连接
    SYN：  同步序列号
    FIN：  发送方无更多数据

  窗口：  16位
```

开始于确认字段中指示的那个数据八位组数，发送该段的主机愿意接受的数量。

校验和：16位

校验和字段是所有头部和正文中所有16位字的一补码和的16位一补码。若一个段包含奇数个待校验的头部和正文八位组，则在最后一个八位组的右侧补零，形成一个16位字以进行校验。补零部分不会作为段的一部分传输。在计算校验和时，校验和字段本身被置零。

校验和还涵盖一个概念上的96位伪头部，该伪头部附加在TCP头部之前。这个伪头部包含源地址、目的地址、协议类型和TCP长度。这为TCP提供了对误路由段的保护。这些信息在互联网协议中携带，并在TCP调用IP的参数或结果中通过TCP/网络接口传输。

+--------+--------+--------+--------+
|           源地址                     |
+--------+--------+--------+--------+
|        目的地址                      |
+--------+--------+--------+--------+
|  零  |  协议  |    TCP长度             |
+--------+--------+--------+--------+

TCP长度是TCP头部长度加上数据长度（以八位组为单位）（这个值不是显式传输的，而是计算得出），且不包括伪头部的12个八位组。

紧急指针：16位

该字段传达当前紧急指针的值，作为相对于该段中序列号的正偏移量。紧急指针指向紧急数据之后的第一个八位组的序列号。只有在设置了URG控制位的段中，才会解释此字段。

选项：可变长度

选项可以占用TCP头部末尾的空间，长度为8位的倍数。所有选项都包含在校验和中。一个选项可以在任何八位组边界开始。选项的格式有两种情况：

情况1：单个八位组的选项类型。

情况2：一个八位组的选项类型，一个八位组的选项长度，以及实际的选项数据八位组。

选项长度包括两个八位组的选项类型和长度字段，以及所有的选项数据八位组。

请注意，选项列表可能比数据偏移字段所暗示的要短。头部中超出“选项结束”标志的内容必须是头部填充（即零）。

TCP必须实现所有选项。

                                                               [第17页]

                                                          1981年9月
传输控制协议
功能规范

目前定义的选项包括（类型以八进制表示）：

  类型     长度    含义
  ----     ------    -------
   0         -       选项列表结束。
   1         -       无操作。
   2         4       最大段大小（MSS）。

具体选项定义

  选项列表结束

    +--------+
    |00000000|
    +--------+
     类型=0

    该选项代码表示选项列表的结束。这可能与根据数据偏移字段所指示的TCP头部结束不同。这用于所有选项的末尾，而不是每个选项的末尾，只有在选项结束位置不与TCP头部结束位置重合时才需要使用。

  无操作

    +--------+
    |00000001|
    +--------+
     类型=1

    该选项代码可用于选项之间，例如，用于将后续选项的起始位置对齐到字边界。发送方不保证一定会使用此选项，因此接收方必须准备好处理即使不在字边界上的选项。

  最大段大小（MSS）

    +--------+--------+---------+--------+
    |00000010|00000100|  最大段大小  |
    +--------+--------+---------+--------+
     类型=2   长度=4

最大段大小选项数据：16位

如果存在此选项，则它传达发送该段的TCP的最大接收段大小。此字段只能在初始连接请求中（即在设置了SYN控制位的段中）发送。如果不使用此选项，则允许任何段大小。

填充：可变

TCP头部填充用于确保TCP头部结束和数据开始在32位边界上。填充由零组成。

3.2. 术语

在我们详细讨论TCP的操作之前，首先需要介绍一些详细的术语。维护一个TCP连接需要记住多个变量。我们将这些变量存储在一个称为传输控制块（Transmission Control Block，简称TCB）的连接记录中。存储在TCB中的变量包括本地和远程的套接字编号、连接的安全级别和优先级、指向用户的发送和接收缓冲区的指针、指向重传队列和当前段的指针。此外，还存储了几个与发送和接收序列号相关的变量。

**发送序列变量**

- SND.UNA（已确认的发送序列号）  
- SND.NXT（下一次要发送的序列号）  
- SND.WND（发送窗口）  
- SND.UP（紧急指针）  
- SND.WL1（用于上次窗口更新的段序列号）  
- SND.WL2（用于上次窗口确认的段序列号）  
- ISS（初始发送序列号）

**接收序列变量**

- RCV.NXT（下一次期望接收的序列号）  
- RCV.WND（接收窗口）  
- RCV.UP（接收紧急指针）  
- IRS（初始接收序列号）

以下图表有助于理解这些变量与序列空间的关系。

**发送序列空间**

```
                   1         2          3          4      
              ----------|----------|----------|---------- 
                     SND.UNA    SND.NXT    SND.UNA        
                                          +SND.WND        
```

- 1：已被确认的旧序列号  
- 2：未被确认的数据的序列号  
- 3：允许用于新数据传输的序列号范围  
- 4：未来的序列号，尚未被允许使用  

**发送序列空间图（图4）**

发送窗口是图4中标记为3的序列空间部分。

**接收序列空间**

```
                       1          2          3      
                   ----------|----------|---------- 
                          RCV.NXT    RCV.NXT        
                                    +RCV.WND        
```

- 1：已被确认的旧序列号  
- 2：允许用于新接收的序列号范围  
- 3：未来的序列号，尚未被允许使用  

**接收序列空间图（图5）**

接收窗口是图5中标记为2的序列空间部分。

此外，在讨论中还会频繁用到一些变量，这些变量的值来自当前段的字段。

1981年9月
传输控制协议
功能规范

当前段变量

  SEG.SEQ - 段序列号
  SEG.ACK - 段确认号
  SEG.LEN - 段长度
  SEG.WND - 段窗口
  SEG.UP  - 段紧急指针
  SEG.PRC - 段优先级值

连接在其生命周期中会经历一系列状态。这些状态包括：LISTEN（监听）、SYN-SENT（已同步已发送）、SYN-RECEIVED（已同步已接收）、ESTABLISHED（已建立）、FIN-WAIT-1（等待终止1）、FIN-WAIT-2（等待终止2）、CLOSE-WAIT（关闭等待）、CLOSING（关闭中）、LAST-ACK（最后确认）、TIME-WAIT（时间等待）以及虚构的状态CLOSED（关闭）。CLOSED是虚构的，因为它代表没有传输控制块（TCB）且没有连接的状态。简要说明各状态的含义如下：

LISTEN - 表示等待来自任何远程TCP和端口的连接请求。

SYN-SENT - 表示在已发送连接请求后，等待匹配的连接请求。

SYN-RECEIVED - 表示在既已接收又已发送连接请求后，等待确认连接请求的确认。

ESTABLISHED - 表示连接已打开，接收到的数据可以传递给用户。是连接数据传输阶段的正常状态。

FIN-WAIT-1 - 表示等待远程TCP的连接终止请求，或等待对之前发送的连接终止请求的确认。

FIN-WAIT-2 - 表示等待远程TCP的连接终止请求。

CLOSE-WAIT - 表示等待本地用户发出连接终止请求。

CLOSING - 表示等待远程TCP对连接终止请求的确认。

LAST-ACK - 表示等待对之前发出的连接终止请求的确认（该确认包括对其连接终止请求的确认）。

TIME-WAIT - 表示等待足够的时间以确保远程TCP已收到其连接终止请求的确认。

CLOSED - 表示没有任何连接状态。

TCP连接会根据事件从一个状态转变到另一个状态。这些事件包括用户调用的OPEN、SEND、RECEIVE、CLOSE、ABORT和STATUS；特别是那些包含SYN、ACK、RST和FIN标志的传入段；以及超时事件。

图6中的状态图仅展示了状态的变化，以及引发这些变化的事件和相应的动作，但未涉及错误条件或与状态变化无关的动作。在后续章节中，将对TCP对事件的反应提供更详细的说明。

注意事项：此图仅为摘要，不能作为完整的规范。

以下是该英文图示的中文翻译：

```
                                    
                              +---------+ ---------\      活跃连接（OPEN）  
                              |  关闭（CLOSED） |            \    -----------  
                              +---------+<---------\   \   创建传输控制块（TCB）  
                                |     ^              \   \  发送 SYN    
                   被动连接（PASSIVE OPEN）|     |   关闭（CLOSE）        \   \           
                   ------------ |     | ----------       \   \         
                    创建 TCB   |     | 删除 TCB         \   \       
                                V     |                      \   \     
                              +---------+            关闭（CLOSE）    |    \   
                              |  监听（LISTEN） |          ---------- |     |  
                              +---------+          删除 TCB |     |  
                   接收 SYN      |     |     发送（SEND）        |     |  
                  -----------   |     |    -------            |     V  
 +---------+      发送 SYN,ACK  /       \   发送 SYN          +---------+
 |         |<-----------------           ------------------>|         |
 |   SYN   |                    接收 SYN                     |   SYN   |
 |   已接收|<-----------------------------------------------|   已发送|
 |         |                    发送 ACK                     |         |
 |         |------------------           -------------------|         |
 +---------+   接收 SYN 的 ACK  \       /  接收 SYN,ACK       +---------+
   |           --------------   |     |   -----------                  
   |                  x         |     |     发送 ACK                    
   |                            V     V                                
   |  关闭（CLOSE）            +---------+                              
   | -------                  |  已建立（ESTAB） |                              
   | 发送 FIN                +---------+                              
   |                   关闭（CLOSE） |     |    接收 FIN                     
   V                  -------   |     |    -------                     
 +---------+          发送 FIN  /       \   发送 ACK          +---------+
 |  FIN    |<-----------------           ------------------>|  关闭（CLOSE） |
 | 等待1  |------------------                              |   等待（WAIT）  |
 +---------+          接收 FIN  \                            +---------+
   | 接收 FIN 的 ACK   -------   |                            关闭（CLOSE） |  
   | --------------   发送 ACK   |                           ------- |  
   V        x                   V                           发送 FIN V  
 +---------+                  +---------+                   +---------+
 |FIN等待2 |                  |  关闭中（CLOSING） |             | 最后确认（LAST-ACK）|
 +---------+                  +---------+                   +---------+
   |                接收 FIN 的 ACK |                 接收 FIN 的 ACK |  
   |  接收 FIN       -------------- |    超时=2MSL -------------- |  
   |  -------              x       V    ------------        x       V  
    \ 发送 ACK
```

CK                 +---------+ 删除 TCB         +---------+
     ------------------------>| TIME WAIT |------------------>| CLOSED  |
                              +---------+                   +---------+

TCP连接状态图
图6。

[第23页]

1981年9月
传输控制协议
功能规范

3.3. 序列号

在设计中，一个基本的概念是通过TCP连接发送的每个字节数据都具有一个序列号。由于每个字节都被编号，因此每个字节都可以被确认。所采用的确认机制是累积确认，即对序列号X的确认表示已收到所有编号小于X的字节（但不包括X本身）。这种机制在重传的情况下可以方便地检测到重复数据。段内字节的编号方式是：紧接在头部之后的第一个数据字节为最低编号，后续字节依次递增编号。

必须记住，实际的序列号空间是有限的，虽然非常大。这个空间的范围是从0到2^32 - 1。由于空间是有限的，所有涉及序列号的算术运算都必须以模2^32进行。这种无符号的模运算保持了序列号在循环时的关系，即从2^32 - 1回到0。计算机的模运算存在一些细微差别，因此在编程中比较这些值时应格外小心。符号“=<”表示“less than or equal to”（小于或等于）（模2^32）。

TCP在进行序列号比较时，常用的类型包括：

(a) 判断确认是否对应某个已发送但尚未确认的序列号。

(b) 判断一个段所占用的所有序列号是否都已被确认（例如，从重传队列中移除该段）。

(c) 判断接收的段是否包含预期的序列号（即，该段是否“重叠”在接收窗口内）。

[第24页]

1981年9月
传输控制协议
功能规范

在发送数据后，TCP会收到确认。以下比较操作是处理确认所必需的。

SND.UNA = 最早未确认的序列号

SND.NXT = 下一次要发送的序列号

SEG.ACK = 来自接收端TCP的确认（接收端期望的下一个序列号）

SEG.SEQ = 一个段的第一个序列号

SEG.LEN = 该段中数据占用的字节数（包括SYN和FIN标志）

SEG.SEQ + SEG.LEN - 1 = 一个段的最后一个序列号

一种新的确认（称为“可接受确认”）满足以下不等式：

  SND.UNA < SEG.ACK ≤ SND.NXT

在重传队列中的一个段如果其序列号加上长度的和小于或等于接收段中的确认值，则被视为已完全确认。

当接收数据时，需要进行以下比较：

  RCV.NXT = 期望接收的下一个序列号，也是接收窗口的左边界或较低边界

  RCV.NXT + RCV.WND - 1 = 期望接收的最后一个序列号，也是接收窗口的右边界或较高边界

  SEG.SEQ = 传入段占用的第一个序列号

  SEG.SEQ + SEG.LEN - 1 = 传入段占用的最后一个序列号

如果满足以下条件之一，则判断一个段占用了有效的接收序列空间：

  RCV.NXT ≤ SEG.SEQ < RCV.NXT + RCV.WND

或

  RCV.NXT ≤ SEG.SEQ + SEG.LEN - 1 < RCV.NXT + RCV.WND

[第25页]

1981年9月
传输控制协议
功能规范

此检测的第一部分检查段的起始位置是否在窗口内，第二部分检查段的结束位置是否在窗口内；只要段通过任意一部分的检测，就说明该段包含在窗口内的数据。

实际上，这比这更复杂一些。由于存在零窗口和零长度段，我们将接收段的可接受性分为四种情况：

| 段长度 | 窗口大小 | 说明 |
|---------|----------|-------|
| 0       | 0        | SEG.SEQ = RCV.NXT |
| 0       | >0       | RCV.NXT ≤ SEG.SEQ < RCV.NXT + RCV.WND |
| >0      | 0        | 不可接受 |
| >0      | >0       | RCV.NXT ≤ SEG.SEQ < RCV.NXT + RCV.WND 或 RCV.NXT ≤ SEG.SEQ + SEG.LEN - 1 < RCV.NXT + RCV.WND |

注意，当接收窗口为零时，除了ACK段外，不应接受任何段。因此，TCP可以在保持零接收窗口的同时，继续传输数据和接收确认（ACK）。然而，即使接收窗口为零，TCP仍必须处理所有传入段的RST和URG字段。

我们利用编号方案也对某些控制信息进行了保护。这是通过在序列空间中隐含地包含一些控制标志来实现的，这样它们就可以被重新传输和确认，而不会引起混淆（即，只有一份控制信息会被处理）。控制信息不会在段数据空间中物理携带。因此，我们必须制定规则，隐式地为控制信息分配序列号。只有SYN和FIN这两种控制信息需要这种保护，这些控制信息仅在连接的建立和关闭时使用。就序列号而言，SYN被视为发生在它所在段的第一个实际数据八字节之前，而FIN被视为发生在它所在段的最后一个实际数据八字节之后。段长度（SEG.LEN）包括数据和占用序列空间的控制信息。当存在SYN时，SEG.SEQ即为SYN的序列号。

【第26页】

1981年9月  
传输控制协议  
功能规范

初始序列号的选择

该协议对某一连接可以反复使用没有任何限制。一个连接由一对套接字定义。新的连接实例将被称为该连接的“化身”。由此引发的问题是——“TCP如何识别来自之前化身的重复段？”当连接快速开启和关闭，或连接因内存丢失而中断后重新建立时，这个问题就会变得明显。

为了避免混淆，我们必须防止来自某一化身的段被误用，同时网络中可能仍存在来自早期化身的相同序列号。我们希望确保这一点，即使TCP崩溃并丢失了所有已使用序列号的知识。当创建新连接时，会使用一个初始序列号（ISN）生成器，该生成器会选择一个新的32位ISN。这个生成器绑定到一个（可能是虚构的）32位时钟上，其最低位大约每4微秒递增一次。因此，ISN大约每4.55小时循环一次。由于我们假设段在网络中的存留时间不会超过最大段寿命（MSL），且MSL少于4.55小时，因此可以合理地认为ISN是唯一的。

每个连接都有一个发送序列号和一个接收序列号。初始发送序列号（ISS）由数据发送端的TCP选择，初始接收序列号（IRS）则在连接建立过程中得知。

为了建立或初始化连接，双方的TCP必须在彼此的初始序列号上进行同步。这通过交换携带控制位“SYN”（同步）和初始序列号的连接建立段来完成。简而言之，携带SYN位的段也被称为“SYN段”。因此，解决方案需要一种合适的机制来选择初始序列号，并通过一个稍微复杂的握手过程来交换这些序列号。

同步过程要求每一方都发送自己的初始序列号，并收到对方确认的应答。每一方还必须接收对方的初始序列号，并发送确认应答。

1）A --> B 发送SYN，序列号为X  
2）A <-- B 发送ACK，确认对方的序列号为X  
3）A <-- B 发送SYN，序列号为Y  
4）A --> B 发送ACK，确认对方的序列号为Y

由于步骤2和步骤3可以合并成一条消息，这个过程被称为“三次握手”或“三次消息握手”。

三次握手是必要的，因为序列号在网络中并不绑定于全局时钟，且不同的TCP实现可能采用不同的机制来选择初始序列号。第一个SYN的接收方无法判断该段是否是旧的延迟段，除非它记得连接中使用的最后一个序列号（但这并不总是可能的），因此必须请求发送方验证这个SYN。关于三次握手和基于时钟的方案的优势，详见[3]。

何时保持沉默

为了确保TCP不会产生携带可能与网络中残留的旧段重复的序列号的段，TCP在启动或从崩溃中恢复（丢失了已用序列号的记忆）时，必须在最大段生存时间（MSL）内保持沉默，之后才能分配新的序列号。对于本规范，MSL取为2分钟。这是一个工程上的选择，如果经验表明有必要，也可以进行调整。注意，如果某个TCP在某种意义上重新初始化，但仍保留其已用序列号的记忆，则无需等待；只需确保使用比最近使用的序列号更大的序列号。

TCP的静默时间概念

本规范规定，主机在“崩溃”后，如果未能保留关于每个活动（即未关闭）连接上最后传输的序列号的任何信息，则应在其所属的互联网系统中，延迟至少一个商定的最大段寿命（MSL）后，才开始发出任何TCP段。在下面的段落中，将对该规范进行解释。TCP的实现者可以违反“静默时间”的限制，但这样做的风险是可能导致一些旧数据被接受为新数据，或者新数据被某些互联网系统中的接收方误认为是旧的重复数据。

每次形成一个段并将其放入源主机的网络输出队列时，TCP都会消耗一部分序列号空间。TCP协议中的重复检测和排序算法依赖于段数据与序列空间的唯一绑定，确保在段数据绑定的序列号在被接收方交付并确认之前，不会循环使用所有的2^32个值。没有这种假设，两个不同的TCP段可能会被分配相同或重叠的序列号，从而导致接收方难以判断哪些数据是新的，哪些是旧的。请记住，每个段都绑定有与其数据字节数相等的连续序列号。

在正常情况下，TCP会跟踪下一个要发出的序列号以及等待确认的最旧序列号，以避免在确认之前重复使用某个序列号。仅靠这一点并不能保证旧的重复数据已从网络中清除，因此，序列空间被设计得非常大，以降低意外重复段到达时引发问题的可能性。在以2兆比特/秒的速率传输时，耗尽2^32字节的序列空间需要4.5小时。由于网络中的最大段寿命不太可能超过几十秒，这被认为对可预见的网络来说已足够安全，即使数据速率升高到数十兆比特/秒也是如此。在100兆比特/秒的速率下，循环时间为5.4分钟，可能略短，但仍在合理范围内。

TCP中的基本重复检测和排序算法可以被绕过，前提是源端TCP没有记忆在特定连接上最后使用的序列号。例如，如果TCP在所有连接中都以序列号0开始，那么在崩溃并重启后，TCP可能会重新建立一个早期的连接（可能是在半开连接解决之后），并发出序列号与网络中仍存在的早期连接发出的包相同或重叠的包。在没有关于特定连接上使用的序列号的知识的情况下，TCP规范建议源端在发出段之前延迟MSL秒，以允许早期连接的段从系统中排出。

即使是能够记住时间并用其选择初始序列号的主机，也不能完全避免这个问题（即使使用时间来为每个新连接实例选择初始序列号）。

举例来说，假设建立一个连接，起始序列号为S。假设这个连接使用不多，最终初始序列号函数（ISN(t)）的值变为该TCP在某个连接上最后发送的段的序列号，比如S1。现在假设此时主机崩溃、恢复，并建立了该连接的一个新实例。所选择的初始序列号为S1 = ISN(t)——即旧实例中最后使用的序列号！如果恢复发生得足够快，网络中带有接近S1的序列号的旧重复包可能会到达，并被新连接的接收端视为新包。

问题在于，恢复中的主机可能不知道它崩溃了多长时间，也不知道系统中是否仍存在来自早期连接实例的旧重复包。

处理这个问题的一种方法是故意延迟在从崩溃恢复后的一段时间（即“静默期”）内发出数据段。这段时间被称为“静默时间”。那些倾向于避免等待的主机，可能愿意冒着在某个目的地可能混淆旧包和新包的风险，选择不等待“静默时间”。实现者可以为TCP用户提供在每个连接基础上选择崩溃后是否等待的能力，或者非正式地为所有连接实现“静默时间”。显然，即使用户选择“等待”，在主机已“上线”至少MSL秒后，也没有必要等待。

总结一下：每个发出的数据段在序列空间中占用一个或多个序列号，直到MSL秒过去，这些序列号被视为“繁忙”或“在用”。当发生崩溃时，一块时空被前一个发出的数据段的字节占用。如果在太早的时候启动新连接，并且使用了前一个连接的最后一个数据段的序列空间中的任何序列号，就可能出现序列号重叠区域，这可能会引起接收端的混淆。

3.4 建立连接

“三次握手”是用来建立连接的过程。这个过程通常由一方TCP发起，另一方TCP响应。如果两个TCP同时发起连接请求，这个过程也能正常工作。当同时尝试时，每个TCP都会收到一个带有“同步”标志（SYN）的段，且在发送SYN后没有确认（ACK）。当然，旧的重复SYN段的到达可能会让接收方误以为正在进行同时连接的尝试。正确使用“重置”段可以消除这些歧义。

以下是一些连接发起的示例。虽然这些示例没有显示使用携带数据的段进行连接同步，但这是完全合法的，只要接收端在确认数据有效之前不将数据交付给用户（即，数据必须在接收端缓冲，直到连接达到“已建立”状态）。三次握手减少了误判连接的可能性。这是一种在内存和消息之间进行权衡的实现方式，旨在提供用于验证的必要信息。

以下是英文内容的中文翻译：

```
  最简单的三次握手过程如图7所示。图中的各行应按以下方式解读。每行都编号以便参考。右箭头（-->）表示TCP段从TCP A发出到TCP B，或从B到A的到达。左箭头（<--）表示相反的方向。省略号（...）表示该段仍在网络中（有延迟）。“XXX”表示该段丢失或被拒绝。括号中的内容为注释。TCP状态表示在段发出或到达后系统所处的状态（段的内容显示在每行的中间部分）。段的内容以简写形式显示，包括序列号、控制标志和确认号字段。为了清晰起见，窗口、地址、长度和文本等其他字段已省略。

      TCP A                                                TCP B

  1.  关闭状态                                            监听状态

  2.  SYN已发送    --> <SEQ=100><CTL=SYN>               --> SYN已接收

  3.  已建立 <-- <SEQ=300><ACK=101><CTL=SYN,ACK>  <-- SYN已接收

  4.  已建立 --> <SEQ=101><ACK=301><CTL=ACK>       --> 已建立

  5.  已建立 --> <SEQ=101><ACK=301><CTL=ACK><DATA> --> 已建立

          连接同步的基本三次握手

                                图7。

在图7的第2行中，TCP A开始发送一个SYN段，表示其将使用序列号100开始。第3行中，TCP B发送一个SYN，并对收到的TCP A的SYN进行确认。注意确认字段显示TCP B现在期望收到序列号101，确认了占用序列号100的SYN。

在第4行，TCP A回应一个空段，包含对TCP B的SYN的确认；第5行，TCP A发送一些数据。注意，第5行段的序列号与第4行相同，因为确认（ACK）不占用序列号空间（如果占用，我们就会确认确认的ACK了！）。

同时发起连接的情况稍微复杂一些，如图8所示。每个TCP状态从关闭（CLOSED）循环到SYN-SENT、SYN-RECEIVED，再到已建立（ESTABLISHED）。

      TCP A                                            TCP B

  1.  关闭                                              关闭

  2.  SYN已发送     --> <SEQ=100><CTL=SYN>             ...

  3.  SYN已接收 <-- <SEQ=300><CTL=SYN>             <-- SYN已发送

  4.               ... <SEQ=100><CTL=SYN>             --> SYN已接收

  5.  SYN已接收 --> <SEQ=100><ACK=301><CTL=SYN,ACK> ...

  6.  已建立  <-- <SEQ=300><ACK=101><CTL=SYN,ACK> <-- SYN已接收

  7.               ... <SEQ=101><ACK=301><CTL=ACK>    --> 已建立
```

同步连接与同步

图8.

三次握手的主要原因是为了防止旧的重复连接请求引起混乱。为此，设计了一种特殊的控制消息——重置（reset）。如果接收端的TCP处于非同步状态（即SYN-SENT或SYN-RECEIVED），收到一个有效的重置消息后会返回到监听（LISTEN）状态。如果TCP处于已同步的状态（ESTABLISHED、FIN-WAIT-1、FIN-WAIT-2、CLOSE-WAIT、CLOSING、LAST-ACK、TIME-WAIT），它会中止连接并通知其用户。我们将在下面的“半开连接”部分讨论后一种情况。

[第32页]

1981年9月
传输控制协议
功能规范

TCP A                                              TCP B

1.  关闭（CLOSED）                                    监听（LISTEN）

2.  发送同步（SYN） --> <SEQ=100><CTL=SYN>             ...

3.  （重复的）... <SEQ=90><CTL=SYN>                   --> SYN-RECEIVED

4.  发送同步（SYN） <-- <SEQ=300><ACK=91><CTL=SYN,ACK>  <-- SYN-RECEIVED

5.  发送同步（SYN） --> <SEQ=91><CTL=RST>             --> 监听（LISTEN）

6.             ... <SEQ=100><CTL=SYN>                   --> SYN-RECEIVED

7.  发送同步（SYN） <-- <SEQ=400><ACK=101><CTL=SYN,ACK>  <-- SYN-RECEIVED

8.  连接已建立（ESTABLISHED） --> <SEQ=101><ACK=401><CTL=ACK>  --> 连接已建立

从旧重复SYN的恢复

图9.

作为从旧重复SYN中恢复的一个简单例子，考虑图9。在第3行，TCP B收到一个旧的重复SYN。TCP B无法判断这是一个旧的重复请求，因此会正常响应（第4行）。TCP A检测到ACK字段不正确，返回一个带有自己选择的SEQ字段的RST（重置）段，以使该段看起来可信。TCP B在收到RST后，返回到监听（LISTEN）状态。当原始的SYN（打趣地称为“原始”）最终到达第6行时，连接同步会正常进行。如果第6行的SYN在RST之前到达，可能会发生更复杂的交换，RST会在两个方向上都被发送。

半开连接与其他异常情况

如果一端的TCP关闭或中止了连接，而另一端尚未得知，或者由于崩溃导致内存丢失，连接就被称为“半开”。此类连接在尝试在任一方向发送数据时会自动被重置（reset）。然而，半开连接通常较为少见，且其恢复过程略微复杂。

如果站点A上的连接不再存在，那么...

以下是英文内容的中文翻译：

```

                                                               [第33页]



                                                          1981年9月
传输控制协议
功能规范



在站点B的用户尝试发送任何数据时，站点B的TCP将收到一个重置控制消息。该消息向站点B的TCP表明出现了问题，预计会中止连接。

假设两个用户进程A和B正在通信，当发生崩溃导致A的TCP丢失内存时。根据支持A的TCP的操作系统，可能存在某种错误恢复机制。当TCP重新启动后，A可能会从头开始或从某个恢复点重新开始。因此，A很可能会再次尝试打开连接，或者尝试在它认为已打开的连接上发送数据。在后一种情况下，它会收到本地（A的）TCP发来的错误信息“连接未打开”。为了建立连接，A的TCP会发送一个包含SYN的段。这种情况导致了图10所示的示例。在TCP A崩溃后，用户试图重新打开连接。与此同时，TCP B认为连接仍然是打开的。

  

      TCP A                                           TCP B

  1.  (崩溃)                               (发送300，接收100)

  2.  关闭状态                                           已建立

  3.  SYN已发送 --> <SEQ=400><CTL=SYN>              --> (??)

  4.  (!!)     <-- <SEQ=300><ACK=100><CTL=ACK>     <-- 已建立

  5.  SYN已发送 --> <SEQ=100><CTL=RST>              --> (中止!!)

  6.  SYN已发送                                         关闭

  7.  SYN已发送 --> <SEQ=400><CTL=SYN>              -->

                     半开连接发现

                               图10。

当第3行中的SYN到达时，处于同步状态的TCP B，且收到的段超出窗口，会用确认应答（ACK）回应，指示它下一次期望听到的序列号（ACK=100）。TCP A看到这个段没有确认它所发送的任何内容，并且由于不同步，发送了一个重置（RST），因为它检测到一个半开连接。TCP B在第5行中中止。TCP A将会继续尝试建立连接；此时问题已简化为图7中的基本三次握手过程。
```

当TCP A崩溃，而TCP B试图在它认为已同步的连接上发送数据时，会出现一种有趣的替代情况。这在图11中有所示意。在这种情况下，从TCP B到TCP A的数据（第2行）是不可接受的，因为不存在这样的连接，所以TCP A会发送一个RST（重置）包。这个RST包是可以接受的，因此TCP B会处理它并中止连接。

图11中，主动方导致半开连接的发现。

在图12中，我们看到两个TCP端点A和B处于被动等待SYN的状态。一个旧的重复包到达TCP B（第2行），激起了B的反应。B返回一个SYN-ACK（第3行），这导致TCP A生成一个RST（第3行中的ACK不被接受）。TCP B接受重置包，并返回到被动的LISTEN状态。

图12中，旧的重复SYN在两个被动套接字上引发重置。

此外，还存在其他多种情况，所有这些情况都可以通过以下关于RST生成和处理的规则来解释。

重置（RST）生成规则

一般而言，当收到的段明显不是针对当前连接时，必须发送重置（RST）。如果不能确定是否如此，则不应发送RST。

重置的生成分为三类状态：

1. 如果连接不存在（CLOSED状态），则对任何到达的段（除了另一个RST段）都应发送RST。特别是，发往不存在连接的SYN段会被拒绝。

2. 如果收到的段中包含ACK字段，重置包的序列号取自该段的ACK字段；否则，重置包的序列号为零，ACK字段设置为收到段的序列号加上段长度。连接在此状态下仍保持在CLOSED状态。

2. 如果连接处于任何非同步状态（LISTEN、SYN-SENT、SYN-RECEIVED），并且传入的段确认了尚未发送的内容（该段携带了不可接受的确认号ACK），或者传入的段具有与连接请求的安全级别或隔离级别不完全匹配的安全级别或隔离级别，则会发送重置（RST）包。

如果我们的SYN尚未被确认，并且传入段的优先级高于请求的优先级，则要么在允许的情况下提高本地优先级（如果用户和系统允许），要么发送重置；或者如果传入段的优先级低于请求的优先级，则继续处理，假设优先级完全匹配（如果远端TCP不能将优先级提高以匹配我们的优先级，这将在它发送的下一段中被检测到，连接也会因此终止）。如果我们的SYN已被确认（可能在此传入段中确认），那么传入段的优先级必须与本地优先级完全匹配，否则必须发送重置。

如果传入段带有ACK字段，重置包的序列号取自该段的ACK字段，否则重置包的序列号为零，并且ACK字段设置为传入段的序列号加上段长度的和。连接保持在原有状态。

[第36页]

1981年9月
传输控制协议
功能规范

3. 如果连接处于已同步状态（ESTABLISHED、FIN-WAIT-1、FIN-WAIT-2、CLOSE-WAIT、CLOSING、LAST-ACK、TIME-WAIT），任何不可接受的段（超出窗口的序列号或不可接受的确认号）都只应引发一个空的确认段，包含当前的发送序列号和指示下一次预期接收的序列号的确认号，连接保持在相同状态。

如果传入段具有安全级别、隔离级别或优先级，并且与连接请求的级别、隔离级别或优先级不完全匹配，则会发送重置（RST）包，连接进入CLOSED状态。重置包的序列号取自该段的ACK字段。

重置处理

在除SYN-SENT状态外的所有状态中，所有的重置（RST）段都通过检查其SEQ字段进行验证。只有当其序列号在窗口范围内时，重置才有效。在SYN-SENT状态（收到对初始SYN的响应的RST），如果ACK字段确认了SYN，则该RST是可接受的。

接收端在收到一个重置（RST）信号后，首先会对其进行验证，然后改变状态。如果接收端之前处于监听（LISTEN）状态，它会忽略该信号。如果接收端之前处于同步已接收（SYN-RECEIVED）状态，并且之前处于监听状态，那么它会返回到监听状态；否则，接收端会中止连接并进入关闭（CLOSED）状态。如果接收端处于其他任何状态，它会中止连接，通知用户，并进入关闭状态。

3.5  关闭连接

关闭（CLOSE）是一种操作，意味着“我没有更多数据要发送”。当然，关于全双工连接的关闭概念存在歧义，因为可能不清楚如何处理连接的接收端。我们选择以单向的方式处理关闭。发起关闭的用户可以继续接收（RECEIVE）直到被通知另一端也已关闭（CLOSED）。因此，一个程序可以先发起多次发送（SEND），然后发出关闭请求（CLOSE），接着继续接收，直到收到信号表明接收失败（因为另一端已关闭）。我们假设TCP会向用户可靠地通知，即使没有未完成的接收操作，也会通知用户另一端已关闭，以便用户可以优雅地终止自己的连接。TCP会可靠地传送在连接关闭前已发送的所有缓冲区，因此，期望没有返回数据的用户只需等待连接成功关闭的通知，即可确认所有数据已到达目标TCP。用户必须持续读取直到TCP通知没有更多数据可发送。

基本上有三种情况：

1) 用户主动请求TCP关闭连接

2) 远端TCP通过发送FIN控制信号发起关闭

3) 双方同时关闭

情况一：本地用户发起关闭

在这种情况下，可以构造一个FIN段并放入发送队列。此后，TCP不再接受用户的任何发送请求，并进入FIN-WAIT-1状态。在此状态下允许接收（RECEIVE）操作。所有在此之前及包括FIN的段都会被重传，直到被确认。当另一端TCP既确认了FIN，又发送了自己的FIN时，第一端TCP可以确认（ACK）这个FIN。注意，接收FIN的TCP会确认（ACK）但不会立即发送自己的FIN，直到用户也关闭了连接。

情况二：TCP从网络接收到FIN信号

如果从网络收到一个未请求的终止（FIN）信号，接收端的TCP可以确认（ACK）它，并告诉用户连接即将关闭。用户会回应一个关闭请求（CLOSE），此时TCP可以在发送完剩余数据后向另一端的TCP发送一个终止（FIN）信号。之后，TCP会等待自己的FIN被确认（ACK），确认后便会删除该连接。如果没有收到确认，经过用户设定的超时后，连接将被中止，并通知用户。

案例3：双方同时关闭

当连接两端的用户同时发起关闭操作时，会交换FIN段。当所有在FIN之前的段都已被处理和确认后，双方的TCP都可以确认（ACK）自己收到的FIN。收到这些确认后，双方会删除该连接。

（以下为示意图，描述了两端TCP在正常关闭和同时关闭时的状态转换过程）

[页面38]

1981年9月
传输控制协议
功能规范

（示意图：TCP A 和 TCP B 的状态转换）

1. 连接已建立（ESTABLISHED）

2. 用户发起关闭（Close）
   TCP A：FIN-WAIT-1  --> <SEQ=100><ACK=300><CTL=FIN,ACK>  --> TCP B：CLOSE-WAIT
   TCP B：FIN-WAIT-1  <-- <SEQ=300><ACK=101><CTL=ACK>  <-- TCP A：CLOSE-WAIT

3. TCP A：FIN-WAIT-2  <-- <SEQ=300><ACK=101><CTL=ACK>
   TCP B：CLOSE-WAIT

4. 用户发起关闭（Close）
   TCP B：TIME-WAIT  <-- <SEQ=300><ACK=101><CTL=FIN,ACK>  <-- TCP A：LAST-ACK

5. TCP A：TIME-WAIT  --> <SEQ=101><ACK=301><CTL=ACK>  --> TCP B：CLOSED

6. 经过2个最大段寿命（MSL）后，连接关闭

（正常关闭序列）

图13

（示意图：双方同时关闭的状态转换）

1. 连接已建立（ESTABLISHED）

2. 用户发起关闭（Close）
   TCP A：FIN-WAIT-1  --> <SEQ=100><ACK=300><CTL=FIN,ACK>  ... 
   TCP B：FIN-WAIT-1  <-- <SEQ=300><ACK=100><CTL=FIN,ACK>  <--
   继续交换FIN和ACK段，直到双方都进入CLOSING状态

3. TCP A：CLOSING  --> <SEQ=101><ACK=301><CTL=ACK>  ... 
   TCP B：CLOSING  <-- <SEQ=301><ACK=101><CTL=ACK>  <--
   继续确认，直到双方都进入TIME-WAIT状态

4. TIME-WAIT状态（2 MSL）

（示意图：双方同时关闭的序列）

图14

[页面39]

1981年9月
传输控制协议
功能规范

3.6. 优先级与安全性

连接仅允许在端口之间进行，前提是这两个端口的安全和隔离（隔离参数）值完全相同，并且连接的优先级不低于两端端口中请求的较高者。

TCP中使用的优先级和安全参数与互联网协议（IP）[2]中定义的完全一致。在整个TCP规范中，“安全/隔离”一词旨在指示在IP中使用的安全参数，包括安全级别、隔离、用户组和处理限制。

如果尝试建立的连接的安全/隔离参数不匹配，或者优先级较低，必须通过发送复位（RST）包来拒绝连接。由于优先级过低而拒绝连接的情况只会在收到SYN确认（ACK）后发生。

请注意，仅在使用默认优先级值的TCP模块仍需检查传入段的优先级，并可能在连接上提升其使用的优先级。

即使在非安全环境中，安全参数也可以被使用（这些值将表示未分类的数据），因此非安全环境中的主机必须准备好接收安全参数，尽管它们不需要发送这些参数。

3.7 数据通信

一旦连接建立，数据通过段的交换进行通信。由于段可能因错误（校验和测试失败）或网络拥塞而丢失，TCP采用重传（在超时后）以确保每个段都能送达。由于网络或TCP重传，可能会收到重复的段。如序列号部分所述，TCP会对段中的序列号和确认号进行某些测试，以验证其有效性。

数据的发送方会在变量SND.NXT中跟踪下一个要使用的序列号。数据的接收方会在变量RCV.NXT中跟踪下一次期望接收的序列号。数据的发送方会在变量SND.UNA中跟踪最早未确认的序列号。如果数据流暂时空闲且所有已发送的数据都已被确认，那么这三个变量将相等。

当发送方创建一个段并传输时，会将SND.NXT向前推进。当接收方接受一个段时，会将RCV.NXT向前推进并发送确认。当数据发送方收到确认时，相关的变量会相应更新。

确认它推动了SND.UNA。 这些变量的值相差的程度是通信延迟的一个衡量标准。 变量提前的长度就是数据段中的数据长度。 注意，一旦进入ESTABLISHED状态，所有的段都必须携带最新的确认信息。

CLOSE用户调用意味着一个推送功能，就像传入段中的FIN控制标志一样。

重传超时

由于组成互联网系统的网络具有可变性，以及TCP连接的用途广泛，因此必须动态确定重传超时时间。这里提供一种确定重传超时的示例程序。

示例重传超时程序

测量从发送具有特定序列号的数据八位组到接收覆盖该序列号的确认所用的时间（发送的段不必与接收的段匹配）。这个测得的时间就是往返时间（RTT）。接下来计算平滑的往返时间（SRTT）：

SRTT = (ALPHA * SRTT) + ((1 - ALPHA) * RTT)

基于此，计算重传超时时间（RTO）为：

RTO = min[UBOUND, max[LBOUND, (BETA * SRTT)]]

其中，UBOUND是超时的上限（例如1分钟），LBOUND是超时的下限（例如1秒），ALPHA是平滑因子（例如0.8到0.9），BETA是延迟变化因子（例如1.3到2.0）。

紧急信息的传递

TCP紧急机制的目标是允许发送方促使接收方接受一些紧急数据，并允许接收方的TCP在所有已知的紧急数据都被用户接收后通知用户。

该机制允许在数据流中指定一个点作为紧急信息的结束。当这个点位于接收TCP的接收序列号（RCV.NXT）之前时，接收TCP必须通知用户进入“紧急模式”；当接收序列号赶上紧急指针时，TCP必须通知用户恢复“正常模式”。如果在用户处于“紧急模式”时更新紧急指针，这一更新对用户来说是不可见的。

该方法使用一个紧急字段，携带在所有传输的段中。URG控制标志表示紧急字段是有意义的，必须将其添加到段的序列号中以得到紧急指针。没有此标志表示没有待处理的紧急数据。

发送紧急指示时，用户还必须至少发送一个数据八位组。如果发送方同时指示了推送功能，则可以增强紧急信息及时传递到目标进程的效果。

窗口管理

每个段中发送的窗口指示了发送窗口（即数据接收方）当前准备接受的序列号范围。假设这个范围与该连接当前可用的数据缓冲区空间有关。

指示较大的窗口会鼓励对方进行传输。如果到达的数据超过了可接受的范围，超出部分将被丢弃。这会导致过多的重传，增加网络和TCP的负担。指示较小的窗口可能会限制数据传输，甚至在每次传输新段时引入往返延迟。

提供的机制允许TCP广告出较大的窗口，随后又广告出较小的窗口，而实际上并未接受那么多数据。这种所谓的“缩小窗口”行为被强烈不建议。健壮性原则规定，TCP不会自行缩小窗口，但会对其他TCP可能出现的此类行为做好准备。

发起端的TCP必须准备好即使窗口为零，也能接受用户至少一个八位组的新数据并进行发送。即使窗口为零，发起端的TCP也必须定期向接收端重传数据。建议在窗口为零时的重传间隔为两分钟。这种重传对于确保当任一端的窗口为零时，窗口重新开启的通知能够可靠传达至关重要。

当接收端TCP的窗口为零且收到一个段时，它仍然必须发送确认，显示其下一个预期的序列号和当前窗口（为零）。

发起端的TCP会将待传输的数据封装成符合当前窗口大小的段，也可以在重传队列中重新封装段。虽然不强制要求重新封装，但这样做可能会有所帮助。

关于单向数据流的连接，窗口信息将包含在所有具有相同序列号的确认段中，因此如果这些段到达的顺序颠倒，也无法重新排序。这并不是一个严重的问题，但它会导致窗口信息有时暂时基于数据接收方的旧报告。为避免这个问题，可以对窗口信息进行改进：只对携带最高确认号的段（即确认号等于或大于之前接收的最高确认号的段）进行处理。

窗口管理策略对通信性能有重要影响。以下是一些建议，供实现者参考。

**窗口管理建议**

- 分配非常小的窗口会导致数据以许多小段的形式传输，而使用较少的大段可以获得更好的性能。

- 为避免小窗口的建议之一是让接收方推迟更新窗口，直到额外的分配至少达到连接最大可能分配的X百分比（X可能在20%到40%之间）。

- 另一种建议是让发送方避免发送小段，等待窗口变大到足够的程度后再发送数据。如果用户发出推送（push）信号，则必须即使是小段也要立即发送。

- 注意，不应延迟确认，否则会导致不必要的重传。一个策略是在收到小段时立即发送确认（不更新窗口信息），然后在窗口变大时再发送带有新窗口信息的确认。

- 用于探测零窗口的段也可能导致传输数据逐渐拆分成越来越小的段。如果接受到包含单个数据字节的探测段（用于检测零窗口），则会占用当前可用窗口的一个字节。如果发送端TCP在窗口非零时尽可能多地发送数据，传输的数据将被拆分成大段和小段交替出现。随着时间推移，接收方偶尔释放窗口资源，可能会将大段拆分成一对较小的段。最终，数据传输将主要由较小的段组成。

这里的建议是，TCP实现需要主动尝试将较小的窗口分配合并成更大的窗口，因为管理窗口的机制往往导致在最简单的实现中出现许多小窗口。

3.8 接口

当然，有两个相关的接口：用户/TCP接口和TCP/底层协议接口。我们对用户/TCP接口有一个相当详细的模型，但对底层协议模块的接口在此未作具体说明，因为它将由底层协议的规范详细定义。对于底层是IP的情况，我们指出一些TCP可能使用的参数值。

用户/TCP接口

对TCP的用户命令的以下功能描述，充其量是虚构的，因为每个操作系统的功能都不同。因此，我们必须提醒读者，不同的TCP实现可能具有不同的用户界面。然而，所有的TCP都必须提供一套最低限度的服务，以保证所有TCP实现都能支持相同的协议层次。本节规定了所有TCP实现所需的功能接口。

TCP用户命令

以下各节在功能上描述了用户/TCP接口。所用符号类似于大多数高级语言中的过程或函数调用，但这种用法并不排除陷阱类型的服务调用（例如，SVCs、UUOs、EMTs）。

下面描述的用户命令规定了TCP必须执行的基本功能，以支持进程间通信。各个实现必须定义其具体的格式，并且可以在单个调用中提供基本功能的组合或子集。特别是，一些实现可能希望在用户首次发出发送或接收命令时自动打开连接。

在提供进程间通信功能时，TCP不仅要接受命令，还必须向所服务的进程返回信息。这些信息包括：

(a) 关于连接的一般信息（例如，中断、远程关闭、未指定的远程套接字绑定）。

(b) 对特定用户命令的回复，指示成功或各种失败类型。

打开

格式：OPEN（本地端口，远程套接字，主动/被动，[超时][优先级][安全/隔离][选项]）→ 本地连接名

我们假设本地的TCP知道它所服务的进程的身份，并会检查该进程使用指定连接的权限。根据TCP的不同实现，源地址的本地网络和TCP标识符要么由TCP提供，要么由底层协议（例如IP）提供。这些考虑因素源于对安全性的担忧，确保没有任何TCP能够冒充成另一个TCP，等等。同样，没有任何进程可以在没有TCP串通的情况下冒充成另一个进程。

如果活动/被动标志被设置为被动，则表示这是一个监听（LISTEN）以等待传入连接的调用。被动打开可以是针对特定连接的完全指定的远程套接字，也可以是未指定的远程套接字，用于等待任何连接。一个完全指定的被动调用可以通过随后的发送（SEND）操作变为主动。

会创建一个传输控制块（TCB），并用来自OPEN命令参数的数据部分填充。

在主动OPEN命令下，TCP将立即开始同步（即建立）连接的过程。

如果存在超时设置，调用者可以为提交给TCP的所有数据设置超时。如果在超时时间内数据未能成功送达目的地，TCP将中止连接。当前的全局默认值为五分钟。

TCP或操作系统的某个组件将验证用户是否有权限以指定的优先级或安全/隔离级别打开连接。OPEN调用中未指定优先级或安全/隔离级别，表示必须使用默认值。

TCP只会接受匹配的传入请求，前提是安全/隔离信息完全相同，并且优先级等于或高于在OPEN调用中请求的优先级。

连接的优先级是请求中的值和接收到的传入请求中的值中的较高者，并在连接的整个生命周期内固定。实现者可能希望让用户控制此优先级协商。例如，用户可能被允许指定必须完全匹配优先级，或者任何试图提升优先级的操作都需得到用户确认。

本地连接名将由TCP返回给用户。  
该本地连接名可以作为一个简写术语，用于表示由<本地套接字，远程套接字>对定义的连接。

发送

格式：SEND（本地连接名，缓冲区地址，字节数，PUSH标志，URGENT标志[,超时时间]）

此调用会将指示的用户缓冲区中的数据通过指定的连接发送出去。如果该连接尚未打开，则视为错误。一些实现可能允许用户先进行发送；在这种情况下，会自动进行连接的打开。如果调用进程没有权限使用该连接，也会返回错误。

如果设置了PUSH标志，数据必须立即传送给接收方，且在由缓冲区创建的最后一个TCP段中会设置PUSH位。如果未设置PUSH标志，数据可以与后续的发送数据合并，以提高传输效率。

如果设置了URGENT标志，发送到目标TCP的段将会设置紧急指针。接收端的TCP会向接收进程发出紧急条件信号，前提是紧急指针指示的数据尚未被接收进程消费。紧急的目的是促使接收方处理紧急数据，并指示接收方何时已收到所有当前已知的紧急数据。发送端TCP多次发出紧急信号的次数不一定等于接收端通知紧急数据存在的次数。

如果在打开连接时未指定远程套接字，但连接已建立（例如，由于有远程段到达，监听中的连接变得具体化），那么指定的缓冲区会被发送到隐含的远程套接字。使用未指定远程套接字进行OPEN的用户，可以在不明确知道远程套接字地址的情况下使用SEND。

然而，如果在远程套接字被指定之前尝试进行SEND操作，将会返回错误。用户可以使用STATUS调用来确认连接的状态。在某些实现中，当未指定套接字被绑定时，TCP可能会通知用户。

如果指定了超时时间，则会将当前连接的用户超时时间更改为新的值。

在最简单的实现中，SEND操作不会返回控制权给发送进程，直到传输完成或超时发生。然而，这种简单的方法容易导致死锁（例如，连接的双方可能在进行任何接收操作之前都试图进行发送），且性能较差，因此不推荐使用。更复杂的实现会立即返回，以允许进程与网络I/O并发运行，并且可以同时进行多个发送操作。多个发送请求按照先到先服务的顺序处理，因此TCP会将无法立即处理的请求排队。

我们隐含假设存在异步用户界面，即后续的SEND操作会引发某种信号或伪中断，通知TCP已完成操作。另一种方案是立即返回响应。例如，SEND操作可能会立即返回本地确认，即使远端TCP尚未确认该段。我们可以乐观地假设最终会成功。如果假设错误，连接仍会因超时而关闭。在这种（同步）实现中，仍会有一些异步信号，但这些信号只涉及连接本身，而不针对特定的段或缓冲区。

为了让进程能够区分不同SEND操作的成功或错误指示，可能需要在响应中同时返回缓冲区地址和编码的响应信息。关于TCP到用户的信号，后文会详细讨论，说明应将哪些信息返回给调用进程。

接收

格式：RECEIVE（本地连接名，缓冲区地址，字节数） -> 实际接收字节数，紧急标志，推送标志

此命令为指定的连接分配一个接收缓冲区。如果在执行此命令之前没有打开连接，或调用进程没有权限使用该连接，则会返回错误。

在最简单的实现中，控制不会返回到调用程序，直到缓冲区被填满或发生某些错误，但这种方案非常容易导致死锁。更复杂的实现会允许同时存在多个接收操作（RECEIVEs）未完成。这些接收操作会在数据段到达时逐个填充。这种策略可以提高吞吐量，但需要采用更复杂（可能是异步的）通知机制，通知调用程序已检测到数据推送（PUSH）或缓冲区已满。

如果在看到推送（PUSH）之前，足够的数据到达以填满缓冲区，则在对接收（RECEIVE）的响应中不会设置PUSH标志。缓冲区会被填充尽可能多的数据。如果在缓冲区填满之前检测到推送，则缓冲区会部分填充并标记为推送。

如果有紧急数据，用户会在数据到达时通过TCP到用户的信号被通知。因此，接收用户应处于“紧急模式”。如果设置了URGENT标志，表示仍有额外的紧急数据未被读取；如果关闭了URGENT标志，则此调用的RECEIVE已返回所有紧急数据，用户可以退出“紧急模式”。注意，紧急指针之后的数据（非紧急数据）不能与之前的紧急数据一起在同一缓冲区中交付给用户，除非边界被明确标记。

为了区分多个未完成的RECEIVE操作，并处理缓冲区未完全填满的情况，返回代码会同时附带一个缓冲区指针和一个字节数，指示实际接收的数据长度。

RECEIVE的其他实现方式可能会由TCP分配缓冲区存储空间，或者TCP可能与用户共享一个环形缓冲区。

关闭

格式：CLOSE（本地连接名）

此命令会导致指定的连接被关闭。如果连接未处于打开状态，或者调用进程没有权限使用该连接，则会返回错误。关闭连接被设计为一种优雅的操作，即在流控制允许的情况下，未完成的发送（SEND）将被传输（并重新传输），直到全部完成。因此，连续多次调用SEND后再调用CLOSE，应该可以确保所有数据都已发送到目的地。同样，用户应继续在关闭的连接上进行接收（RECEIVE），因为另一端可能还在尝试传输最后的数据。因此，CLOSE意味着“我没有更多数据要发送”，但不意味着“我不会再接收任何数据”。如果用户层协议设计不合理，可能会出现关闭端在超时前无法清除所有数据的情况。在这种情况下，CLOSE会变成ABORT，关闭的TCP连接会放弃连接。

用户可以在任何时候自主发起CLOSE，也可以响应TCP的各种提示（例如：远端关闭、传输超时、目的地不可达）而发起。

由于关闭连接需要与远端的TCP通信，连接可能会在关闭状态下短暂停留。若在TCP回复CLOSE命令之前尝试重新打开连接，将会收到错误响应。

CLOSE操作还意味着推送（push）功能。

状态（Status）

格式：STATUS（本地连接名）->状态数据

这是一个依赖于具体实现的用户命令，可以在没有影响的情况下省略。返回的信息通常来自与该连接相关联的传输控制块（TCB）。

此命令会返回一个数据块，包含以下信息：

- 本地套接字（socket）
- 远端套接字
- 本地连接名
- 接收窗口
- 发送窗口
- 连接状态
- 等待确认的缓冲区数量
- 待接收的缓冲区数量
- 紧急状态
- 优先级
- 安全/隔离信息
- 传输超时

根据连接的状态或实现细节，部分信息可能不可用或无意义。如果调用进程没有权限使用该连接，将返回错误。这可以防止未授权的进程获取连接的相关信息。

中止（Abort）

格式： ABORT（本地连接名）

此命令会中止所有待处理的发送和接收操作，删除对应的传输控制块（TCB），并向连接另一端的TCP发送一条特殊的重置（RESET）消息。根据不同的实现，用户可能会收到每个未完成的发送或接收操作的中止指示，或者仅收到一条中止确认（ABORT-acknowledgment）。

TCP到用户的消息

假设操作系统环境提供一种机制，使TCP能够异步地向用户程序发出信号。当TCP发出信号时，会向用户传递某些信息。通常在规范中，这些信息是错误消息。在其他情况下，可能会提供与完成处理发送（SEND）或接收（RECEIVE）或其他用户调用相关的信息。

提供的信息包括：

- 本地连接名 —— 始终提供
- 响应字符串 —— 始终提供
- 缓冲区地址 —— 仅在发送和接收时提供
- 字节数（计数已接收的字节） —— 仅在接收时提供
- 推送标志 —— 仅在接收时提供
- 紧急标志 —— 仅在接收时提供

[第50页]

1981年9月
传输控制协议
功能规范

TCP/底层接口

TCP调用底层协议模块，实际在网络上传输和接收信息。其中一种情况是ARPA互联网系统，其底层模块是互联网协议（IP）[2]。

如果底层协议是IP，它会提供服务类型和生存时间（TTL）的参数。TCP为这些参数使用以下设置：

- 服务类型 = 优先级：普通，延迟：正常，吞吐量：正常，可靠性：正常；或00000000。

- 生存时间（TTL）= 一分钟，或00111100。

注意，假定的最大段寿命为两分钟。在这里，我们明确要求，如果一个数据段在互联网系统中无法在一分钟内送达，就应将其销毁。

如果底层协议是IP（或其他提供此功能的协议），并且使用源路由，则接口必须允许传递路由信息。这一点尤为重要，以确保TCP校验和中使用的源地址和目的地址是起始源和最终目的地。同时，也要确保能保留返回路由，以便响应连接请求。

任何较低层协议都必须提供源地址、目的地址和协议字段，以及一种确定“TCP长度”的方法，这既是为了提供与IP等效的功能服务，也是为了在TCP校验和中使用。

[第51页]

1981年9月
传输控制协议
功能规范

3.9 事件处理

本节描述的处理方式是其中一种可能的实现示例。其他实现可能会有略微不同的处理顺序，但它们的差异应仅在细节上，而不影响实质内容。

TCP的活动可以被描述为对事件的响应。发生的事件可以归为三类：用户调用、到达的段和超时。本节介绍了TCP对每类事件的处理。在许多情况下，所需的处理取决于连接的状态。

发生的事件包括：

用户调用

- OPEN（打开连接）
- SEND（发送数据）
- RECEIVE（接收数据）
- CLOSE（关闭连接）
- ABORT（中止连接）
- STATUS（状态查询）

到达的段

- SEGMENT ARRIVES（段到达）

超时

- USER TIMEOUT（用户超时）
- RETRANSMISSION TIMEOUT（重传超时）
- TIME-WAIT TIMEOUT（等待时间超时）

TCP/用户接口的模型是，用户命令的响应是立即返回，可能通过事件或伪中断的方式延迟响应。在以下描述中，“信号”一词意味着引发延迟响应。

错误响应以字符字符串的形式给出。例如，引用不存在的连接的用户命令会收到“error: connection not open”（错误：连接未打开）。

请注意，以下所有关于序列号、确认号、窗口等的算术运算都是模2^32的，即序列号空间的大小。同时，“=<”表示小于或等于（模2^32）。

[第52页]

1981年9月
传输控制协议
功能规范

处理传入段的自然方式是，首先测试它们的序列号是否正确（即，它们的内容是否在预期的“接收窗口”范围内，基于序列号空间），然后通常将它们排队并按序列号顺序处理。

当一个段与已接收的其他段重叠时，我们会重建该段，使其只包含新数据，并调整头字段以保持一致。

注意，如果没有提及状态变化，TCP将保持在相同的状态。

以下是英文内容的中文翻译：

---

                                                               [第53页]



                                                          1981年9月
传输控制协议
功能规范
                                                               OPEN调用



  OPEN调用

    关闭状态（即，TCB不存在）

      创建一个新的传输控制块（TCB），用于存放连接状态信息。填写本地套接字标识符、远端套接字、优先级、安全/隔离级别以及用户超时信息。注意，在被动OPEN中，远端套接字的某些部分可能未被指定，这些部分应由传入的SYN段的参数填充。验证请求的安全级别和优先级是否被允许，如果不允许，则返回“错误：不允许的优先级”或“错误：不允许的安全/隔离级别”。如果是被动操作，则进入LISTEN状态并返回。如果是主动操作且远端套接字未指定，则返回“错误：未指定远端套接字”；如果是主动操作且远端套接字已指定，则发出一个SYN段。选择一个初始发送序列号（ISS），并发送形式为<SEQ=ISS><CTL=SYN>的SYN段。将SND.UNA设置为ISS，SND.NXT设置为ISS+1，进入SYN-SENT状态，并返回。

      如果调用者没有访问指定的本地套接字的权限，则返回“错误：此进程的连接非法”。如果没有资源创建新连接，则返回“错误：资源不足”。

    LISTEN状态

      如果是主动操作且已指定远端套接字，则将连接状态由被动变为主动，选择一个ISS。发送一个SYN段，将SND.UNA设置为ISS，SND.NXT设置为ISS+1。进入SYN-SENT状态。与SEND相关的数据可以在发送SYN段时一同发送，或在进入ESTABLISHED状态后排队传输。若命令中请求了紧急位，则必须在由此命令引发的所有数据段中一同发送。若没有空间排队请求，则返回“错误：资源不足”。如果未指定远端套接字，则返回“错误：未指定远端套接字”。












[第54页]                                                               



1981年9月                                                          
传输控制协议
功能规范
OPEN调用



    SYN-SENT状态
    SYN-RECEIVED状态
    ESTABLISHED状态
    FIN-WAIT-1状态
    FIN-WAIT-2状态
    CLOSE-WAIT状态
    CLOSING状态
    LAST-ACK状态
    TIME-WAIT状态

      返回“错误：连接已存在”。






































                                                               [第55页]

1981年9月
传输控制协议
功能规范
发送调用

发送调用

关闭状态（即，TCP控制块不存在）

如果用户没有权限访问该连接，则返回
“错误：此进程的连接非法”。

否则，返回“错误：连接不存在”。

监听状态

如果指定了远端套接字，则将连接状态由被动变为主动，选择一个初始序列号（ISS）。发送一个SYN段，将SND.UNA设置为ISS，SND.NXT设置为ISS+1。进入SYN-SENT状态。与发送相关的数据可以与SYN段一起发送，或在进入ESTABLISHED状态后排队等待传输。命令中请求的紧急位必须与由此命令触发的段一起发送。如果没有空间将请求排队，则返回“错误：资源不足”。如果未指定远端套接字，则返回“错误：未指定远端套接字”。

SYN-SENT状态
SYN-RECEIVED状态

在进入ESTABLISHED状态后，将数据排队等待传输。如果没有空间排队，则返回“错误：资源不足”。

已建立状态
关闭等待状态

将缓冲区分段并带有携带确认（确认值为RCV.NXT）地发送。如果没有足够的空间存储此缓冲区，则直接返回“错误：资源不足”。

如果设置了紧急标志，则将SND.UP设置为SND.NXT-1，并在发出的段中设置紧急指针。

[第56页]

1981年9月
传输控制协议
功能规范
发送调用

FIN-WAIT-1状态
FIN-WAIT-2状态
关闭中状态
最后确认状态
等待时间状态

返回“错误：连接正在关闭”，并且不处理请求。

[第57页]

1981年9月
传输控制协议
功能规范
接收调用

接收调用

关闭状态（即，TCP控制块不存在）

如果用户没有权限访问该连接，则返回
“错误：此进程的连接非法”。

否则返回“错误：连接不存在”。

监听状态
SYN-SENT状态
SYN-RECEIVED状态

在进入ESTABLISHED状态后，将请求排队等待处理。如果没有空间排队，则返回“错误：资源不足”。

已建立状态  
终止等待-1状态  
终止等待-2状态

如果排队的传入段不足以满足请求，则将请求加入队列。如果没有足够的队列空间来存储接收请求，则回应“错误：资源不足”。

将排队的传入段重新组装到接收缓冲区，并返回给用户。如果发生这种情况，应标记“已看到推送（PUSH）”。

如果接收指针（RCV.UP）领先于当前传递给用户的数据，则通知用户存在紧急数据。

当TCP负责将数据传递给用户时，必须通过确认（ACK）通知发送方。关于生成此类确认的详细过程在后续关于处理传入段的讨论中描述。

[第58页]  

1981年9月  
传输控制协议  
功能规范  
接收调用

等待关闭状态

由于远端已发送FIN，接收操作必须满足已在手中的文本，但尚未传递给用户。如果没有待传递的文本，接收操作将返回“错误：连接正在关闭”。否则，任何剩余的文本都可以用来满足接收请求。

关闭状态  
最后确认状态  
等待时间状态

返回“错误：连接正在关闭”。

[第59页]  

1981年9月  
传输控制协议  
功能规范  
关闭调用

关闭调用

已关闭状态（即，TCP控制块（TCB）不存在）

如果用户没有权限访问此连接，则返回“错误：此进程的连接非法”。

否则，返回“错误：连接不存在”。

监听状态

任何未完成的接收请求都将返回“错误：正在关闭”的响应。删除控制块，进入已关闭状态，并返回。

同步已发送状态

删除控制块，并对任何排队的发送或接收请求返回“错误：正在关闭”。

同步已接收状态

如果没有发出任何发送请求且没有待发送的数据，则形成一个FIN段并发送，然后进入终止等待-1状态；否则，将其排队，待进入已建立状态后处理。

已建立状态

将请求排队，直到所有前面的发送请求被段化，然后形成一个FIN段并发送。在任何情况下，都进入终止等待-1状态。

终止等待-1状态  
终止等待-2状态

严格来说，这是一个错误，应该返回“error: 连接关闭”响应。只要没有发出第二个FIN（第一个FIN可以被重传），返回“ok”也是可以接受的。

[第60页]

1981年9月
传输控制协议
功能规范
关闭（CLOSE）调用

CLOSE等待状态

将此请求排队，直到所有前面的发送（SEND）被分段；然后发送一个FIN段，进入关闭（CLOSING）状态。

关闭状态
最后确认（LAST-ACK）状态
TIME-WAIT状态

应回复“error: 连接正在关闭”。

[第61页]

1981年9月
传输控制协议
功能规范
中止（ABORT）调用

中止调用

已关闭状态（即，TCB不存在）

如果用户不应访问此连接，应返回“error: 该连接对本进程非法”。

否则返回“error: 连接不存在”。

监听（LISTEN）状态

任何未完成的接收（RECEIVE）应返回“error: 连接重置”响应。删除TCB，进入已关闭（CLOSED）状态，并返回。

SYN已发送（SYN-SENT）状态

所有排队的发送（SEND）和接收（RECEIVE）应给予“连接重置”通知，删除TCB，进入已关闭（CLOSED）状态，并返回。

SYN已接收（SYN-RECEIVED）状态
已建立（ESTABLISHED）状态
FIN等待1（FIN-WAIT-1）状态
FIN等待2（FIN-WAIT-2）状态
关闭等待（CLOSE-WAIT）状态

发送一个重置（RST）段：

<SEQ=SND.NXT><CTL=RST>

所有排队的发送和接收应给予“连接重置”通知；所有待传输（除上述RST外）或重传的段应被清除，删除TCB，进入已关闭（CLOSED）状态，并返回。

关闭状态
最后确认（LAST-ACK）状态
TIME-WAIT状态

应回复“ok”，并删除TCB，进入已关闭（CLOSED）状态，并返回。

[第62页]

1981年9月
传输控制协议
功能规范
状态（STATUS）调用

状态（STATUS）调用

已关闭状态（即，TCB不存在）

如果用户不应访问此连接，应返回“error: 该连接对本进程非法”。

否则返回“error: 连接不存在”。

监听（LISTEN）状态

返回“state = LISTEN”，以及TCB指针。

SYN已发送（SYN-SENT）状态

返回“state = SYN-SENT”，以及TCB指针。

同步已接收状态

返回“状态 = 同步已接收”，以及对应的TCB指针。

连接已建立状态

返回“状态 = 已建立”，以及对应的TCB指针。

FIN等待1状态

返回“状态 = FIN等待1”，以及对应的TCB指针。

FIN等待2状态

返回“状态 = FIN等待2”，以及对应的TCB指针。

关闭等待状态

返回“状态 = 关闭等待”，以及对应的TCB指针。

关闭中状态

返回“状态 = 关闭中”，以及对应的TCB指针。

最后确认状态

返回“状态 = 最后确认”，以及对应的TCB指针。

【第63页】

1981年9月
传输控制协议
功能规范
状态调用

TIME-WAIT状态

返回“状态 = TIME-WAIT”，以及对应的TCB指针。

【第64页】

1981年9月
传输控制协议
功能规范
段到达

段到达

如果状态为关闭（即，TCB不存在），则

所有传入段中的数据都将被丢弃。包含重置（RST）标志的段将被丢弃。不包含RST的传入段会引发一个重置（RST）响应。确认和序列号字段的值将被选择，使得重置序列对发送引发段的TCP来说是可接受的。

如果ACK位未设置，则使用序列号0，

<SEQ=0><ACK=SEG.SEQ+SEG.LEN><CTL=RST,ACK>

如果ACK位已设置，

<SEQ=SEG.ACK><CTL=RST>

返回。

如果状态为监听（LISTEN），则

首先检查是否有RST

应忽略任何传入的RST。返回。

第二，检查ACK

任何在仍处于LISTEN状态的连接上到达的确认都是不正确的。应为任何带有ACK的到达段形成一个可接受的重置段。RST应按如下格式：

<SEQ=SEG.ACK><CTL=RST>

返回。

第三，检查SYN

如果SYN位被设置，检查安全性。如果传入段的安全/隔离级别与TCB中的完全不匹配，则发送重置并返回。

<SEQ=SEG.ACK><CTL=RST>

如果SEG.PRC大于TCB.PRC，则在用户和系统允许的情况下，将TCB.PRC设置为SEG.PRC；如果不允许，则发送重置（RST）并返回。

<SEQ=SEG.ACK><CTL=RST>

如果SEG.PRC小于TCB.PRC，则继续处理。

将RCV.NXT设置为SEG.SEQ+1，IRS设置为SEG.SEQ，其他任何控制信息或文本应排队等待后续处理。应选择一个初始序列号ISS，并发送一个形式如下的SYN段：

<SEQ=ISS><ACK=RCV.NXT><CTL=SYN,ACK>

SND.NXT设置为ISS+1，SND.UNA设置为ISS。连接状态应变为SYN-RECEIVED。注意，任何其他的传入控制或数据（与SYN一起）将在SYN-RECEIVED状态下处理，但SYN和ACK的处理不应重复。如果监听未完全指定（即，远端套接字未完全指定），则应在此时填写未指定的字段。

第四部分：其他文本或控制信息

任何其他携带控制或文本的段（不包含SYN）都必须带有ACK，因此会被ACK处理机制丢弃。传入的RST段可能无效，因为它不可能是对本连接的任何已发数据的响应。因此，你不太可能会到达这里，但如果到达了，就丢弃该段并返回。

如果状态为SYN-SENT，则

首先检查ACK位

如果ACK位被设置

如果SEG.ACK ≤ ISS，或SEG.ACK > SND.NXT，则发送重置（除非RST位已设置，此时丢弃段并返回）

<SEQ=SEG.ACK><CTL=RST>

并丢弃该段，返回。

如果SND.UNA ≤ SEG.ACK ≤ SND.NXT，则ACK被接受。

其次检查RST位

如果RST位被设置

如果ACK被接受，则向用户发出“错误：连接重置”的信号，丢弃该段，进入CLOSED状态，删除TCB，并返回。否则（没有ACK），丢弃该段并返回。

第三检查安全性和优先级

如果段中的安全/隔离域与TCB中的不完全匹配，则发送重置

如果有ACK

<SEQ=SEG.ACK><CTL=RST>

否则

<SEQ=0><ACK=SEG.SEQ+SEG.LEN><CTL=RST,ACK>

如果有ACK

段中的优先级必须与TCB中的优先级匹配，否则发送重置

<SEQ=SEG.ACK><CTL=RST>

如果没有ACK，则不再继续。

如果该段中的优先级高于TCP控制块（TCB）中的优先级，则如果用户允许且系统允许，将TCB中的优先级提升至该段中的优先级；如果不允许提升优先级，则发送重置（RST）信号。

<SEQ=0><ACK=SEG.SEQ+SEG.LEN><CTL=RST,ACK>

如果该段中的优先级低于TCB中的优先级，则继续处理。

如果已发送重置（RST）信号，则丢弃该段并返回。

第四步，检查SYN位

此步骤应仅在确认ACK有效或没有ACK，且该段不包含RST时进行。

如果SYN位开启，且安全/隔离级别和优先级均可接受，则将接收下一序列号（RCV.NXT）设置为SEG.SEQ+1，将本端的IRS（初始接收序列号）设置为SEG.SEQ。如果存在ACK，则将已发送未确认（SND.UNA）前移至SEG.ACK，并删除已被确认的重传队列中的段。

如果SND.UNA > ISS（表示我们的SYN已被确认），则将连接状态改为ESTABLISHED，形成一个ACK段：

<SEQ=SND.NXT><ACK=RCV.NXT><CTL=ACK>

并发送该段。可以在其中包含已排队待发的数据或控制信息。如果段中有其他控制或文本内容，则继续进行第六步，检查URG位，否则返回。

否则，进入SYN-RECEIVED状态，形成一个SYN,ACK段：

<SEQ=ISS><ACK=RCV.NXT><CTL=SYN,ACK>

并发送。如果段中有其他控制或文本内容，则将它们排队，待连接状态达到ESTABLISHED后再处理，之后返回。

第五步，如果SYN和RST位都未设置，则丢弃该段并返回。

否则，

首先检查序列号

适用于以下状态：
- SYN-RECEIVED
- ESTABLISHED
- FIN-WAIT-1
- FIN-WAIT-2
- CLOSE-WAIT
- CLOSING
- LAST-ACK
- TIME-WAIT

段的处理按序进行。到达时的初步检测用于丢弃旧的重复段，但后续处理仍按SEG.SEQ的顺序进行。如果一个段的内容跨越了旧的和新的边界，则只处理其中的新版内容。

关于传入段的可接受性测试，有四种情况：

| 段长度 | 窗口大小 | 测试条件                                                         |
|---------|----------|------------------------------------------------------------------|
| 0       | 0        | SEG.SEQ = RCV.NXT                                               |
| 0       | >0       | RCV.NXT ≤ SEG.SEQ < RCV.NXT + RCV.WND                            |
| >0      | 0        | 不可接受                                                        |
| >0      | >0       | RCV.NXT ≤ SEG.SEQ < RCV.NXT + RCV.WND，或 RCV.NXT ≤ SEG.SEQ + SEG.LEN - 1 < RCV.NXT + RCV.WND |

如果接收窗口（RCV.WND）为零，则不接受任何段，但应特别允许接受有效的确认（ACK）、紧急指针（URG）和重置（RST）段。

如果一个传入段不可接受，应回复一个确认应答（ACK），除非RST位被设置（如果是这样，则丢弃该段并返回）：

<SEQ=SND.NXT><ACK=RCV.NXT><CTL=ACK>

在发送确认应答后，丢弃该不可接受的段并返回。

【第69页】

1981年9月
传输控制协议
功能规范
段到达

以下假设该段为理想化的段，从RCV.NXT开始，且不超过窗口范围。可以通过裁剪超出窗口范围的部分（包括SYN和FIN）来调整实际段，使其符合此假设，且只有在段开始于RCV.NXT时才进行后续处理。具有更高起始序列号的段可以暂时保留以待后续处理。

第二步，检查RST位。

SYN已接收状态（SYN-RECEIVED）

如果RST位被设置：

- 如果该连接是通过被动打开（即来自LISTEN状态）发起的，则将此连接返回到LISTEN状态并返回。用户无需通知。
- 如果该连接是通过主动打开（即来自SYN-SENT状态）发起的，则连接被拒绝，向用户发出“连接被拒绝”的信号。
- 无论哪种情况，应清除重传队列中的所有段。在主动打开的情况下，还应进入CLOSED状态，删除传输控制块（TCB），然后返回。

已建立状态（ESTABLISHED）
等待终止确认（FIN-WAIT-1）
等待终止（FIN-WAIT-2）
关闭等待（CLOSE-WAIT）

如果RST位被设置，则所有未完成的接收和发送操作应收到“重置”响应。所有段队列应被清空。用户还应收到一个未请求的“连接重置”信号。进入CLOSED状态，删除TCB，然后返回。

关闭中状态（CLOSING）
最后确认状态（LAST-ACK）
TIME-WAIT（等待时间）

如果RST位被设置，则进入CLOSED状态，删除TCB，然后返回。

1981年9月
传输控制协议
功能规范
段到达

第三步：检查安全性和优先级

    SYN-RECEIVED（同步已接收）状态
        如果段中的安全/隔离和优先级与TCP块（TCB）中的完全不匹配，
        则发送复位（reset）并返回。

    已建立（ESTABLISHED）状态
        如果段中的安全/隔离和优先级与TCP块中的完全不匹配，
        则发送复位（reset），所有未完成的接收（RECEIVEs）和发送（SEND）应
        接收“复位”响应。所有段队列应被清空。用户还应收到一条非请求的
        一般“连接重置”信号。进入关闭（CLOSED）状态，删除TCP块（TCB），
        并返回。

    注意：此检查在序列号检查之后进行，以防止来自不同安全级别或优先级的旧连接段
    导致当前连接中止。

第四步：检查SYN位

    状态：SYN-RECEIVED（同步已接收）
    状态：ESTABLISHED（已建立）
    状态：FIN-WAIT-1（等待终止-1）
    状态：FIN-WAIT-2（等待终止-2）
    状态：CLOSE-WAIT（等待关闭）
    状态：CLOSING（关闭中）
    状态：LAST-ACK（最后确认）
    状态：TIME-WAIT（时间等待）

        如果SYN在窗口内，则为错误，发送复位（reset），所有未完成的接收和发送应
        接收“复位”响应，所有段队列应被清空，用户还应收到一条非请求的
        一般“连接重置”信号，进入关闭（CLOSED）状态，删除TCP块（TCB），
        并返回。

        如果SYN不在窗口内，则不会到达此步骤，且在第一步（序列号检查）中已
        发送确认（ACK）。

[第70页]

1981年9月
传输控制协议
功能规范
段到达

第五步：检查ACK字段

    如果ACK位关闭，则丢弃该段并返回。

    如果ACK位开启：

        SYN-RECEIVED（同步已接收）状态
            如果SND.UNA ≤ SEG.ACK ≤ SND.NXT，则进入已建立（ESTABLISHED）状态
            并继续处理。

            如果段的确认号不可接受，则形成一个复位段，
                <SEQ=SEG.ACK><CTL=RST>
            并将其发送。

        已建立（ESTABLISHED）状态

如果 SND.UNA < SEG.ACK ≤ SND.NXT，则将 SND.UNA 设置为 SEG.ACK。  
所有在重传队列中因此被完全确认的段都将被移除。用户应对已发送且完全确认的缓冲区（即，发送缓冲区应返回“ok”响应）收到正向确认。如果确认（ACK）是重复的（SEG.ACK < SND.UNA），则可以忽略。若确认确认了尚未发送的内容（SEG.ACK > SND.NXT），则应发送一个确认，丢弃该段，并返回。

如果 SND.UNA < SEG.ACK ≤ SND.NXT，则应更新发送窗口。若（SND.WL1 < SEG.SEQ 或（SND.WL1 = SEG.SEQ 且 SND.WL2 ≤ SEG.ACK）），则将 SND.WND 设置为 SEG.WND，SND.WL1 设置为 SEG.SEQ，SND.WL2 设置为 SEG.ACK。

注意，SND.WND 是相对于 SND.UNA 的偏移量，SND.WL1 记录用于更新 SND.WND 的最后一个段的序列号，SND.WL2 记录用于更新 SND.WND 的最后一个段的确认号。这里的检查防止使用旧的段来更新窗口。

[第72页]

1981年9月  
传输控制协议  
功能规范  
段到达

FIN-WAIT-1 状态

除了对已建立（ESTABLISHED）状态的处理外，如果我们的 FIN 已被确认，则进入 FIN-WAIT-2 状态，并在该状态下继续处理。

FIN-WAIT-2 状态

除了对已建立状态的处理外，如果重传队列为空，用户的关闭请求（CLOSE）可以被确认（“ok”），但不删除传输控制块（TCB）。

CLOSE-WAIT 状态

执行与已建立状态相同的处理。

CLOSING 状态

除了对已建立状态的处理外，如果确认（ACK）确认了我们的 FIN，则进入 TIME-WAIT 状态，否则忽略该段。

LAST-ACK 状态

在此状态下唯一可能收到的是对我们 FIN 的确认。如果我们的 FIN 已被确认，则删除 TCB，进入 CLOSED 状态，并返回。

TIME-WAIT 状态

在此状态下唯一可能收到的是远端 FIN 的重传。应对此进行确认，并重新启动 2 MSL 超时。

第六，检查 URG 位，

在已建立（ESTABLISHED）状态、FIN-WAIT-1 状态和 FIN-WAIT-2 状态。

如果URG位被设置，接收方的RCV.UP将更新为两者中的较大值（最大值），并在远端发送的紧急指针（RCV.UP）领先于已消费的数据时，通知用户有紧急数据到达。如果用户已经收到过通知（或仍处于“紧急模式”）以应对这连续一段时间的紧急数据，则不再重复通知用户。

[第73页]

1981年9月
传输控制协议
功能规范
段到达

等待关闭状态
关闭中状态
最后确认状态
TIME-WAIT（等待时间）

这不应发生，因为已从远端接收到FIN。请忽略URG。

第七，处理段文本，

已建立状态
FIN-WAIT-1状态
FIN-WAIT-2状态

一旦进入已建立状态，就可以将段中的文本传递给用户的接收缓冲区。段中的文本可以被移动到缓冲区，直到缓冲区满或段为空。如果段为空且携带PUSH标志，则在缓冲区返回时通知用户已收到PUSH。

当TCP负责将数据传递给用户时，还必须确认已收到这些数据。

一旦TCP负责处理数据，它会将RCV.NXT向前推进，覆盖已接受的数据，并根据当前缓冲区的可用情况调整RCV.WND。RCV.NXT与RCV.WND的总和不应减少。

请注意第3.7节中的窗口管理建议。

应发送如下确认应答：

<SEQ=SND.NXT><ACK=RCV.NXT><CTL=ACK>

如果可能，应将此确认信息与正在传输的段合并（“piggyback”），以避免不必要的延迟。

[第74页]

1981年9月
传输控制协议
功能规范
段到达

等待关闭状态
关闭中状态
最后确认状态
TIME-WAIT状态

这不应发生，因为已从远端接收到FIN。请忽略段文本。

第八，检查FIN位，

如果状态为CLOSED、LISTEN或SYN-SENT，则不处理FIN，因为无法验证SEG.SEQ；应丢弃该段并返回。

如果设置了FIN位，则向用户发出“连接关闭”的信号，并返回所有待处理的接收（RECEIVE）请求，带有相同的消息，推进接收序列号（RCV.NXT）超过FIN，并为该FIN发送确认。注意，FIN意味着对于尚未传递给用户的任何段文本，也应设置PUSH。

SYN-RECEIVED状态
ESTABLISHED（已建立）状态

进入CLOSE-WAIT（关闭等待）状态。

FIN-WAIT-1（等待终止确认）状态

如果我们的FIN已被确认（可能在此段中），则进入TIME-WAIT（时间等待）状态，启动时间等待计时器，关闭其他计时器；否则进入CLOSING（关闭中）状态。

FIN-WAIT-2（等待终止）状态

进入TIME-WAIT状态。启动时间等待计时器，关闭其他计时器。

CLOSE-WAIT（关闭等待）状态

保持在CLOSE-WAIT状态。

CLOSING（关闭中）状态

保持在CLOSING状态。

LAST-ACK（最后确认）状态

保持在LAST-ACK状态。

[第75页]

1981年9月
传输控制协议
功能规范
段到达

TIME-WAIT（时间等待）状态

保持在TIME-WAIT状态。重新启动2MSL（最大段寿命）时间等待超时。

并返回。

[第76页]

1981年9月
传输控制协议
功能规范
用户超时

用户超时

对于任何状态，如果用户超时到期，则清空所有队列，向用户发出“错误：由于用户超时，连接中止”的信号，对于任何未完成的调用，删除传输控制块（TCB），进入CLOSED（关闭）状态并返回。

重传超时

对于任何状态，如果重传超时在重传队列中的某个段上到期，则重新发送重传队列前端的段，重新初始化重传计时器，并返回。

时间等待超时

如果时间等待超时在某个连接上到期，则删除TCB，进入CLOSED状态并返回。

[第77页]

1981年9月
传输控制协议

[第78页]

1981年9月
传输控制协议

术语表

1822  
BBN报告1822，“主机与IMP互连的规范”。关于主机与ARPANET之间接口的规范。

ACK  
一种控制位（确认位），不占用序列空间，用于指示该段的确认字段指定了发送方期望接收的下一个序列号，从而确认已接收所有之前的序列号。

ARPANET消息  
在ARPANET中，主机与IMP之间传输的基本单位。最大尺寸约为1012字节（8096比特）。

ARPANET数据包  
在ARPANET内部IMP之间使用的传输单位。最大尺寸约为126字节（1008比特）。

连接  
由一对套接字标识的逻辑通信路径。

数据报  
在分组交换计算机通信网络中发送的消息。

目的地址  
目标地址，通常包括网络和主机标识符。

FIN  
一种控制位（结束位），占用一个序列号，用于指示发送方将不再发送任何数据或控制信息，占用序列空间。

碎片  
数据的逻辑单元的一部分，特别是互联网碎片是互联网数据报的一部分。

FTP  
文件传输协议。

【第79页】

1981年9月  
传输控制协议  
术语表

头部  
消息、段、碎片、数据包或数据块开头的控制信息。

主机  
一台计算机，特别是在通信网络中，从源或目的地的角度来看。

标识符  
互联网协议中的字段。由发送方分配的识别值，有助于组装数据报的碎片。

IMP  
接口消息处理器，ARPANET的分组交换机。

互联网地址  
特定于主机层的源或目的地址。

互联网数据报  
在互联网模块与更高层协议之间交换的数据单位，连同互联网头部。

互联网碎片  
带有互联网头部的互联网数据报的一部分。

IP  
互联网协议。

IRS  
初始接收序列号。连接中由发送方使用的第一个序列号。

ISN  
初始序列号。连接中使用的第一个序列号（无论是ISS还是IRS），通过基于时钟的程序选择。

ISS  
初始发送序列号。由发送方在连接中使用的第一个序列号。

领导
          控制信息位于消息或数据块的开头。特别是在ARPANET中，指在主机-IMP接口上的ARPANET消息中的控制信息。

[第80页]

1981年9月
传输控制协议
术语表

左边序列
          这是接收端TCP（或当前未确认的最低序列号）应确认的下一个序列号，有时也称为发送窗口的左边界。

本地数据包
          在局域网内传输的单位。

模块
          一种协议或其他程序的实现，通常是软件实现。

MSL
          最大段生存时间（Maximum Segment Lifetime），指一个TCP段在互联网系统中可以存在的时间。通常定义为2分钟。

八位字节
          一个由8位组成的字节。

选项
          选项字段可以包含多个选项，每个选项可能由多个八位字节组成。选项主要用于测试场景，例如携带时间戳。互联网协议和TCP都提供了选项字段。

数据包
          带有头部的数据包，可能在逻辑上不完整。更常见的是物理包装，而非逻辑包装。

端口
          套接字的一部分，指定与数据相关联的进程的逻辑输入或输出通道。

进程
          正在执行的程序。从TCP或其他端到端协议的角度来看，是数据的源或目的地。

推送（PUSH）
          一个不占用序列空间的控制位，表示该段包含必须立即推送到接收用户的数据。

RCV.NXT
          接收端的下一个期望接收的序列号。

RCV.UP
          接收端的紧急指针。

RCV.WND
          接收窗口。

接收下一个序列号
          这是本地TCP期望接收的下一个序列号。

接收窗口
          表示本地（接收端）TCP愿意接收的序列号范围。因此，本地TCP认为覆盖范围在RCV.NXT到RCV.NXT + RCV.WND - 1之间的段携带的是可接受的数据或控制信息。包含完全在此范围之外的序列号的段被视为重复段并被丢弃。

RST
          一个控制位（重置位），不占用序列空间，表示接收方应在不进行进一步交互的情况下删除连接。接收方可以根据收到的段中的序列号和确认号字段判断是否应执行重置命令或忽略它。在任何情况下，收到包含RST的段都不会引发响应的RST。

RTP
          实时传输协议：一种用于传输时间敏感信息的端到端协议。

SEG.ACK
          段确认

SEG.LEN
          段长度

SEG.PRC
          段优先级值

SEG.SEQ
          段序列号

SEG.UP
          段紧急指针字段

[第82页]

1981年9月
传输控制协议
术语表

SEG.WND
          段窗口字段

段
          一个逻辑数据单位，特别是TCP段，是在一对TCP模块之间传输的数据单位。

段确认
          到达段中的确认字段所包含的序列号。

段长度
          一个段占用的序列号空间的大小，包括任何占用序列空间的控制信息。

段序列
          到达段中的序列字段中的编号。

发送序列
          这是本地（发送端）TCP在连接中将使用的下一个序列号。它最初从一个初始序列号曲线（ISN）中选择，并在每次传输数据或有序控制信息的每个八位组后递增。

发送窗口
          代表远端（接收端）TCP愿意接收的一段序列号范围。它是远端（数据接收端）TCP在段中指定的窗口字段的值。TCP可能发出的新序列号范围在SND.NXT和SND.UNA + SND.WND - 1之间。当然，SND.UNA和SND.NXT之间的序列号重传是预期的。

SND.NXT
          发送序列号

SND.UNA
          最左边的未确认序列号

SND.UP
          发送紧急指针

SND.WL1
          上次窗口更新时的段序列号

SND.WL2
          上次窗口更新时的段确认号

[第83页]

SND.WND
          发送窗口

套接字
          一个特别包括端口标识符的地址，即互联网地址与TCP端口的连接组合。

源地址
          通常指网络和主机标识符的源地址。

SYN
          一个控制位，位于传入的数据段中，占用一个序列号，用于建立连接时，指示序列编号的起始位置。

TCB
          传输控制块，记录连接状态的数据结构。

TCB.PRC
          连接的优先级。

TCP
          传输控制协议：一种用于互联网环境中可靠通信的端到端协议。

TOS
          服务类型，是互联网协议中的一个字段。

服务类型
          一个互联网协议字段，用于指示该互联网分段的服务类型。

URG
          一个控制位（紧急），不占用序列空间，用于通知接收方用户应进行紧急处理，只要有数据待处理且序列号小于紧急指针所指的值。

紧急指针
          仅在URG位被置位时有意义的控制字段。该字段传达紧急指针的值，指示与发送方紧急呼叫相关联的数据字节位置。