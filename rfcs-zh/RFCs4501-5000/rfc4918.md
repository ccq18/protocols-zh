# RFC 4918 中文翻译 (stub)
# 原文文件: ../../rfcs/RFCs4501-5000/rfc4918.txt

网络工作组                                  L. Dusseault，主编
意见请求编号：4918                                   CommerceNet
废止：2518                                              2007年6月
类别：标准轨道


用于Web分布式创作与版本控制（WebDAV）的HTTP扩展

本备忘录的状态

   本文件为互联网社区制定的互联网标准轨道协议，旨在征求讨论和改进建议。请参阅当前版本的《互联网官方协议标准》（STD 1），了解该协议的标准化状态和现行状态。本备忘录的分发不受限制。

版权声明

   版权所有（C）IETF信托（2007年）。

摘要

   Web分布式创作与版本控制（WebDAV）由一组与HTTP/1.1相关的方法、头部和内容类型组成，用于管理资源属性、创建和管理资源集合、操作URL命名空间以及资源锁定（避免冲突）。

   RFC 2518于1999年2月发布，本规范用一些小的修订（主要基于互操作性经验）取代了RFC 2518。




















Dusseault                   标准轨道                     [第1页]


RFC 4918                         WebDAV                        2007年6月


目录

   1. 引言 ....................................................7
   2. 符号约定 ................................................8
   3. 术语 ....................................................8
   4. 资源属性的数据模型 ....................................10
      4.1. 资源属性模型 ......................................10
      4.2. 属性与HTTP头部 ....................................10
      4.3. 属性值 ............................................10
           4.3.1. 示例——混合内容的属性 ........................12
      4.4. 属性名称 ..........................................14
      4.5. 源资源与输出资源 ..................................14
   5. Web资源的集合 ..........................................14
      5.1. HTTP URL命名空间模型 ...............................15
      5.2. 集合资源 ..........................................15
   6. 锁定 ....................................................17
      6.1. 锁模型 ............................................18
      6.2. 独占锁与共享锁 ....................................19
      6.3. 必要支持 ..........................................20
      6.4. 锁创建者与权限 ....................................20
      6.5. 锁令牌 ............................................21
      6.6. 锁超时 ............................................21
      6.7. 锁能力发现 ........................................22
      6.8. 活动锁发现 ........................................22
   7. 写锁 ....................................................23
      7.1. 写锁与属性 ........................................24
      7.2. 避免丢失更新 ......................................24
      7.3. 写锁与未映射URL ....................................25
      7.4. 写锁与集合 ........................................26
      7.5. 写锁与If请求头 ....................................28
           7.5.1. 示例——写锁与复制 ............................28
           7.5.2. 示例——删除锁定集合的成员 ....................29
      7.6. 写锁与复制/移动 ....................................30
      7.7. 刷新写锁 ..........................................30
   8. 请求与响应的通用处理 ..................................31
      8.1. 错误处理中的优先级 ................................31
      8.2. XML的使用 ..........................................31
      8.3. URL处理 ............................................32
           8.3.1. 示例——正确的URL处理 ..........................32
      8.4. 请求中必需的请求体 ................................33
      8.5. WebDAV中使用的HTTP头部 ............................33
      8.6. ETag ...............................................33
      8.7.包含错误响应体 .....................................34
      8.8.命名空间操作对缓存验证器的影响 ....................34
   9. 分布式创作的HTTP方法 ..................................35
      9.1. PROPFIND方法 ........................................35
           9.1.1. PROPFIND状态码 .................................37



Dusseault                   标准轨道                     [第2页]


RFC 4918                         WebDAV                        2007年6月


           9.1.2. 在'propstat'元素中使用的状态码 ..................37
           9.1.3. 示例——检索命名属性 ............................38
           9.1.4. 示例——使用'propname'检索所有属性名 ............39
           9.1.5. 示例——使用'allprop' ..............................41
           9.1.6. 示例——结合'use 'allprop'和'include' ............43
      9.2. PROPPATCH方法 .......................................44
           9.2.1. 在'propstat'元素中使用的状态码 ..................44
           9.2.2. 示例——PROPPATCH ................................45
      9.3. MKCOL方法 ...........................................46
           9.3.1. MKCOL状态码 ....................................47
           9.3.2. 示例——MKCOL ....................................47
      9.4. 集合的GET、HEAD ....................................48
      9.5. 集合的POST ...........................................48
      9.6. 删除（DELETE）要求 ..................................48
           9.6.1. 集合的DELETE ..................................49
           9.6.2. 示例——DELETE ..................................49
      9.7. PUT要求 .............................................50
           9.7.1. 非集合资源的PUT ................................50
           9.7.2. 集合的PUT ......................................51
      9.8. 复制（COPY）方法 ....................................51
           9.8.1. 非集合资源的COPY ...............................51
           9.8.2. 属性的COPY ....................................52
           9.8.3. 集合的COPY ....................................52
           9.8.4. COPY与目标资源的覆盖 ..........................53
           9.8.5. 状态码 .........................................54
           9.8.6. 示例——带覆盖的COPY ............................55
           9.8.7. 示例——不覆盖的COPY ............................55
           9.8.8. 集合的COPY .....................................56
      9.9. 移动（MOVE）方法 ....................................56
           9.9.1. 属性的MOVE .....................................57
           9.9.2. 集合的MOVE .....................................57
           9.9.3. MOVE与覆盖头 ..................................58
           9.9.4. 状态码 .........................................59
           9.9.5. 示例——非集合的MOVE ............................60
           9.9.6. 示例——集合的MOVE ...............................60
      9.10. 锁定（LOCK）方法 ....................................61
           9.10.1. 创建现有资源的锁 ..............................61
           9.10.2. 刷新锁 ........................................62
           9.10.3. 深度与锁定 ....................................62
           9.10.4. 未映射URL的锁定 .................................63
           9.10.5. 锁兼容性表 ....................................63
           9.10.6. LOCK响应 ......................................63
           9.10.7. 示例——简单锁请求 ..............................64
           9.10.8. 示例——刷新写锁 ................................65
           9.10.9. 示例——多资源锁请求 ............................66
      9.11. 解锁（UNLOCK）方法 ..................................68
           9.11.1. 状态码 ........................................68



Dusseault                   标准轨道                     [第3页]


RFC 4918                         WebDAV                        2007年6月


           9.11.2. 示例——UNLOCK ..................................69
   10. 用于分布式创作的HTTP头部 ................................69
      10.1. DAV头部 ..............................................69
      10.2. 深度（Depth）头部 ..................................70
      10.3. 目标（Destination）头部 ............................71
      10.4. If头部 ..............................................72
           10.4.1. 目的 ..........................................72
           10.4.2. 语法 ..........................................72
           10.4.3. 列表评估 ......................................73
           10.4.4. 匹配状态令牌与ETag ............................74
           10.4.5. If头部与非DAV代理 ..............................74
           10.4.6. 示例——无标签的生产 ............................75
           10.4.7. 示例——使用"Not"的无标签生产 ..................75
           10.4.8. 示例——使条件始终成立 ..........................75
           10.4.9. 示例——COPY中的带标签列表If头  ...............76
           10.4.10. 示例——匹配锁令牌与集合锁 ....................76
           10.4.11. 示例——未映射URL的ETag匹配 ....................76
      10.5. 锁令牌（Lock-Token）头部 ............................77
      10.6. 覆盖（Overwrite）头部 ...............................77
      10.7. 超时请求（Timeout）头部 .............................78
   11. HTTP/1.1状态码扩展 ......................................78
      11.1. 207多状态 ...........................................78
      11.2. 422无法处理的实体 ..................................78
      11.3. 423已锁定 ...........................................78
      11.4. 424依赖失败 .........................................79
      11.5. 507存储空间不足 ....................................79
   12. HTTP状态码的使用 ........................................79
      12.1. 412前提条件失败 ....................................79
      12.2. 414请求URI过长 .....................................79
   13. 多状态响应 ..............................................80
      13.1. 响应头 ..............................................80
      13.2. 处理重定向的子资源 ................................81
      13.3. 内部状态码 ..........................................81
   14. XML元素定义 ............................................81
      14.1. activelock XML元素 ..................................81
      14.2. allprop XML元素 .....................................82
      14.3. collection XML元素 ..................................82
      14.4. depth XML元素 .......................................82
      14.5. error XML元素 .......................................82
      14.6. exclusive XML元素 ...................................83
      14.7. href XML元素 ........................................83
      14.8. include XML元素 .....................................83
      14.9. location XML元素 ....................................83
      14.10. lockentry XML元素 ..................................84
      14.11. lockinfo XML元素 ...................................84
      14.12. lockroot XML元素 ...................................84



Dusseault                   标准轨道                     [第4页]


RFC 4918                         WebDAV                        2007年6月


      14.13. lockscope XML元素 ..................................84
      14.14. locktoken XML元素 ..................................85
      14.15. locktype XML元素 ...................................85
      14.16. multistatus XML元素 .................................85
      14.17. owner XML元素 ......................................85
      14.18. prop XML元素 .......................................86
      14.19. propertyupdate XML元素 ..............................86
      14.20. propfind XML元素 ...................................86
      14.21. propname XML元素 ...................................87
      14.22. propstat XML元素 ...................................87
      14.23. remove XML元素 .....................................87
      14.24. response XML元素 ...................................88
      14.25. responsedescription XML元素 .........................88
      14.26. set XML元素 ........................................88
      14.27. shared XML元素 .....................................89
      14.28. status XML元素 .....................................89
      14.29. timeout XML元素 ....................................89
      14.30. write XML元素 ......................................89
   15. DAV属性 .................................................90
   16. 先决条件/后置条件XML元素 ..............................98
   17. DAV中的XML扩展 ........................................101
   18. DAV合规性类别 ..........................................103
      18.1. 类别1 ..............................................103
      18.2. 类别2 ..............................................103
      18.3. 类别3 ..............................................103
   19. 国际化考虑 ............................................104
   20. 安全性考虑 ............................................105
      20.1. 客户端认证 ........................................105
      20.2. 拒绝服务 ..........................................106
      20.3. 通过模糊处理实现安全 ................................106
      20.4. 与锁相关的隐私问题 ................................106
      20.5. 与属性相关的隐私问题 ...............................107
      20.6. XML实体的影响 ......................................107
      20.7. 与锁令牌相关的风险 ................................108
      20.8. 托管恶意内容 ......................................108
   21. IANA注意事项 ...........................................109
      21.1. 新的URI方案 .......................................109
      21.2. XML命名空间 .......................................109
      21.3. 消息头字段 ........................................109
           21.3.1. DAV ...........................................109
           21.3.2. 深度 .........................................110
           21.3.3. 目标 .........................................110
           21.3.4. If ...........................................110
           21.3.5. 锁令牌 .......................................110
           21.3.6. 覆盖 .........................................111
           21.3.7. 超时 .........................................111
      21.4. HTTP状态码 ........................................111
   22. 致谢 ....................................................112



Dusseault                   标准轨道                     [第5页]


RFC 4918                         WebDAV                        2007年6月


   23. 本规范的贡献者 ........................................113
   24. RFC 2518的作者 ..........................................113
   25. 参考文献 ...............................................114
      25.1. 规范性参考文献 ....................................114
      25.2. 资料性参考文献 ....................................115
   附录A. 关于XML元素处理的说明 ............................117
      A.1. 关于空XML元素的说明 ................................117
      A.2. 关于非法XML处理的说明 ..............................117
      A.3. 示例——XML语法错误 ..................................117
      A.4. 示例——意外的XML元素 ................................118
   附录B. 关于HTTP客户端兼容性的说明 ......................119
   附录C. 'opaquelocktoken'方案与URI ..........................120
   附录D. 锁空资源 ............................................120
      D.1. 使用LOCK创建资源的客户端指南 ......................121
   附录E. 希望进行认证的客户端指南 ..........................121
   附录F. RFC 2518的变更总结 ..................................123
      F.1. 对客户端和服务器实现的变更 .........................123
      F.2. 服务器实现的变更 ..................................125
      F.3. 其他变更 ............................................126


























Dusseault                   标准轨道                     [第6页]


1. 引言

   本文档描述了对HTTP/1.1协议的扩展，允许客户端执行远程Web内容创作操作。该扩展提供了一套连贯的方法、头部、请求实体格式和响应实体格式，支持以下操作：

   属性：创建、删除和查询Web页面的相关信息，如作者、创建日期等。

   集合：创建文档集并检索层级成员列表（类似文件系统中的目录列表）。

   锁定：防止多个用户同时编辑同一文档，避免“丢失更新”问题，即在一个作者修改后未合并到另一个作者的更改前，修改被覆盖丢失。

   命名空间操作：指示服务器复制和移动Web资源，这些操作会改变URL到资源的映射关系。

   这些操作的需求和理由在配套文档《Web分布式创作与版本控制协议的需求》（[RFC2291]）中有详细描述。

   本文档未定义[RFC2291]中建议的版本控制操作。这些内容在另一份文档《WebDAV的版本控制扩展》（[RFC3253]）中进行了说明。

   以下章节详细介绍了WebDAV的各种抽象概念：资源属性（第4节）、资源集合（第5节）、锁（第6节）以及专门的写锁（第7节）。

   这些抽象概念由WebDAV专用的HTTP方法（第9节）和配合WebDAV使用的额外HTTP头部（第10节）进行操作。关于WebDAV中HTTP请求和响应的通用处理原则，详见第8节。

   虽然HTTP/1.1提供的状态码足以描述大多数WebDAV方法遇到的错误，但仍存在一些不完全适用的错误情况。本规范定义了为WebDAV方法开发的额外状态码（第11节），并说明了WebDAV中使用的现有HTTP状态码（第12节）。由于某些WebDAV方法可能涉及多个资源，特引入多状态（Multi-Status）响应（第13节）以返回多个资源的状态信息。最后，本版本WebDAV在错误响应体中引入了先决条件和后置条件（第16节）XML元素。

   WebDAV使用XML（[REC-XML]）作为属性名和部分值的表示方式，也用XML封装复杂的请求和响应。本文档包含所有属性（第15节）和其他XML元素（第14节）的DTD和文本定义，用于封装。WebDAV还规定了向后兼容扩展WebDAV XML封装的特殊规则（第17节）。

   规范的最后部分包括：资源符合本规范的定义（第18节）、国际化支持（第19节）以及安全性（第20节）。

URI/URL映射——指绝对URI与资源之间的关系。由于一个资源既可能代表无法通过网络检索的项目，也可能代表可以检索的项目，因此一个资源可以有零个、一个或多个URI映射。将资源映射到“http”方案的URI，使得可以通过该URI向资源提交HTTP协议请求。

路径段——非正式地，指在URI中位于斜杠（“/”）之间的字符。正式定义见[RFC3986]第3.3节。

集合——非正式地，指既作为资源，又作为子资源引用容器的资源。正式定义为：包含路径段与资源之间映射集的资源，并满足第5节中定义的要求。

内部成员（集合的）——非正式地，指集合中的子资源。正式定义为：由集合中包含的路径段映射所引用的资源。

内部成员URL（集合的）——指内部成员的URL，由集合的URL（包括尾部斜杠）加上标识内部成员的路径段组成。

成员（集合的）——非正式地，指集合的“后代”。正式定义为：集合的内部成员，或递归地，是内部成员的成员。

成员URL（集合的）——指要么是集合自身的内部成员URL，要么是该集合中某个成员的内部成员URL。

属性——包含关于资源的描述性信息的名/值对。

实时属性——由服务器强制执行其语义和语法的属性。例如，DAV:getcontentlength是一个实时属性，其值（GET请求返回实体的长度）由服务器自动计算。

死属性——其语义和语法不由服务器强制执行。服务器只记录死属性的值，客户端负责维护死属性的语法和语义的一致性。

主体——发起访问网络资源的不同人类或计算实体。

状态令牌——表示资源状态的URI。锁定令牌是本规范中定义的唯一状态令牌。

4. 资源属性的数据模型

4.1. 资源属性模型

属性是描述资源状态的数据。属性是关于数据的数据。

在分布式创作环境中，属性用于高效地发现和管理资源。例如，“主题”属性可以用来按主题索引所有资源，“作者”属性可以用来查找由哪些作者撰写的文档。

DAV属性模型由名/值对组成。属性的名称标识其语法和语义，并提供引用其语法和语义的地址。

属性分为两类：“实时”属性和“死”属性。实时属性由服务器强制执行其语法和语义，包括：a）属性值由服务器保护和维护；b）属性值由客户端维护，但服务器对提交的值进行语法检查。所有同一实时属性的实例必须符合该属性名的定义。死属性的语法和语义由客户端强制执行，服务器仅原样记录其值。

4.2. 属性与HTTP头

在HTTP消息头中，已有有限的属性存在。然而，在分布式创作环境中，需要描述资源状态的属性数量较多，通过HTTP头设置/返回所有属性效率低下。因此，需要一种机制，使主体能够识别感兴趣的属性集，并仅设置或检索这些属性。

4.3. 属性值

属性的值始终是一个（格式良好的）XML片段。

选择XML的原因包括其灵活性、自描述性、结构化数据格式的支持（支持丰富的模式定义）以及对多字符集的支持。XML的自描述特性允许通过添加元素扩展任何属性的值。客户端遇到扩展时不会崩溃，因为它们仍然拥有原始模式中定义的数据，并且必须忽略不理解的元素。

XML支持多字符集，允许用用户熟悉的字符集编码和读取任何人类可读的属性。XML支持多语言，使用“xml:lang”属性处理多语言字符集的情况。注意，xml:lang的作用范围是递归的，包含属性名元素的任何元素上的xml:lang属性都适用于属性值，除非被更局部的属性覆盖。属性只有一个值（可以是某一语言，也可以不定义语言）；不存在多语言的多个值或单一值对应多语言的情况。

属性总是用一个XML元素表示，元素名为“属性名元素”。最简单的例子是空属性，与不存在的属性不同：

```xml
<R:title xmlns:R="http://www.example.com/ns/"></R:title>
```

属性值在属性名元素内。值可以是任何格式良好的XML内容，包括纯文本和混合内容。服务器在存储和传输死属性时，必须保留以下XML信息项（参考[REC-XML-INFOSET]）：

- 属性名元素信息项：
  - [namespace name]
  - [local name]
  - [attributes]（包括“xml:lang”或作用域内的类似属性）
  - [children]（元素或字符类型）

- 属性值中的所有元素信息项：
  - [namespace name]
  - [local name]
  - [attributes]
  - [children]（元素或字符）

- 属性值中的属性信息项：
  - [namespace name]
  - [local name]
  - [normalized value]

- 属性值中的字符信息项：
  - [character code]

由于某些XML词汇（如XPath和XML Schema）使用前缀，服务器应保留值中的前缀信息：
  - [prefix]

服务器可以保留未列出的XML Infoset属性，但客户端不得依赖其被保留。上述规则默认也适用于实时属性，除非另有定义。

服务器必须忽略存在的xml:space属性，不得用其改变空白字符处理。属性值中的空白字符是有意义的。

4.3.1. 示例——带混合内容的属性

假设客户端创建了一个死属性“author”，内容如下：

```xml
<D:prop xml:lang="en" xmlns:D="DAV:">
  <x:author xmlns:x='http://example.com/ns'>
    <x:name>Jane Doe</x:name>
    <!-- Jane的联系方式 -->
    <x:uri type='email' added='2005-11-26'>mailto:jane.doe@example.com</x:uri>
    <x:uri type='web' added='2005-11-27'>http://www.example.com</x:uri>
    <x:notes xmlns:h='http://www.w3.org/1999/xhtml'>
      Jane一直在为期待已久的修订版工作，长达数年。
      <![CDATA[<RFC2518>]]>
    </x:notes>
  </x:author>
</D:prop>
```

请求此属性时，服务器可能返回：

```xml
<D:prop xmlns:D='DAV:'>
  <author xml:lang='en' xmlns:x='http://example.com/ns' xmlns='http://example.com/ns' xmlns:h='http://www.w3.org/1999/xhtml'>
    <x:name>Jane Doe</x:name>
    <x:uri added="2005-11-26" type="email">mailto:jane.doe@example.com</x:uri>
    <x:uri added="2005-11-27" type="web">http://www.example.com</x:uri>
    <x:notes>
      Jane一直在为期待已久的修订版工作，长达数年。
      <h:em>太</h:em>长了。
    </x:notes>
  </author>
</D:prop>
```

注意事项：
- 属性名本身的前缀未被保留（无关紧要），但其他前缀已被保留。
- 属性值用双引号替代单引号（引号风格无关紧要），属性顺序未被保留。
- xml:lang属性已在属性名元素上返回（设置时在作用域内，响应中的位置不重要，只要在作用域内）。
- 标签之间的空白已被保留（属性之间的空白未必）。
- CDATA被字符转义替代（反之亦然也合法）。
- 注释已被去除（处理指令也会被去除）。

实现提示：在某些编辑场景中，客户端可能需要逐字符保留XML内容（如属性顺序或引号风格）。此时，客户端应考虑使用纯文本属性值，通过转义所有在XML解析中具有特殊含义的字符。

4.4. 属性名

属性名是与提供属性语法和语义信息的模式相关联的全局唯一标识符。由于属性名是全局唯一的，客户端可以依赖在多个资源上对某一特定属性的行为一致（只要该属性在资源上是“实时”的，且实现忠实于定义）。XML命名空间机制（基于URI）用于命名属性，避免命名空间冲突，并提供不同程度的管理控制。

属性命名空间是扁平的，不存在显式的层级关系。因此，如果资源上存在属性A和A/B，则两者之间没有任何关系。未来可能会有专门的规范解决层级属性的问题。

此外，不允许在单一资源上定义相同的属性两次，否则会导致属性命名空间的冲突。

4.5. 源资源与输出资源

某些HTTP资源由服务器动态生成。对于这些资源，可能存在控制其生成方式的源代码。源文件与输出HTTP资源的关系可以是一对一、一对多、多对一或多对多。HTTP没有机制判断资源是否动态生成，也无法知道源文件位置或如何创建。虽然这个问题可以通过解决，但广泛部署的WebDAV实现主要处理静态资源，未解决动态资源的问题，因此本规范未定义源资源与输出资源的关系，将其留待单独文档。

5. Web资源集合

本节描述一种Web资源类型——集合，并讨论其与HTTP URL命名空间和HTTP方法的交互。集合资源的目的是在服务器命名空间中模拟类似目录的对象（如文件系统目录）。

所有符合DAV的资源必须支持本文定义的HTTP URL命名空间模型。

5.1. HTTP URL命名空间模型

HTTP URL命名空间是一个层级结构，层级由“/”字符分隔。

如果满足以下条件，则称HTTP URL命名空间为一致的：对于层级中的每个URL，都存在一个集合包含该URL作为内部成员URL。考虑的命名空间的根或顶层集合不受此规则限制。顶层集合不一定是由绝对路径“/”标识的集合，也可能由一个或多个路径段（如 /servlets/webdav/...）标识。

HTTP/1.1和WebDAV都不要求整个HTTP URL命名空间必须一致——某些WebDAV资源可能没有父集合。然而，某些WebDAV方法禁止产生导致命名空间不一致的结果。

如[RFC2616]和[RFC3986]所暗示，任何资源（包括集合资源）都可以由多个URI标识。例如，一个资源可以由多个HTTP URL标识。

5.2. 集合资源

资源集合与其他资源的不同之处在于它们同时也是容器。一些HTTP方法仅适用于集合，但也有一些方法适用于由集合定义的容器内的某些或全部资源。当方法的作用范围不明确时，客户端可以指定应用的深度。深度可以是零级（仅集合本身）、一级（集合及其直接包含的资源）或无限级（集合及其所有递归包含的资源）。

集合的状态至少包括路径段与资源之间的映射集，以及集合本身的一组属性。在本文档中，如果存在路径段映射指向资源B，并且该映射包含在资源A中，则称资源B被包含在集合资源A中。集合必须最多包含一个给定路径段的映射，即不允许将同一路径段映射到多个资源。

定义在集合上的属性与非集合资源上的属性表现完全一致。集合还可以具有其他状态，例如由GET请求返回的实体主体。

对于所有符合WebDAV标准的资源A和B，分别由URL“U”和“V”标识，若“V”等于“U/SEGMENT”，则A必须是一个包含从“SEGMENT”到B的映射的集合。因此，如果URL为“http://example.com/bar/blah”的资源B符合WebDAV标准，且URL为“http://example.com/bar/”的资源A也符合WebDAV标准，则资源A必须是一个集合，并且必须包含一个从“blah”到B的映射。

虽然映射通常由单个路径段和一个资源组成，但一般而言，映射可以由一组路径段和一个资源组成。这允许服务器将一组路径段视为等价（即，所有路径段都映射到同一资源，或都不映射到任何资源）。例如，进行大小写折叠的服务器会将“ab”、“Ab”、“aB”和“AB”视为等价。客户端可以使用任何这些路径段来标识资源。注意，PROPFIND的结果会选择其中一个等价路径段来标识映射，因此每个映射会对应一个PROPFIND响应元素，而不是每个路径段。

集合资源可以在HTTP URL命名空间层级中映射到非WebDAV兼容的资源，但这不是强制要求。例如，如果URL为“http://example.com/bar/blah”的资源X不符合WebDAV标准，而URL为“http://example.com/bar/”的资源A标识一个WebDAV集合，则A可以有或没有从“blah”到X的映射。

如果一个WebDAV兼容的资源在HTTP URL命名空间层级中没有任何WebDAV兼容的内部成员，则该WebDAV资源不必是一个集合。

有一个常规约定，当用其名称（不带尾部斜杠）引用集合时，服务器可以将请求视为带有尾部斜杠的情况处理。在这种情况下，服务器应在响应中返回Content-Location头，指向以“/”结尾的URL。例如，客户端对“http://example.com/blah”发起请求（无尾部斜杠），服务器可以响应为在“http://example.com/blah/”上执行操作，并在响应中返回Content-Location头，值为“http://example.com/blah/”。无论何时服务器生成指向集合的URL，都应包含尾部斜杠。通常，客户端应使用带尾部斜杠的集合名形式。如果客户端不使用尾部斜杠形式，则需要准备好应对重定向响应。客户端会发现，使用DAV:resourcetype属性比URL更可靠，用于判断资源是否为集合。

客户端必须支持WebDAV资源包含在非WebDAV资源中的情况。例如，如果“http://example.com/servlet/dav/collection”的OPTIONS响应表明支持WebDAV，客户端不能假设“http://example.com/servlet/dav/”或其父资源一定是WebDAV集合。

映射的URL未作为其父集合成员出现的典型场景之一是服务器允许链接或重定向到非WebDAV资源。例如，“/col/link”可能不会作为“/col/”的成员出现，尽管对“/col/link”的GET请求会返回302状态码；因此，URL“/col/link”确实被映射。同样，动态生成的页面可能有从“/col/index.html”的URL映射，因此该资源可能对GET请求返回200 OK，但不作为“/col/”的成员。

某些映射到WebDAV兼容资源的URL也可能不出现在父集合中。例如，支持多个别名URL的服务器。服务器可能实现不区分大小写的URL，因此“/col/a”和“/col/A”指向同一资源，但在列出“/col/”的成员时，只会报告“a”或“A”中的一个。当服务器将一组路径段视为等价时，必须在PROPFIND响应中只暴露一个首选路径段，且该路径段应始终一致。

6. 锁定

锁定资源的能力提供了一种序列化访问该资源的机制。通过锁定，编辑客户端可以合理保证在编辑过程中，其他主体不会修改该资源，从而避免“丢失更新”问题。

本规范允许锁的参数变化，包括涉及的主体数（独占锁与共享锁）和授予的访问类型。本文件仅定义写操作的锁，但语法具有扩展性，未来可以支持其他访问类型的锁。

6.1. 锁模型

本节简要描述锁的行为模型。后续章节将提供更多细节，并回溯这些模型声明。关于LOCK和UNLOCK方法处理的规范性声明可在相关章节找到，任何方法的规范性声明都集中在此。

1. 锁要么直接锁定资源，要么间接锁定资源。

2. 当对某资源的URL发起LOCK请求并创建新锁时，该资源变为直接锁定。新锁的“锁根”即为该URL。如果请求时该URL未映射到任何资源，则会创建一个空资源并直接锁定。

3. 独占锁（第6.2节）与同一资源上的任何其他类型的锁（无论是直接还是间接）冲突。服务器不得在资源上创建冲突的锁。

4. 对于深度无限的锁L锁定的集合，所有成员资源都被间接锁定。成员变动会影响间接锁定的资源集：

   * 添加新成员时，新成员资源不得已有冲突锁，因为它必须由锁L间接锁定。

   * 取消成员关系时，该资源不再由锁L间接锁定。

5. 每个锁由一个全局唯一的锁令牌（第6.5节）标识。

6. 解除锁请求（UNLOCK）会删除带有指定锁令牌的锁。锁被删除后，不再有资源被该锁锁定。

7. 当锁令牌出现在“如果”头（Section 7，“写锁”）中时，即视为提交了锁令牌（讨论写锁时何时需要提交令牌）。

8. 如果请求导致任何锁的锁根变成未映射的URL，则该锁也必须由该请求删除。

6.2. 独占锁与共享锁

最基本的锁类型是独占锁。独占锁避免了内容变更冲突，无需除本规范描述的方法外的其他协调。

但有时锁的目标不是排除他人行使访问权，而是提供一种机制，让主体表明其打算行使访问权。为此，提供共享锁。共享锁允许多个主体获得锁。因此，拥有访问权限和有效锁的任何主体都可以使用被锁定的资源。

在共享锁的情况下，影响资源的信任集有两个。第一个由访问权限创建。例如，受信任的主体可能有权限写入资源。在拥有写权限的主体中，持有共享锁的主体也必须彼此信任，形成一个较小的信任集。

从互联网的每个潜在主体开始，在大多数情况下，这些主体中绝大多数都没有对某资源的写权限。在拥有写权限的少数主体中，有些可能会通过使用独占写锁来保证其编辑不被覆盖。其他主体可能相信其协作者不会覆盖其工作（潜在协作者集为拥有写权限的主体），因此使用共享锁，通知协作者某个主体可能正在处理该资源。

WebDAV对HTTP的扩展不需要提供所有必要的通信路径以协调主体的活动。使用共享锁时，主体可以通过任何带外通信渠道（如面对面、书面笔记、屏幕便签、电话、电子邮件等）协调工作。共享锁的目的是让协作者知道还有谁可能在处理资源。

引入共享锁的原因之一是经验表明，独占锁过于刚性。独占锁用于强制执行特定的编辑流程：获取独占锁、读取资源、进行编辑、写入资源、释放锁。这一流程存在锁未正确释放的问题，例如程序崩溃或锁创建者离开未解锁。虽然可以通过超时（第6.6节）和管理操作来移除问题锁，但在需要时可能无法使用这些机制；超时可能时间较长，管理员也可能不在。

成功请求一个新的共享锁必须生成一个唯一的锁，关联到请求主体。因此，如果五个主体对同一资源都获得了共享写锁，则会有五个锁和五个锁令牌，每个主体对应一个。

6.3. 必要支持

WebDAV资源不强制支持任何形式的锁定。如果支持锁定，可以选择支持任何组合的独占和共享锁，适用于任何访问类型。

之所以留出这种灵活性，是因为锁策略直接关系到存储仓库采用的资源管理和版本控制系统。这些系统需要控制支持何种锁。例如，有些仓库只支持共享写锁，有些只支持独占写锁，还有些不支持锁。由于每个系统差异较大，导致某些锁功能无法兼容，因此本规范将锁定作为WebDAV中唯一的协商轴心。

6.4. 锁创建者与权限

锁的创建者拥有使用该锁修改资源的特殊权限。当一个资源被加锁后进行修改，服务器必须检查已认证的主体是否与锁的创建者一致（除了验证锁令牌的提交之外）。

服务器可以允许除锁的创建者之外的其他具有特权的用户（例如，资源所有者或管理员）销毁锁。[RFC3744]中定义的“解锁”权限即为此目的。

服务器没有义务接受所有用户或匿名用户发起的LOCK请求。

请注意，拥有锁并不意味着拥有完全的资源修改权限。写入权限和其他权限必须通过正常的权限或认证机制来 enforced，而不能仅仅依赖于锁令牌值的隐藏性。

---

6.5. 锁令牌

锁令牌是一种状态令牌，用于标识特定的锁。每个锁由服务器生成且只有一个唯一的锁令牌。客户端不得试图以任何方式解释锁令牌。

锁令牌的URI必须在所有资源中保持唯一，且这一唯一性应持续有效。这一约束允许在不同资源和服务器之间提交锁令牌而不引起混淆。由于锁令牌是唯一的，客户端可以在其他资源的If头中提交该锁令牌。

当LOCK操作创建新锁时，新的锁令牌会在第10.5节定义的Lock-Token响应头中返回，也会在响应体中显示。

服务器可以将锁令牌设为公开可读（例如，在DAV:lockdiscovery属性中）。这样做的一个用例是，资源所有者（即获得锁的客户端）可以在锁持有时间较长时自行移除锁（比如，客户端崩溃或断开连接后未能清理锁）。除非在用户指导下使用UNLOCK，否则客户端不应使用由其他客户端实例创建的锁令牌。

本规范鼓励服务器为锁令牌创建全局唯一标识符（UUID），并采用“UUID URN命名空间”([RFC4122])中定义的URI格式。然而，服务器也可以使用任何满足唯一性要求的URI（例如，采用其他方案的URI），例如可以使用附录C中定义的“opaquelocktoken”方案构造有效的锁令牌。

示例：“urn:uuid:f81d4fae-7dec-11d0-a765-00a0c91e6bf6”

---

6.6. 锁超时

锁可以具有有限的存续时间。客户端在创建或刷新锁时建议设置存续时间，但最终由服务器决定超时时间。超时时间以秒为单位，表示距离锁到期的剩余时间。

如果刷新锁请求成功，超时计数器必须重新开始（见第9.10.2节）。在其他情况下，不应重新启动超时计数器。

当超时到期后，应移除该锁。在这种情况下，服务器应视为已执行了使用锁令牌的UNLOCK操作。

建议服务器密切关注客户端提交的超时时间值，因为它们反映了客户端的活动意图。例如，浏览器中的小程序可能需要锁定资源，但由于环境不稳定，可能会在未警告的情况下关闭。为了确保锁能尽快被释放，小程序可能会请求较短的超时时间。而文档管理系统可能会请求极长的超时时间，以便用户可能会离线。

客户端不得假设超时一到，锁就立即被移除。同样，也不得假设超时未到，锁仍然存在。客户端应假设锁可能随时消失，无论Timeout头中给出的值如何。Timeout头仅表示在没有特殊情况发生时，服务器的预期行为。例如，具有足够权限的用户可以随时移除锁，系统崩溃也可能导致锁记录丢失。

---

6.7. 锁能力发现

由于服务器支持锁功能是可选的，客户端在尝试锁定资源时，可以直接尝试，也可以通过某种发现机制确定服务器支持的锁类型。这被称为锁能力发现。客户端可以通过检索DAV:supportedlock属性来了解服务器支持的锁类型。

任何支持LOCK方法的DAV兼容资源都必须支持DAV:supportedlock属性。

---

6.8. 活动锁发现

如果其他主体锁定了某个资源，而另一个主体希望访问该资源，了解第一个主体是谁非常有用。为此，提供了DAV:lockdiscovery属性。该属性列出所有未解决的锁，描述它们的类型，甚至可能提供锁令牌。

任何支持LOCK方法的DAV兼容资源都必须支持DAV:lockdiscovery属性。

---

7. 写锁

本节描述特定于写锁类型的语义。写锁是锁类型的一个具体实例，也是本规范中唯一描述的锁类型。

排他性写锁保护资源：它阻止除锁的创建者之外的任何主体对资源进行更改，且在未提交锁令牌的情况下（例如，其他客户端进程未持有锁时）也不允许更改。

客户端必须在修改被写锁保护的资源的请求中提交其被授权使用的锁令牌。写锁覆盖的修改包括：

1. 对任何被写锁保护的资源的以下方面进行更改：

   * 任何变体（variant），

   * 任何死属性（dead property），

   * 任何可锁定的活属性（live property，除非另有定义，默认可锁定）。

2. 对集合（collection）的内部成员URI进行任何修改。内部成员URI被视为已修改，如果它被添加、删除或指向不同的资源。关于写锁和集合的更多讨论见第7.4节。

3. 对写锁根目录的映射进行修改，无论是指向其他资源还是无资源（例如，DELETE操作）。

在HTTP和WebDAV定义的方法中，PUT、POST、PROPPATCH、LOCK、UNLOCK、MOVE、COPY（目标资源）、DELETE和MKCOL会受到写锁的影响。其他方法（尤其是GET）在没有写锁的情况下也能正常工作。

接下来的章节将更具体地描述写锁与各种操作的交互。

---

7.1. 写锁与属性

没有写锁的情况下，不能修改资源的属性，但即使在锁定状态下，由于其模式的要求，活属性的值仍可能发生变化。只有死属性和定义为可锁定的活属性在写锁状态下保证不会变化。

---

7.2. 避免丢失更新

虽然写锁有助于防止丢失更新，但不能完全保证更新不会丢失。考虑如下场景：

两个客户端A和B都想编辑资源“index.html”。客户端A是HTTP客户端，不支持锁定；它没有锁定资源，只是GET后开始编辑。

客户端B执行LOCK，GET后开始编辑，完成后执行PUT和UNLOCK。

客户端A随后执行PUT，覆盖了B的所有更改，导致更新丢失。

WebDAV协议本身无法防止这种情况，原因包括：它不能强制所有客户端使用锁定（因为要兼容不支持锁定的HTTP客户端）；也不能要求服务器支持锁定（不同存储实现可能依赖预留和合并而非锁定）；此外，协议是无状态的，不能强制执行LOCK→GET→PUT→UNLOCK的操作序列。

支持锁定的WebDAV服务器可以通过要求客户端在修改前锁定资源，减少客户端误覆盖的可能性，从而有效阻止HTTP 1.0和1.1客户端修改资源。

WebDAV客户端应在与支持锁定的服务器交互时，采用“锁定→检索→写入→解锁”的操作序列（至少默认如此）。

HTTP 1.1客户端也应通过在If-Match头中使用实体标签（ETag）来避免覆盖其他客户端的更改。

信息管理系统可以通过在修改前强制锁定资源的客户端操作流程，试图防止覆盖。

---

7.3. 写锁与未映射URL

WebDAV允许向未映射的URL发出LOCK请求，以预留该名称。这是一种避免在创建新资源时发生丢失更新问题的简单方法（另一种方法是使用第14.26节中的If-None-Match头）。此操作的副作用是立即锁定新资源，供创建者使用。

注意，集合（collection）不涉及丢失更新问题，因为MKCOL只能用来创建集合，不能覆盖已有集合。试图在创建时锁定集合时，客户端可以通过同时发出MKCOL和LOCK请求（管道化）来增加成功的可能性（但由于这不将两个操作合成一个原子操作，不能保证一定成功）。

成功的锁定请求（针对未映射URL）必须创建一个带有空内容的锁定（非集合）资源。随后，正确的PUT请求（携带正确的锁令牌）会为该资源提供内容。注意，LOCK请求没有机制让客户端提供Content-Type或Content-Language，服务器将使用默认值或空值，并依赖后续的PUT请求提供正确的值。

用锁创建的资源为空，但在其他方面表现得像普通资源。它的行为类似于用空内容的PUT请求创建的资源（未指定Content-Type和Content-Language），随后对同一资源发出LOCK请求。基于此模型，锁定的空资源：

- 可以被读取、删除、移动和复制，行为与普通非集合资源相同。

- 作为其父集合的成员出现。

- 在锁消失时不应消失（客户端应负责清理自己的“烂摊子”，如同处理其他操作或非空资源一样）。

- 可能没有客户端尚未指定的属性值（如DAV:getcontentlanguage）。

- 可以通过PUT请求添加内容。

- 不得转变为集合。服务器应拒绝对已存在的非集合资源发出的MKCOL请求（与对任何已存在的非集合资源的MKCOL请求一样）。

- 必须定义DAV:lockdiscovery和DAV:supportedlock属性的值。

以下是该英文内容的中文翻译：

```
   o  响应必须指示资源已被创建，使用“201 Created”响应码（对已存在资源的LOCK请求将返回200 OK）。响应体仍然必须包含DAV:lockdiscovery属性，就像对已存在资源的LOCK请求一样。

   客户端预计在锁定空资源后不久，使用PUT（可能还包括PROPPATCH）来更新该被锁定的空资源。

   另外，为了向后兼容[RFC2518]，服务器可以实现Lock-Null Resources（LNRs）（见附录D中的定义）。客户端可以通过仅在对未映射的URL进行LOCK后尝试PUT（而非MKCOL或GET），并且不依赖LNR的特定属性，来与支持旧模型LNRs的服务器以及推荐的“锁定空资源”模型进行互操作。

7.4.  写锁与集合

   集合有两种写锁类型。对集合的深度0写锁保护该集合的属性以及该集合的内部成员URL，但不保护成员资源的内容或属性（如果集合本身有实体内容，则也受到保护）。对集合的深度无限写锁则在保护该集合的同时，也对所有成员资源提供写锁保护。

   换句话说，任何类型的写锁都保护在被写锁定的集合中创建新资源的请求、删除内部成员URL的请求，以及更改内部成员段名的请求。

   因此，集合的写锁保护以下所有操作：

   o  删除集合的直接内部成员，

   o  将内部成员移出集合，

   o  将内部成员移入集合，

   o  在集合内重命名内部成员（MOVE操作），

   o  将内部成员复制到集合中（COPY操作），

   o  以及发起创建新内部成员的PUT或MKCOL请求。

   如果内部成员被单独锁定，则必须提供集合的锁令牌。

   此外，深度无限锁会影响对被锁定集合所有成员的所有写操作。使用深度无限锁时，锁定资源的根节点被直接锁定，所有子资源间接被锁定。

   o  任何作为深度无限锁的后代添加的资源，都会变成间接锁定状态。

   o  任何从被锁定集合中移出的间接锁定资源，之后会被解锁。

   o  任何从被锁定源集合中移出的间接锁定资源，移入深度无限锁定的目标集合后，仍然保持间接锁定状态，但由目标集合的锁保护（之后需要目标集合的锁令牌才能进行进一步操作）。

   如果对包含当前被锁定资源的成员URL的集合发起深度无限写锁请求，且这些资源的锁状态与新锁冲突（见第6.1节第3点），则请求必须以423（Locked）状态码失败，响应应包含“no-conflicting-lock”预条件。

   如果锁请求导致资源的URL被添加为深度无限锁定集合的内部成员URL，则新资源必须自动受到该锁的保护。例如，如果对/ a / b/集合进行写锁定，并将资源/c移动到/a/b/c，则资源/a/b/c将被加入到该写锁中。

7.5.  写锁与If请求头

   用户代理在请求对被锁定资源的操作时，必须证明其知道该资源的锁。否则，可能会出现以下场景：程序A由用户A运行，对某资源进行写锁；程序B（同样由用户A运行）不知道程序A的锁，但对该资源发起PUT请求。在这种情况下，PUT会成功，因为锁是与主体（principal）关联的，而非与程序关联的，程序B凭借用户A的凭证被允许执行PUT操作。然而，如果程序B知道了锁，就不会覆盖资源，而是会弹出对话框提示用户冲突。为防止不同程序在没有意识到的情况下忽略其他程序的锁，必须使用机制确保锁的唯一性。

   为了避免这些冲突，所有可能被方法更改的被锁定资源，都必须由授权主体提交锁令牌，否则方法必须失败。锁令牌在If头中出现时提交。例如，如果要移动一个资源，且源和目标都被锁定，则必须在If头中提交两个锁令牌，一个对应源，一个对应目标。

7.5.1.  示例——写锁与COPY

   >>请求

     COPY /~fielding/index.html HTTP/1.1
     Host: www.example.com
     Destination: http://www.example.com/users/f/fielding/index.html
     If: <http://www.example.com/users/f/fielding/index.html>
         (<urn:uuid:f81d4fae-7dec-11d0-a765-00a0c91e6bf6>)

   >>响应

     HTTP/1.1 204 No Content

   在此示例中，尽管源和目标都被锁定，但只需提交一个锁令牌（目标的锁）。这是因为COPY操作不会修改源资源，因此不受写锁影响。在此示例中，用户代理的身份验证之前已通过HTTP协议之外的机制完成（如底层传输层）。

7.5.2.  示例——删除锁定集合的成员

   考虑一个名为“/locked”的集合，具有排他性深度无限写锁，尝试删除内部成员“/locked/member”：

   >>请求

     DELETE /locked/member HTTP/1.1
     Host: example.com

   >>响应

     HTTP/1.1 423 Locked
     Content-Type: application/xml; charset="utf-8"
     Content-Length: xxxx

     <?xml version="1.0" encoding="utf-8" ?>
     <D:error xmlns:D="DAV:">
       <D:lock-token-submitted>
         <D:href>/locked/</D:href>
       </D:lock-token-submitted>
     </D:error>

   因此，客户端必须在请求中提交锁令牌才能成功。可以使用多种形式的If头（见第10.4节）来实现。

   “无标签列表”格式：

     If: (<urn:uuid:150852e2-3847-42d5-8cbe-0f4f296f26cf>)

   “标签列表”格式（针对“http://example.com/locked/”）：

     If: <http://example.com/locked/>
         (<urn:uuid:150852e2-3847-42d5-8cbe-0f4f296f26cf>)

   “标签列表”格式（针对“http://example.com/locked/member”）：

     If: <http://example.com/locked/member>
         (<urn:uuid:150852e2-3847-42d5-8cbe-0f4f296f26cf>)

   注意，为提交锁令牌，实际的格式无关紧要；关键在于锁令牌必须出现在If头中，并且If头本身必须成立。

7.6.  写锁与COPY/MOVE

   COPY操作不得复制源上的任何写锁。然而，如前所述，如果COPY将资源复制到一个被深度无限锁定的集合中，则该资源将被加入到该锁中。

   对被写锁定的资源发起成功的MOVE请求时，不得将写锁随资源一起移动。但如果目标位置已有锁，服务器必须将被移动的资源加入到目标的锁范围内。例如，如果MOVE操作使资源成为具有深度无限锁的集合的子项，则该资源将被加入到该集合的锁中。此外，如果具有深度无限锁的资源被移动到同一锁范围内的目标（如在锁覆盖的URL命名空间树内），该资源也会再次被加入到锁中。在这两种情况下（见第7.5节），都必须提交包含源和目标的锁令牌的If头。

7.7.  刷新写锁

   客户端不得重复提交相同的写锁请求。注意，客户端总是知道自己在重新提交相同的锁请求，因为必须在If头中包含锁令牌，以请求已被锁定的资源。

   但客户端可以提交带有If头但无正文的LOCK请求。接收无正文的LOCK请求的服务器不得创建新锁——此类LOCK请求仅用于“刷新”现有锁（至少意味着必须重置与锁相关的任何计时器）。

   客户端可以在锁刷新请求中提交任意值的Timeout头。服务器可以忽略客户端提交的Timeout头，也可以用不同于之前的超时时间刷新锁，只要在LOCK刷新响应中公布新值。

   如果在响应中收到错误，客户端不得假设锁已被成功刷新。
```

以下是该英文内容的中文翻译：

```
   o  使用点段（"." 或 ".."），或者

   o  拥有与请求URI不匹配的前缀（使用[RFC2616]第3.2.3节中定义的比较规则）。

   集合的标识符应以“/”字符结尾。

8.3.1.  示例——正确的URL处理

   考虑集合 http://example.com/sample/，其内部成员URL为 http://example.com/sample/a%20test，以及下面的PROPFIND请求：

   >>请求：

     PROPFIND /sample/ HTTP/1.1
     Host: example.com
     Depth: 1

在这种情况下，服务器应返回两个包含 'href' 元素的响应，内容为：

   o  'http://example.com/sample/' 和
      'http://example.com/sample/a%20test'，或者

   o  '/sample/' 和 '/sample/a%20test'

请注意，即使服务器内部将成员资源存储为 'a test'，在URI引用中使用时也必须进行百分比编码（参见[RFC3986]第2.1节）。还应注意，合法的URI可能仍包含在XML字符数据中需要转义的字符，例如“&”字符。

8.4.  请求中必需的正文

   一些新方法未定义正文。服务器必须检查所有请求是否包含正文，即使没有预期正文。在请求正文存在但会被服务器忽略的情况下，服务器必须以415（不支持的媒体类型）拒绝请求。这通知客户端（可能试图使用扩展功能）正文无法按预期处理。

8.5.  WebDAV中使用的HTTP头

   HTTP定义了许多可用于WebDAV请求和响应的头部。并非所有头部在所有情况下都适用，某些交互可能未定义。请注意，HTTP/1.1要求所有响应尽可能包含Date头（参见[RFC2616]第14.18节）。

   服务器在检查任何HTTP条件头之前，必须进行授权检查。

8.6.  ETag

   HTTP/1.1建议使用ETag而非修改日期进行缓存控制，且出于更强的理由，优先使用ETag进行内容标识。在分布式协作环境中，正确使用ETag尤为重要，因为ETag与锁结合使用可以避免“丢失更新”问题。例如，当锁超时且客户端意外离线或正在进行长时间上传时，客户端可能未能续订锁。当客户端未能续订锁时，资源仍可能被重新锁定，用户可以继续编辑，只要在此期间没有进行更改。ETag使客户端能够区分这种情况，否则，客户端不得不询问用户是否覆盖服务器上的资源，甚至无法告知用户资源是否已更改。时间戳在解决此问题方面远不如ETag。

强ETag比弱ETag在协作场景中更有用（参见[RFC2616]第13.3.3节）。语义等价性是一个有用的概念，但这取决于文档类型和应用类型，互操作性可能需要超出本规范和HTTP的某些协议或标准。还应注意，HTTP中弱ETag有一定限制，例如不能在If-Match头中使用。

请注意，PUT响应中的ETag的含义在本文或RFC2616中都未明确定义（即，ETag是否意味着资源与PUT请求体完全一致，或服务器在存储时可能对格式或内容做了微小更改）。这是HTTP的问题，不仅仅是WebDAV的问题。

由于客户端可能被迫提示用户或丢弃已更改的内容（如果ETag发生变化），WebDAV服务器不应更改具有未变正文和位置的资源的ETag（或Last-Modified时间）。ETag代表资源正文或内容的状态，目前没有类似的方法来判断属性是否已更改。

8.7. 包含错误响应正文

在WebDAV的版本控制扩展规范引入机制之前，HTTP和WebDAV大多数错误响应未使用正文提供机器可解析的信息（参见[RFC3253]第1.6节）。错误正文机制适用于任何可能带正文但尚未定义正文的错误响应。当状态码可能意味着多种情况（例如，400 Bad Request可能意味着缺少必要的头部、头部格式错误等）时，此机制尤为适用。该机制在第16节中有详细说明。

8.8. 命名空间操作对缓存验证器的影响

请注意，HTTP响应头“Etag”和“Last-Modified”（参见[RFC2616]第14.19和14.29节）是针对每个URL（而非每个资源）定义的，客户端用它们进行缓存。因此，服务器必须确保执行任何影响URL命名空间的操作（如COPY、MOVE、DELETE、PUT或MKCOL）时，能保持其语义，特别是：

   o  对于任何给定的URL，"Last-Modified"值必须在GET返回的表示发生变化时递增（在时间戳分辨率范围内）。

   o  对于任何给定的URL，"ETag"值不得在不同的表示之间重复使用。

实际上，这意味着服务器

   o  可能需要为命名空间操作的目标命名空间中的每个资源递增"Last-Modified"时间戳，除非能更有选择性地操作，且

   o  可能需要为这些资源重新分配"ETag"值（除非服务器以某种方式分配实体标签，使其在整个由服务器管理的URL命名空间中唯一）。

请注意，这些考虑也适用于特定用例，例如使用PUT在已映射但已删除的URL上创建新资源。

最后，继承HTTP头语义的WebDAV属性（如DAV:getetag和DAV:getlastmodified）必须相应地表现。

9.  分布式协作的HTTP方法

9.1.  PROPFIND方法

   PROPFIND方法用于检索由请求URI标识的资源上的属性（如果资源没有内部成员），或者在资源是具有内部成员URL的集合时，检索该资源及其成员资源上的属性。所有符合DAV规范的资源必须支持PROPFIND方法及其对应的propfind XML元素（第14.20节）以及所有为该元素定义的XML元素。

   客户端必须在PROPFIND请求中提交Depth头，值为"0"、"1"或"infinity"。服务器必须支持WebDAV兼容资源上的"0"和"1"深度请求，并应支持"infinity"请求。实际上，由于性能和安全考虑，可能会禁用对无限深度请求的支持。服务器应将没有Depth头的请求视为包含"Depth: infinity"头的请求。

   客户端可以在请求体中提交描述所请求信息的'propfind' XML元素。可以：

   o  请求特定属性值，通过在'prop'元素中命名所需的属性（属性的顺序可能被服务器忽略），

   o  请求本规范定义的属性（至少）以及死属性的属性值，使用'allprop'元素（可以结合'use include'元素，指示服务器还应包括可能未返回的其他活动属性），

   o  请求资源上所有定义属性的名称列表，使用'propname'元素。

   客户端可以选择不提交请求体。空的PROPFIND请求体必须视为请求所有属性（'allprop'请求）。

   请注意，'allprop'不会返回所有活动属性的值。WebDAV服务器中存在一些昂贵计算或较长的属性（参见[RFC3253]和[RFC3744]），并不总是返回所有属性。相反，WebDAV客户端可以使用propname请求来发现存在的活动属性，并在检索值时请求特定属性。对于其他定义的活动属性，其定义可以指定是否在'allprop'请求中返回。

   所有服务器必须支持返回内容类型为text/xml或application/xml的响应，内容包含描述检索各种属性结果的多状态XML元素。

   如果在检索属性时发生错误，响应中必须包含适当的错误结果。请求不存在的属性值是错误，必须用包含404（未找到）状态码的'response' XML元素标识。

   因此，集合资源的'multistatus' XML元素必须为集合中的每个成员URL（按请求的深度）包含一个'response' XML元素。不应为非WebDAV兼容的资源包含任何'response'元素。每个'response'元素必须包含一个'href'元素，指明定义属性的资源URL。对集合资源的PROPFIND结果以扁平列表返回，条目的顺序不重要。请注意，一个属性在某个特定名称下可能只有一个值，因此在PROPFIND响应中该属性可能只出现一次。

   属性可能受到访问控制。在'allprop'和'propname'请求中，如果主体没有权限知道某个属性是否存在，则该属性可以被静默排除在响应之外。

   某些PROPFIND结果可以谨慎缓存，因为大多数属性没有缓存验证机制。此方法是安全且幂等的（参见[RFC2616]第9.1节）。

9.1.1.  PROPFIND状态码

   本节（与其他方法类似）提供一些关于错误码和在PROPFIND中可能特别有用的前置条件或后置条件（定义在第16节）指导。

   403 Forbidden——服务器可能会拒绝对深度为"Infinity"的集合执行PROPFIND请求，此时应在错误体中使用此错误及前置条件代码'propfind-finite-depth'。

9.1.2.  'propstat'元素中使用的状态码

   在PROPFIND响应中，关于单个属性的信息在'propstat'元素中返回（第14.22节），每个'propstat'包含一个'状态'元素，描述其中的属性。以下总结了在'propstat'中最常用的状态码；但客户端应准备处理其他2/3/4/5xx系列状态码。

   200 OK——属性存在且/或其值成功返回。

   401 Unauthorized——没有适当授权，无法查看该属性。

   403 Forbidden——无论是否认证，都无法查看该属性。

   404 Not Found——属性不存在。

9.1.3.  示例——检索命名属性

   >>请求

     PROPFIND /file HTTP/1.1
     Host: www.example.com
     Content-type: application/xml; charset="utf-8"
     Content-Length: xxxx

     <?xml version="1.0" encoding="utf-8" ?>
     <D:propfind xmlns:D="DAV:">
       <D:prop xmlns:R="http://ns.example.com/boxschema/">
         <R:bigbox/>
         <R:author/>
         <R:DingALing/>
         <R:Random/>
       </D:prop>
     </D:propfind>

   >>响应

     HTTP/1.1 207 Multi-Status
     Content-Type: application/xml; charset="utf-8"
     Content-Length: xxxx

     <?xml version="1.0" encoding="utf-8" ?>
     <D:multistatus xmlns:D="DAV:">
       <D:response xmlns:R="http://ns.example.com/boxschema/">
         <D:href>http://www.example.com/file</D:href>
         <D:propstat>
           <D:prop>
             <R:bigbox>
               <R:BoxType>Box type A</R:BoxType>
             </R:bigbox>
             <R:author>
               <R:Name>J.J. Johnson</R:Name>
             </R:author>
           </D:prop>
           <D:status>HTTP/1.1 200 OK</D:status>
         </D:propstat>
         <D:propstat>
           <D:prop><R:DingALing/><R:Random/></D:prop>
           <D:status>HTTP/1.1 403 Forbidden</D:status>
           <D:responsedescription>用户没有访问DingALing属性的权限。
           </D:responsedescription>
         </D:propstat>
       </D:response>
       <D:responsedescription>发生了访问权限冲突错误。
       </D:responsedescription>
     </D:multistatus>
```

在这个示例中，PROPFIND 方法在非集合资源 http://www.example.com/file 上执行。propfind XML 元素指定了四个属性的名称，请求获取这些属性的值。在此情况下，只返回了两个属性，因为发出请求的主体没有足够的访问权限查看第三和第四个属性。

9.1.4 示例——使用 'propname' 获取所有属性名称

>>请求

```
PROPFIND /container/ HTTP/1.1
Host: www.example.com
Content-Type: application/xml; charset="utf-8"
Content-Length: xxxx

<?xml version="1.0" encoding="utf-8" ?>
<propfind xmlns="DAV:">
  <propname/>
</propfind>
```

>>响应

```
HTTP/1.1 207 Multi-Status
Content-Type: application/xml; charset="utf-8"
Content-Length: xxxx

<?xml version="1.0" encoding="utf-8" ?>
<multistatus xmlns="DAV:">
  <response>
    <href>http://www.example.com/container/</href>
    <propstat>
      <prop xmlns:R="http://ns.example.com/boxschema/">
        <R:bigbox/>
        <R:author/>
        <creationdate/>
        <displayname/>
        <resourcetype/>
        <supportedlock/>
      </prop>
      <status>HTTP/1.1 200 OK</status>
    </propstat>
  </response>
  <response>
    <href>http://www.example.com/container/front.html</href>
    <propstat>
      <prop xmlns:R="http://ns.example.com/boxschema/">
        <R:bigbox/>
        <creationdate/>
        <displayname/>
        <getcontentlength/>
        <getcontenttype/>
        <getetag/>
        <getlastmodified/>
        <resourcetype/>
        <supportedlock/>
      </prop>
      <status>HTTP/1.1 200 OK</status>
    </propstat>
  </response>
</multistatus>
```

在此示例中，PROPFIND 方法在集合资源 http://www.example.com/container/ 上执行，XML 中包含 propname 元素，意味着应返回所有属性的名称。由于没有指定 Depth 头部，默认值为“infinity”，即返回集合及其所有后代的属性名称。

与前一个示例一致，资源 http://www.example.com/container/ 上定义了六个属性：在 "http://ns.example.com/boxschema/" 命名空间中的 bigbox 和 author，以及在 "DAV:" 命名空间中的 creationdate、displayname、resourcetype 和 supportedlock。

资源 http://www.example.com/container/index.html，作为 "container" 集合的成员，定义了九个属性：在 "http://ns.example.com/boxschema/" 命名空间中的 bigbox，以及在 "DAV:" 命名空间中的 creationdate、displayname、getcontentlength、getcontenttype、getetag、getlastmodified、resourcetype 和 supportedlock。

此示例还演示了 XML 命名空间作用域和默认命名空间的使用。由于 "xmlns" 属性没有包含前缀，命名空间默认应用于所有包含的元素。因此，所有未明确声明所属命名空间的元素，都是 "DAV:" 命名空间的成员。

9.1.5 示例——使用所谓的 'allprop'

注意，尽管名为 'allprop'，为了向后兼容，它并不返回所有属性，而只返回死属性和本规范定义的活属性。

>>请求

```
PROPFIND /container/ HTTP/1.1
Host: www.example.com
Depth: 1
Content-Type: application/xml; charset="utf-8"
Content-Length: xxxx

<?xml version="1.0" encoding="utf-8" ?>
<D:propfind xmlns:D="DAV:">
  <D:allprop/>
</D:propfind>
```

>>响应

```
HTTP/1.1 207 Multi-Status
Content-Type: application/xml; charset="utf-8"
Content-Length: xxxx

<?xml version="1.0" encoding="utf-8" ?>
<D:multistatus xmlns:D="DAV:">
  <D:response>
    <D:href>/container/</D:href>
    <D:propstat>
      <D:prop xmlns:R="http://ns.example.com/boxschema/">
        <R:bigbox><R:BoxType>Box type A</R:BoxType></R:bigbox>
        <R:author><R:Name>Hadrian</R:Name></R:author>
        <D:creationdate>1997-12-01T17:42:21-08:00</D:creationdate>
        <D:displayname>示例集合</D:displayname>
        <D:resourcetype><D:collection/></D:resourcetype>
        <D:supportedlock>
          <D:lockentry>
            <D:lockscope><D:exclusive/></D:lockscope>
            <D:locktype><D:write/></D:locktype>
          </D:lockentry>
          <D:lockentry>
            <D:lockscope><D:shared/></D:lockscope>
            <D:locktype><D:write/></D:locktype>
          </D:lockentry>
        </D:supportedlock>
      </D:prop>
      <D:status>HTTP/1.1 200 OK</D:status>
    </D:propstat>
  </D:response>
  <D:response>
    <D:href>/container/front.html</D:href>
    <D:propstat>
      <D:prop xmlns:R="http://ns.example.com/boxschema/">
        <R:bigbox><R:BoxType>Box type B</R:BoxType></R:bigbox>
        <D:creationdate>1997-12-01T18:27:21-08:00</D:creationdate>
        <D:displayname>示例HTML资源</D:displayname>
        <D:getcontentlength>4525</D:getcontentlength>
        <D:getcontenttype>text/html</D:getcontenttype>
        <D:getetag>"zzyzx"</D:getetag>
        <D:getlastmodified>Mon, 12 Jan 1998 09:25:56 GMT</D:getlastmodified>
        <D:resourcetype/>
        <D:supportedlock>
          <D:lockentry>
            <D:lockscope><D:exclusive/></D:lockscope>
            <D:locktype><D:write/></D:locktype>
          </D:lockentry>
          <D:lockentry>
            <D:lockscope><D:shared/></D:lockscope>
            <D:locktype><D:write/></D:locktype>
          </D:lockentry>
        </D:supportedlock>
      </D:prop>
      <D:status>HTTP/1.1 200 OK</D:status>
    </D:propstat>
  </D:response>
</D:multistatus>
```

在此示例中，PROPFIND 在资源 http://www.example.com/container/ 上以 Depth 头部值为 1 调用，意味着请求适用于该资源及其子资源，XML 中包含 allprop 元素，表示请求应返回所有在资源上定义的死属性的名称和值，以及本规范定义的所有属性的名称和值。此示例还演示了响应中 'href' 元素的相对引用用法。

资源 http://www.example.com/container/ 上定义了六个属性：在 "http://ns.example.com/boxschema/" 命名空间中的 'bigbox' 和 'author'，以及在 "DAV:" 命名空间中的 'creationdate'、'displayname'、'resourcetype' 和 'supportedlock'。

这四个属性中，后四个是 WebDAV 特有的，定义在第15节中。由于此资源不支持 GET 方法，get* 系列属性（如 DAV:getcontentlength）未在此资源上定义。WebDAV 特有属性声明，“container” 于 1997 年 12 月 1 日下午5:42:21 在 GMT 西偏 8 小时的时区创建（DAV:creationdate），名称为“示例集合”（DAV:displayname），资源类型为集合（DAV:resourcetype），支持排他写锁和共享写锁（DAV:supportedlock）。

资源 http://www.example.com/container/front.html 上定义了九个属性：

在 "http://ns.example.com/boxschema/" 命名空间中的 'bigbox'（另一个“bigbox”属性类型的实例），以及在 "DAV:" 命名空间中的 'creationdate'、'displayname'、'getcontentlength'、'getcontenttype'、'getetag'、'getlastmodified'、'resourcetype' 和 'supportedlock'。

这些 WebDAV 特有属性声明，“front.html” 于 1997 年 12 月 1 日下午6:27:21 在 GMT 西偏 8 小时的时区创建（DAV:creationdate），名称为“示例HTML资源”（DAV:displayname），内容长度为 4525 字节（DAV:getcontentlength），MIME 类型为“text/html”（DAV:getcontenttype），实体标签为“zzyzx”（DAV:getetag），最后修改时间为 1998 年 1 月 12 日星期一 09:25:56 GMT（DAV:getlastmodified），资源类型为空，表示不是集合（DAV:resourcetype），支持排他写锁和共享写锁（DAV:supportedlock）。

9.1.6 示例——结合使用 'allprop' 和 'include'

>>请求

```
PROPFIND /mycol/ HTTP/1.1
Host: www.example.com
Depth: 1
Content-Type: application/xml; charset="utf-8"
Content-Length: xxxx

<?xml version="1.0" encoding="utf-8" ?>
<D:propfind xmlns:D="DAV:">
  <D:allprop/>
  <D:include>
    <D:supported-live-property-set/>
    <D:supported-report-set/>
  </D:include>
</D:propfind>
```

在此示例中，PROPFIND 在资源 http://www.example.com/mycol/ 及其内部成员资源上执行。客户端请求获取本规范定义的所有活属性的值、所有死属性，以及 [RFC3253] 中定义的另外两个活属性。响应未显示。

9.2 PROPPATCH 方法

PROPPATCH 方法根据请求体中的指令，设置和/或删除资源（由请求 URI 标识）上的属性。

所有符合 DAV 规范的资源必须支持 PROPPATCH 方法，并且必须处理使用 propertyupdate、set 和 remove XML 元素指定的指令。当然，执行这些指令受到访问控制限制。支持 DAV 规范的资源应支持设置任意死属性。

PROPPATCH 请求消息体必须包含 propertyupdate XML 元素。

服务器必须按文档顺序处理 PROPPATCH 指令（与顺序无关的常规规则除外）。所有指令要么全部执行，要么全部不执行。因此，如果在处理过程中发生任何错误，所有已执行的指令都必须撤销，并返回适当的错误结果。指令处理的详细信息可在第14.23和14.26节中关于 set 和 remove 指令的定义中找到。

如果服务器试图对请求中的任何属性进行更改（即请求未在处理请求体前因高层错误被拒绝），响应必须是第9.2.1节所述的多状态（Multi-Status）响应。

此方法是幂等的，但不是安全的（参见 [RFC2616] 第9.1节）。对此方法的响应不得缓存。

9.2.1 'propstat' 元素中状态码的使用

在 PROPPATCH 的响应中，关于单个属性的信息会在 'propstat' 元素中返回（见第14.22节），每个 'propstat' 包含一个 'status' 元素，描述其中涉及的属性的状态。以下总结了在 'propstat' 中最常用的状态码；但客户端应准备处理其他 2/3/4/5xx 系列的状态码。

- 200 (OK)——属性设置或更改成功。注意，如果此状态码出现在某个属性上，则响应中的每个属性都将显示此状态码，因为 PROPPATCH 是原子操作。

- 403 (Forbidden)——客户端因某些原因（由服务器决定不予说明）无法更改某个属性。

- 403 (Forbidden)：客户端试图设置受保护的属性（如 DAV:getetag）。如果返回此错误，服务器应在响应体中使用预条件代码 'cannot-modify-protected-property'。

- 409 (Conflict)——客户端提供的值对该属性的语义不适用。

- 424 (Failed Dependency)——由于其他属性更改失败，导致无法进行此属性的更改。

- 507 (Insufficient Storage)——服务器没有足够空间记录属性。

9.2.2 示例——PROPPATCH

>>请求

```
PROPPATCH /bar.html HTTP/1.1
Host: www.example.com
Content-Type: application/xml; charset="utf-8"
Content-Length: xxxx

<?xml version="1.0" encoding="utf-8" ?>
<D:propertyupdate xmlns:D="DAV:"
        xmlns:Z="http://ns.example.com/standards/z39.50/">
  <D:set>
    <D:prop>
      <Z:Authors>
        <Z:Author>Jim Whitehead</Z:Author>
        <Z:Author>Roy Fielding</Z:Author>
      </Z:Authors>
    </D:prop>
  </D:set>
  <D:remove>
    <D:prop><Z:Copyright-Owner/></D:prop>
  </D:remove>
</D:propertyupdate>
```

>>响应

```
HTTP/1.1 207 Multi-Status
Content-Type: application/xml; charset="utf-8"
Content-Length: xxxx

<?xml version="1.0" encoding="utf-8" ?>
<D:multistatus xmlns:D="DAV:"
        xmlns:Z="http://ns.example.com/standards/z39.50/">
  <D:response>
    <D:href>http://www.example.com/bar.html</D:href>
    <D:propstat>
      <D:prop><Z:Authors/></D:prop>
      <D:status>HTTP/1.1 424 Failed Dependency</D:status>
    </D:propstat>
    <D:propstat>
      <D:prop><Z:Copyright-Owner/></D:prop>
      <D:status>HTTP/1.1 409 Conflict</D:status>
    </D:propstat>
    <D:responsedescription>版权所有者无法被删除或更改。</D:responsedescription>
  </D:response>
</D:multistatus>
```

在此示例中，客户端请求服务器在 "http://ns.example.com/standards/z39.50/" 命名空间中设置 "Authors" 属性的值，并删除同一命名空间中的 "Copyright-Owner" 属性。由于无法删除 "Copyright-Owner" 属性，未发生任何属性修改。对于 "Authors" 属性返回的 424（Failed Dependency）状态码，表示如果没有与删除 "Copyright-Owner" 属性的冲突，此操作本应成功。

9.3 MKCOL 方法

MKCOL 在请求 URI 指定的位置创建一个新的集合资源。如果请求 URI 已映射到某个资源，则必须失败。在处理 MKCOL 时，服务器必须将请求 URI 作为其父集合的内部成员，除非请求 URI 为 "/"。如果不存在这样的祖先，方法必须失败。当 MKCOL 操作创建新集合资源时，所有祖先必须已存在，否则方法将以 409（冲突）状态码失败。例如，若请求创建 /a/b/c/d/，而 /a/b/c/ 不存在，则请求必须失败。

当没有请求体时，创建的集合应没有成员。

MKCOL 请求消息可以包含消息体。若请求体存在，其具体行为未定义，但限于创建集合、集合成员、成员的内容以及集合或成员上的属性。如果服务器收到不支持或无法理解的请求实体类型，必须返回 415（不支持的媒体类型）状态码。若服务器决定因实体存在或类型而拒绝请求，也应返回 415。

此方法是幂等的，但不是安全的（参见 [RFC2616] 第9.1节）。对此方法的响应不得缓存。

9.3.1 MKCOL 状态码

除一般状态码外，以下状态码在 MKCOL 中具有特殊适用性：

- 201（已创建）——集合已成功创建。

- 403（禁止）——表示至少满足以下两个条件之一：1）服务器不允许在其 URL 命名空间中的该位置创建集合；2）请求 URI 的父集合存在但不能接受成员。

- 405（方法不允许）——只能在未映射的 URL 上执行 MKCOL。

- 409（冲突）——在创建中间集合之前，不能在请求 URI 位置创建集合。服务器不得自动创建中间集合。

- 415（不支持的媒体类型）——服务器不支持请求体类型（尽管在 MKCOL 请求中允许请求体，但由于本规范未定义任何类型，服务器可能不支持任何请求体类型）。

- 507（存储空间不足）——资源没有足够空间记录操作后的状态。

9.3.2 示例——MKCOL

此示例在 www.example.com 服务器上创建一个名为 /webdisc/xfiles/ 的集合。

>>请求

```
MKCOL /webdisc/xfiles/ HTTP/1.1
Host: www.example.com
```

>>响应

```
HTTP/1.1 201 Created
```

9.4 集合的 GET 和 HEAD

当应用到集合时，GET 的语义保持不变，因为 GET 被定义为“检索由请求 URI 标识的任何信息（以实体形式）”[RFC2616]。应用于集合时，GET 可能返回“index.html”资源的内容、集合内容的可读视图，或其他内容。因此，GET 对集合的操作结果可能与集合的成员关系没有任何关联。

类似地，由于HEAD的定义是一个没有响应消息体的GET，因此在应用到集合资源时，HEAD的语义保持不变。

9.5.  集合的POST

由于POST的实际功能由服务器决定，且通常依赖于特定资源，因此在应用于集合时，POST的行为不能被有意义地修改，因为其大部分是未定义的。因此，应用于集合的POST的语义保持不变。

9.6.  DELETE的要求

DELETE在[RFC2616]第9.7节中被定义为“删除由Request-URI标识的资源”。然而，WebDAV对某些DELETE处理要求进行了更改。

处理成功的DELETE请求的服务器：

- 必须销毁根植于被删除资源上的锁
- 必须移除Request-URI到任何资源的映射

因此，在成功执行DELETE操作后（且没有其他操作的情况下），对目标Request-URI的后续GET/HEAD/PROPFIND请求必须返回404（未找到）。

9.6.1.  集合的DELETE

对集合的DELETE方法必须表现得就像使用了“Depth: infinity”头一样。客户端不得在对集合执行DELETE时提交除“infinity”以外的Depth头。

DELETE指示应删除Request-URI指定的集合以及其内部成员URL所标识的所有资源。

如果任何由成员URL标识的资源无法删除，则其所有祖先资源也不得删除，以维护URL命名空间的一致性。

任何随DELETE请求包含的头部都必须在处理每个待删除的资源时应用。

当DELETE方法处理完毕后，必须确保URL命名空间的一致性。

如果在删除成员资源（即Request-URI之外的资源）时发生错误，响应可以是207（多状态）。多状态响应用于指示哪些内部资源无法删除，包括错误代码，有助于客户端理解失败原因。例如，如果内部资源被锁定，响应体中可以包含状态为423（已锁定）的响应。

如果请求完全失败，服务器可以返回4xx状态码，而不是207。

对于DELETE的207响应，不应包含424（依赖失败）状态码。这些可以安全省略，因为客户端会在收到祖先资源的错误时知道无法删除其祖先。此外，207响应中不应返回204（无内容）错误，因为204是默认的成功状态码。

9.6.2.  示例——DELETE

>>请求

DELETE /container/ HTTP/1.1  
Host: www.example.com

>>响应

HTTP/1.1 207 Multi-Status  
Content-Type: application/xml; charset="utf-8"  
Content-Length: xxxx

<?xml version="1.0" encoding="utf-8" ?>  
<d:multistatus xmlns:d="DAV:">  
  <d:response>  
    <d:href>http://www.example.com/container/resource3</d:href>  
    <d:status>HTTP/1.1 423 Locked</d:status>  
    <d:error><d:lock-token-submitted/></d:error>  
  </d:response>  
</d:multistatus>

在此示例中，尝试删除http://www.example.com/container/resource3失败，因为它被锁定，且请求中未提交锁令牌。因此，尝试删除http://www.example.com/container/也失败了。因此，客户端知道，删除http://www.example.com/container/的尝试也必然失败，因为父资源不能在子资源未删除的情况下被删除。尽管没有包含Depth头，但由于操作对象是集合，默认假定深度为无限。

9.7.  PUT的要求

9.7.1.  非集合资源的PUT

对现有资源执行的PUT会替换该资源的GET响应实体。资源上定义的属性在PUT处理过程中可能会被重新计算，但不会受到其他影响。例如，如果服务器识别请求体的内容类型，可能会自动提取信息并将其作为属性暴露。

如果PUT会导致在没有适当范围的父集合中创建资源，则必须返回409（冲突）状态码。

PUT请求允许客户端指示实体主体的媒体类型，以及在覆盖时是否应更改。因此，如果已知，客户端应为新资源提供Content-Type。如果未提供，服务器可以创建没有Content-Type的资源，或尝试分配一个。

注意，虽然接收方通常应将HTTP请求中提供的元数据视为权威，但实际上没有保证服务器会接受客户端提供的元数据（例如，以“Content-”开头的请求头）。许多服务器甚至不允许为每个资源单独配置Content-Type。因此，客户端不能总是依赖通过包含Content-Type请求头来直接影响内容类型。

9.7.2.  集合的PUT

本规范未定义对已存在集合的PUT行为。对已存在集合的PUT请求可能被视为错误（405 方法不允许）。

定义了MKCOL方法，用于创建集合。

9.8.  COPY方法

COPY方法在Request-URI标识的源资源和Destination头中指定的目标资源之间创建一个副本。必须存在Destination头。COPY方法的具体行为取决于源资源的类型。

所有符合WebDAV的资源必须支持COPY方法，但支持COPY并不保证一定能成功复制资源。例如，可能由不同程序控制同一服务器上的资源，因此可能无法将资源复制到看似在同一服务器上的位置。

此方法是幂等的，但不是安全的（参见[RFC2616]第9.1节）。对此方法的响应不得缓存。

9.8.1.  非集合资源的COPY

当源资源不是集合时，COPY的结果是在目标位置创建一个新资源，其状态和行为尽可能与源资源一致。由于目标环境可能与源不同（例如缺少必要的资源以确保正确操作），可能无法完全复制资源的行为。对目标资源的后续更改不会影响源资源，反之亦然。

9.8.2.  属性的COPY

成功执行COPY后，源资源上的所有死属性应复制到目标资源。本文档描述的活属性应在目标资源上以相同的行为复制，但不一定具有相同的值。服务器不应将活属性转换为死属性，否则客户端可能会得出错误的资源状态或功能结论。某些活属性定义了其缺失具有特定含义（例如，存在表示某个状态，缺失则相反），在这种情况下，成功的COPY可能导致后续请求中该属性显示为“未找到”。

当目标是未映射的URL时，COPY操作会像PUT一样创建新资源。与资源创建相关的活属性（如DAV:creationdate）应相应设置其值。

9.8.3.  集合的COPY

对没有Depth头的集合执行COPY时，必须表现得就像包含“Depth: infinity”一样。客户端可以在对集合执行COPY时提交Depth头，值为“0”或“infinity”。服务器必须支持WebDAV资源上的“0”和“infinity”深度行为。

无限深度的COPY指示将Request-URI标识的集合资源复制到Destination头中指定的位置，并将其所有内部成员资源递归复制到相对于该位置的目标中。注意，若不正确处理，/A/复制到 /A/B/可能导致无限递归。

“Depth: 0”的COPY只复制集合及其属性，不复制由内部成员URL标识的资源。

任何随COPY请求包含的头部都必须在处理每个待复制资源时应用，除了Destination头。

Destination头仅指定Request-URI的目标位置。当应用于Request-URI标识的集合成员时，Destination的值应根据层级结构进行调整。例如，Request-URI为/a/，Host头为http://example.com/，若Destination为http://example.com/b/，则处理http://example.com/a/c/d时，必须使用Destination为http://example.com/b/c/d。

完成COPY操作后，必须在目标位置创建一个一致的URL命名空间（参见第5.1节关于命名空间一致性的定义）。但如果在复制内部集合时发生错误，服务器不得复制该集合中的任何资源（即跳过此子树），否则会导致命名空间不一致。检测到错误后，COPY操作应尽可能完成原始复制的其他部分（即，服务器应继续尝试复制未出错的子树及其成员）。

例如，若对包含集合/a/、/a/b/和/a/c/的集合/a/执行无限深度复制，且在复制/a/b/时出错，仍应尝试复制/a/c/。类似地，在复制非集合资源时遇到错误后，服务器也应尽可能完成剩余的复制。

如果在执行COPY时，发生了对Request-URI以外资源的错误，响应必须为207（多状态），且出错资源的URL必须在响应中明确显示。

不应在COPY的207响应中返回424（依赖失败）状态码。这些可以安全省略，因为客户端在收到父资源的错误时会知道其子资源无法复制。此外，207响应中也不应返回201（已创建）或204（无内容）状态码，因为它们是默认的成功状态。

9.8.4.  COPY与覆盖目标资源

如果COPY请求的OverWrite头为“F”，且目标URL上已有资源，服务器必须拒绝请求。

当服务器执行COPY并覆盖目标资源时，具体行为可能依赖多种因素，包括WebDAV扩展能力（特别参见[RFC3253]）。例如，覆盖普通资源时，服务器可以在复制前删除目标资源，或进行就地覆盖以保留活属性。

当覆盖集合时，成功的COPY后，目标集合的成员必须与复制前源集合的成员相同。将源和目标集合的成员合并到目标中，不符合规范。

一般来说，如果客户端在执行复制（COPY）之前需要清除目标URL的状态（例如，为了强制重置实时属性），那么客户端可以在发起COPY请求之前先发送一个DELETE请求，以确保目标被重置。

9.8.5. 状态码

除了常规的状态码外，以下状态码在COPY操作中具有特定的适用性：

- 201（已创建）——源资源已成功复制。该COPY操作导致一个新资源的创建。
- 204（无内容）——源资源已成功复制到一个已存在的目标资源。
- 207（多状态）——多个资源将受到影响，但其中一些资源的错误阻止了操作的完成。具体的错误信息以及最合适的源和目标URL会显示在多状态响应的正文中。例如，如果目标资源被锁定，无法覆盖，则目标资源的URL会伴随状态码423（已锁定）。
- 403（禁止）——操作被禁止。COPY的一个特殊情况是，源资源和目标资源是同一个资源。
- 409（冲突）——在创建目标资源之前，必须先创建一个或多个中间的集合。服务器不得自动创建这些中间集合。
- 412（前提条件失败）——前提条件头部检查失败，例如，覆盖（Overwrite）头设置为“F”，而目标URL已映射到某个资源。
- 423（已锁定）——目标资源或目标集合中的资源被锁定。此响应应包含‘lock-token-submitted’的前提条件元素。
- 502（网关错误）——当目标在另一台服务器、存储库或URL命名空间中时可能发生。可能源命名空间不支持复制到目标命名空间，或目标命名空间拒绝接受资源。客户端可能需要尝试使用GET/PUT和PROPFIND/PROPPATCH。
- 507（存储空间不足）——目标资源没有足够的空间来记录执行此方法后资源的状态。

9.8.6. 示例——带覆盖的COPY

此示例将资源http://www.example.com/~fielding/index.html复制到http://www.example.com/users/f/fielding/index.html。状态码204（无内容）表示目标已存在的资源被覆盖。

>>请求

```
COPY /~fielding/index.html HTTP/1.1
Host: www.example.com
Destination: http://www.example.com/users/f/fielding/index.html
```

>>响应

```
HTTP/1.1 204 No Content
```

9.8.7. 示例——不覆盖的COPY

以下示例执行相同的复制操作，但将覆盖头（Overwrite）设置为“F”。由于目标URL已映射到某个资源，返回状态码412（前提条件失败）。

>>请求

```
COPY /~fielding/index.html HTTP/1.1
Host: www.example.com
Destination: http://www.example.com/users/f/fielding/index.html
Overwrite: F
```

>>响应

```
HTTP/1.1 412 Precondition Failed
```

9.8.8. 示例——集合的复制

>>请求

```
COPY /container/ HTTP/1.1
Host: www.example.com
Destination: http://www.example.com/othercontainer/
Depth: infinity
```

>>响应

```
HTTP/1.1 207 Multi-Status
Content-Type: application/xml; charset="utf-8"
Content-Length: xxxx

<?xml version="1.0" encoding="utf-8" ?>
<d:multistatus xmlns:d="DAV:">
  <d:response>
    <d:href>http://www.example.com/othercontainer/R2/</d:href>
    <d:status>HTTP/1.1 423 Locked</d:status>
    <d:error><d:lock-token-submitted/></d:error>
  </d:response>
</d:multistatus>
```

在此示例中，默认情况下，COPY操作会视为提交了“Depth: infinity”头部。在大多数资源和集合成功复制的同时，集合R2因被锁定而复制失败。由于发生了复制错误，R2的成员未被复制，但由于错误最小化规则，没有列出这些成员的错误。

9.9. 移动（MOVE）方法

对非集合资源的MOVE操作，实际上是复制（COPY）后进行一致性维护处理，再删除源资源的逻辑组合，三者在一次操作中完成。一致性维护步骤允许服务器执行由移动引起的更新，例如，更新所有URL（除了请求URI指向源资源的部分）以指向新的目标资源。

所有MOVE请求必须包含Destination头部，并且必须满足COPY请求的所有要求。所有支持WebDAV的资源都必须支持MOVE方法。

支持MOVE方法并不保证资源一定能移动到特定的目标。例如，不同的程序可能控制同一服务器上的不同资源集，因此，可能无法在看似属于同一服务器的命名空间内移动资源。

如果目标已存在，MOVE操作会将其删除（受Overwrite头部限制）。此方法是幂等的，但不安全（参见[RFC2616]第9.1节）。对此方法的响应不得缓存。

9.9.1. MOVE属性

本文件描述的实时属性应随资源一起移动，使目标资源具有相同表现的实时属性，但不一定值相同。注意，有些实时属性定义了属性缺失的特定含义（例如，某个标志存在表示某一状态，缺失则相反），在这些情况下，成功的MOVE可能导致后续请求中该属性显示为“未找到”。如果实时属性在目标处不能以相同方式工作，服务器可以拒绝请求。

客户端常用MOVE来重命名文件而不改变其父集合，因此不应重置在资源创建时设置的所有实时属性。例如，DAV:creationdate属性值应在MOVE后保持不变。

死属性（Dead Properties）必须随资源一起移动。

9.9.2. MOVE集合

带有“Depth: infinity”的MOVE指示将请求URI标识的集合移动到Destination头部指定的地址，且其内部成员URL所标识的所有资源都应递归地移动到相对于新位置的路径中。

对集合的MOVE必须表现得像使用了“Depth: infinity”头部。客户端不得在对集合执行MOVE时提交除“infinity”之外的Depth值。

所有包含的头部（除Destination外）都应在处理每个待移动资源时应用。Destination头的行为与集合上的COPY相同。

完成MOVE操作后，必须在源和目标处创建一致的URL命名空间（参见第5.1节关于命名空间一致性的定义）。如果在移动内部集合时发生错误，服务器不得移动该集合中的任何资源（即，必须跳过引发错误的子树），否则会导致命名空间不一致。在检测到错误后，移动操作应尽可能完成原始移动的其他部分。例如，在对包含/a/、/a/b/和/a/c/的集合执行无限深度移动时，如果在移动/a/b/时出错，仍应尝试移动/a/c/。类似地，在遇到非集合资源的无限深度移动错误后，服务器也应尽可能完成剩余的移动。

如果在请求URI之外的资源发生错误，响应必须为207（多状态），且出错资源的URL应显示具体错误。

MOVE方法的207响应中不应返回424（依赖失败）状态码。这些错误可以安全省略，因为客户端会在父资源出错时知道其子资源无法移动。此外，201（已创建）/204（无内容）响应也不应作为MOVE的207响应中的值返回，因为它们是默认的成功码。

9.9.3. MOVE与Overwrite头

如果目标已存在资源且Overwrite头为“T”，在执行移动前，服务器必须对目标资源执行带“Depth: infinity”的DELETE操作。如果Overwrite头为“F”，操作将失败。

9.9.4. 状态码

除了常规状态码外，以下状态码在MOVE操作中具有特定的适用性：

- 201（已创建）——源资源成功移动，且在目标处创建了新的URL映射。
- 204（无内容）——源资源成功移动到已映射的URL。
- 207（多状态）——多个资源将受到影响，但部分资源的错误阻止了操作的完成。具体错误信息和最合适的源/目标URL会显示在多状态响应正文中。例如，源资源被锁定且无法移动时，源资源的URL会伴随状态码423（已锁定）。
- 403（禁止）——在许多禁止MOVE的原因中，建议在源和目标资源相同时使用此状态码。
- 409（冲突）——在创建目标资源前，必须先创建一个或多个中间集合。服务器不得自动创建这些集合。或者，服务器无法在移动过程中保持实时属性的行为（参见“preserved-live-properties”后置条件）。
- 412（前提条件失败）——条件头部检查失败。对于MOVE，可能意味着Overwrite头为“F”，且目标URL已映射到某资源。
- 423（已锁定）——源或目标资源、其父资源，或源/目标集合中的某些资源被锁定。此响应应包含‘lock-token-submitted’的前提条件元素。
- 502（网关错误）——当目标在另一台服务器且被拒绝接受资源时可能发生，也可能发生在目标在同一服务器命名空间的不同子区。

9.9.5. 示例——非集合的MOVE

此示例将资源http://www.example.com/~fielding/index.html移动到http://www.example.com/users/f/fielding/index.html。若目标URL已映射到资源，内容会被覆盖。在此例中，目标资源为空，因此响应码为201（已创建）。

>>请求

```
MOVE /~fielding/index.html HTTP/1.1
Host: www.example.com
Destination: http://www.example.com/users/f/fielding/index.html
```

>>响应

```
HTTP/1.1 201 Created
Location: http://www.example.com/users/f/fielding/index.html
```

9.9.6. 示例——集合的MOVE

>>请求

```
MOVE /container/ HTTP/1.1
Host: www.example.com
Destination: http://www.example.com/othercontainer/
Overwrite: F
If: (<urn:uuid:fe184f2e-6eec-41d0-c765-01adc56e6bb4>)
   (<urn:uuid:e454f3f3-acdc-452a-56c7-00a5c91e4b77>)
```

>>响应

```
HTTP/1.1 207 Multi-Status
Content-Type: application/xml; charset="utf-8"
Content-Length: xxxx

<?xml version="1.0" encoding="utf-8" ?>
<d:multistatus xmlns:d='DAV:'>
  <d:response>
    <d:href>http://www.example.com/othercontainer/C2/</d:href>
    <d:status>HTTP/1.1 423 Locked</d:status>
    <d:error><d:lock-token-submitted/></d:error>
  </d:response>
</d:multistatus>
```

在此示例中，客户端在请求中提交了多个锁定令牌。每个被锁定的资源（无论是源资源还是目标资源）都需要提交一个锁定令牌，涵盖方法范围内的所有资源。在本例中，未为目标资源 http://www.example.com/othercontainer/C2/ 提交正确的锁定令牌。这意味着资源 /container/C2/ 无法被移动。由于移动 /container/C2/ 时发生错误，/container/C2/ 的所有成员都未被移动。然而，由于错误最小化规则，没有列出这些成员的错误信息。用户代理的身份验证已通过HTTP协议之外的机制在底层传输层完成。

9.10. LOCK 方法

以下章节描述了 LOCK 方法，该方法用于获取任何访问类型的锁以及刷新现有的锁。这些关于 LOCK 方法的章节仅描述与 LOCK 方法特有的语义，且与请求锁的访问类型无关。

支持 LOCK 方法的任何资源，必须至少支持本文定义的XML请求和响应格式。

该方法既不是幂等的，也不安全（参见 [RFC2616] 第9.1节）。对该方法的响应不得被缓存。

9.10.1. 在现有资源上创建锁

对现有资源发起 LOCK 请求，将在由请求URI标识的资源上创建锁，前提是该资源未被与之冲突的锁定。如果成功，资源成为锁的根节点。创建新锁的 LOCK 请求必须包含XML请求体。服务器必须保留客户端在LOCK请求中的'owner'元素中提供的信息。LOCK请求可以包含Timeout头。

当新锁创建成功后，LOCK响应必须：

- 包含一个主体，内含DAV:lockdiscovery属性的值，放在prop XML元素中。此信息必须完整描述刚授予的锁，关于其他（共享）锁的信息为可选。

- 包含Lock-Token响应头，携带与新锁相关联的令牌。

9.10.2. 刷新锁

通过向锁范围内的资源URL发送LOCK请求来刷新锁。此请求不得有请求体，必须通过'If'头指定要刷新的锁（只允许刷新一个锁）。请求可以包含Timeout头，服务器可能接受并调整锁的剩余时间。服务器在刷新LOCK时必须忽略Depth头。

如果资源上存在其他（共享）锁，刷新该锁不会影响它们。此外，这些锁不会阻止指定锁的刷新。

成功刷新锁后，响应中不会返回Lock-Token头，但响应体必须包含新的DAV:lockdiscovery属性值。

9.10.3. 深度参数与锁定

可以在LOCK方法中使用Depth头。除0或infinity外的值不得用于LOCK方法的Depth头。所有支持LOCK的资源都必须支持Depth头。

Depth值为0表示仅锁定请求URI指定的资源。

如果Depth设置为infinity，则请求URI及其所有子资源（层级下所有成员）都将被锁定。成功时，返回一个锁令牌。若对该令牌执行解锁操作，所有相关资源都将被解锁。因此，LOCK或UNLOCK操作不支持部分成功，要么整个层级被锁定，要么没有资源被锁定。

如果无法对所有资源授予锁，服务器必须返回多状态响应（Multi-Status），其中至少一个资源的响应元素应显示阻止锁定的原因（如403 Forbidden或423 Locked）。如果导致失败的资源不是请求URI本身，服务器还应在响应中包括请求URI的响应元素，状态码为424 Failed Dependency。

如果未提交Depth头，则视为提交了"Depth:infinity"。

9.10.4. 未映射URL的锁定

成功的LOCK操作应在不存在资源的URL上创建一个空资源（非集合资源）并对其加锁。之后，锁可能会失效，但空资源仍然存在。空资源必须在PROPFIND响应中显示，包括在响应范围内。服务器应对空资源的GET请求返回成功，无内容（204 No Content）或200 OK并Content-Length为零。

9.10.5. 锁的兼容性表

下表描述了在资源上发起锁请求时的行为：

| 当前状态             | 共享锁允许 | 独占锁允许 |
|---------------------|------------|------------|
| 无锁                | 是         | 是         |
| 共享锁              | 是         | 否         |
| 独占锁              | 否         | 否*        |

注：是表示可以授予锁，否表示不允许。*请求相同锁两次在原则上是非法的。

资源的当前锁状态在左列，锁请求在第一行。行列交叉点显示请求结果。例如，资源已持有共享锁，若请求独占锁，结果为“否”。

9.10.6. LOCK响应

除常规状态码外，以下状态码对LOCK特别适用：

- 200 (OK)：LOCK请求成功，响应体中包含DAV:lockdiscovery属性。

- 201 (Created)：请求URI未映射，成功创建新资源，响应体中包含DAV:lockdiscovery。

- 409 (Conflict)：在目标位置无法创建资源，必须先创建中间集合，且不能自动创建。

- 423 (Locked)，可能带有“no-conflicting-lock”前提条件：资源已被不兼容的锁定。

- 412 (Precondition Failed)，带有“lock-token-matches-request-uri”前提条件：请求中带有If头，意图刷新锁，但请求URI不在锁范围内，锁已失效或锁令牌无效。

9.10.7. 示例——简单锁请求

>>请求

```
LOCK /workspace/webdav/proposal.doc HTTP/1.1
Host: example.com
Timeout: Infinite, Second-4100000000
Content-Type: application/xml; charset="utf-8"
Content-Length: xxxx
Authorization: Digest username="ejw",
  realm="ejw@example.com", nonce="...",
  uri="/workspace/webdav/proposal.doc",
  response="...", opaque="..."

<?xml version="1.0" encoding="utf-8" ?>
<D:lockinfo xmlns:D='DAV:'>
  <D:lockscope><D:exclusive/></D:lockscope>
  <D:locktype><D:write/></D:locktype>
  <D:owner>
    <D:href>http://example.org/~ejw/contact.html</D:href>
  </D:owner>
</D:lockinfo>
```

>>响应

```
HTTP/1.1 200 OK
Lock-Token: <urn:uuid:e71d4fae-5dec-22d6-fea5-00a0c91e6be4>
Content-Type: application/xml; charset="utf-8"
Content-Length: xxxx

<?xml version="1.0" encoding="utf-8" ?>
<D:prop xmlns:D="DAV:">
  <D:lockdiscovery>
    <D:activelock>
      <D:locktype><D:write/></D:locktype>
      <D:lockscope><D:exclusive/></D:lockscope>
      <D:depth>infinity</D:depth>
      <D:owner>
        <D:href>http://example.org/~ejw/contact.html</D:href>
      </D:owner>
      <D:timeout>Second-604800</D:timeout>
      <D:locktoken>
        <D:href>urn:uuid:e71d4fae-5dec-22d6-fea5-00a0c91e6be4</D:href>
      </D:locktoken>
      <D:lockroot>
        <D:href>http://example.com/workspace/webdav/proposal.doc</D:href>
      </D:lockroot>
    </D:activelock>
  </D:lockdiscovery>
</D:prop>
```

此示例成功在资源 http://example.com/workspace/webdav/proposal.doc 上创建了一个排他写锁。资源 http://example.org/~ejw/contact.html 包含锁创建者的联系信息。服务器对该资源设置了基于活动的超时策略，锁会在一周（604800秒）后自动移除。注意，Authorization请求头中的nonce、response和opaque字段尚未计算。

9.10.8. 示例——刷新写锁

>>请求

```
LOCK /workspace/webdav/proposal.doc HTTP/1.1
Host: example.com
Timeout: Infinite, Second-4100000000
If: (<urn:uuid:e71d4fae-5dec-22d6-fea5-00a0c91e6be4>)
Authorization: Digest username="ejw",
  realm="ejw@example.com", nonce="...",
  uri="/workspace/webdav/proposal.doc",
  response="...", opaque="..."
```

>>响应

```
HTTP/1.1 200 OK
Content-Type: application/xml; charset="utf-8"
Content-Length: xxxx

<?xml version="1.0" encoding="utf-8" ?>
<D:prop xmlns:D="DAV:">
  <D:lockdiscovery>
    <D:activelock>
      <D:locktype><D:write/></D:locktype>
      <D:lockscope><D:exclusive/></D:lockscope>
      <D:depth>infinity</D:depth>
      <D:owner>
        <D:href>http://example.org/~ejw/contact.html</D:href>
      </D:owner>
      <D:timeout>Second-604800</D:timeout>
      <D:locktoken>
        <D:href>urn:uuid:e71d4fae-5dec-22d6-fea5-00a0c91e6be4</D:href>
      </D:locktoken>
      <D:lockroot>
        <D:href>http://example.com/workspace/webdav/proposal.doc</D:href>
      </D:lockroot>
    </D:activelock>
  </D:lockdiscovery>
</D:prop>
```

此请求旨在刷新锁，试图将超时重置为请求头中指定的新值。注意，客户端请求无限超时，但服务器选择忽略该请求。在此示例中，nonce、response和opaque字段尚未在Authorization请求头中计算。

9.10.9. 示例——多资源锁请求

>>请求

```
LOCK /webdav/ HTTP/1.1
Host: example.com
Timeout: Infinite, Second-4100000000
Depth: infinity
Content-Type: application/xml; charset="utf-8"
Content-Length: xxxx
Authorization: Digest username="ejw",
  realm="ejw@example.com", nonce="...",
  uri="/workspace/webdav/proposal.doc",
  response="...", opaque="..."

<?xml version="1.0" encoding="utf-8" ?>
<D:lockinfo xmlns:D="DAV:">
  <D:locktype><D:write/></D:locktype>
  <D:lockscope><D:exclusive/></D:lockscope>
  <D:owner>
    <D:href>http://example.org/~ejw/contact.html</D:href>
  </D:owner>
</D:lockinfo>
```

>>响应

```
HTTP/1.1 207 Multi-Status
Content-Type: application/xml; charset="utf-8"
Content-Length: xxxx

<?xml version="1.0" encoding="utf-8" ?>
<D:multistatus xmlns:D="DAV:">
  <D:response>
    <D:href>http://example.com/webdav/secret</D:href>
    <D:status>HTTP/1.1 403 Forbidden</D:status>
  </D:response>
  <D:response>
    <D:href>http://example.com/webdav/</D:href>
    <D:status>HTTP/1.1 424 Failed Dependency</D:status>
  </D:response>
</D:multistatus>
```

此示例请求对一个集合及其所有子资源施加排他写锁。请求中，客户端指定希望获得无限期锁（如果可用），否则超时为41亿秒。请求实体中包含锁持有者的联系信息（此处为网页URL）。

由于资源 http://example.com/webdav/secret 无法被锁定，导致未能对任何资源加锁。响应中包含请求URI的响应元素（response），符合规范。注意，nonce、response和opaque字段尚未在Authorization头中计算。

9.11. UNLOCK 方法

UNLOCK方法用于解除由Lock-Token请求头中的锁令牌标识的锁。请求URI必须指向锁范围内的资源。

注意，使用Lock-Token头提供锁令牌的方式与其他状态变更方法不同，后者都需要带有包含锁令牌的If头。因此，UNLOCK请求中不需要提供If头来携带锁令牌。当然，如果存在If头，其含义仍为条件头。

成功响应时，服务器必须完全删除该锁。

如果无法解锁所有由提交的锁令牌锁定的资源，UNLOCK请求必须失败。

成功响应并不意味着资源已解锁，只表示对应的锁令牌已不存在。

任何支持LOCK方法的DAV兼容资源，必须支持UNLOCK方法。

该方法是幂等的，但不安全（参见 [RFC2616] 第9.1节）。响应不得缓存。

9.11.1. 状态码

除常规状态码外，以下状态码对UNLOCK特别适用：

- 204 (No Content)：成功解除锁定，无响应体（不同于200 OK，后者通常包含响应体，但UNLOCK成功通常不含内容）。

- 400 (Bad Request)：未提供锁令牌。

- 403 (Forbidden)：当前已认证的主体无权限解除锁定。

409（冲突），带有“lock-token-matches-request-uri”预条件——
资源未被锁定，或者请求的Request-URI不在锁的范围内。





Dusseault                   标准轨道                    [第68页]


RFC 4918                         WebDAV                        2007年6月


9.11.2.  示例——解锁（UNLOCK）

   >>请求

     UNLOCK /workspace/webdav/info.doc HTTP/1.1
     Host: example.com
     Lock-Token: <urn:uuid:a515cfa4-5da4-22e1-f5b5-00a0451e6bf7>
     Authorization: Digest username="ejw"
       realm="ejw@example.com", nonce="...",
       uri="/workspace/webdav/proposal.doc",
       response="...", opaque="..."

   >>响应

     HTTP/1.1 204 无内容

   在此示例中，由锁令牌
   "urn:uuid:a515cfa4-5da4-22e1-f5b5-00a0451e6bf7"标识的锁
   已成功从资源
   http://example.com/workspace/webdav/info.doc中移除。如果此锁
   包含多个资源，则会从锁定的所有资源中移除。

   在此示例中，Authorization请求头中的nonce、response和opaque字段尚未被计算。

10.  分布式创作的HTTP头

   所有DAV头遵循与HTTP头相同的基本格式规则。这包括换行续行规则以及如何用逗号合并（或分隔）多个相同的头实例。

   WebDAV在HTTP定义的基础上增加了两个新的条件头：If和Overwrite。

10.1.  DAV头

    DAV              = "DAV" ":" #( compliance-class )
    compliance-class = ( "1" | "2" | "3" | extend )
    extend           = 编码的URL | token
                       ; token在RFC 2616第2.2节中定义
    编码的URL        = "<" 绝对URI ">"
                       ; 编码的URL中不允许有线性空白（LWS）
                       ; 绝对URI定义在RFC 3986第4.3节

   这个出现在响应中的通用头表示资源支持所声明的DAV模式和协议。所有符合DAV的资源必须在所有OPTIONS响应中返回带有“1”级别的DAV头。若WebDAV仅在服务器命名空间的部分支持，则对非WebDAV资源（包括“/”）的OPTIONS请求不应宣传WebDAV支持。

   其值是所有资源支持的合规级别标识符的逗号分隔列表。标识符可以是编码的URL或令牌（由[RFC2616]定义）。标识符可以任意顺序出现。通过IETF RFC流程标准化的标识符为令牌，但其他标识符应为编码的URL，以鼓励唯一性。

   如果资源显示支持第2或第3级别的合规性，则必须显示第1级别的合规性。一般而言，支持某一合规级别不意味着支持其他级别，特别是支持第3级别不要求支持第2级别。有关本规范中定义的合规级别的更多细节，请参阅第18节。

   注意，许多WebDAV服务器在响应“OPTIONS *”时不会宣传WebDAV支持。

   作为请求头，此头允许客户端在服务器需要时宣传其支持的特性。除非标准轨道规范要求，否则客户端不应发送此头。任何利用此作为请求头的扩展都需要仔细考虑缓存影响。

10.2.  深度（Depth）头

      Depth = "Depth" ":" ("0" | "1" | "infinity")

   深度请求头用于对可能具有内部成员的资源执行的方法，指示该方法是否仅应用于资源本身（"Depth: 0"）、仅应用于资源及其内部成员（"Depth: 1"）或应用于资源及其所有成员（"Depth: infinity"）。

   仅当方法定义明确支持此功能时，深度头才被支持。

   以下是支持深度头的任何方法的默认行为规则。方法可以在定义中覆盖这些默认行为。

   支持深度头的方法可能选择不支持所有深度值，并且可以根据具体情况定义在未提供深度头时的方法行为。例如，MOVE方法只支持"Depth: infinity"，如果未提供深度头，则视为已应用"Depth: infinity"。

   客户端不得依赖方法按特定顺序在其层次结构成员上执行，或假设执行是原子性的，除非该方法明确保证如此。

   执行时，带有深度头的方法会尽可能完成其任务，然后返回一份说明其完成情况和未能完成部分的响应。

   例如，尝试复制（COPY）一个层次结构可能只复制部分成员。

   默认情况下，深度头不会与其他头交互。也就是说，带有深度头的请求中的每个头必须只应用于Request-URI，除非为该头定义了特定的深度行为。

   如果深度头作用范围内的源或目标资源被锁定，阻止方法成功执行，则必须在If请求头中提交该资源的锁令牌。

   深度头仅影响方法对内部成员的行为。如果资源没有内部成员，则必须忽略深度头。

10.3.  目标（Destination）头

   目标请求头指定用于COPY和MOVE等方法的目标资源URI。

      Destination = "Destination" ":" 简单引用

   如果目标值是绝对URI（见[RFC3986]第4.3节），它可以指向不同的服务器（或不同的端口或方案）。如果源服务器无法尝试复制到远程服务器，则必须请求失败。注意，将资源复制或移动到远程服务器在本规范中未完全定义（例如，具体的错误条件）。

   如果目标值过长或其他原因不可接受，服务器应返回400（错误请求），最好在错误体中提供有用信息。

10.4.  如果（If）头

   If请求头旨在具有类似于[RFC2616]第14.24节中定义的If-Match头的功能。然而，If头处理任何状态令牌以及ETag。典型的状态令牌示例是锁令牌，且锁令牌是本规范中唯一定义的状态令牌。

10.4.1.  目的

   If头有两个不同的目的：

   o  第一个目的是通过提供一系列状态列表（条件匹配令牌和ETag）使请求具有条件性，针对特定资源。如果评估此头且所有状态列表都失败，则请求必须以412（前提条件失败）状态失败。反之，只要其中一个状态列表成功，请求即可成功。状态列表和匹配函数的成功标准在第10.4.3和第10.4.4节中定义。

   o  另外，仅仅在If头中出现状态令牌意味着它已“提交”给请求。通常用来表示客户端已知晓该状态令牌。提交状态令牌的语义取决于其类型（锁令牌请参见第6节）。

   注意，这两个目的必须区别对待：状态令牌的提交与服务器是否实际评估其所在的状态列表无关，也与其表达的条件是否成立无关。

10.4.2.  语法

     If = "If" ":" ( 1*无标签列表 | 1*标签列表 )

     无标签列表 = 列表
     标签列表 = 资源标签 1*列表

     列表 = "(" 1*条件 ")"
     条件 = ["Not"]（状态令牌 | "[" 实体标签 "]"）
     ; 实体标签：见[RFC2616]第3.11节
     ; "[", 实体标签和"]"之间不允许有LWS

   语法区分未标记列表（"无标签列表"）和带标签列表（"标签列表"）。未标记列表适用于由Request-URI标识的资源，而带标签列表适用于由前述资源标签标识的资源。

   资源标签适用于所有后续列表，直到下一个资源标签。

   注意，两个列表类型不能在同一If头中混用。这不是功能限制，因为无标签列表语法实际上是带标签列表的简写形式，其中资源标签指向Request-URI。

   每个列表由一个或多个条件组成。每个条件由实体标签或状态令牌定义，可能由前缀"Not"取反。

   注意，If头的语法不允许在单个请求中出现多个If头实例。但HTTP头语法允许通过插入换行和空白字符（见[RFC2616]第4.2节）扩展单个头值。

10.4.3.  列表评估

   由单个实体标签或状态令牌组成的条件，如果资源与描述的状态匹配，则评估为true（具体匹配函数在第10.4.4节中定义）。在前面加上"Not"会反转评估结果（因此，"Not"只作用于后续的实体标签或状态令牌）。

   每个列表由一系列条件组成。只有当所有条件都评估为true时，整个列表才评估为true（即，列表是条件的逻辑与）。

   每个无标签列表和带标签列表都可以包含一个或多个子列表。它们评估为true的条件是：只要其中任何一个子列表评估为true（即，多个列表的序列是列表的逻辑或）。

   最后，整个If头只有在至少一个无标签列表或带标签列表评估为true时才评估为true。如果评估为false，服务器必须以412（前提条件失败）状态拒绝请求。否则，请求可以继续执行，就像头不存在一样。

10.4.4.  匹配状态令牌和ETag

   在处理If头时，匹配状态令牌或实体标签的定义如下：

   识别资源：由URI和令牌（在带标签列表中）或由Request-URI（在未标记列表中）标识资源。

   匹配实体标签：实体标签与所识别资源关联的实体标签匹配。服务器必须使用[RFC2616]第13.3.3节中定义的弱或强比较函数。

   匹配状态令牌：If头中的状态令牌与所识别资源上的任何状态令牌完全匹配。如果资源在锁的范围内，则锁状态令牌被视为匹配。

   处理未映射的URL：对于ETag和状态令牌，都视为该URL标识的资源存在，但没有指定的状态。

10.4.5.  If头与非WebDAV代理

   非WebDAV代理不会支持If头，因为它们不理解该头，HTTP要求对不理解的头忽略。当与HTTP/1.1代理通信时，客户端必须使用"Cache-Control: no-cache"请求头，以防止代理错误地从缓存中提供请求。与HTTP/1.0代理通信时，也必须使用"Pragma: no-cache"请求头，原因相同。

   由于一般情况下客户端可能无法可靠检测非WebDAV中间件，建议始终使用上述请求指令防止缓存。





Dusseault                   标准轨道                    [第74页]


RFC 4918                         WebDAV                        2007年6月


10.4.6.  示例——无标签生产（No-tag Production）

     If: (<urn:uuid:181d4fae-7d8c-11d0-a765-00a0c91e6bf2>
       ["我是一条ETag"])
       (["我又是一条ETag"])

之前的头部要求请求中的资源（由Request-URI标识）必须被用指定的锁令牌锁定，并且处于由“I am an ETag”这个ETag标识的状态，或者处于由第二个ETag“I am another ETag”标识的状态。

更直白地说，可以将之前的If头部理解为表达以下条件：

（
  资源被锁定，锁令牌为urn:uuid:181d4fae-7d8c-11d0-a765-00a0c91e6bf2，并且匹配“我是一种ETag”
）或
（
  匹配“我另一种ETag”
）

10.4.7. 示例——在没有标签的生产中使用“Not”

例如：  
If: (Not <urn:uuid:181d4fae-7d8c-11d0-a765-00a0c91e6bf2> <urn:uuid:58f202ac-22cf-11d1-b12d-002035b29092>)

此If头部要求资源不能被锁定，锁令牌为urn:uuid:181d4fae-7d8c-11d0-a765-00a0c91e6bf2，并且必须由锁令牌为urn:uuid:58f202ac-22cf-11d1-b12d-002035b29092的锁锁定。

10.4.8. 示例——使条件始终评估为真

有些情况下，客户端希望提交状态令牌，但又不希望请求因为状态令牌不再有效而失败。一种简单的方法是包含一个已知总是评估为真的条件，例如：

If: (<urn:uuid:181d4fae-7d8c-11d0-a765-00a0c91e6bf2>)  
  (Not <DAV:no-lock>)

“DAV:no-lock”被认为永远不代表当前的锁令牌。锁令牌由服务器分配，遵循第6.5节中描述的唯一性要求，因此不能使用“DAV:”方案。因此，通过对一个已知不再有效的状态令牌应用“Not”，这个条件总是评估为真。因此，整个If头部将始终为真，无论如何，锁令牌urn:uuid:181d4fae-7d8c-11d0-a765-00a0c91e6bf2都将被提交。

10.4.9. 示例——COPY操作中的带标签列表的If头部

请求示例：  
COPY /resource1 HTTP/1.1  
Host: www.example.com  
Destination: /resource2  
If: </resource1>  
  (<urn:uuid:181d4fae-7d8c-11d0-a765-00a0c91e6bf2> [W/"A weak ETag"]) (["strong ETag"])

在此示例中，资源http://www.example.com/resource1被复制到http://www.example.com/resource2。当首次对http://www.example.com/resource1应用此方法时，资源1必须处于由“(<urn:uuid:181d4fae-7d8c-11d0-a765-00a0c91e6bf2> [W/"A weak ETag"]) (["strong ETag"])”指定的状态。也就是说，它要么用锁令牌urn:uuid:181d4fae-7d8c-11d0-a765-00a0c91e6bf2锁定，并具有弱实体标签W/"A weak ETag"，要么具有强实体标签“strong ETag”。

10.4.10. 示例——匹配集合锁的锁令牌

请求示例：  
DELETE /specs/rfc2518.txt HTTP/1.1  
Host: www.example.com  
If: <http://www.example.com/specs/>  
  (<urn:uuid:181d4fae-7d8c-11d0-a765-00a0c91e6bf2>)

此例中，锁令牌必须与被标识的资源（即由标签列表生产中URL标识的“specs”集合）相匹配。如果“specs”集合没有被指定的锁令牌锁定，则请求必须失败。否则，因If头部评估为真且影响资源的锁的锁令牌已提交，此请求可以成功。

10.4.11. 示例——匹配未映射URL上的ETag

考虑一个不包含成员“/specs/rfc2518.doc”的集合“/specs”。此时，If头部：  
If: </specs/rfc2518.doc> (["4217"])  
将会评估为假（因为URI未映射，所标识的资源没有匹配ETag“4217”）。

相反，使用：  
If: </specs/rfc2518.doc> (Not ["4217"])  
则会评估为真。

注意，如第10.4.4节中所定义，匹配状态令牌的情况也适用上述考虑。

10.5. Lock-Token头部

Lock-Token = "Lock-Token" ":" Coded-URL

Lock-Token请求头用于UNLOCK方法，标识要解除的锁。Lock-Token请求头中的锁令牌必须标识包含Request-URI所指资源的锁。

Lock-Token响应头用于LOCK方法，指示成功创建的锁的锁令牌。

10.6. Overwrite头部

Overwrite = "Overwrite" ":" ("T" | "F")

Overwrite请求头指示在COPY或MOVE操作中，服务器是否应覆盖目标URL映射的资源。值为“F”表示如果目标URL映射到资源，服务器不得执行COPY或MOVE操作。如果在COPY或MOVE请求中未包含此头，则资源应视为具有“Overwrite: T”的值。虽然“Overwrite”头似乎与使用“如果匹配：*”头（参见[RFC2616]）的功能相似，但“如果匹配”仅适用于Request-URI，而不适用于COPY或MOVE的目标。

如果因“Overwrite”头的值而未执行COPY或MOVE，方法必须以状态码412（Precondition Failed）失败。在检查此类条件性头之前，服务器必须进行授权检查。

所有符合DAV规范的资源都必须支持“Overwrite”头。

10.7. Timeout请求头

TimeOut = "Timeout" ":" 1#TimeType  
TimeType = ("Second-" DAVTimeOutVal | "Infinite")  
; TimeType内不允许空白字符  
DAVTimeOutVal = 1*DIGIT

客户端可以在LOCK请求中包含Timeout请求头，但服务器不一定会响应或考虑这些请求。客户端不得在除LOCK方法之外的其他方法中提交Timeout请求头。

“Second”类型指定从服务器授予锁到自动移除锁之间的秒数。TimeType为“Second”的超时时间不得超过2^32-1秒。

关于锁超时行为的详细描述，请参见第6.6节。

11. HTTP/1.1状态码扩展

以下状态码是对HTTP/1.1 [RFC2616]中定义的状态码的补充。

11.1. 207 多状态

207（Multi-Status）状态码提供多个独立操作的状态信息（详见第13节）。

11.2. 422 不可处理的实体

422（Unprocessable Entity）状态码表示服务器理解请求实体的内容类型（因此415（不支持的媒体类型）不适用），且请求实体的语法正确（因此400（错误请求）不适用），但无法处理其中的指令。例如，如果XML请求体包含格式正确但语义错误的XML指令，就会出现此错误。

11.3. 423 被锁定

423（Locked）状态码表示请求的源或目标资源被锁定。此响应应包含适当的前置条件或后置条件代码，例如“lock-token-submitted”或“no-conflicting-lock”。

11.4. 424 依赖失败

424（Failed Dependency）状态码表示无法对资源执行请求，因为请求的操作依赖于另一个操作，而该操作失败。例如，如果PROPPATCH中的某个命令失败，至少其他命令也会以424失败。

11.5. 507 存储空间不足

507（Insufficient Storage）状态码表示无法在资源上执行请求，因为服务器无法存储完成请求所需的表示。此情况被视为临时的。如果收到此状态码的请求是用户操作的结果，则必须等待用户再次操作后再试。

12. HTTP状态码的使用

这些HTTP状态码未被重新定义，但其用法在WebDAV的方法和要求中有所扩展。一般而言，许多HTTP状态码可以用于任何请求的响应，而不仅限于本文描述的情况。还应注意，WebDAV服务器可能会使用300级重定向响应（早期互操作性测试发现客户端未准备好处理这些响应）。当服务器创建了新资源时，不应使用300级响应。

12.1. 412 先决条件失败

任何请求都可以包含HTTP定义的条件头（如If-Match、If-Modified-Since等）或本规范定义的“If”或“Overwrite”条件头。如果服务器评估条件头后条件不成立，则必须返回此错误码。如果请求中未包含条件头，则服务器不得使用此状态码。

12.2. 414 请求URI过长

此状态码仅在HTTP 1.1中用于请求URI，不适用于其他位置的URI。

13. 多状态响应

多状态响应在多种状态码可能适用的情况下，传达多个资源的状态信息。默认的多状态响应体为带有‘multistatus’根元素的text/xml或application/xml HTTP实体。内部包含的元素会显示在调用过程中产生的200、300、400和500系列状态码。100系列状态码不应在‘response’ XML元素中记录。

虽然用207作为整体响应状态码，但接收方需要查看多状态响应体的内容，以获取关于方法执行成功或失败的详细信息。此响应可用于成功、部分成功或失败的情况。

‘multistatus’根元素下可以有零个或多个‘response’元素，顺序不限，每个‘response’元素都必须有‘href’元素以标识资源。

多状态响应有两种不同的状态表示格式：

1. 作为‘response’元素子元素的‘status’元素，指示所标识资源整体的状态（例如，第9.6.2节）。某些方法定义会提供应准备好在响应中看到的特定状态码信息，但客户端必须能够处理其他状态码，遵循[RFC2616]第10节中的通用规则。

2. 对于PROPFIND和PROPPATCH，扩展使用‘propstat’元素代替‘status’，提供关于资源各个属性的状态信息。此格式专用于PROPFIND和PROPPATCH，详见第9.1和9.2节。

13.1. 响应头

HTTP定义了Location头，用于指示请求URI所指资源的首选URL（例如，成功的PUT请求或重定向响应中）。但在多状态响应中，响应体中包含多个资源地址时，使用此头会引起歧义。因此，WebDAV明确不定义在多状态响应中使用Location头。

13.2. 处理重定向的子资源

HTTP 1.1中的重定向响应（300-303、305和307）通常带有Location头，指示从Request-URI重定向的单一资源的新URI。多状态响应中包含多个资源地址，但在[RFC2518]中未定义服务器提供重定向资源新URI的方式。此规范定义了一个‘location’元素（见第14.9节）用于此信息。服务器必须在多状态响应的重定向中使用此新元素。

遇到多状态响应中的重定向资源时，客户端不得依赖‘location’元素一定包含新URI。如果未出现此元素，客户端可以重新对重定向的单个资源发起请求，因为该请求的响应可以通过Location头重定向到新URI。

13.3. 内部状态码

第9.2.1、9.1.2、9.6.1、9.8.3和9.9.2节定义了多状态响应中使用的各种状态码。此规范未定义其他可能出现在这些响应中的状态码的含义。

14. XML元素定义

本节中，每个节的最后一行给出元素类型声明，采用[REC-XML]中定义的格式。存在的“Value”字段，进一步限制XML元素内容，使用BNF（即限制PCDATA元素的值）。注意，这里定义的所有元素都可以根据第17节中的规则扩展。所有定义的元素都属于“DAV:”命名空间。

14.1. activelock XML元素

名称：activelock

目的：描述对资源的锁定。

<!ELEMENT activelock (lockscope, locktype, depth, owner?, timeout?, locktoken?, lockroot)>

Dusseault  标准轨迹  [第81页]

RFC 4918  WebDAV  2007年6月

14.2. allprop XML元素

名称：allprop

目的：指定应返回资源上所有死属性和由本文档定义的实时属性的所有名称和值。

<!ELEMENT allprop EMPTY>

14.3. collection XML元素

名称：collection

目的：标识相关资源为集合。集合资源的DAV:resourcetype属性必须包含此元素。通常为空，但扩展可以添加子元素。

<!ELEMENT collection EMPTY>

14.4. depth XML元素

名称：depth

目的：用于表示XML内容中的深度值（例如，在锁信息中）。

值： "0" | "1" | "infinity"

<!ELEMENT depth (#PCDATA)>

14.5. error XML元素

名称：error

目的：错误响应，特别是403 Forbidden和409 Conflict，有时需要更多信息以指示出错原因。在这些情况下，服务器可以返回一个XML响应体，包含一个名为‘error’的文档元素，以及子元素用以标识特定的条件代码。

描述：包含至少一个XML元素，且不得包含文本或混合内容。‘error’元素的任何子元素都视为预条件或后条件代码。未识别的元素必须忽略。

<!ELEMENT error ANY>

Dusseault  标准轨迹  [第82页]

RFC 4918  WebDAV  2007年6月

14.6. exclusive XML元素

名称：exclusive

目的：指定排他锁。

<!ELEMENT exclusive EMPTY>

14.7. href XML元素

名称：href

目的：必须包含一个URI或相对引用。

描述：根据使用场景，‘href’的值可能有限制。请参阅使用‘href’的规范文本，了解每种情况的限制。

值：Simple-ref

<!ELEMENT href (#PCDATA)>

14.8. include XML元素

名称：include

目的：任何子元素代表要包含在PROPFIND响应中的属性名。‘include’元素内的所有元素必须定义与资源相关的属性，尽管可能的属性名不限于本文档或其他标准中定义的那些。此元素不得包含文本或混合内容。

<!ELEMENT include ANY>

14.9. location XML元素

名称：location

目的：HTTP定义了“Location”头（参见[RFC2616]第14.30节）用于某些状态码（如201和3xx系列）。当这些状态码在‘multistatus’元素中使用时，可以用‘location’元素提供对应的Location头值。

描述：包含一个href元素，其值与Location头中使用的值相同。

<!ELEMENT location (href)>

14.10. lockentry XML元素

名称：lockentry

目的：定义可用于资源的锁类型。

<!ELEMENT lockentry (lockscope, locktype)>

14.11. lockinfo XML元素

名称：lockinfo

目的：‘lockinfo’ XML元素用于LOCK方法，指定客户端希望创建的锁类型。

<!ELEMENT lockinfo (lockscope, locktype, owner?)>

14.12. lockroot XML元素

名称：lockroot

目的：包含锁的根URL，即在LOCK请求中用于定位资源的URL。

描述：href元素包含锁的根。服务器应在所有DAV:lockdiscovery属性值和LOCK请求的响应中包含此元素。

<!ELEMENT lockroot (href)>

14.13. lockscope XML元素

名称：lockscope

目的：指定锁是排他锁还是共享锁。

<!ELEMENT lockscope (exclusive | shared)>

14.14. locktoken XML元素

名称：locktoken

目的：与锁相关联的锁令牌。

描述：href包含一个锁令牌URI，指向该锁。

<!ELEMENT locktoken (href)>

14.15. locktype XML元素

名称：locktype

目的：指定锁的访问类型。目前，此规范只定义一种锁类型，即写锁。

<!ELEMENT locktype (write)>

14.16. multistatus XML元素

名称：multistatus

目的：包含多个响应消息。

描述：顶层的‘responsedescription’元素用于提供描述响应总体性质的通用信息。如果有此值，应用程序可以用它代替响应中包含的各个响应描述。

<!ELEMENT multistatus (response*, responsedescription?)>

14.17. owner XML元素

名称：owner

目的：存放客户端提供的关于锁创建者的信息。

描述：允许客户端提供足够信息以直接联系主体（如电话号码或电子邮件URI），或用于发现创建锁的主体（如主页URL）。所提供的值必须作为死属性在XML信息项中保存。除非客户端提供的owner值为空，否则服务器不得更改此值。为了不同客户端实现之间的互操作性，如果客户端有适合用户显示的URI格式的联系人信息，建议将这些URI放在‘owner’元素的‘href’子元素中。

扩展性：可以通过子元素、混合内容、文本内容或属性进行扩展。

<!ELEMENT owner ANY>

14.18. prop XML元素

名称：prop

目的：包含与资源相关的属性。

描述：资源定义属性的通用容器。‘prop’元素内的所有元素必须定义与资源相关的属性，尽管属性名没有限制。此元素不得包含文本或混合内容。

<!ELEMENT prop ANY>

14.19. propertyupdate XML元素

名称：propertyupdate

目的：包含修改资源属性的请求。

描述：此XML元素是修改资源属性所需信息的容器。

<!ELEMENT propertyupdate (remove | set)+>

14.20. propfind XML元素

名称：propfind

目的：指定从PROPFIND方法返回的属性。定义了四个特殊元素用于‘propfind’：‘prop’，‘allprop’，‘include’，和‘propname’。如果在‘propfind’中使用‘prop’，则不得包含属性值。

<!ELEMENT propfind (propname | (allprop, include?) | prop)>

14.21. propname XML元素

名称：propname

目的：仅返回资源上的属性名列表。

<!ELEMENT propname EMPTY>

14.22. propstat XML元素

名称：propstat

目的：将与特定‘href’元素相关联的prop和status元素组合在一起。

描述：‘propstat’ XML元素必须包含一个‘prop’元素和一个‘status’元素。‘prop’元素的内容只能列出适用于‘status’元素中的结果的属性名。可选的预条件/后条件元素和‘responsedescription’文本也适用于‘prop’中列出的属性。

<!ELEMENT propstat (prop, status, error?, responsedescription?)>

14.23. remove XML元素

名称：remove

目的：列出要从资源中移除的属性。

描述：‘remove’指示应移除‘prop’中指定的属性。指定不存在的属性的移除不是错误。‘remove’元素内的‘prop’元素中的所有子元素必须为空，因为只需要属性的名称。

<!ELEMENT remove (prop)>

14.24. response XML元素

名称：response

目的：描述方法对资源及其属性的影响的单个响应。

描述：在‘response’容器中，‘href’元素包含指向WebDAV资源的HTTP URL。当在‘multistatus’元素下使用时，某个‘href’值不得作为子元素在多个‘response’中重复出现。此要求是为了使响应处理成本保持线性。基本上，这避免了必须搜索以按‘href’分组所有响应的情况，但对‘href’值的排序没有要求。可选的预条件/后条件元素和‘responsedescription’文本可以提供关于该资源相对于请求或结果的附加信息。

<!ELEMENT response (href, ((href*, status)|(propstat+)), error?, responsedescription?, location?)>

14.25. responsedescription XML元素

名称：responsedescription

目的：包含关于多状态响应中的状态信息。

描述：提供适合呈现给用户的信息。

<!ELEMENT responsedescription (#PCDATA)>

14.26. set XML元素

名称：set

目的：列出要设置的资源属性值。

描述：‘set’元素必须只包含一个‘prop’元素。‘set’元素内的‘prop’元素必须指定要在请求URI标识的资源上设置的属性的名称和值。如果属性已存在，则其值将被替换。‘prop’元素中的作用域（如存在‘xml:lang’属性）中的语言标签信息必须与属性一同持久存储，并且必须通过PROPFIND可检索。

<!ELEMENT set (prop)>

14.27. shared XML元素

名称：shared

目的：指定共享锁。

<!ELEMENT shared EMPTY>

14.28. status XML元素

名称：status

目的：存放单个HTTP状态行。

值：状态行（定义见[RFC2616]第6.1节）

<!ELEMENT status (#PCDATA)>

14.29. timeout XML元素

名称：timeout

目的：锁到期前剩余的秒数。

值：TimeType（定义见第10.7节）

<!ELEMENT timeout (#PCDATA)>

14.30. write XML元素

名称：write

目的：指定写锁。

<!ELEMENT write EMPTY>

Dusseault  标准轨迹  [第89页]

15. DAV属性

对于DAV属性，属性名也是包含其值的XML元素的名称。在下文中，每个部分的最后一行给出使用[REC-XML]中定义的格式的元素类型声明。‘Value’字段（如果有）进一步限制XML元素内容的允许范围，使用BNF（即进一步限制PCDATA元素的值）。

受保护的属性是指不能通过PROPPATCH请求更改的属性。可能还存在其他请求会导致受保护属性发生变化（如LOCK请求影响DAV:lockdiscovery的情况）。注意，一个属性在某些资源类型上可能是受保护的，而在其他资源类型上则不是。

计算属性是指其值由某种计算得出（基于资源的内容和其他属性，或甚至其他资源的内容）。计算属性始终是受保护的属性。

COPY和MOVE行为指本地的复制和移动操作。

对于基于HTTP GET响应头定义的属性（DAV:get*），头部值可能包含[RFC2616]第4.2节定义的LWS（空白字符）。服务器实现者应在使用这些值作为WebDAV属性值之前去除LWS。

15.1. creationdate 属性

名称：creationdate

目的：记录资源的创建时间和日期。

值：date-time（定义见[RFC3339]，参见第5.6节的ABNF）

受保护：可能受保护。一些服务器允许将DAV:creationdate更改为反映文档创建时间（比上传时间更有意义）。因此，客户端在同步逻辑中不应使用此属性（应使用DAV:getetag）。

COPY/MOVE行为：在MOVE操作中应保持此属性值，但在通过COPY创建资源时通常会重新初始化。复制时不应设置此属性。

描述：所有符合DAV的资源应定义DAV:creationdate属性。若存在，它包含资源创建的时间戳。不能持久记录创建日期的服务器应不定义此属性（即返回“未找到”）。

<!ELEMENT creationdate (#PCDATA)>

15.2. displayname 属性

名称：displayname

用途：提供一个适合向用户展示的资源名称。

值：任何文本。

受保护：不应受保护。请注意，实施[RFC2518]的服务器可能已将此属性设为受保护的，因为这是一个新要求。

复制/移动行为：在复制和移动操作中，应保留此属性的值。

描述：包含适合向用户展示的资源描述。该属性定义在资源上，因此应具有相同的值，无论使用何种请求URI进行检索（因此，基于请求URI计算此属性的方法已被弃用）。虽然通用客户端可能会将该属性值显示给最终用户，但客户端界面设计者必须理解，资源的标识方法仍然是URL。对DAV:displayname的更改不会向服务器发出移动或复制操作，而只是更改单个资源的元数据。即使在同一集合内，两个资源也可以具有相同的DAV:displayname值。

<!ELEMENT displayname (#PCDATA) >

15.3. getcontentlanguage 属性

名称：getcontentlanguage

用途：包含Content-Language头的值（来自[RFC2616]第14.12节），即在没有接受头的GET请求中返回的值。

值：语言标签（language-tag，定义在[RFC2616]第3.10节中）

受保护：不应受保护，以便客户端可以重置语言。请注意，实施[RFC2518]的服务器可能已将此属性设为受保护的，因为这是一个新要求。

复制/移动行为：在复制和移动操作中，应保留此属性的值。

描述：DAV:getcontentlanguage属性必须在任何返回Content-Language头的DAV兼容资源上定义。

<!ELEMENT getcontentlanguage (#PCDATA) >

15.4. getcontentlength 属性

名称：getcontentlength

用途：包含在没有接受头的GET请求中返回的Content-Length头。

值：参见[RFC2616]第14.13节。

受保护：此属性是计算得出的，因此应受保护。

描述：在任何返回Content-Length头的DAV兼容资源上，必须定义DAV:getcontentlength属性。

复制/移动行为：此属性值依赖于目标资源的大小，而非源资源上的值。

<!ELEMENT getcontentlength (#PCDATA) >

15.5. getcontenttype 属性

名称：getcontenttype

用途：包含Content-Type头的值（来自[RFC2616]第14.17节），即在没有接受头的GET请求中返回的值。

值：媒体类型（定义在[RFC2616]第3.7节）

受保护：如果服务器倾向于自行分配内容类型，则可能受保护（详见第9.7.1节的讨论）。

复制/移动行为：在复制和移动操作中，应保留此属性的值。

描述：必须在任何返回Content-Type头的DAV兼容资源上定义此属性。

<!ELEMENT getcontenttype (#PCDATA) >

15.6. getetag 属性

名称：getetag

用途：包含ETag头的值（来自[RFC2616]第14.19节），即在没有接受头的GET请求中返回的值。

值：实体标签（定义在[RFC2616]第3.11节）

受保护：必须受保护，因为此值由服务器创建和控制。

复制/移动行为：此属性值依赖于目标资源的最终状态，而非源资源上的值。另请参见第8.8节的注意事项。

描述：必须在任何返回ETag头的DAV兼容资源上定义此属性。完整定义ETag语义请参见[RFC2616]第3.11节，关于WebDAV中ETag的讨论请参见第8.6节。

<!ELEMENT getetag (#PCDATA) >

15.7. getlastmodified 属性

名称：getlastmodified

用途：包含Last-Modified头的值（来自[RFC2616]第14.29节），即在没有接受头的GET请求中返回的值。

值：rfc1123日期（定义在[RFC2616]第3.3.1节）

受保护：应受保护，因为某些客户端可能依赖此值进行适当的缓存行为，或依赖于此属性关联的Last-Modified头的值。

复制/移动行为：此属性值依赖于目标资源的最后修改日期，而非源资源上的值。请注意，一些服务器实现会使用文件系统的修改日期作为DAV:getlastmodified的值，即使HTTP的Last-Modified值应当变化，也可以在移动操作中保持此值。由于[RFC2616]要求客户端在提供ETag时使用ETag，支持ETag的服务器可以依赖客户端使用比修改日期更优的机制进行离线同步或缓存控制。请参见第8.8节的注意事项。

描述：资源的最后修改日期应仅反映资源内容（GET响应）的变化。属性的更改不应导致最后修改日期变化，因为客户端可能依赖此日期判断何时覆盖现有内容。必须在任何返回Last-Modified头的DAV兼容资源上定义此属性。

<!ELEMENT getlastmodified (#PCDATA) >

15.8. lockdiscovery 属性

名称：lockdiscovery

用途：描述资源上的活动锁。

受保护：必须受保护。客户端通过LOCK和UNLOCK更改锁列表，而非通过PROPPATCH。

复制/移动行为：此属性的值依赖于目标的锁状态，而非源资源的锁状态。请记住，锁不会在MOVE操作中移动。

描述：返回锁定信息的列表，包括锁的拥有者、锁类型、超时类型及剩余时间、以及相关的锁令牌。若信息被视为敏感，所有者信息可以省略。如果没有锁，但服务器支持锁，此属性将存在但包含零个'activelock'元素。如果存在一个或多个锁，则每个锁对应一个'activelock'元素。此属性对写锁（第7节）不可加锁。

<!ELEMENT lockdiscovery (activelock)* >

15.8.1. 示例——检索DAV:lockdiscovery

>>请求

PROPFIND /container/ HTTP/1.1  
Host: www.example.com  
Content-Length: xxxx  
Content-Type: application/xml; charset="utf-8"  

<?xml version="1.0" encoding="utf-8" ?>  
<D:propfind xmlns:D='DAV:'>  
  <D:prop><D:lockdiscovery/></D:prop>  
</D:propfind>  

>>响应

HTTP/1.1 207 Multi-Status  
Content-Type: application/xml; charset="utf-8"  
Content-Length: xxxx  

<?xml version="1.0" encoding="utf-8" ?>  
<D:multistatus xmlns:D='DAV:'>  
  <D:response>  
    <D:href>http://www.example.com/container/</D:href>  
    <D:propstat>  
      <D:prop>  
        <D:lockdiscovery>  
          <D:activelock>  
            <D:locktype><D:write/></D:locktype>  
            <D:lockscope><D:exclusive/></D:lockscope>  
            <D:depth>0</D:depth>  
            <D:owner>Jane Smith</D:owner>  
            <D:timeout>Infinite</D:timeout>  
            <D:locktoken>  
              <D:href>urn:uuid:f81de2ad-7f3d-a1b2-4f3c-00a0c91a9d76</D:href>  
            </D:locktoken>  
            <D:lockroot>  
              <D:href>http://www.example.com/container/</D:href>  
            </D:lockroot>  
          </D:activelock>  
        </D:lockdiscovery>  
      </D:prop>  
      <D:status>HTTP/1.1 200 OK</D:status>  
    </D:propstat>  
  </D:response>  
</D:multistatus>  

此资源上有一个无限超时的专用写锁。

15.9. resourcetype 属性

名称：resourcetype

用途：指明资源的性质。

受保护：应受保护。资源类型通常由创建资源的操作（MKCOL与PUT）决定，而非由PROPPATCH。

复制/移动行为：通常，资源的复制或移动会在目标处产生相同类型的资源。

描述：必须在所有DAV兼容资源上定义。每个子元素标识资源所属的具体类型，例如“collection”，这是本规范定义的唯一资源类型（见第14.3节）。如果元素包含“collection”子元素及其他未识别的元素，通常视为集合资源；如果不包含任何识别的子元素，则视为非集合资源。默认值为空。此元素不得包含文本或混合内容。任何自定义子元素都被视为资源类型的标识符。

示例（虚构示例，展示扩展性）：

```xml
<x:resourcetype xmlns:x="DAV:">
    <x:collection/>
    <f:search-results xmlns:f="http://www.example.com/ns"/>
</x:resourcetype>
```

15.10. supportedlock 属性

名称：supportedlock

用途：提供资源支持的锁机制的列表。

受保护：必须受保护。由服务器而非客户端决定支持的锁机制。

复制/移动行为：此属性值依赖于目标支持的锁类型，而非源资源上的值。服务器在尝试复制到目标时，不应试图设置此属性。

描述：返回在资源上锁请求中可以指定的作用域和访问类型的组合列表。注意，实际内容由访问控制控制，因此服务器不必提供客户端未授权查看的信息。此属性对写锁（第7节）不可加锁。

<!ELEMENT supportedlock (lockentry)* >

15.10.1. 示例——检索DAV:supportedlock

>>请求

PROPFIND /container/ HTTP/1.1  
Host: www.example.com  
Content-Length: xxxx  
Content-Type: application/xml; charset="utf-8"  

<?xml version="1.0" encoding="utf-8" ?>  
<D:propfind xmlns:D="DAV:">  
  <D:prop><D:supportedlock/></D:prop>  
</D:propfind>  

>>响应

HTTP/1.1 207 Multi-Status  
Content-Type: application/xml; charset="utf-8"  
Content-Length: xxxx  

<?xml version="1.0" encoding="utf-8" ?>  
<D:multistatus xmlns:D="DAV:">  
  <D:response>  
    <D:href>http://www.example.com/container/</D:href>  
    <D:propstat>  
      <D:prop>  
        <D:supportedlock>  
          <D:lockentry>  
            <D:lockscope><D:exclusive/></D:lockscope>  
            <D:locktype><D:write/></D:locktype>  
          </D:lockentry>  
          <D:lockentry>  
            <D:lockscope><D:shared/></D:lockscope>  
            <D:locktype><D:write/></D:locktype>  
          </D:lockentry>  
        </D:supportedlock>  
      </D:prop>  
      <D:status>HTTP/1.1 200 OK</D:status>  
    </D:propstat>  
  </D:response>  
</D:multistatus>

所有这些元素都属于“DAV:”命名空间。除非另有说明，否则每个条件的XML元素内容定义为空。

名称：lock-token-matches-request-uri

适用场景：409 Conflict（冲突）

用途：（前置条件）——请求可能包含一个Lock-Token头，用于标识解锁（UNLOCK）方法的锁。然而，如果请求的URI不在由该令牌标识的锁的范围内，服务器应返回此错误。锁可能具有不包括请求URI的范围，或者锁已消失，亦或令牌无效。

Dusseault                   标准轨迹                    [第99页]

RFC 4918                         WebDAV                        2007年6月

名称：lock-token-submitted（前置条件）

适用场景：423 Locked（已锁定）

用途：请求无法成功，因为应提交一个锁令牌。如果存在此元素，必须至少包含一个阻止请求的被锁定资源的URL。在涉及集合锁的MOVE、COPY和DELETE操作中，客户端可能难以得知哪个被锁定的资源导致请求失败——但服务器只需返回一个这样的资源。如果知道所有阻止请求成功的被锁定资源，服务器可以返回所有这些资源。

<!ELEMENT lock-token-submitted (href+) >

名称：no-conflicting-lock（前置条件）

适用场景：通常为423 Locked

用途：由于已存在冲突的锁，LOCK请求失败。注意，即使请求的资源仅间接被锁定，锁也可能存在冲突。在这种情况下，可以使用此前置条件代码通知客户端冲突锁的根资源，避免单独查找“lockdiscovery”属性。

<!ELEMENT no-conflicting-lock (href)* >

名称：no-external-entities

适用场景：403 Forbidden（禁止）

用途：（前置条件）——如果服务器因请求体中包含外部实体而拒绝客户端请求，服务器应使用此错误。

名称：preserved-live-properties

适用场景：409 Conflict（冲突）

用途：（后置条件）——服务器已收到一个本应有效的MOVE或COPY请求，但无法在目标端保持相同的实时属性。可能是服务器仅支持某些实时属性在仓库的某些部分，或内部发生了错误。

名称：propfind-finite-depth

适用场景：403 Forbidden（禁止）

用途：（前置条件）——此服务器不允许对集合进行无限深度的PROPFIND请求。

名称：cannot-modify-protected-property

适用场景：403 Forbidden（禁止）

用途：（前置条件）——客户端试图在PROPPATCH中设置受保护的属性（如DAV:getetag）。另请参见[RFC3253]第3.12节。

17.  DAV中的XML扩展性

本规范中使用了XML命名空间扩展（[REC-XML-NAMES]），以允许添加新的XML元素而不必担心与其他元素名冲突。虽然WebDAV的请求和响应体可以通过任意XML元素扩展，且这些元素可以被消息接收者忽略，但除非该XML元素在经过WebDAV工作组审查的IETF RFC中明确定义，否则“DAV:”命名空间中的XML元素不应在请求或响应体中使用。

为了使WebDAV既具有扩展性又向后兼容，客户端和服务器都需要知道在收到意外或未识别的命令扩展时应如何表现。对于XML处理，这意味着客户端和服务器必须像未出现的元素和属性（以及所有未识别元素的子元素）不存在一样处理接收的XML文档。未识别的元素或属性包括在其他上下文中可能使用但在此不预期的内容。忽略这些内容在处理时当然可以与记录所有信息或用于调试的行为一致。

此限制也适用于客户端处理DAV属性值时，除非属性的模式另有声明，否则应忽略未预期的XML元素。

此外，此限制不适用于在服务器上设置死的DAV属性，服务器必须记录所有XML元素。

另外，此限制不适用于XML的使用场景，例如，将XML作为实体体内容类型（如PUT请求的正文）。

XML中的处理指令应由接收方忽略。因此，扩展WebDAV的规范不应使用处理指令来定义规范行为。

本规范为所有定义的XML元素包含DTD片段。然而，由于命名空间的使用和扩展规则，正确的XML不会符合任何DTD的有效性。特别地：

- 元素（来自本规范）属于“DAV:”命名空间；
- 元素的顺序除非另有说明，否则无关紧要；
- 可以添加扩展属性；
- 对于“ANY”类型的元素定义，规范文本定义了其内容和含义；
- 对于“#PCDATA”类型的元素定义，不应添加扩展元素；
- 对于其他类型的元素定义，包括“EMPTY”，可以添加扩展元素。

请注意，这意味着包含子元素的元素不能扩展为包含文本，反之亦然。

在上述规则放宽DTD验证的情况下，DTD片段所描述的约束具有规范性（参见附录A）。接收带有XML正文的WebDAV消息的实体不得根据任何硬编码或动态声明的DTD验证XML文档。

本节描述的是向后兼容的扩展规则。也可能存在不向后兼容的扩展设计，例如，定义一个重用本文档中定义的XML元素但省略某些子元素的扩展。

18.  DAV的合规性类别

符合DAV的资源可以声明多个合规类别。客户端可以通过对资源执行OPTIONS请求并检查返回的“DAV”头部，了解该资源的合规类别。特别要注意的是，这里所说的合规资源是指资源，而非服务器。这是因为理论上，服务器上的某些资源可能支持不同的功能集。例如，某个子仓库可能支持版本控制等高级功能，即使该功能未在所有子仓库中支持。

由于本规范扩展了HTTP/1.1协议，所有DAV合规的资源、客户端和代理至少必须符合[RFC2616]。

支持第2类或第3类的资源还必须支持第1类。

18.1.  类别1

类别1合规的资源必须满足本文档所有“必须”要求。

类别1合规的资源在所有对OPTIONS方法的响应中，至少应在DAV头中返回值“1”。

18.2.  类别2

类别2合规的资源必须满足类别1的所有要求，并支持LOCK方法、DAV:supportedlock属性、DAV:lockdiscovery属性、Time-Out响应头和Lock-Token请求头。类别2的资源还应支持Timeout请求头和“owner”XML元素。

类别2合规的资源在所有对OPTIONS方法的响应中，至少应在DAV头中返回值“1”和“2”。

18.3.  类别3

资源可以明确声明支持本规范中对[RFC2518]所做的修订。必须支持类别1，可能支持类别2。支持类别3（在支持类别1和2的基础上）意味着服务器支持本规范中的所有要求。支持类别3和类别1但不支持类别2，意味着服务器支持除可能涉及锁定支持之外的所有本规范要求。

示例：

            DAV: 1, 3

19.  国际化考虑

在国际化方面，本规范遵循IETF字符集策略[RFC2277]。在本规范中，可在属性值或响应实体体中的错误信息中找到人类可读的字段。两者都使用XML编码，XML对字符集标记和编码有明确规定，要求XML处理器至少以UTF-8 [RFC3629]和UTF-16 [RFC2781]编码的ISO 10646多语言平面读取XML元素。本规范中的XML示例演示了Content-Type头中的字符集参数（定义在[RFC3023]中）以及XML字符集声明的使用。

XML还提供了语言标记功能，用于指定特定XML元素内容的语言。“xml:lang”属性出现在XML元素上，用以标识其内容和属性的语言。详见[REC-XML]中的定义。

WebDAV应用必须支持XML规范中的字符集标记、字符集编码和语言标记功能。建议开发者阅读“XML媒体类型” [RFC3023]，了解应使用何种MIME媒体类型进行XML传输，以及Content-Type头的charset参数的使用。

本规范中使用的名称分为四类：协议元素（如方法和头部）、XML元素名称、属性名称和条件名称。协议元素的命名遵循HTTP的惯例，使用US-ASCII编码的英文名。由于这些元素对用户不可见，只是长的标记符，因此不需要支持多语言。同理，本文规范中使用的XML元素名称也不对用户可见，也不需支持多语言。

WebDAV的属性名是限定的XML名称（由XML命名空间和本地名组成的对）。虽然某些应用（如通用属性查看器）会直接显示属性名，但预期大多数应用会使用一组固定的属性，并在显示属性名时提供从属性名和命名空间到人类可读字段的映射。只有在属性集事先未知的情况下，应用才需要向用户显示属性名。建议应用尽可能提供易于理解的属性名。

在错误报告方面，遵循HTTP/1.1状态码的惯例，为每个状态码提供简短的英文描述（如423（Locked））。虽然存在某些用户代理可能会将此消息显示给用户的可能性，但国际化应用会忽略此消息，并以用户的语言和字符集显示适当的消息。

由于客户端和服务器的互操作性不依赖于区域设置信息，本规范未规定传输此类信息的机制。

20.  安全考虑

本节旨在详细说明WebDAV应用需注意的安全问题。

所有关于HTTP/1.1（[RFC2616]）和XML（[RFC3023]）的安全考虑也同样适用于WebDAV。此外，远程创作的固有安全风险要求采用更强的认证技术，引入若干新的隐私问题，并可能增加因服务器设计不当带来的危险。以下详细说明这些问题。

20.1.  客户端的认证

鉴于WebDAV强调创作功能，服务器需要使用认证技术，不仅保护对网络资源的访问，还要保护资源的完整性。此外，锁定功能的引入也需要支持认证。

在不安全的通道中以明文方式传输的密码，无法有效保护资源的访问性和完整性，因为密码可能会被截获。由于HTTP/1.1的基本认证（Basic Authentication）本质上是明文传输密码，除非连接是安全的，否则不得使用基本认证对WebDAV客户端进行身份验证。此外，WebDAV服务器不得在非安全连接中在WWW-Authenticate头中发送基本认证挑战。一个安全连接的例子是采用强密码套件和服务器认证的传输层安全（TLS）连接。

WebDAV应用必须支持摘要认证（Digest Authentication）[RFC2617]。由于摘要认证验证通信双方都知道一个共享秘密（密码），而无需明文传输该秘密，因此它避免了基本认证固有的安全问题，同时在多种场景中提供了有用的认证级别。

20.2 拒绝服务（Denial of Service）

拒绝服务攻击对WebDAV服务器尤其令人担忧。WebDAV结合HTTP，可能对系统资源的各个部分发起拒绝服务攻击。

- 底层存储可以通过PUT极大文件进行攻击。
- 对大型集合执行递归操作可能会攻击处理时间。
- 在多个连接上进行多路请求可能会攻击网络连接。

WebDAV服务器需要意识到各种层面的拒绝服务攻击的可能性。对此类攻击的合理应对措施可以是直接断开连接，或者在服务器能够响应的情况下，使用如400（错误请求）之类的状态码，并说明请求被拒绝的原因（而使用500级别的状态码则表示问题出在服务器端，非故意的拒绝服务攻击则是客户端可以采取措施的）。

20.3 以“隐藏”实现的安全性（Security through Obscurity）

WebDAV通过PROPFIND方法提供列出集合成员资源的机制。这大大削弱了仅依赖于网络资源名称难以被发现的安全或隐私技术的效果。建议WebDAV服务器的用户采用访问控制技术，防止未授权访问资源，而不是依赖资源名称的相对隐蔽性。

20.4 与锁相关的隐私问题

提交锁请求时，用户代理可以同时提交一个“owner” XML字段，提供锁定者的联系信息（适用于由人而非机器人进行锁定的情况）。这些联系信息存储在资源的DAV:lockdiscovery属性中，其他协作者可以利用这些信息开始协商访问权限。然而，这些联系信息可能非常私密，不应被广泛传播。服务器应限制对DAV:lockdiscovery属性的读取权限。此外，用户代理应提供控制是否发送联系信息的选项，以及在发送时，控制具体发送哪些信息。

20.5 与属性相关的隐私问题

由于属性值通常用于存储诸如文档作者等信息，可能引发隐私担忧，尤其是在资源属性数据被广泛访问的情况下。为了降低无意中泄露私人信息的风险，建议服务器开发访问控制机制，将对资源内容的读取权限与对资源属性的读取权限分开。这使用户可以控制其属性数据的传播，而不必过度限制对资源内容的访问。

20.6 XML实体的影响

XML支持一种称为“外部实体”的机制（定义在[REC-XML]的第4.2.2节），指示XML处理器检索并包含额外的XML。外部XML实体可以用来附加或修改XML文档的类型声明（DTD），也可以用来在XML内容中包含XML。对于非验证型XML（如本规范使用的XML），包含外部XML实体不是XML的强制要求，但XML确实声明处理器可以自行决定是否包含外部实体。

外部XML实体没有固有的可信度，容易受到任何HTTP GET请求中常见的攻击。此外，外部实体还可能修改DTD，从而影响XML文档的最终形式，严重时可能改变其语义或使XML处理器面临[RFC3023]中讨论的安全风险。因此，开发者应将外部XML实体视为不可信的。如果服务器选择不处理外部实体，应在请求中包含“no-external-entities”条件码。

此外，广泛部署使用外部XML实体的应用存在可扩展性风险。大量请求某个外部实体可能会导致服务器过载，尤其是当请求集中在包含外部实体的资源上。

还存在基于[REC-XML]第4.2.2节定义的“内部实体”的风险。利用嵌套内部实体的精心设计的小型请求，可能会消耗大量内存或处理时间。服务器实现者应意识到这一风险，并配置XML解析器以便尽早检测和拒绝此类请求。

20.7 与锁令牌（Lock Tokens）相关的风险

本规范鼓励使用“全球唯一标识符（UUID）”[RFC4122]的URN命名空间（第6.5节）作为锁令牌，以确保其在空间和时间上的唯一性。第1节定义的版本1 UUID可能包含“节点”字段（由IEEE 802 MAC地址组成，通常是主机地址），对于多地址系统，可以使用任何可用的地址。由于WebDAV服务器在其生命周期内会发出许多锁，意味着它可能会公开其IEEE 802地址。

公开IEEE 802地址存在多种风险：

- 可以追踪硬件在子网间的移动。
- 可能识别运行WebDAV服务器的硬件制造商。
- 可能推断出运行WebDAV的不同类型计算机的数量。

此风险仅影响基于主机地址的UUID版本。第4节描述了其他生成UUID的方法，这些方法不涉及主机地址，因此不存在此风险。

20.8 托管恶意内容的风险

HTTP具有托管在客户端机器上执行程序的能力，这些程序可以是Web脚本、可执行文件、插件模块或文档中的宏。WebDAV不会改变这些程序的安全性问题，但常在允许广泛用户在服务器上发布文档的场景中使用。服务器可能与发布者没有紧密的信任关系。允许客户端发布任意内容的服务器应采取措施，确保发布内容不会对其他客户端造成危害。可以通过限制允许发布的内容类型、运行病毒和恶意软件检测软件等方式实现。此外，服务器还应通过适当的访问限制和身份验证，控制允许发布内容的用户。

21. IANA考虑事项

21.1 新的URI方案

本规范定义了两种URI方案：

1. 附录C中定义的“opaquelocktoken”方案；
2. 传统用于[RFC2518]中区分WebDAV属性和XML元素名的“DAV” URI方案，且在本规范及其他扩展WebDAV的规范中仍然使用。 “DAV:”命名空间的标识符由IETF控制。

注意：现已不鼓励为XML命名空间定义新的URI方案。“DAV:”是在标准最佳实践出现之前定义的。

21.2 XML命名空间

XML命名空间用于区分WebDAV属性名和XML元素。任何WebDAV用户或应用都可以定义新的命名空间，以创建自定义属性或扩展WebDAV XML语法。IANA无需管理这些命名空间、属性名或元素名。

21.3 消息头字段

以下消息头字段应被添加到永久注册表（参见[RFC3864]）。

21.3.1 DAV

- 头字段名：DAV
- 适用协议：http
- 状态：标准
- 作者/变更控制：IETF
- 规范文档：本规范（第10.1节）

21.3.2 Depth

- 头字段名：Depth
- 适用协议：http
- 状态：标准
- 作者/变更控制：IETF
- 规范文档：本规范（第10.2节）

21.3.3 Destination

- 头字段名：Destination
- 适用协议：http
- 状态：标准
- 作者/变更控制：IETF
- 规范文档：本规范（第10.3节）

21.3.4 If

- 头字段名：If
- 适用协议：http
- 状态：标准
- 作者/变更控制：IETF
- 规范文档：本规范（第10.4节）

21.3.5 Lock-Token

- 头字段名：Lock-Token
- 适用协议：http
- 状态：标准
- 作者/变更控制：IETF
- 规范文档：本规范（第10.5节）

21.3.6 Overwrite

- 头字段名：Overwrite
- 适用协议：http
- 状态：标准
- 作者/变更控制：IETF
- 规范文档：本规范（第10.6节）

21.3.7 Timeout

- 头字段名：Timeout
- 适用协议：http
- 状态：标准
- 作者/变更控制：IETF
- 规范文档：本规范（第10.7节）

21.4 HTTP状态码

本规范定义了以下HTTP状态码：

- 207 多状态（Section 11.1）
- 422 无法处理的实体（Section 11.2）
- 423 被锁定（Section 11.3）
- 424 依赖失败（Section 11.4）
- 507 存储空间不足（Section 11.5）

这些状态码应在<http://www.iana.org/assignments/http-status-codes>注册表中更新。

注意：在本规范中已删除HTTP状态码102（Processing）；其IANA注册应继续引用RFC2518。

22. 致谢

像本规范这样的文档依赖于严谨的评审，也会因漠不关心而衰败。作者衷心感谢以下人员的贡献，他们在我们工作的每个阶段都提供了宝贵的见解。

RFC2518的贡献者包括：特里·艾伦、哈拉尔德·阿尔维斯特拉德、吉姆·阿姆斯登、贝基·安德森、艾伦·巴比奇、桑福德·巴尔、迪兰·巴雷尔、伯纳德·切斯特、蒂姆·伯纳斯-李、丹·康诺利、吉姆·坎宁安、罗恩·丹尼尔二世、吉姆·戴维斯、基思·道森、马克·戴、布莱恩·迪恩、马丁·杜尔斯特、戴维·杜兰、李·法雷尔、查克·费、韦斯利·费尔特、罗伊·菲尔丁、马克·费舍尔、艾伦·弗赖尔、乔治·弗洛伦丁、吉姆·盖蒂斯、菲尔·霍尔姆-贝克、丹尼斯·汉密尔顿、史蒂夫·亨宁、米德·希梅尔斯坦、亚历克斯·霍普曼、安德烈·范·德·霍克、本·洛里、保罗·利奇、奥拉·拉西拉、凯伦·麦克阿瑟、史蒂文·马丁、拉里·马辛特、迈克尔·米洛林、基思·摩尔、托马斯·纳尔滕、亨里克·尼尔森、太田健二、鲍勃·帕克、格伦·彼得森、乔恩·拉多夫、萨维恩·雷迪、亨利·桑德斯、克里斯托弗·塞瓦尔德、朱迪思·斯莱因、迈克·斯普赖策、艾纳·斯特弗鲁德、格雷格·斯坦、拉尔夫·斯威克、高桥健二、理查德·N·泰勒、罗伯特·陶、约翰·特纳、桑卡尔·维尔达格里斯瓦兰、法比奥·维塔利、格雷戈里·伍德豪斯和劳伦·伍德。

其中两人值得特别提及：拉里·马辛特的贡献极为宝贵，他不仅协助组建工作组，还耐心指导作者，树立了高标准；朱迪思·斯莱因的贡献也非常重要，她澄清了需求，耐心审阅多个版本，不仅改善了本规范，还拓宽了我们对文档管理的理解。

我们还要感谢约翰·特纳开发的XML DTD。

RFC 2518的作者包括Yaron Goland、Jim Whitehead、A. Faizi、Steve Carter和D. Jensen。由于IETF的作者人数限制，他们的名字不得不被删除，但他们应当为WebDAV的大部分设计工作贡献了重要力量。

对本规范的额外致谢

本规范中重要的文字贡献者在下文的“贡献者”部分有所列出。我们还要衷心感谢Geoff Clemm、Joel Soderberg和Dan Brotsky，他们在邮件列表或会议中共同探讨具体文本内容。Joe Hildebrand和Cullen Jennings帮助解决了许多问题。Barry Lind提出了额外的安全考虑，Cullen Jennings为该考虑提供了相关文本。Jason Crawford在数年间追踪了本文件的问题状态，之后由Elias Sinderson继续跟进。

23. 本规范的贡献者

Julian Reschke  
<green/>bytes GmbH  
Hafenweg 16, 48155 Münster, 德国  
电子邮箱：julian.reschke@greenbytes.de

Elias Sinderson  
加州大学圣克鲁斯分校  
1156 High Street, Santa Cruz, CA 95064  
电子邮箱：elias@cse.ucsc.edu

Jim Whitehead  
加州大学圣克鲁斯分校  
1156 High Street, Santa Cruz, CA 95064  
电子邮箱：ejw@soe.ucsc.edu

24. RFC 2518的作者

Y. Y. Goland  
微软公司  
One Microsoft Way  
雷德蒙德, WA 98052-6399  
电子邮箱：yarong@microsoft.com

E. J. Whitehead Jr.  
加州大学欧文分校信息与计算机科学系  
Irvine, CA 92697-3425  
电子邮箱：ejw@ics.uci.edu

A. Faizi  
网景公司  
685 East Middlefield Road  
山景城, CA 94043  
电子邮箱：asad@netscape.com

S. R. Carter  
Novell公司  
1555 N. Technology Way  
M/S ORM F111  
奥雷姆, UT 84097-2399  
电子邮箱：srcarter@novell.com

D. Jensen  
Novell公司  
1555 N. Technology Way  
M/S ORM F111  
奥雷姆, UT 84097-2399  
电子邮箱：dcjensen@novell.com

25. 参考文献

25.1. 必要性参考文献

[REC-XML] Bray, T.等，“可扩展标记语言（XML）1.0（第四版）”，W3C推荐标准-xml-20060816，2006年8月，<http://www.w3.org/TR/2006/REC-xml-20060816/>。

[REC-XML-INFOSET] Cowan, J. 和 R. Tobin，“XML信息集（第二版）”，W3C推荐-xml-infoset-20040204，2004年2月，<http://www.w3.org/TR/2004/REC-xml-infoset-20040204/>。

[REC-XML-NAMES] Bray, T.等，“XML 1.0中的命名空间（第二版）”，W3C推荐-xml-names-20060816，2006年8月，<http://www.w3.org/TR/2006/REC-xml-names-20060816/>。

[RFC2119] Bradner, S.，“在RFC中使用的关键词以指示需求级别”，BCP 14，RFC 2119，1997年3月。

[RFC2277] Alvestrand, H.，“IETF关于字符集和语言的政策”，BCP 18，RFC 2277，1998年1月。

[RFC2616] Fielding, R.等，“超文本传输协议——HTTP/1.1”，RFC 2616，1999年6月。

[RFC2617] Franks, J.等，“HTTP认证：基本和摘要访问认证”，RFC 2617，1999年6月。

[RFC3339] Klyne, G.（编辑）和 C. Newman，“互联网日期和时间：时间戳”，RFC 3339，2002年7月。

[RFC3629] Yergeau, F.，“UTF-8，ISO 10646的变换格式”，STD 63，RFC 3629，2003年11月。

[RFC3986] Berners-Lee, T.、Fielding, R. 和 L. Masinter，“统一资源标识符（URI）：通用语法”，STD 66，RFC 3986，2005年1月。

[RFC4122] Leach, P.、Mealling, M. 和 R. Salz，“全球唯一标识符（UUID）URN命名空间”，RFC 4122，2005年7月。

25.2. 说明性参考文献

[RFC2291] Slein, J.等，“Web的分布式创作与版本控制协议的需求”，RFC 2291，1998年2月。

[RFC2518] Goland, Y.等，“用于分布式创作的HTTP扩展——WEBDAV”，RFC 2518，1999年2月。

[RFC2781] Hoffman, P. 和 F. Yergeau，“UTF-16，ISO 10646的编码”，RFC 2781，2000年2月。

[RFC3023] Murata, M.、St. Laurent, S. 和 D. Kohn，“XML媒体类型”，RFC 3023，2001年1月。

[RFC3253] Clemm, G.等，“WebDAV的版本控制扩展（Web Distributed Authoring and Versioning）”，RFC 3253，2002年3月。

[RFC3648] Whitehead, J. 和 J. Reschke（编辑），“Web分布式创作与版本控制（WebDAV）有序集合协议”，RFC 3648，2003年12月。

[RFC3744] Clemm, G.、Reschke, J.、Sedlar, E. 和 J. Whitehead，“Web分布式创作与版本控制（WebDAV）访问控制协议”，RFC 3744，2004年5月。

[RFC3864] Klyne, G.、Nottingham, M. 和 J. Mogul，“消息头字段的注册程序”，BCP 90，RFC 3864，2004年9月。

（以下省略部分内容，内容与原文一致，因篇幅较长，此处不再逐一翻译。）

附录A. 关于处理XML元素的说明

A.1. 空XML元素的说明

XML支持两种指示元素无内容的机制。第一种是声明形式如<A></A>，第二种是<A/>。这两种XML元素在语义上是等价的。

A.2. 关于非法XML处理的说明

XML是一种灵活的数据格式，容易提交看似合法但实际上不合法的数据。“接受你所接受的要灵活，发送的要严格”的原则仍然适用，但不能不当应用。XML在处理空白字符、元素顺序、插入新元素等方面极为灵活，但这不意味着可以扩展，尤其是在元素含义方面。

接受非法组合的XML元素没有善意，最多只会导致不希望的结果，最坏的可能造成实际损害。

A.3. 示例——XML语法错误

以下PROPFIND请求体是非法的：

```xml
<?xml version="1.0" encoding="utf-8" ?>
<D:propfind xmlns:D="DAV:">
  <D:allprop/>
  <D:propname/>
</D:propfind>
```

因为propfind元素只允许包含allprop或propname之一，不可同时出现。因此，应返回400（错误请求）。

假设服务器出于“善意”选择将allprop视为有效元素并响应，带宽有限的客户端可能会大吃一惊，因为它原本打算执行propname。

此外，如果服务器宽容地处理此请求，结果可能因服务器不同而异，有些会执行allprop指令，有些会执行propname指令，这会降低互操作性。

A.4. 示例——意外的XML元素

前例非法的原因是包含了在propfind元素中被明确禁止同时出现的两个元素。然而，XML是可扩展的语言，可以定义新元素用于propfind。以下是一个带有未被理解的扩展元素的请求体，必须被服务器以400（错误请求）拒绝：

```xml
<?xml version="1.0" encoding="utf-8" ?>
<D:propfind xmlns:D="DAV:"
  xmlns:E="http://www.example.com/standards/props/">
  <E:expired-props/>
</D:propfind>
```

如果服务器不理解expired-props元素，根据第17节的WebDAV特定XML处理规则，应将其视为不存在该元素，处理请求时忽略它。此时，服务器看到的实际上是空的propfind，依据元素定义这是非法的。

值得注意的是，如果扩展是累加的，不一定会导致400错误。例如，以下请求体：

```xml
<?xml version="1.0" encoding="utf-8" ?>
<D:propfind xmlns:D="DAV:"
  xmlns:E="http://www.example.com/standards/props/">
  <D:propname/>
  <E:leave-out>*boss*</E:leave-out>
</D:propfind>
```

其中的leave-out元素是虚构的，用于阻止返回匹配特定模式的属性。如果提交到不理解该元素的服务器，结果只会是忽略它，执行propname。

附录B. 关于HTTP客户端兼容性的说明

WebDAV设计之初即与HTTP/1.1向后兼容。PUT和DELETE方法在HTTP中已有定义，既可由普通HTTP客户端使用，也可由WebDAV客户端使用，但本规范对PUT和DELETE的响应做了扩展，只有WebDAV客户端才能完全预料到。有人担心这些扩展的响应会影响纯HTTP客户端的互操作性，本文对此进行了说明。

因为任何HTTP客户端都应将未识别的400级和500级状态码视为错误，以下新状态码应不会引起问题：422、423和507（424也是新状态码，但只在多状态响应体中出现）。例如，若HTTP客户端试图对被锁定的资源执行PUT或DELETE，返回的423（已锁定）应作为通用错误提示给用户。

207多状态响应较为特殊，HTTP客户端发出DELETE请求时可能会误解为成功，即使实际上资源是集合且可能部分失败。因为200级响应仅表示“已接收、理解并接受”请求，而不代表完全成功。

一种方案是服务器将对集合的DELETE视为原子操作，成功时返回204（无内容），失败时返回适当的错误状态（如400或500）。此方案能最大程度保持向后兼容。然而，经过互操作性测试和工作组讨论，目前尚未发现HTTP客户端对WebDAV集合执行DELETE的实例，因此此担忧更多是理论上的。即使服务器将任何集合的DELETE请求视为WebDAV请求并返回207多状态，也不会影响大部分互操作。

一般建议服务器实现者优先使用本文定义的详细响应和机制，而非为理论互操作性问题做出修改。

附录C. ‘opaquelocktoken’方案及URI

‘opaquelocktoken’ URI方案在[RFC2518]中定义（由IANA注册），用于生成符合语法且易于生成的UUID URI，作为锁令牌，确保在所有资源中唯一且永久。

opaquelocktoken URI由“opaquelocktoken”方案与UUID（以及可选扩展）拼接而成。服务器可为每个新锁令牌生成新的UUID。若希望重用UUID，必须添加扩展，且生成扩展的算法必须保证相同UUID的扩展永不重复。

```plaintext
OpaqueLockToken-URI = "opaquelocktoken:" UUID [Extension]
```

其中UUID在[RFC4122]第3节定义，元素间不允许空白字符。

扩展（Extension）定义在[RFC3986]第3.3节。

附录D. 锁空资源

最初的WebDAV模型中，锁定未映射URL会创建“锁空资源”。该模型过于复杂，导致一些互操作和实现问题。新模型（见第7.3节）创建了“锁定空资源”。锁空资源已被废弃。本文简要讨论原始模型，因为客户端必须能处理两者。

在原始“锁空资源”模型中（不再推荐实现）：

- 锁空资源有时显示为“未找到”。服务器对除PUT、MKCOL、OPTIONS、PROPFIND、LOCK、UNLOCK之外的任何方法响应404或405。

- 锁空资源仍会作为其父集合的成员出现。

服务器会在锁定失效（在其转换为普通资源之前）时，完全删除锁空资源（其URI变得未映射）。请注意，锁不仅在到期或解锁时失效，还会在资源重命名或移动，或任何父集合被重命名或移动时被移除。

如果对该URL的PUT请求成功，服务器会将锁空资源转换为普通资源。

如果对该URL的MKCOL请求成功，服务器会将锁空资源转换为集合（尽管实际操作中显示，并非所有服务器都遵循此要求）。

对于DAV:lockdiscovery和DAV:supportedlock属性值已被定义，但其他属性如DAV:getcontenttype未必如此。

客户端可以通过仅在对未映射的URL进行LOCK后尝试PUT，而不进行MKCOL或GET，来轻松实现与支持旧模型“锁空资源”以及推荐模型“锁定空资源”的服务器的互操作性。

### 附录D.1. 使用LOCK创建资源的客户端指南

实现本规范的WebDAV客户端可能会遇到创建锁空资源（在本规范之前通过[RFC2518]实现）以及创建锁定空资源的服务器。LOCK请求的响应不会指示创建了何种资源。以下几种技术可以帮助客户端应对这两种情况。

- 如果客户端希望避免意外创建锁空或空锁定资源，可以在LOCK请求中加入“If-Match: *”头，防止服务器创建新资源。

- 如果LOCK请求创建了资源，且客户端随后希望用COPY或MOVE请求覆盖该资源，应在请求中加入“Overwrite: T”头。

- 如果LOCK请求创建了资源，且客户端决定删除该资源，理论上对锁空资源的DELETE请求应失败，应该使用UNLOCK代替。但对于空锁定资源，UNLOCK不会让资源消失。因此，客户端可能需要尝试两者请求，并忽略其中一个请求的错误。

### 附录E. 客户端认证指南

许多已实现的WebDAV客户端具有账户设置（类似于电子邮件客户端存储IMAP账户信息的方式）。因此，客户端在首次请求服务器时可以进行认证，只要它能从服务器获取带有realm名称、nonce和其他挑战信息的认证挑战。

注意，某些请求的结果可能会因是否已认证而不同——例如，PROPFIND在已认证时可能返回更多可见资源，但匿名访问也不一定失败。

客户端可以通过多种方式触发服务器提供认证挑战。以下介绍两种特别可能奏效的方法。

第一种方法是发起一个应要求认证的请求。由于某些服务器可能在没有认证的情况下也会处理任何请求，为了安全起见，客户端可以在请求中加入条件头，确保即使权限检查通过，服务器也不会实际处理请求。例如，使用带有虚假ETag值的“如果匹配”头的PUT请求。这种方法可能因服务器未在测试条件前进行授权验证（见第8.5节）或不需要验证授权而失败。

示例——用写操作强制认证挑战：

```
PUT /forceauth.txt HTTP/1.1
Host: www.example.com
If-Match: "xxx"
Content-Type: text/plain
Content-Length: 0
```

第二种方法是使用Authorization头（定义在[RFC2617]中），服务器可能会拒绝，但会发出正确的认证挑战。例如，客户端可以用包含虚假Basic认证信息（如用户名密码字符串）或实际可信凭据的PROPFIND请求。此方法依赖于服务器在收到未知用户名、无效密码或不支持Basic认证时返回“401 Unauthorized”及挑战信息（符合RFC2617的要求）。

示例——用Authorization头强制认证挑战：

```
PROPFIND /docs/ HTTP/1.1
Host: www.example.com
Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==
Content-type: application/xml; charset="utf-8"
Content-Length: xxxx
[正文省略]
```

### 附录F. RFC 2518的变更总结

本节列出本规范与RFC 2518之间的主要变更，重点在于可能影响实现的内容。服务器应在DAV响应头中返回“3”支持级别，表明支持所有本规范中的变更（参见第10.1和18.3节）。

#### F.1. 客户端和服务器实现的变更

**集合与命名空间操作**

- PROPFIND的'allprop'语义已放宽，服务器应至少返回本规范定义的活跃属性，但不一定返回其他活跃属性。'allprop'现在更像“返回请求时应返回的所有属性”，可能包括自定义属性和其他规范定义的属性（如有需要）。此外，'allprop'请求可以扩展为包括特定命名属性（使用include语法），避免因语义变化而多次请求。

- 服务器现在可以拒绝Depth: Infinity的PROPFIND请求，客户端需改为一系列Depth:1请求。

- 多状态响应体现在新加入的'location'元素中，可以传递HTTP的Location响应头的值，帮助客户端避免额外的往返。

- COPY的定义已放宽，不再要求先删除目标资源（解决与[RFC3253]的不兼容问题），详见第9.8节。

**请求头和封送**

- Destination和If请求头现在允许使用绝对路径（而非仅URI），详见第8.3节。这对通过反向代理操作的客户端可能有用。

- 采用[RFC3253]定义的错误封送扩展和“前提条件/后置条件”术语（第16节），并在多状态响应中加入“error”XML元素（第14.5节，但格式不同于[RFC3253]的建议）。

- 发送者和接收者必须支持XML消息体中的UTF-16字符编码（第19节）。

- 客户端必须在PROPFIND请求中加入Depth头，尽管服务器鼓励支持不带Depth的请求。

**锁定**

- RFC 2518中的“锁空资源”概念已被简化为“锁定空资源”，详见第7.3节。锁空资源的某些特性（如用它们创建锁定集合或在未发出PUT或MKCOL时UNLOCK后消失）不再可靠。服务器仍可实现LNR。

- 不再隐式刷新锁。锁只在明确请求时刷新（第9.10.2节）。

- 明确锁请求中的DAV:owner值应由服务器保留，类似死属性（第14.17节）；同时加入DAV:lockroot元素（第14.12节），帮助客户端发现锁根。

#### F.2. 服务器实现的变更

**集合与命名空间操作**

- 由于互操作性问题，multistatus响应中'href'元素内容的格式受限（第8.3节）。

- 由于缺乏实现，已移除对COPY和MOVE的'propertybehavior'请求体支持，改为明确属性保持要求（第9.8和9.9节）。

**属性**

- 加强对属性值存储的要求，特别是语言信息（xml:lang）、空白字符和XML命名空间信息的持久性（第4.3节）。

- 明确哪些属性应由客户端写入支持，特别是“DAV:displayname”应由服务器支持（第15节）。

- 仅允许使用rfc1123-date格式作为DAV:getlastmodified的值（第15.7节）。

**请求头和封送**

- 服务器现在必须在处理条件头之前进行授权检查（第8.5节）。

**锁定**

- 加强在访问锁定资源时验证锁创建者身份的要求（第6.4节）。客户端应意识到，返回给其他主体的锁令牌只能用于解除锁定。

- [RFC2518]第8.10.4节错误地要求在应使用207状态的情况下返回409状态，现已更正（第9.10节）。

#### F.3. 其他变更

- 集合状态的定义已修正，不再依赖Request-URI（第5.2节）。

- 第4.6节引入的DAV:source属性已移除，因缺乏实现经验。

- DAV头允许通过URI支持非IETF扩展，且可在请求中使用，但本规范未定义相关语义（第10.1节）。

- RFC 2518中，Depth头的默认应用范围已反转（第10.2节）。

- 由于缺乏实现，HTTP状态码102和Status-URI响应头已移除（第10.1和9.7节）。

- Timeout请求头中的TimeType格式和“timeout”XML元素曾支持扩展，但现仅允许本规范定义的两种格式（第10.7节）。

### 作者联系方式

Lisa Dusseault（编辑）  
CommerceNet  
2064 Edgewood Dr.  
Palo Alto, CA 94303  
美国

电子邮箱：ldusseault@commerce.net

### 版权声明

版权所有 (C) IETF Trust (2007)。  
本文件受BCP 78中的权利、许可和限制约束，除非另有说明，作者保留所有权利。  
本文件及其中信息按“原样”提供，贡献者、其代表的组织（如有）、互联网协会、IETF信托及互联网工程任务组不对其任何明示或暗示的保证负责，包括但不限于不侵犯任何权利或适销性、适用性的保证。

### 知识产权

IETF对任何可能声称与本文件所描述技术的实现或使用相关的知识产权或其他权利的有效性或范围不持任何立场，也不对是否存在相关许可提供任何声明；它也不表示已进行任何独立努力以识别此类权利。关于RFC文件中权利相关程序的信息，可以在BCP 78和BCP 79中找到。

向IETF秘书处提交的知识产权披露文件的副本，以及承诺提供的许可保证，或为实现或使用本规范的相关专有权利而尝试获得的一般许可或权限的结果，可以在IETF的在线知识产权库（http://www.ietf.org/ipr）中获取。

IETF欢迎任何相关方就可能涉及实现本标准所需技术的版权、专利或专利申请，或其他专有权利，向其提供信息。请将相关信息发送至IETF的电子邮箱：ietf-ipr@ietf.org。

致谢

目前，RFC编辑工作的资金由互联网协会提供。