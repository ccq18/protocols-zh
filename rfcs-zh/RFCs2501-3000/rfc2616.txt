# RFC 2616 中文翻译 (stub)
# 原文文件: ../../rfcs/RFCs2501-3000/rfc2616.txt

网络工作组                                      R. Fielding
评论请求：2616                                   加州大学欧文分校
废止：2068                                              J. Gettys
类别：标准轨道                                   康柏公司/W3C
                                                              J. Mogul
                                                                康柏公司
                                                            H. Frystyk
                                                               W3C/MIT
                                                           L. Masinter
                                                                 施乐公司
                                                              P. Leach
                                                             微软公司
                                                        T. Berners-Lee
                                                               W3C/MIT
                                                             1999年6月


                超文本传输协议——HTTP/1.1

本备忘录的状态

   本文档为互联网社区制定的互联网标准轨道协议，旨在征求讨论和改进建议。请参阅当前版本的《互联网官方协议标准》（STD 1）以了解该协议的标准化状态和最新情况。本备忘录的分发不受限制。

版权声明

   版权所有 © 互联网协会（1999年）。保留所有权利。

摘要

   超文本传输协议（HTTP）是一种面向应用层的协议，用于分布式、协作式超媒体信息系统。它是一个通用的、无状态的协议，可以通过扩展请求方法、错误代码和头字段，应用于超文本之外的许多任务，例如名称服务器和分布式对象管理系统[47]。HTTP的一个特点是支持数据表示的类型和协商，允许系统在不依赖于传输数据的具体内容的情况下构建。

   自1990年以来，HTTP一直被全球信息网络计划——万维网所使用。本规范定义了被称为“HTTP/1.1”的协议，并对RFC 2068 [33]进行了更新。





Fielding 等人            标准轨道                     [第1页]


RFC 2616                        HTTP/1.1                       1999年6月


目录

   1   引言 ...................................................7
   1.1  目的......................................................7
   1.2  需求......................................................8
   1.3  术语......................................................8
   1.4  整体操作...............................................12
   2   表示法约定与通用语法....................................14
   2.1  增强BNF.................................................14
   2.2  基本规则...............................................15
   3   协议参数.................................................17
   3.1  HTTP版本...............................................17
   3.2  统一资源标识符（URI）..................................18
   3.2.1  一般语法..............................................19
   3.2.2  http URL..............................................19
   3.2.3  URI比较..............................................20
   3.3  日期/时间格式...........................................20
   3.3.1  完整日期..............................................20
   3.3.2  相对秒数..............................................21
   3.4  字符集..................................................21
   3.4.1  缺失字符集............................................22
   3.5  内容编码...............................................23
   3.6  传输编码...............................................24
   3.6.1  分块传输编码..........................................25
   3.7  媒体类型...............................................26
   3.7.1  规范化与文本默认值....................................27
   3.7.2  多部分类型............................................27
   3.8  产品标记...............................................28
   3.9  质量值.................................................29
   3.10  语言标签..............................................29
   3.11  实体标签..............................................30
   3.12  范围单位..............................................30
   4   HTTP消息.................................................31
   4.1  消息类型...............................................31
   4.2  消息头.................................................31
   4.3  消息体.................................................32
   4.4  消息长度...............................................33
   4.5  通用头字段.............................................34
   5   请求.....................................................35
   5.1  请求行.................................................35
   5.1.1  方法.................................................36
   5.1.2  请求URI..............................................36
   5.2  请求所标识的资源.......................................38
   5.3  请求头字段.............................................38
   6   响应.....................................................39
   6.1  状态行.................................................39
   6.1.1  状态码与原因短语.....................................39
   6.2  响应头字段.............................................41



Fielding 等人            标准轨道                     [第2页]


RFC 2616                        HTTP/1.1                       1999年6月


   7   实体.....................................................42
   7.1  实体头字段...........................................42
   7.2  实体体...............................................43
   7.2.1  类型...............................................43
   7.2.2  实体长度...........................................43
   8   连接.....................................................44
   8.1  持久连接...............................................44
   8.1.1  目的.................................................44
   8.1.2  整体操作.............................................45
   8.1.3  代理服务器...........................................46
   8.1.4  实际考虑.............................................46
   8.2  消息传输要求...........................................47
   8.2.1  持久连接与流控制....................................47
   8.2.2  监控连接以获取错误状态信息..........................48
   8.2.3  使用100（继续）状态..................................48
   8.2.4  服务器提前关闭连接时客户端的行为....................50
   9   方法定义.................................................51
   9.1  安全与幂等方法.........................................51
   9.1.1  安全方法.............................................51
   9.1.2  幂等方法.............................................51
   9.2  OPTIONS.................................................52
   9.3  GET.....................................................53
   9.4  HEAD....................................................54
   9.5  POST....................................................54
   9.6  PUT.....................................................55
   9.7  DELETE..................................................56
   9.8  TRACE...................................................56
   9.9  CONNECT.................................................57
   10  状态码定义..............................................57
   10.1  信息性1xx..............................................57
   10.1.1  100 继续.............................................58
   10.1.2  101 切换协议.........................................58
   10.2  成功2xx...............................................58
   10.2.1  200 成功.............................................58
   10.2.2  201 已创建...........................................59
   10.2.3  202 已接受...........................................59
   10.2.4  203 非权威信息.......................................59
   10.2.5  204 无内容...........................................60
   10.2.6  205 重置内容.........................................60
   10.2.7  206 部分内容.........................................60
   10.3  重定向3xx.............................................61
   10.3.1  300 多重选择.........................................61
   10.3.2  301 永久移动.........................................62
   10.3.3  302 临时找到.........................................62
   10.3.4  303 参见其他.........................................63
   10.3.5  304 未修改...........................................63
   10.3.6  305 使用代理.........................................64
   10.3.7  306（未使用）.......................................64
   10.3.8  307 临时重定向.......................................65
   10.4  客户端错误4xx.........................................65
   10.4.1  400 错误请求.........................................65
   10.4.2  401 未授权...........................................66
   10.4.3  402 需要付款.........................................66
   10.4.4  403 禁止访问.........................................66
   10.4.5  404 未找到...........................................66
   10.4.6  405 方法不被允许.....................................66
   10.4.7  406 不可接受.........................................67
   10.4.8  407 代理认证要求.....................................67
   10.4.9  408 请求超时.........................................67
   10.4.10  409 冲突............................................67
   10.4.11  410 已删除..........................................68
   10.4.12  411 需要内容长度....................................68
   10.4.13  412 预条件失败......................................68
   10.4.14  413 请求实体过大....................................69
   10.4.15  414 请求URI过长.....................................69
   10.4.16  415 不支持的媒体类型................................69
   10.4.17  416 请求范围不满足..................................69
   10.4.18  417 预期失败........................................70
   10.5  服务器错误5xx.........................................70
   10.5.1  500 服务器内部错误..................................70
   10.5.2  501 未实现..........................................70
   10.5.3  502 网关错误..........................................70
   10.5.4  503 服务不可用.......................................70
   10.5.5  504 网关超时..........................................71
   10.5.6  505 HTTP版本不支持..................................71
   11  访问认证...............................................71
   12  内容协商...............................................71
   12.1  由服务器驱动的协商....................................72
   12.2  由代理驱动的协商......................................73
   12.3  透明协商..............................................74
   13  HTTP中的缓存...........................................74
   13.1.1  缓存正确性...........................................75
   13.1.2  警告.................................................76
   13.1.3  缓存控制机制.........................................77
   13.1.4  明确的用户代理警告..................................78
   13.1.5  规则和警告的例外....................................78
   13.1.6  客户端控制的行为....................................79
   13.2  过期模型..............................................79
   13.2.1  服务器指定的过期时间................................79
   13.2.2  启发式过期..........................................80
   13.2.3  年龄计算............................................80
   13.2.4  过期时间计算........................................83
   13.2.5  消歧义的过期值......................................84
   13.2.6  消歧义的多重响应....................................84
   13.3  验证模型..............................................85
   13.3.1  最后修改日期........................................86



Fielding 等人            标准轨道                     [第4页]


RFC 2616                        HTTP/1.1                       1999年6月


   13.3.2  实体标签缓存验证器..................................86
   13.3.3  弱验证器与强验证器..................................86
   13.3.4  使用实体标签和最后修改日期的规则..................89
   13.3.5  非验证条件..........................................90
   13.4  响应缓存性............................................91
   13.5  从缓存构建响应........................................92
   13.5.1  端到端和跳跃头字段..................................92
   13.5.2  不可修改的头字段....................................92
   13.5.3  头字段的组合........................................94
   13.5.4  字节范围的组合......................................95
   13.6  协商响应的缓存........................................95
   13.7  共享与非共享缓存......................................96
   13.8  错误或不完整响应缓存行为..............................97
   13.9  GET和HEAD的副作用....................................97
   13.10  更新或删除后的无效化..................................97
   13.11  强制写入..............................................98
   13.12  缓存替换..............................................99
   13.13  历史列表..............................................99
   14  头字段定义.............................................100
   14.1  Accept.................................................100
   14.2  Accept-Charset.........................................102
   14.3  Accept-Encoding.........................................102
   14.4  Accept-Language.........................................104
   14.5  Accept-Ranges...........................................105
   14.6  Age.....................................................106
   14.7  Allow...................................................106
   14.8  Authorization...........................................107
   14.9  Cache-Control...........................................108
   14.9.1  缓存可否.............................................109
   14.9.2  缓存可存储内容.......................................110
   14.9.3  基本过期机制的修改..................................111
   14.9.4  缓存重验证与重新加载控制............................113
   14.9.5  不进行内容转换......................................115
   14.9.6  缓存控制扩展........................................116
   14.10  连接.................................................117
   14.11  内容编码.............................................118
   14.12  内容语言.............................................118
   14.13  内容长度.............................................119
   14.14  内容位置.............................................120
   14.15  内容MD5..............................................121
   14.16  内容范围.............................................122
   14.17  内容类型.............................................124
   14.18  日期.................................................124
   14.18.1  无时钟源的源服务器操作............................125
   14.19  实体标签（ETag）....................................126
   14.20  期望.................................................126
   14.21  过期时间.............................................127
   14.22  来源.................................................128



Fielding 等人            标准轨道                     [第5页]


RFC 2616                        HTTP/1.1                       1999年6月


   14.23  主机.................................................128
   14.24  如果匹配.............................................129
   14.25  如果修改时间.........................................130
   14.26  如果不匹配...........................................132
   14.27  如果范围.............................................133
   14.28  如果未修改...........................................134
   14.29  最后修改.............................................134
   14.30  位置.................................................135
   14.31  最大转发次数.........................................136
   14.32  Pragma...............................................136
   14.33  代理认证.............................................137
   14.34  代理授权.............................................137
   14.35  范围.................................................138
   14.35.1  字节范围...........................................138
   14.35.2  范围检索请求.......................................139
   14.36  引用.................................................140
   14.37  重试等待时间.........................................141
   14.38  服务器...............................................141
   14.39  TE...................................................142
   14.40  预告.................................................143
   14.41  传输编码.............................................143
   14.42  升级.................................................144
   14.43  用户代理.............................................145
   14.44  变体.................................................145
   14.45  通过.................................................146
   14.46  警告.................................................148
   14.47  WWW-Authenticate.....................................150
   15  安全注意事项...........................................150
   15.1  个人信息.............................................151
   15.1.1  服务器日志信息的滥用................................151
   15.1.2  敏感信息的传输......................................151
   15.1.3  URI中敏感信息的编码..................................152
   15.1.4  与Accept头相关的隐私问题............................152
   15.2  基于文件和路径名的攻击................................153
   15.3  DNS欺骗...............................................154
   15.4  位置头和欺骗..........................................154
   15.5  内容处置问题..........................................154
   15.6  认证凭据与空闲客户端..................................155
   15.7  代理与缓存............................................155
   15.7.1  拒绝服务攻击（DoS）对代理的影响....................156
   16  致谢.....................................................156
   17  参考文献...............................................158
   18  作者联系方式...........................................162
   19  附录...................................................164
   19.1  互联网媒体类型 message/http 和 application/http......164
   19.2  互联网媒体类型 multipart/byteranges..................165
   19.3  宽容性应用............................................166
   19.4  HTTP实体与RFC 2045实体的差异..........................167
   19.4.1  MIME版本.............................................167
   19.4.2  转换为规范形式.......................................167
   19.4.3  日期格式转换.........................................168
   19.4.4  内容编码的引入.......................................168
   19.4.5  无内容传输编码.......................................168
   19.4.6  传输编码的引入.......................................169
   19.4.7  MHTML与行长度限制...................................169
   19.5  附加功能..............................................169
   19.5.1  内容处置.............................................170
   19.6  与以前版本的兼容性....................................170
   19.6.1  与HTTP/1.0的变化....................................171
   19.6.2  与HTTP/1.0持久连接的兼容性..........................172
   19.6.3  与RFC 2068的变化....................................172
   20  索引.....................................................175
   21  完整版权声明...........................................176

1 引言

1.1 目的

   超文本传输协议（HTTP）是一种面向应用层的协议，用于分布式、协作式超媒体信息系统。自1990年以来，HTTP一直被全球信息网络计划——万维网所采用。HTTP的第一个版本，称为HTTP/0.9，是一种用于在互联网上传输原始数据的简单协议。RFC 1945 [6]定义的HTTP/1.0对协议进行了改进，允许消息采用类似MIME的格式，包含关于传输数据的元信息以及请求/响应语义的修饰。然而，HTTP/1.0未充分考虑层级代理、缓存、持久连接或虚拟主机的影响。此外，许多自称“HTTP/1.0”的应用程序实现不完整，促使协议版本需要升级，以便通信双方能正确识别彼此的能力。

   本规范定义了“HTTP/1.1”协议。该协议比HTTP/1.0具有更严格的要求，以确保其功能的可靠实现。

   实用的信息系统需要比简单检索更丰富的功能，包括搜索、前端更新和注释。HTTP支持一组开放式的方法和头字段，用于指示请求的目的[47]。它依赖于统一资源标识符（URI）[3]提供的规范性，URI可以作为位置（URL）[4]或名称（URN）[20]，用以指示要应用方法的资源。消息采用类似互联网邮件[9]的格式传输，由多用途互联网邮件扩展（MIME）[7]定义。

   HTTP还作为一种通用协议，用于用户代理与代理/网关之间的通信，连接其他互联网系统，包括SMTP[16]、NNTP[13]、FTP[18]、Gopher[2]和WAIS[10]协议。通过这种方式，HTTP实现了对多样应用中资源的基本超媒体访问。

实体
      指作为请求或响应负载传输的信息。实体由元信息（以实体头字段的形式）和内容（以实体主体的形式）组成，具体描述见第7节。

表示
      指包含在响应中的、受内容协商影响的实体，如第12节所述。对于特定的响应状态，可能存在多个相关的表示。

内容协商
      指在处理请求时选择合适表示的机制，如第12节所述。任何响应中的实体表示都可以通过协商确定（包括错误响应）。

变体
      一个资源在任何给定时刻可能具有一个或多个相关的表示。每个这样的表示称为“变体”。使用“变体”一词并不一定意味着该资源必须进行内容协商。

客户端
      一个建立连接以发送请求的程序。

用户代理
      发起请求的客户端，通常是浏览器、编辑器、爬虫（网页遍历机器人）或其他终端用户工具。

服务器
      一个接受连接以提供服务的应用程序，通过返回响应来满足请求。任何程序都可能同时具有客户端和服务器的角色；这里的用语仅指程序在特定连接中所扮演的角色，而非其整体能力。同样，任何服务器都可以作为源服务器、代理、网关或隧道，根据每个请求的性质切换行为。

源服务器
      存放或即将创建特定资源的服务器。

代理
      作为中介的程序，既充当服务器又充当客户端，代表其他客户端发出请求。请求可以在内部处理，也可以转发（可能经过转换）到其他服务器。代理必须实现本规范中的客户端和服务器要求。透明代理是不修改请求或响应内容（除必要的代理认证和识别之外）的代理。非透明代理则会修改请求或响应，以提供额外服务，如分组注释、媒体类型转换、协议简化或匿名过滤。除非明确说明为透明或非透明，否则HTTP代理的要求适用于两者。

网关
      作为其他服务器的中介的服务器。不同于代理，网关接收请求时，表现得像是请求资源的源服务器；请求的客户端可能不知道它在与网关通信。

隧道
      作为两个连接之间的盲中继的中介程序。一旦激活，隧道不再被视为HTTP通信的参与方，尽管它可能由HTTP请求启动。两个端点关闭后，隧道即不存在。

缓存
      程序的本地存储，用于存放响应消息及控制其存储、检索和删除的子系统。缓存存储可缓存的响应，以减少未来相同请求的响应时间和网络带宽消耗。任何客户端或服务器都可以包含缓存，但作为隧道的服务器不能使用缓存。

可缓存
      如果允许缓存存储响应的副本以用于后续请求，则该响应是可缓存的。HTTP响应的可缓存性规则在第13节中定义。即使资源是可缓存的，可能仍有额外限制，影响缓存是否可以使用缓存的副本来应答特定请求。

第一手
      直接且没有不必要延迟地从源服务器获得的响应，可能经过一个或多个代理。若响应的有效性刚刚通过与源服务器的直接验证确认，也视为第一手。

明确的过期时间
      源服务器打算在此时间点之后，缓存不应在未经验证的情况下返回该实体。

启发式过期时间
      缓存在没有明确过期时间时，分配的过期时间。

年龄
      响应的年龄是自其由源服务器发出或成功验证以来的时间。

新鲜期
      从响应生成到其过期时间之间的时间长度。

新鲜
      如果响应的年龄尚未超过其新鲜期，则视为新鲜。

过期
      如果响应的年龄已超过其新鲜期，则视为过期。

语义透明
      当缓存对特定响应的使用不会影响请求客户端或源服务器（除提升性能外）时，称其为“语义透明”。当缓存语义透明时，客户端收到的响应与直接由源服务器处理请求时收到的完全相同（跳跃头除外）。

验证器
      用于判断缓存条目是否为实体的等价副本的协议元素（如实体标签或最后修改时间）。

上游/下游
      描述消息流动的方向：所有消息都从上游流向下游。

入站/出站
      指请求和响应的路径：“入站”指向源服务器方向，“出站”指向用户代理方向。

1.4 整体操作

   HTTP协议是一个请求/响应协议。客户端以请求方法、URI和协议版本的形式，向服务器发送请求，随后通过连接传输包含请求修饰符、客户端信息和可能的实体内容的类似MIME的消息。服务器以状态行（包括协议版本和成功或错误代码）响应，后跟包含服务器信息、实体元信息和可能的实体主体内容的MIME样式消息。HTTP与MIME的关系详见附录19.4。

   大部分HTTP通信由用户代理发起，内容是对某个源服务器上资源的请求。最简单的情况是通过单一连接（v）实现的：

          请求链 ------------------------>
       UA -------------------v------------------- O
          <----------------------- 响应链

   当请求/响应链中存在一个或多个中介时，情况会更复杂。常见的中介类型有：代理、网关和隧道。代理是转发代理，接收对URI的请求（绝对路径形式），重写部分或全部消息，然后转发到URI指定的服务器。网关是接收代理，作为某些其他服务器之上的一层，必要时将请求转换为底层服务器的协议。隧道作为两个连接之间的中继点，不改变消息内容；当通信需要通过中介（如防火墙）时使用，即使中介无法理解消息内容。

          请求链 -------------------------------------->
       UA -----v----- A -----v----- B -----v----- C -----v----- O
          <------------------------------------- 响应链

   上图显示了用户代理与源服务器之间的三个中介（A、B、C）。一条请求或响应消息经过整个链条时，会经过四个不同的连接。这一区别很重要，因为某些HTTP通信选项可能只适用于与最近的非隧道邻居的连接、链的端点，或链上的所有连接。虽然图示为线性，但每个参与者可能同时进行多重通信。例如，B可能同时接收来自多个客户端的请求，或将请求转发到其他服务器，而不仅仅是C，同时处理A的请求。

   任何非隧道的通信参与方都可以使用内部缓存来处理请求。缓存的作用是，如果链中的某个参与者有适用的缓存响应，则缩短请求/响应链。如下示意：如果B有来自O（通过C）的早期响应的缓存副本，而该请求未被UA或A缓存，则链会变成：

          请求链 ---------->
       UA -----v----- A -----v----- B - - - - - - C - - - - - - O
          <--------- 响应链

   并非所有响应都可以有效缓存，某些请求可能包含特殊修饰符，要求缓存表现符合特定规则。HTTP关于缓存行为和可缓存响应的要求在第13节中定义。

   目前，全球范围内正在试验或部署各种不同的缓存和代理架构。这些系统包括：用于节省跨洋带宽的国家级代理缓存层、广播或多播缓存条目的系统、通过CD-ROM分发缓存子集的组织等。HTTP系统也在企业内网中通过高速链路使用，或在低功耗无线链路和间歇连接的PDA上访问。HTTP/1.1的目标是支持已部署的多样化配置，同时引入满足高可靠性需求的协议结构，或者在无法保证时，至少提供可靠的故障指示。

   HTTP通信通常通过TCP/IP连接进行，默认端口为TCP 80 [19]，但也可以使用其他端口。这不排除在互联网或其他网络上基于任何其他协议实现HTTP。HTTP只假设传输可靠；任何提供此保证的协议都可以使用；将HTTP/1.1的请求和响应结构映射到所用协议的传输数据单元，超出本规范范围。

   在HTTP/1.0中，大多数实现为每个请求/响应交换建立新连接。而在HTTP/1.1中，连接可以用于多个请求/响应交换，尽管连接可能因各种原因关闭（见第8.1节）。

2 记法约定与通用语法

2.1 扩展BNF
   本文档中所有机制均以文字描述和类似RFC 822 [9]所用的扩展BNF（Backus-Naur Form）描述。实现者需熟悉此符号以理解规范。扩展BNF包括以下构造：

   name = 定义
      规则的名称即为其本身（不带尖括号），用“=”分隔定义。空白字符仅在续行缩进时有意义，用以表示规则跨多行。某些基本规则用大写字母表示，如SP（空格）、LWS（空白符）、HT（水平制表符）、CRLF（回车换行）、DIGIT（数字）、ALPHA（字母）等。定义中若出现尖括号，便于识别规则名。

   "字面值"
      用引号括起的文本。除非另有说明，否则文本不区分大小写。

   rule1 | rule2
      用“|”分隔的元素为备选项，例如“yes | no”表示接受yes或no。

   (rule1 rule2)
      括号内的元素视为单一元素。例如“(elem (foo | bar) elem)”允许“elem foo elem”和“elem bar elem”两种序列。

   *rule
      前置的“*”表示重复。完整形式为“<n>*<m>元素”，表示元素至少出现<n>次，最多<m>次。默认值为0和无限，因此“*(元素)”允许任何次数（包括零），“1*元素”至少一次，“1*2元素”允许一次或两次。

[规则]
方括号内的元素为可选项；"[foo bar]"等价于"*1(foo bar)"。

Fielding 等人  标准轨迹  [第14页]

RFC 2616  HTTP/1.1  1999年6月

N规则
特定重复："<n>(元素)"等价于"<n>*<n>(元素)"；即，恰好有<n>个(元素)。例如，2DIGIT表示一个两位数字，3ALPHA表示由三个字母字符组成的字符串。

#规则
定义了一个类似于"*"的构造符"#"，用于定义元素列表。完整形式为"<n>#<m>元素"，表示至少<n>个，最多<m>个元素，每个元素之间用一个或多个逗号（","）和可选的线性空白（LWS）分隔。这使得列表的常用形式非常简便；比如
   ( *LWS 元素 *( *LWS "," *LWS 元素))
可以写成
   1#元素
在使用此构造时，允许空元素，但空元素不计入元素总数。也就是说，"(元素)， ，(元素)"是允许的，但只算两个元素。因此，当至少需要一个元素时，必须至少有一个非空元素。默认值为0和无穷大，因此"#元素"允许任何数量，包括零；"1#元素"至少需要一个；"1#2元素"允许一个或两个。

; 注释
分号（";"）在规则文本右侧一定距离处开始，直到行尾的内容为注释。这是一种在规范中并行包含有用说明的简便方式。

隐含的*LWS
本规范描述的语法是基于词的。除非另有说明，线性空白（LWS）可以在任何两个相邻的词（标记或引号字符串）之间，以及在相邻词和分隔符之间插入，而不会改变字段的解释。两个标记之间必须至少有一个分隔符（LWS和/或分隔符），否则会被解释为单一的标记。

2.2 基本规则
以下规则在整个规范中用于描述基本的解析结构。US-ASCII字符集由ANSI X3.4-1986 [21]定义。

OCTET          = <任何8位数据序列>
CHAR           = <任何US-ASCII字符（字节0-127）>
UPALPHA        = <任何US-ASCII大写字母 "A".."Z">
LOALPHA        = <任何US-ASCII小写字母 "a".."z">
ALPHA          = UPALPHA | LOALPHA
DIGIT          = <任何US-ASCII数字 "0".."9">
CTL            = <任何US-ASCII控制字符（字节0-31）和DEL（127）>
CR             = <US-ASCII回车符，13>
LF             = <US-ASCII换行符，10>
SP             = <US-ASCII空格，32>
HT             = <US-ASCII水平制表符，9>
<">            = <US-ASCII双引号（34）>

HTTP/1.1定义了CR LF序列作为所有协议元素（除实体主体外）的行结束标志（详见附录19.3的容错应用）。实体主体内的行结束由其相关媒体类型定义，如第3.7节所述。

CRLF           = CR LF

HTTP/1.1的头字段值可以折叠成多行，续行必须以空格或水平制表符开始。所有线性空白，包括折叠，具有与SP相同的语义。接收方可以在解析字段值或转发消息前，将任何线性空白替换为单一空格。

LWS            = [CRLF] 1*( SP | HT )

TEXT规则仅用于描述性字段内容和值，不打算由消息解析器解释。*TEXT中的字符集可以超出ISO-8859-1 [22]，但必须按照RFC 2047 [14]的规则编码。

TEXT           = <任何除了CTL之外的OCTET，但包括LWS>

TEXT定义中的CRLF仅在头字段续行中允许。预期折叠的LWS会在解析TEXT值前被替换为单一空格。

十六进制数字字符在多个协议元素中使用。

HEX            = "A" | "B" | "C" | "D" | "E" | "F"
               | "a" | "b" | "c" | "d" | "e" | "f" | DIGIT

许多HTTP/1.1头字段值由由LWS或特殊字符分隔的词组成。这些特殊字符必须用引号字符串括起来，才能在参数值中使用（见第3.6节）。

token          = 1*<任何非CTL或分隔符的CHAR>
separators     = "(" | ")" | "<" | ">" | "@"
               | "," | ";" | ":" | "\" | <">
               | "/" | "[" | "]" | "?" | "="
               | "{" | "}" | SP | HT

某些HTTP头字段允许在字段值中用括号括起注释文本。注释仅在字段值定义中包含"comment"时允许。在其他字段中，括号视为字段值的一部分。

comment        = "(" *( ctext | quoted-pair | comment ) ")"
ctext          = <任何TEXT，排除"("和")">

用双引号括起的文本字符串会被解析为单个词。

quoted-string  = ( <"> *(qdtext | quoted-pair ) <"> )
qdtext         = <任何TEXT，排除<">>

反斜杠字符（"\"）仅在引号字符串和注释结构中作为单字符转义机制使用。

quoted-pair    = "\" CHAR

3 协议参数

3.1 HTTP版本
HTTP使用"<major>.<minor>"的编号方案表示协议版本。协议版本策略旨在让发送方指示消息的格式及其理解后续HTTP通信的能力，而非通信中实现的功能。对不影响通信行为或仅增加可扩展字段值的消息组件的添加，不会更改版本号。当协议的更改引入新功能而不改变一般消息解析算法时，<minor>号递增；当消息格式发生变化时，<major>号递增。详见RFC 2145 [36]。

HTTP消息的版本由首行中的HTTP-Version字段指示。

HTTP-Version   = "HTTP" "/" 1*DIGIT "." 1*DIGIT

注意，主版本号和次版本号必须作为独立的整数处理，且每个可能超过一位数字。因此，HTTP/2.4低于HTTP/2.13，后者又低于HTTP/12.3。接收方必须忽略前导零，且不得发送。

发出请求或响应消息且包含HTTP-Version为"HTTP/1.1"的应用，必须至少符合本规范的条件。符合本规范的应用应在其消息中使用HTTP-Version为"HTTP/1.1"，且对于任何不兼容HTTP/1.0的消息，必须如此。关于何时发送特定HTTP-Version的详细信息，请参见RFC 2145 [36]。

应用的HTTP版本是其至少条件符合的最高HTTP版本。

代理和网关应用在转发不同协议版本的消息时需谨慎。由于协议版本指示发送方的协议能力，代理/网关不得发送版本号大于其实际版本的消息。如果收到更高版本的请求，代理/网关必须降级请求版本、响应错误或切换到隧道行为。

鉴于自RFC 2068 [33]发布以来发现的与HTTP/1.0代理的互操作性问题，缓存代理必须，网关可以，隧道不得将请求升级到它们支持的最高版本。代理/网关对该请求的响应必须与请求的主版本相同。

注意：在不同HTTP版本之间转换可能涉及修改所需或禁止的头字段。

3.2 统一资源标识符（URI）
URI曾被称为：WWW地址、通用文档标识符、通用资源标识符 [3]，以及统一资源定位符（URL） [4]和名称（URN） [20]的组合。就HTTP而言，统一资源标识符仅是格式化的字符串，用于通过名称、位置或其他特征标识资源。

3.2.1 一般语法
HTTP中的URI可以是绝对形式，也可以相对于已知的基础URI [11]。两者的区别在于，绝对URI总是以方案名开始，后跟冒号。关于URL语法和语义的详细信息，请参见"统一资源标识符（URI）：通用语法和语义"，RFC 2396 [42]（取代RFC 1738 [4]和RFC 1808 [11]）。本规范采用该文档中的"URI引用"、"绝对URI"、"相对URI"、"端口"、"主机"、"绝对路径"、"相对路径"和"权限"的定义。

HTTP协议对URI的长度没有预设限制。服务器必须能处理其所提供资源的任何URI，并应能处理无限长度的URI（如果提供基于GET的表单以生成此类URI）。如果URI超出服务器处理能力，应返回414（请求URI过长）状态码（详见第10.4.15节）。

注意：服务器应谨慎依赖超过255字节的URI长度，因为一些旧的客户端或代理实现可能不支持。

3.2.2 http URL
"http"方案用于通过HTTP协议定位网络资源。本节定义http URL的方案特定语法和语义。

http_URL = "http:" "//" host [ ":" port ] [ abs_path [ "?" query ]]

如果端口为空或未给出，则假定为端口80。其语义是，所标识的资源位于监听该主机该端口TCP连接的服务器上，资源的Request-URI为abs_path（详见第5.1.2节）。应尽量避免在URL中使用IP地址（详见RFC 1900 [24]）。如果abs_path未在URL中出现，作为资源的Request-URI时必须写为"/"（第5.1.2节）。如果代理收到的主机名不是完全限定域名（FQDN），可以添加其域名；如果是FQDN，则不得更改。

3.2.3 URI比较
比较两个URI是否匹配时，应对整个URI进行区分大小写的字节逐字节比较，除非满足以下例外：

- 空或未给出的端口等同于该URI引用的默认端口；
- 主机名的比较必须不区分大小写；
- 方案名的比较必须不区分大小写；
- 空的abs_path等同于"/"。

除"保留"和"不安全"字符集（详见RFC 2396 [42]）外的字符，等同于其"%HEXHEX"编码。

例如，以下三个URI是等价的：

http://abc.com:80/~smith/home.html
http://ABC.com/%7Esmith/home.html
http://ABC.com:/%7esmith/home.html

3.3 日期/时间格式
3.3.1 完整日期
HTTP应用程序历来支持三种不同的日期/时间戳表示格式：

Sun, 06 Nov 1994 08:49:37 GMT  ; RFC 822，RFC 1123更新
Sunday, 06-Nov-94 08:49:37 GMT ; RFC 850，RFC 1036废止
Sun Nov  6 08:49:37 1994       ; ANSI C的asctime()格式

以下是该英文内容的中文翻译：

```
第一种格式被首选为互联网标准，代表由RFC 1123 [8]（对RFC 822 [9]的更新）定义的固定长度子集。第二种格式在实际中较为常用，但基于已废弃的RFC 850 [12]日期格式，且缺少四位数的年份。解析HTTP/1.1客户端和服务器的日期值时，必须接受这三种格式（以兼容HTTP/1.0），但它们只能在头字段中生成RFC 1123格式的HTTP日期值。有关更多信息，请参见19.3节。

注意：鼓励接收方在接受日期值时具有一定的鲁棒性，以应对非HTTP应用程序可能发送的日期值，例如通过代理/网关检索或发布消息到SMTP或NNTP时的情况。

Fielding 等人            标准轨迹                    [第20页]

RFC 2616                        HTTP/1.1                       1999年6月

所有HTTP日期/时间戳必须以格林威治标准时间（GMT）表示，且无例外。就HTTP而言，GMT与协调世界时（UTC）完全相等。在前两种格式中，通过包含“GMT”作为时区的三字母缩写来表示这一点，读取asctime格式时也必须假定为GMT。HTTP日期是区分大小写的，且不得包含除语法中明确包含的空白字符（SP）之外的额外空白。

HTTP日期格式定义如下：
```
HTTP-date    = rfc1123-date | rfc850-date | asctime-date
rfc1123-date = wkday "," SP date1 SP time SP "GMT"
rfc850-date  = weekday "," SP date2 SP time SP "GMT"
asctime-date = wkday SP date3 SP time SP 4DIGIT
date1        = 2DIGIT SP month SP 4DIGIT
               ; 例如：02 Jun 1982
date2        = 2DIGIT "-" month "-" 2DIGIT
               ; 例如：02-Jun-82
date3        = month SP ( 2DIGIT | ( SP 1DIGIT ))
               ; 例如：Jun  2
time         = 2DIGIT ":" 2DIGIT ":" 2DIGIT
               ; 00:00:00 - 23:59:59
wkday        = "Mon" | "Tue" | "Wed" | "Thu" | "Fri" | "Sat" | "Sun"
weekday      = "Monday" | "Tuesday" | "Wednesday" | "Thursday" | "Friday" | "Saturday" | "Sunday"
month        = "Jan" | "Feb" | "Mar" | "Apr" | "May" | "Jun" | "Jul" | "Aug" | "Sep" | "Oct" | "Nov" | "Dec"
```

注意：HTTP对日期/时间戳格式的要求仅适用于协议流中的使用。客户端和服务器不必在用户界面、请求日志等方面使用这些格式。

3.3.2 增量秒数

一些HTTP头字段允许用十进制整数秒数表示时间值，表示消息接收时间之后的秒数。

```
delta-seconds  = 1*DIGIT
```

3.4 字符集

HTTP使用的“字符集”定义与MIME中描述的相同：

“字符集”一词在本文中用来指一种通过一个或多个表将一系列八位字节转换为字符序列的方法。注意，不要求进行无条件的反向转换，因为并非所有字符都在某个字符集中可用，一个字符集可能为某个字符提供多种八位字节序列。这一定义旨在允许各种字符编码方式，从简单的单表映射（如US-ASCII）到复杂的表切换技术（如ISO-2022的方法）。但与MIME字符集名称相关的定义必须完整指定从八位字节到字符的映射，特别是不允许使用外部配置文件信息来确定具体映射。

注意：此处“字符集”一词更常被称为“字符编码”。但由于HTTP和MIME共享同一注册表，保持术语一致非常重要。

HTTP字符集由不区分大小写的标记（token）标识。完整的标记集由IANA字符集注册表 [19] 定义。

```
charset = token
```

虽然HTTP允许使用任意标记作为字符集值，但任何在IANA字符集注册表中预定义的标记，必须代表该注册表定义的字符集。应用程序应限制字符集的使用，仅使用IANA注册表中定义的字符集。

实现者应注意IETF关于字符集的要求 [38][41]。

3.4.1 缺失字符集

一些HTTP/1.0软件错误地将没有charset参数的Content-Type头解释为“接收方应猜测”。希望避免此行为的发送方可以即使在字符集为ISO-8859-1时也包含charset参数，且在已知不会引起接收方困惑时应如此做。

不幸的是，一些较旧的HTTP/1.0客户端未能正确处理显式的charset参数。HTTP/1.1的接收方必须尊重由发送方提供的字符集标签；而那些具有“猜测”字符集功能的用户代理，在首次显示文档时，必须使用内容类型字段中的字符集，而非用户偏好。详见3.7.1节。

3.5 内容编码

内容编码值表示已应用或可以应用于实体的编码转换。内容编码主要用于允许文档被压缩或以其他有用的方式转换，而不丢失其底层媒体类型的身份和信息。通常，实体以编码形式存储、直接传输，只有在接收端解码。

```
content-coding = token
```

所有内容编码值不区分大小写。HTTP/1.1在Accept-Encoding（第14.3节）和Content-Encoding（第14.11节）头字段中使用内容编码值。虽然值描述了内容编码，但更重要的是它指示需要什么解码机制来去除编码。

互联网号码管理局（IANA）作为内容编码值的注册机构。最初，注册表包含以下标记：

- gzip：由文件压缩程序“gzip”（GNU zip）产生的编码格式，如RFC 1952 [25]所述。此格式为带有32位CRC的Lempel-Ziv编码（LZ77）。
- compress：由常用的UNIX文件压缩程序“compress”产生的编码格式。此格式为自适应的Lempel-Ziv-Welch编码（LZW）。
  不建议使用程序名作为编码格式的标识，未来编码也应避免如此。这里的用法代表历史实践，而非良好设计。为了与以前的HTTP实现兼容，应用应将“x-gzip”和“x-compress”视为等同于“gzip”和“compress”。

- deflate：由RFC 1950 [31]定义的“zlib”格式（结合RFC 1951 [29]描述的“deflate”压缩机制）。

- identity：默认（原样）编码；不进行任何转换。此内容编码仅在Accept-Encoding头中使用，不应在Content-Encoding头中使用。

应注册新的内容编码值，以实现客户端和服务器之间的互操作性。实现新值的内容编码算法的规范应公开且足够独立实现，且符合本节定义的内容编码目的。

3.6 传输编码

传输编码值用于指示已应用、可以应用或可能需要应用于实体主体的编码转换，以确保“安全传输”通过网络。这与内容编码不同，传输编码是消息的属性，而非原始实体的属性。

```
transfer-coding = "chunked" | transfer-extension
transfer-extension = token *( ";" parameter )
```

参数以属性/值对的形式出现。

```
parameter = attribute "=" value
attribute = token
value = token | quoted-string
```

所有传输编码值不区分大小写。HTTP/1.1在TE头字段（第14.39节）和Transfer-Encoding头字段（第14.41节）中使用传输编码值。

当对消息体应用传输编码时，除非通过关闭连接终止消息，否则必须包含“chunked”。使用“chunked”传输编码时，它必须是应用到消息体的最后一个传输编码。一个消息体不能多次应用“chunked”编码。这些规则允许接收方确定消息的传输长度（第4.4节）。

传输编码类似于MIME的Content-Transfer-Encoding值 [7]，旨在实现二进制数据在7位传输服务中的安全传输。然而，对于8位清洁的传输协议，安全传输的关注点不同。在HTTP中，消息体唯一的不安全特性是难以精确确定其长度（第7.2.2节），或希望对数据进行加密以通过共享传输。

互联网号码管理局（IANA）作为传输编码值的注册机构。最初，注册表包含以下标记：“chunked”（第3.6.1节）、“identity”（第3.6.2节）、“gzip”（第3.5节）、“compress”（第3.5节）和“deflate”（第3.5节）。

应以与内容编码相同的方式注册新的传输编码值。

接收带有未知传输编码的实体主体的服务器应返回501（未实现）状态码，并关闭连接。服务器不得向HTTP/1.0客户端发送传输编码。

3.6.1 分块传输编码

分块编码将消息体修改为一系列块，每个块有自己的大小指示符，后跟一个可选的包含实体头字段的尾部（trailer）。这允许动态生成的内容与验证完整消息所需的信息一同传输。

```
Chunked-Body = *chunk
               last-chunk
               trailer
               CRLF

chunk = chunk-size [ chunk-extension ] CRLF
chunk-size = 1*HEX
last-chunk = 1*("0") [ chunk-extension ] CRLF
chunk-extension= *( ";" chunk-ext-name [ "=" chunk-ext-val ] )
chunk-ext-name = token
chunk-ext-val  = token | quoted-string
chunk-data     = chunk-size (OCTET)
trailer        = *(entity-header CRLF)
```

chunk-size字段是表示块大小的十六进制字符串。以大小为零的块结束编码，后跟尾部（trailer），尾部以空行终止。

尾部允许发送方在消息末尾包含额外的HTTP头字段。Trailer头字段可用来指示尾部中包含的头字段（见第14.40节）。

使用分块传输编码的响应服务器不得在没有满足以下条件之一的情况下使用尾部：

a) 请求中包含TE头字段，指示“trailers”在响应的传输编码中是可接受的（见第14.39节）；
b) 服务器是响应的源服务器，尾部字段完全由可选元数据组成，且接收方可以在不接收这些元数据的情况下使用消息（以源服务器可接受的方式）。换句话说，源服务器愿意接受尾部字段可能在传输路径中被静默丢弃的可能性。

此要求避免在消息由HTTP/1.1（或更高版本）代理接收并转发到HTTP/1.0接收方时出现互操作性问题。它避免了协议要求可能导致代理端无限缓冲的问题。

关于解码分块消息体的示例流程，详见附录19.4.6。

所有HTTP/1.1应用必须能够接收和解码“chunked”传输编码，并应忽略它们不理解的块扩展。

3.7 媒体类型

HTTP在Content-Type（第14.17节）和Accept（第14.1节）头字段中使用互联网媒体类型 [17]，以提供开放且可扩展的数据类型和类型协商。

```
media-type = type "/" subtype *( ";" parameter )
type = token
subtype = token
```

参数可以跟在类型/子类型之后，以属性/值对的形式（详见第3.6节）。
```

类型、子类型和参数属性名称对大小写不敏感。参数值可能区分大小写，也可能不区分，具体取决于参数名称的语义。类型和子类型之间，以及属性与其值之间，必须不得使用线性空白（LWS）。参数的存在与否可能对媒体类型的处理具有重要意义，这取决于其在媒体类型注册表中的定义。

请注意，一些较旧的HTTP应用程序可能不识别媒体类型参数。在向较旧的HTTP应用程序发送数据时，实施者应仅在参数定义要求时才使用媒体类型参数。

媒体类型的值由互联网号码管理局（IANA）注册。媒体类型的注册流程详见RFC 1590。建议不要使用未注册的媒体类型。

3.7.1 规范化与文本默认值

互联网媒体类型以规范形式注册。通过HTTP传输的实体主体必须在传输前以相应的规范形式表示，"文本"类型除外，如下一段所定义。

在规范形式下，"文本"类型的子类型使用CRLF作为文本行的换行符。HTTP放宽了这一要求，允许在整个实体主体中一致地使用纯CR或LF作为换行符进行文本媒体的传输。HTTP应用程序必须接受CRLF、裸CR和裸LF作为HTTP传输的文本媒体中的换行符。此外，如果文本采用不使用13和10字节（即CR和LF）作为换行符的字符集（如某些多字节字符集），HTTP允许使用该字符集定义的任何字节序列来表示换行符的等价物。这种关于换行符的灵活性仅适用于实体主体中的文本媒体；在任何HTTP控制结构（如头字段和多部分边界）中，绝不能用裸CR或LF替代CRLF。

如果实体主体经过内容编码，编码前的底层数据必须符合上述规范。

"charset"参数用于某些媒体类型，定义数据的字符集（详见第3.4节）。当发送方未明确提供charset参数时，"文本"类型的子类型在HTTP中默认字符集为"ISO-8859-1"。使用其他字符集的数据必须标明相应的字符集。详见第3.4.1节，了解兼容性问题。

3.7.2 多部分类型

MIME定义了多种"多部分"类型——将一个或多个实体封装在单一消息体内。所有多部分类型共享RFC 2046第5.1.1节定义的通用语法，且必须包含边界参数作为媒体类型值的一部分。消息体本身是协议元素，因此只能使用CRLF表示各部分之间的换行。不同于RFC 2046，任何多部分消息的后记（epilogue）必须为空；HTTP应用程序不得传输后记（即使原始多部分消息包含后记）。这些限制旨在保持多部分消息体的自我界定特性，即通过结束的多部分边界指示消息体的结束。

通常，HTTP将多部分消息体视为普通的载荷类型。唯一的例外是"multipart/byteranges"类型（见附录19.2），在206（部分内容）响应中出现时，某些HTTP缓存机制会据此处理（详见第13.5.4和14.16节）。在其他情况下，HTTP用户代理应遵循类似MIME用户代理的行为。多部分消息体中每个部分的MIME头字段对HTTP而言，仅具有其MIME语义所定义的意义。

一般而言，HTTP用户代理应模仿MIME用户代理在接收多部分类型时的行为。如果应用程序收到未识别的多部分子类型，必须将其视为等同于"multipart/mixed"。

注意："multipart/form-data"类型已被专门定义，用于携带适合通过POST请求处理的表单数据（详见RFC 1867 [15]）。

3.8 产品标记

产品标记用于让通信应用识别自身的软件名称和版本。大多数使用产品标记的字段也允许列出构成应用重要部分的子产品，子产品之间用空白字符分隔。通常，产品按其识别应用的重要性顺序列出。

产品格式：
```
product = token ["/" product-version]
product-version = token
```

示例：

```
User-Agent: CERN-LineMode/2.15 libwww/2.17b3
Server: Apache/0.8.4
```

产品标记应简洁明了，不得用于广告或其他非必要信息。虽然版本号部分可以包含任何字符，但应仅用于版本标识（即，同一产品的不同版本应仅在product-version部分不同）。

3.9 质量值

HTTP内容协商（第12节）使用短的"浮点"数字表示各种协商参数的相对重要性（"权重"）。权重归一化为0到1之间的实数，0表示最低，1表示最高。如果参数的质量值为0，则客户端不接受带有该参数的内容。HTTP/1.1应用程序不得在数字后面生成超过三位的小数。用户配置这些值时也应遵循此限制。

qvalue = ("0" ["." 0*3DIGIT]) | ("1" ["." 0*3("0")])

"质量值"这一术语不准确，因为这些值仅表示期望质量的相对下降。

3.10 语言标签

语言标签用于标识人类用以交流信息的自然语言（书写或口头），不包括计算机语言。HTTP在Accept-Language和Content-Language字段中使用语言标签。

HTTP语言标签的语法和注册表与RFC 1766 [1]相同。简而言之，语言标签由一个或多个部分组成：主语言标签和可能为空的子标签序列：

```
language-tag = primary-tag *( "-" subtag )
primary-tag  = 1*8ALPHA
subtag       = 1*8ALPHA
```

标签中不允许空白字符，所有标签对大小写不敏感。语言标签的命名空间由IANA管理。示例标签包括：

en、en-US、en-cockney、i-cherokee、x-pig-latin

其中，任何两个字母的主标签是ISO-639语言代码，任何两个字母的初始子标签是ISO-3166国家代码（上述最后三个标签未注册，除最后一个外，都是未来可能注册的示例标签）。

3.11 实体标签

实体标签用于比较来自同一请求资源的两个或多个实体。HTTP/1.1在ETag（第14.19节）、If-Match（第14.24节）、If-None-Match（第14.26节）和If-Range（第14.27节）头字段中使用实体标签。它们的用法和比较方式（作为缓存验证器）详见第13.3.3节。实体标签由一个不透明的引号字符串组成，可能带有弱标志。

实体标签格式：
```
entity-tag = [ weak ] opaque-tag
weak = "W/"
opaque-tag = quoted-string
```

“强实体标签”只有在两个实体字节完全相等时才可以共享。带有"W/"前缀的“弱实体标签”只有在两个实体相等且可以互相替代且不影响语义的情况下才可以共享。弱实体标签仅用于弱比较。

实体标签必须在与特定资源相关的所有版本中唯一。一个实体标签值可以用于不同URI请求获得的实体，但在不同URI请求中使用相同实体标签值，并不意味着这些实体相等。

3.12 范围单位

HTTP/1.1允许客户端请求响应实体的部分内容（范围）。它在Range（第14.35节）和Content-Range（第14.16节）头字段中使用范围单位。实体可以根据不同结构单元划分为子范围。

范围单位：
```
range-unit = bytes-unit | other-range-unit
bytes-unit = "bytes"
other-range-unit = token
```

HTTP/1.1唯一定义的范围单位是"bytes"。实现可以忽略使用其他单位指定的范围。

HTTP/1.1设计允许不依赖范围知识的应用实现。

多个具有相同字段名的消息头字段可以在一条消息中同时存在，但前提是该字段的全部字段值被定义为用逗号分隔的列表（即#(值)）。必须能够将多个头字段合并成一个“字段名：字段值”的对，而不改变消息的语义，方法是将每个后续的字段值附加到第一个字段值后面，用逗号隔开。因此，具有相同字段名的头字段的接收顺序对合并后字段值的解释具有重要意义，代理在转发消息时不得更改这些字段值的顺序。

4.3 消息体

HTTP消息的消息体（如果有的话）用于携带与请求或响应相关联的实体主体。消息体与实体主体的区别仅在于是否应用了传输编码（Transfer-Encoding），后者由Transfer-Encoding头字段指示（第14.41节）。

       message-body = entity-body
                    | <entity-body encoded as per Transfer-Encoding>

必须使用Transfer-Encoding来指示应用在消息上的任何传输编码，以确保消息的安全和正确传输。Transfer-Encoding是消息的属性，而不是实体的属性，因此可以由请求/响应链中的任何应用程序添加或删除（但第3.6节对某些传输编码的使用有限制）。

请求和响应中允许消息体的规则不同。

请求中是否包含消息体由请求头中的Content-Length或Transfer-Encoding字段的存在与否来信号。如果请求方法的规范（第5.1.1节）不允许在请求中发送实体主体，则不得包含消息体。服务器应在任何请求中读取并转发消息体；如果请求方法没有定义实体主体的语义，则在处理请求时应忽略消息体。

对于响应消息，是否包含消息体取决于请求方法和响应状态码（第6.1.1节）。所有对HEAD请求的响应都不得包含消息体，即使实体头字段可能让人误以为有。所有1xx（信息性）、204（无内容）和304（未修改）响应都不得包含消息体。其他响应都应包含消息体，尽管其长度可以为零。

4.4 消息长度

消息的传输长度是指消息体的长度，即在应用任何传输编码后消息中实体主体的长度。当消息中包含消息体时，其传输长度由以下优先顺序确定：

1. 任何“不得”包含消息体的响应（如1xx、204、304响应及HEAD请求的响应）都在头字段后第一个空行处终止，无论消息中是否存在实体头字段。

2. 如果存在Transfer-Encoding头字段且其值不是“identity”，则传输长度由“chunked”传输编码（第3.6节）定义，除非通过关闭连接来终止消息。

3. 如果存在Content-Length头字段，其十进制值（以字节为单位）表示实体长度和传输长度。如果存在Transfer-Encoding头字段，则Content-Length必须不被使用（即忽略）。

4. 如果使用“multipart/byteranges”媒体类型，且未另行指定传输长度，则该自我限制的媒体类型定义传输长度。除非发送方确认接收方能解析multipart/byteranges响应，否则不得使用此媒体类型。请求中带有多个字节范围的Range头字段也暗示接收方能解析此响应。

   代理在转发不理解multipart/byteranges的请求时，可能会转发请求而不处理范围，必须用第1、3或5项中定义的方法来界定消息。

5. 通过服务器关闭连接来终止消息（关闭连接不能用来表示请求体的结束，因为这样服务器就无法返回响应）。

为了兼容HTTP/1.0应用，包含消息体的HTTP/1.1请求必须包含有效的Content-Length头字段，除非服务器已知支持HTTP/1.1。如果请求中有消息体但未提供Content-Length，服务器应返回400（错误请求）以表示无法确定消息长度，或返回411（长度必需）以坚持接收有效的Content-Length。

所有接收实体的HTTP/1.1应用必须接受“chunked”传输编码（第3.6节），以便在无法提前确定消息长度时使用此机制。

消息不得同时包含Content-Length头字段和非“identity”的传输编码。如果消息中包含非“identity”的传输编码，则Content-Length必须被忽略。

在允许消息体的消息中，如果提供了Content-Length，其值必须与消息体中的字节数完全一致。HTTP/1.1用户代理在接收到无效长度时应通知用户。

4.5 一般头字段

有一些头字段对请求和响应都具有一般适用性，但不适用于被传输的实体。这些头字段仅适用于传输中的消息。

       general-header = Cache-Control            ; 第14.9节
                      | Connection               ; 第14.10节
                      | Date                     ; 第14.18节
                      | Pragma                   ; 第14.32节
                      | Trailer                  ; 第14.40节
                      | Transfer-Encoding        ; 第14.41节
                      | Upgrade                  ; 第14.42节
                      | Via                      ; 第14.45节
                      | Warning                  ; 第14.46节

一般头字段名只能在协议版本变更时可靠地扩展。然而，如果通信双方都将某些新或试验性头字段视为一般头字段，则可以赋予其相应的语义。未识别的头字段将被视为实体头字段。

5 请求

客户端向服务器发出的请求消息在第一行中包括要对资源执行的方法、资源标识符和所用协议版本。

        Request       = Request-Line              ; 第5.1节
                        *(( general-header        ; 第14.5节
                         | request-header         ; 第5.3节
                         | entity-header ) CRLF)  ; 第7.1节
                        CRLF
                        [ message-body ]          ; 第4.3节

5.1 请求行

请求行以方法标记开始，后跟请求URI和协议版本，以CRLF结束。各元素之间用空格（SP）字符分隔。除了最后的CRLF序列外，不允许出现CR或LF。

        Request-Line   = Method SP Request-URI SP HTTP-Version CRLF

5.1.1 方法

Method标记指示对请求URI所标识资源执行的方法。方法名区分大小写。

       Method         = "OPTIONS"                ; 第9.2节
                      | "GET"                    ; 第9.3节
                      | "HEAD"                   ; 第9.4节
                      | "POST"                   ; 第9.5节
                      | "PUT"                    ; 第9.6节
                      | "DELETE"                 ; 第9.7节
                      | "TRACE"                  ; 第9.8节
                      | "CONNECT"                ; 第9.9节
                      | extension-method
       extension-method = token

资源允许的方法列表可在Allow头字段（第14.7节）中指定。响应的返回码会通知客户端某个方法是否当前被允许，因为允许的方法集可能会动态变化。若资源已知但不允许某个方法，原始服务器应返回405（方法不允许）；若方法未被识别或未实现，应返回501（未实现）。所有通用服务器必须支持GET和HEAD方法。其他方法为可选，但如果实现了上述方法，必须遵循第9节中的语义。

5.1.2 请求URI

请求URI是一个统一资源标识符（第3.2节），用于标识要操作的资源。

       Request-URI    = "*" | absoluteURI | abs_path | authority

请求URI的四种形式依赖于请求的性质。星号“*”表示请求不针对特定资源，而是针对服务器本身，仅在所用方法不一定适用于某个资源时允许。例如：

       OPTIONS * HTTP/1.1

在代理请求中，绝对URI形式是必须的。请求被请求转发或由缓存服务，然后返回响应。注意，代理可以将请求转发到另一个代理或直接到由绝对URI指定的服务器。为了避免请求循环，代理必须识别所有其服务器名，包括别名、本地变体和数字IP地址。例如：

       GET http://www.w3.org/pub/WWW/TheProject.html HTTP/1.1

为了未来所有请求都能支持绝对URI，所有HTTP/1.1服务器必须接受请求中的绝对URI形式，尽管HTTP/1.1客户端只会在请求代理时生成。

“authority”形式仅由CONNECT方法（第9.9节）使用。

最常用的请求URI形式是用来标识原始服务器或网关上的资源。在这种情况下，URI的绝对路径（第3.2.1节）必须作为请求URI传送，URI的网络位置（authority）必须在Host头字段中传送。例如，客户端希望直接从原始服务器获取上述资源，会建立到“www.w3.org”端口80的TCP连接，并发送：

       GET /pub/WWW/TheProject.html HTTP/1.1
       Host: www.w3.org

随后是请求的其余部分。注意，绝对路径不能为空；如果原始URI中没有路径，则必须用“/”表示（服务器根目录）。

请求URI按第3.2.1节的格式传送。如果请求URI使用“% HEX HEX”编码（第42节），则原始服务器必须解码请求URI以正确理解请求。服务器应对无效的请求URI返回适当的状态码。

透明代理在转发请求时不得重写接收的请求URI中的“abs_path”部分，除非为将空路径替换为“/”的特殊情况。

注意：“不重写”规则防止代理在原始服务器错误使用非保留字符时改变请求的含义。实现者应注意，某些早于HTTP/1.1的代理曾被发现会重写请求URI。

5.2 请求所标识的资源

由互联网请求所标识的确切资源由请求URI和Host头字段共同决定。

不允许资源因请求的主机不同而不同的原始服务器，可以在确定请求的资源时忽略Host头字段的值（但有关Host支持的其他要求，请参见第19.6.1.1节）。

一个根据请求的主机名区分资源的起源服务器（有时称为虚拟主机或虚荣主机名）必须遵循以下规则，以确定HTTP/1.1请求中的请求资源：

1. 如果请求的Request-URI是绝对URI，则主机名是Request-URI的一部分。请求中的任何Host头字段的值都必须被忽略。

2. 如果Request-URI不是绝对URI，并且请求中包含Host头字段，则主机名由Host头字段的值决定。

3. 如果根据规则1或2确定的主机名在服务器上不是有效的主机名，则响应必须返回一个400（错误请求）错误信息。

对于没有Host头字段的HTTP/1.0请求，接收方可以尝试使用启发式方法（例如检查URI路径中是否有某些特定于某个主机的唯一标识）来判断请求的具体资源。

5.3 请求头字段

请求头字段允许客户端向服务器传递关于请求的附加信息，以及关于客户端本身的信息。这些字段作为请求的修饰符，其语义等同于编程语言中方法调用的参数。

请求头字段名只能在协议版本变更时可靠地扩展。然而，如果通信双方都识别某些新或试验性的头字段为请求头字段，则可以赋予其相应的语义。未被识别的头字段将被视为实体头字段。

6. 响应

在接收并解析请求消息后，服务器会用HTTP响应消息作出回应。

响应格式如下：

响应 = 状态行 + （通用头 | 响应头 | 实体头）CRLF + （消息体）

6.1 状态行

响应消息的第一行是状态行，由协议版本、状态码（数字）和状态短语组成，各元素之间用空格分隔。除了最后的CRLF序列外，不允许出现CR或LF。

状态行格式：

状态行 = HTTP版本 SP 状态码 SP 原因短语 CRLF

6.1.1 状态码与原因短语

状态码是一个三位数字的结果代码，用于表示对请求的理解和处理情况。这些代码在第10节中有详细定义。原因短语旨在提供对状态码的简短文本描述。状态码主要供自动机使用，原因短语则供人类用户阅读。客户端无需检查或显示原因短语。

状态码的第一位数字定义响应的类别，后两位没有类别含义。第一位数字的五个取值范围：

- 1xx：信息性 - 请求已接收，继续处理
- 2xx：成功 - 请求已成功接收、理解并接受
- 3xx：重定向 - 需要采取进一步措施以完成请求
- 4xx：客户端错误 - 请求语法错误或无法完成
- 5xx：服务器错误 - 服务器未能完成有效请求

以下列出HTTP/1.1定义的部分状态码及示例原因短语。这里列出的原因短语仅为建议，可以根据本地习惯替换，但不影响协议。

状态码示例（部分）：

- 100：继续
- 101：切换协议
- 200：成功
- 201：已创建
- 202：已接受
- 203：非权威信息
- 204：无内容
- 205：重置内容
- 206：部分内容
- 300：多重选择
- 301：永久移动
- 302：找到
- 303：参见其他
- 304：未修改
- 305：使用代理
- 307：临时重定向
- 400：错误请求
- 401：未授权
- 402：需要付款
- 403：禁止访问
- 404：未找到
- 405：方法不允许
- 406：不可接受
- 407：代理认证要求
- 408：请求超时
- 409：冲突
- 410：已删除
- 411：需要长度
- 412：预处理条件失败
- 413：请求实体过大
- 414：请求URI过长
- 415：不支持的媒体类型
- 416：请求范围不满足
- 417：预期失败
- 500：服务器内部错误
- 501：未实现
- 502：网关错误
- 503：服务不可用
- 504：网关超时
- 505：HTTP版本不支持

扩展状态码（extension-code）为三位数字，原因短语为任意文本（不含CR、LF）。

HTTP状态码是可扩展的。HTTP应用程序不必理解所有已注册的状态码，但应理解其类别（由第一位数字指示），未识别的响应应视为该类别的x00状态码，且不得缓存。例如，客户端收到未识别的状态码431时，应认为请求有误，像收到400一样处理。此类响应的实体内容应呈现给用户，通常包含人类可读的说明信息。

6.2 响应头字段

响应头字段提供关于响应的附加信息，这些信息不能放在状态行中。这些字段描述服务器信息以及对请求URI资源的进一步访问。

响应头格式示例：

响应头 = Accept-Ranges | Age | ETag | Location | Proxy-Authenticate | Retry-After | Server | Vary | WWW-Authenticate

响应头字段名只能在协议版本变更时可靠扩展。新或试验性头字段可以赋予响应头的语义，但前提是通信双方都识别它们为响应头字段。未识别的头字段应被视为实体头字段。

7. 实体

请求和响应消息可以携带实体（entity），除非请求方法或响应状态码另有限制。实体由实体头字段和实体体组成，部分响应可能只包含实体头。

在本节中，发送者和接收者指的是客户端或服务器，具体取决于谁发出和谁接收实体。

7.1 实体头字段

实体头字段定义关于实体体的元信息，或者在没有实体体时，关于请求所标识资源的元信息。部分元信息是可选的，部分可能是本规范要求的。

实体头格式示例：

实体头 = Allow | Content-Encoding | Content-Language | Content-Length | Content-Location | Content-MD5 | Content-Range | Content-Type | Expires | Last-Modified | 扩展头

扩展头 = 消息头

扩展头机制允许定义额外的实体头字段，而无需更改协议，但接收方不能假设这些字段一定被识别。未识别的头字段应被忽略，并由透明代理转发。

7.2 实体体

实体体（如果有）是通过实体头字段定义的格式和编码的内容。

实体体仅在消息中存在消息体时出现（详见第4.3节）。实体体通过解码可能应用的传输编码（Transfer-Encoding）获得，以确保消息的安全和正确传输。

7.2.1 类型

当消息包含实体体时，其数据类型由Content-Type和Content-Encoding头字段决定。这定义了一个两层的有序编码模型：

实体体 = Content-Encoding( Content-Type(数据) )

Content-Type指定基础数据的媒体类型。Content-Encoding用于指示对数据应用的任何附加内容编码（通常用于数据压缩），这是请求资源的属性。没有默认编码。

任何包含实体体的HTTP/1.1消息应包含Content-Type头字段，定义实体体的媒体类型。如果没有提供Content-Type，接收方可以尝试通过内容或URI的扩展名猜测媒体类型。如果仍未知，应将其视为“application/octet-stream”。

7.2.2 实体长度

消息的实体长度是指在应用任何传输编码之前的消息体长度。第4.4节定义了如何确定消息体的传输长度。

- HTTP可以更优雅地演进，因为错误可以被报告而无需关闭TCP连接。使用未来版本HTTP的客户端可能会乐观地尝试新功能，但如果与较旧的服务器通信，在报告错误后应重试使用旧的语义。

HTTP实现应当支持持久连接。








Fielding 等人            标准轨迹                    [第44页]


RFC 2616                        HTTP/1.1                       1999年6月


8.1.2 整体操作

   HTTP/1.1与早期版本的HTTP的一个显著区别在于，持久连接是任何HTTP连接的默认行为。也就是说，除非另有指示，客户端应假设服务器会维持持久连接，即使在收到服务器的错误响应后也是如此。

   持久连接提供了一种机制，客户端和服务器可以通过它来信号关闭TCP连接。该信号通过使用Connection头字段（第14.10节）进行。一旦发出关闭信号，客户端不得在该连接上发送更多请求。

8.1.2.1 协商

   除非请求中包含带有连接标记“close”的Connection头，否则HTTP/1.1服务器可以假设HTTP/1.1客户端打算保持持久连接。如果服务器选择在发送响应后立即关闭连接，应在响应中包含带有连接标记“close”的Connection头。

   HTTP/1.1客户端可以期望连接保持开启，但会根据服务器响应中是否包含带有连接标记“close”的Connection头来决定是否保持连接。如果客户端不希望在完成该请求后继续保持连接，应在请求中包含带有连接标记“close”的Connection头。

   如果客户端或服务器在Connection头中发送了关闭标记“close”，该请求即为该连接的最后一个请求。

   除非明确发出信号，否则客户端和服务器不应假设HTTP版本低于1.1的连接会保持持久。有关与HTTP/1.0客户端的向后兼容性，请参见第19.6.2节。

   为了保持持久性，连接上的所有消息必须具有自定义的消息长度（即，不由连接关闭定义的长度），如第4.4节所述。









Fielding 等人            标准轨迹                    [第45页]


RFC 2616                        HTTP/1.1                       1999年6月


8.1.2.2 管线化

   支持持久连接的客户端可以“管线化”请求（即，连续发送多个请求而不等待响应）。服务器必须按照请求的接收顺序返回响应。

   假设支持持久连接并在连接建立后立即管线化的客户端，应准备在首次管线化尝试失败时重试连接。如果进行重试，必须在确认连接是持久的之前不进行管线化。客户端还应准备在服务器关闭连接且未发送所有响应时重新发送请求。

   客户端不应对非幂等方法或非幂等方法序列进行管线化（参见第9.1.2节），否则，过早终止传输连接可能导致结果不确定。希望发送非幂等请求的客户端应等待收到前一请求的响应状态后再发送请求。

8.1.3 代理服务器

   正确实现Connection头字段的属性（第14.10节）尤为重要。

   代理服务器必须分别向其连接的客户端和源服务器（或其他代理服务器）信号持久连接。每个持久连接仅适用于一个传输链路。

   代理服务器不得与HTTP/1.0客户端建立HTTP/1.1持久连接（但关于许多HTTP/1.0客户端实现的Keep-Alive头存在的问题，请参见RFC 2068 [33]）。

8.1.4 实际考虑

   服务器通常会设置超时值，超出后不再维持非活动连接。代理服务器可能会设置更高的超时值，因为客户端可能会通过同一服务器建立更多连接。使用持久连接对客户端和服务器的超时长度没有硬性要求（详见第4.4节）。

   当客户端或服务器希望超时关闭连接时，应发出优雅关闭的信号。客户端和服务器都应持续监测对方的关闭信号，并作出相应反应。如果未能及时检测到对方关闭，可能会造成网络资源的浪费。

   客户端、服务器或代理可以随时关闭传输连接。例如，客户端可能在向服务器发送新请求的同时，服务器决定关闭“空闲”连接。从服务器角度看，连接在空闲时被关闭；从客户端角度看，请求仍在进行中。

   这意味着客户端、服务器和代理必须能够从异步关闭事件中恢复。客户端软件应在请求序列幂等的前提下，无需用户干预，重新打开传输连接并重发中断的请求序列（参见第9.1.2节）。非幂等方法或序列不得自动重试，但用户代理可以提供重试的选择。具有语义理解的用户代理软件确认后，可代替用户确认。若第二次请求序列失败，自动重试不应继续。

   服务器应尽可能对每个连接至少响应一个请求。除非怀疑网络或客户端故障，否则不应在响应传输中途关闭连接。

   使用持久连接的客户端应限制其对某一服务器的同时连接数。单用户客户端不应与任何服务器或代理保持超过2个连接。代理应使用最多2*N个连接与另一台服务器或代理通信，其中N为同时活跃的用户数。这些指南旨在改善HTTP响应时间并避免网络拥堵。

8.2 消息传输要求

8.2.1 持久连接与流量控制

   HTTP/1.1服务器应维持持久连接，并利用TCP的流量控制机制解决临时过载，而不是终止连接，期望客户端重试。后者可能会加剧网络拥堵。

8.2.2 监控连接中的错误状态消息

   发送消息体的HTTP/1.1（或更高版本）客户端在传输请求时，应监控网络连接中的错误状态。如果检测到错误状态，应立即停止传输消息体。如果使用“分块”编码（第3.6节）发送消息体，可以用零长度块和空尾部提前标记消息结束。如果消息体前有Content-Length头，客户端必须关闭连接。

8.2.3 使用100（Continue）状态

   100（Continue）状态（见第10.1.1节）的目的是让客户端在发送请求体之前，判断源服务器是否愿意接受请求（基于请求头）。在某些情况下，如果服务器在不查看请求体的情况下就会拒绝请求，客户端发送请求体可能既不合适也效率低下。

   HTTP/1.1客户端的要求：

      - 如果客户端会等待100（Continue）响应再发送请求体，必须在请求中加入Expect请求头（第14.20节），并设置“100-continue”期望。

      - 如果客户端不打算发送请求体，则不得在请求中加入Expect请求头（第14.20节）中的“100-continue”期望。

   由于存在旧实现，协议允许出现模糊情况，即客户端可能在未收到417（Expectation Failed）或100（Continue）状态码的情况下，发送“Expect: 100-continue”。因此，当客户端向未见过100（Continue）状态码的源服务器（可能通过代理）发送此头时，应避免无限期等待后再发送请求体。

   源服务器的要求：

      - 收到包含“100-continue”期望的Expect请求头的请求后，必须回应100（Continue）状态并继续读取输入流，或回应最终状态码。不得在收到请求体前等待回应100（Continue）。如果回应最终状态码，可能关闭传输连接或继续读取并丢弃请求的其余部分。不得执行请求的方法（除非返回最终状态码）。

      - 如果请求不包含“100-continue”期望的Expect请求头，源服务器不应发送100（Continue）响应，也不得对来自HTTP/1.0（或更早）客户端的请求发送此响应。为兼容RFC 2068，服务器可以对未包含“100-continue”期望的HTTP/1.1 PUT或POST请求，发送100（Continue）状态。这一例外旨在减少因未声明等待100（Continue）状态而引起的客户端处理延迟，仅适用于HTTP/1.1请求，不适用于其他HTTP版本。

      - 如果已部分接收请求体，源服务器可以省略发送100（Continue）响应。

      - 发送100（Continue）响应的源服务器，最终必须在接收并处理完请求体后，发出最终状态码，除非提前关闭传输连接。

      - 如果源服务器收到不包含“100-continue”期望的Expect请求头的请求，且请求包含请求体，且在未完整读取请求体前就返回最终状态码，则应在读取完整请求或客户端关闭连接之前，不关闭传输连接，否则客户端可能无法可靠接收响应。此要求不应被理解为阻止服务器防御拒绝服务攻击或应对客户端实现缺陷。

源代理的要求：

      - 如果代理收到包含“100-continue”期望的Expect请求头的请求，且知道下一跳服务器符合HTTP/1.1或更高版本，或不知道下一跳服务器的HTTP版本，则必须转发请求，包括Expect头。

      - 如果知道下一跳服务器是HTTP/1.0或更低版本，则不得转发请求，应回应417（Expectation Failed）状态。

      - 代理应维护一个缓存，记录最近访问的下一跳服务器的HTTP版本。

      - 如果请求来自HTTP/1.0（或更早）客户端，且未包含“100-continue”期望的Expect请求头，则代理不得转发100（Continue）响应。

（未完，后续内容省略）

如果一个HTTP/1.1客户端发送了包含请求体的请求，但没有包含带有“100-continue”期望的Expect请求头字段，并且该客户端没有直接连接到HTTP/1.1源服务器，并且在未收到任何状态响应之前就看到连接关闭，客户端应当重试该请求。如果客户端确实重试此请求，可以使用以下“二进制指数退避”算法，以确保获得可靠的响应：

1. 建立一个新的连接到服务器
2. 传输请求头
3. 初始化变量R为到服务器的估算往返时间（例如，基于建立连接所用的时间），如果无法获得往返时间，则设为常数值5秒
4. 计算T = R * (2^N)，其中N是之前重试此请求的次数
5. 等待，要么收到服务器的错误响应，要么等待T秒（以先到者为准）
6. 如果在T秒内未收到错误响应，则传输请求体
7. 如果客户端发现连接提前关闭，则从第1步重新开始，直到请求被接受、收到错误响应，或用户变得不耐烦并终止重试过程

在任何时候如果收到错误状态，客户端应当：

- 不再继续
- 如果请求尚未完成发送，应关闭连接

第9节 方法定义

以下定义了HTTP/1.1的常用方法集。虽然此集合可以扩展，但不能假设额外的方法在语义上与已定义的方法相同，特别是在客户端和服务器端的扩展中。

所有HTTP/1.1请求都必须包含Host请求头字段（第14.23节）。

9.1 安全和幂等方法

9.1.1 安全方法

实现者应意识到，软件代表用户在互联网中的交互，应谨慎允许用户了解其可能采取的任何行动，这些行动可能对自己或他人具有意外的意义。

特别是，已建立的约定是GET和HEAD方法不应具有除检索之外的其他操作意义。这些方法应被视为“安全的”。这允许用户代理以特殊方式表示其他方法，如POST、PUT和DELETE，以便用户意识到请求的可能不安全操作。

当然，不可能确保服务器在执行GET请求时不会产生副作用；实际上，一些动态资源视其为特性。这里的重要区别在于，用户没有请求副作用，因此不能为其负责。

9.1.2 幂等方法

方法还可以具有“幂等性”属性，即（除错误或过期问题外）多个相同请求的副作用与单个请求相同。GET、HEAD、PUT和DELETE共享此属性。此外，OPTIONS和TRACE方法不应具有副作用，因此本质上是幂等的。

然而，即使所有执行的请求方法都是幂等的，多个请求序列也可能不是幂等的。例如，如果序列的结果依赖于后续在同一序列中被修改的值，则该序列是非幂等的。

没有副作用的序列本身是幂等的（前提是没有对相同资源集的并发操作）。

9.2 OPTIONS

OPTIONS方法请求关于请求/响应链中可用通信选项的信息。它允许客户端在不涉及资源操作或检索资源的情况下，确定资源的选项和/或要求，或服务器的能力。

此方法的响应不可缓存。

如果请求包含实体主体（由Content-Length或Transfer-Encoding指示），则必须用Content-Type字段指明媒体类型。虽然本规范未定义此类主体的用途，但未来的HTTP扩展可能会利用OPTIONS主体进行更详细的查询。服务器如果不支持此类扩展，可以丢弃请求体。

如果Request-URI是星号（“*”），则此OPTIONS请求旨在适用于整个服务器，而非特定资源。由于服务器的通信选项通常依赖于资源，星号请求仅作为“ping”或“无操作”类型的方法；它除了让客户端测试服务器能力外，不执行其他操作。例如，可以用来测试代理是否符合HTTP/1.1标准。

如果Request-URI不是星号，则此OPTIONS请求仅适用于与该资源通信时可用的选项。

200响应应包含指示服务器实现的可选功能的头字段（如Allow），可能还包括本规范未定义的扩展。响应体（如果有）也应包含通信选项信息。此类体的格式未由本规范定义，但未来的HTTP扩展可能会定义。可以使用内容协商选择合适的响应格式。如果没有响应体，响应必须包含Content-Length字段，值为“0”。

Max-Forwards请求头字段可用于定位请求链中的特定代理。当代理收到针对绝对URI的OPTIONS请求（允许请求转发）时，必须检查Max-Forwards字段。如果字段值为零（“0”），代理不得转发请求，而应以自身的通信选项作出响应。如果字段值大于零，代理在转发请求时应递减该值。如果请求中没有Max-Forwards字段，则转发的请求不得包含此字段。

9.3 GET

GET方法表示检索由Request-URI标识的任何信息（以实体形式）。如果Request-URI指向一个数据生成过程，则应返回生成的数据作为响应实体，而不是该过程的源文本，除非该文本恰好是输出。

如果请求消息中包含If-Modified-Since、If-Unmodified-Since、If-Match、If-None-Match或If-Range头字段，GET的语义将变为“条件GET”。条件GET请求仅在条件头字段描述的情况下传输实体。此方法旨在减少不必要的网络使用，通过允许缓存实体在不发起多次请求或传输客户端已持有数据的情况下刷新。

如果请求中包含Range头字段，GET的语义将变为“部分GET”。部分GET请求只传输实体的一部分，详见第14.35节。此方法旨在减少不必要的网络使用，允许在不传输客户端已持有数据的情况下完成部分检索。

GET请求的响应如果符合第13节中描述的HTTP缓存要求，则可缓存。

有关使用GET进行表单提交的安全考虑，请参见第15.1.3节。

9.4 HEAD

HEAD方法与GET相同，但服务器不得在响应中返回消息体。响应中的HTTP头信息应与GET请求的响应信息一致。此方法可用于获取关于请求所暗示实体的元信息，而无需传输实体本身。常用于测试超文本链接的有效性、可访问性和最近修改。

HEAD请求的响应可能是可缓存的，即响应中的信息可用于更新之前缓存的实体。如果新字段值表明缓存实体与当前实体不同（如Content-Length、Content-MD5、ETag或Last-Modified的变化），则缓存必须将该缓存条目视为过期。

9.5 POST

POST方法用于请求源服务器接受请求中包含的实体，将其作为请求URI所标识资源的一个新子资源。POST旨在提供一种统一的方法，涵盖以下功能：

- 对现有资源进行注释；
- 向公告板、新闻组、邮件列表或类似的文章组发布消息；
- 提供一块数据（如提交表单的结果）给数据处理过程；
- 通过追加操作扩展数据库。

POST实际执行的功能由服务器决定，通常依赖于Request-URI。提交的实体在层级关系上属于该URI，就像文件属于包含它的目录、新闻文章属于发布它的新闻组、记录属于数据库一样。

POST的操作可能不会产生可由URI标识的资源。在这种情况下，响应状态应为200（OK）或204（无内容），具体取决于是否包含描述结果的实体。

如果在源服务器上创建了资源，响应应为201（已创建），并包含描述请求状态、指向新资源的实体，以及Location头（见第14.30节）。

除非响应中包含适当的Cache-Control或Expires头字段，否则POST的响应不可缓存。也可以使用303（See Other）响应引导用户代理检索可缓存的资源。

POST请求必须遵守第8.2节中规定的消息传输要求。

有关安全考虑，请参见第15.1.3节。

9.6 PUT

PUT方法请求将包含的实体存储在提供的Request-URI下。如果Request-URI指向已存在的资源，则应将包含的实体视为对该资源的修改版本。如果Request-URI未指向现有资源，并且请求的用户代理可以定义该URI为新资源，源服务器可以用该URI创建资源。如果创建成功，必须用201（已创建）响应，并包含描述状态和新资源的实体，以及Location头。如果修改现有资源，应返回200（OK）或204（无内容）以表示请求成功。如果无法创建或修改资源，应返回反映问题性质的适当错误响应。实体的接收者不得忽略任何它不理解或未实现的Content-*（如Content-Range）头，并在这种情况下返回501（未实现）响应。

如果请求经过缓存，并且Request-URI标识一个或多个当前缓存的实体，则这些条目应被视为过时。对此方法的响应不可缓存。

POST和PUT请求的根本区别在于Request-URI的不同含义。POST请求中的URI标识将处理所附实体的资源。该资源可能是一个接受数据的进程、某个协议的网关，或一个接受注释的独立实体。相反，PUT请求中的URI标识随请求一同包含的实体——用户代理知道意图的URI，服务器不得试图将请求应用于其他资源。如果服务器希望将请求应用于不同的URI，必须返回301（永久移动）响应；用户代理可以自行决定是否重定向请求。

一个资源可能由多个不同的URI标识。例如，一篇文章可能有一个URI用于标识“当前版本”，而另一个URI用于标识每个具体版本。在这种情况下，对一个通用URI的PUT请求可能会导致定义出多个由源服务器管理的URI。

HTTP/1.1未定义PUT方法如何影响源服务器的状态。

PUT请求必须遵守第8.2节中规定的消息传输要求。

除非为特定实体头另有说明，PUT请求中的实体头应应用于由PUT创建或修改的资源。

9.7 删除（DELETE）

DELETE方法请求源服务器删除由Request-URI标识的资源。此方法可能会被源服务器上的人工干预（或其他手段）覆盖。即使源服务器返回的状态码表明操作已成功完成，也不能保证操作已被执行。然而，除非在响应时源服务器打算删除资源或将其移动到无法访问的位置，否则不应指示成功。

如果响应包含描述状态的实体，则应为200（OK）；如果操作尚未执行，则应为202（已接受）；如果操作已执行，但响应不包含实体，则应为204（无内容）。

如果请求经过缓存，并且Request-URI标识一个或多个当前缓存的实体，则这些条目应被视为过时。对此方法的响应不可缓存。

9.8 跟踪（TRACE）

TRACE方法用于调用请求消息的远程应用层回环。请求的最终接收者应将收到的消息反映回客户端，作为200（OK）响应的实体主体。最终接收者可以是源服务器，也可以是在请求中将Max-Forwards值设为零（0）的第一个代理或网关（参见第14.31节）。TRACE请求不得包含实体。

TRACE允许客户端查看请求链另一端接收的内容，并利用这些数据进行测试或诊断。Via头字段（第14.45节）的值尤为重要，因为它作为请求链的追踪。Max-Forwards头字段允许客户端限制请求链的长度，这在测试无限循环的代理链时非常有用。

如果请求有效，响应应在实体主体中包含整个请求消息，内容类型为“message/http”。对该方法的响应不得缓存。

10 状态码定义

每个状态码如下描述，包括它可以跟随的请求方法以及响应中所需的元信息。

10.1 信息性1xx

此类状态码表示临时响应，仅由状态行和可选头部组成，以空行结束。此类状态码没有必需的头部。由于HTTP/1.0未定义任何1xx状态码，服务器不得向HTTP/1.0客户端发送1xx响应，除非在试验条件下。

客户端必须准备接受一个或多个1xx状态响应，甚至在不预期收到100（继续）状态消息的情况下。意外的1xx状态响应可以被用户代理忽略。

代理必须转发1xx响应，除非与客户端的连接已关闭，或代理本身请求生成了1xx响应（例如，代理在转发请求时添加了“Expect: 100-continue”字段，则无需转发相应的100（继续）响应）。

10.1.1 100 继续（Continue）

客户端应继续其请求。此临时响应用于通知客户端，已接收请求的初始部分，尚未被服务器拒绝。客户端应继续发送请求的其余部分，或如果请求已完成，则忽略此响应。服务器在请求完成后必须发送最终响应。详细用法和处理请参见第8.2.3节。

10.1.2 101 切换协议（Switching Protocols）

服务器理解并愿意遵从客户端通过Upgrade消息头（第14.42节）提出的请求，以切换所使用的应用协议。服务器将在响应的空行之后立即切换到响应头中定义的协议。

协议应仅在有利时切换。例如，切换到更新版本的HTTP比旧版本更有优势，或者在传输使用实时同步特性的资源时切换到实时协议可能更合适。

10.2 成功的2xx

此类状态码表示客户端的请求已成功接收、理解并接受。

10.2.1 200 OK

请求成功。响应中返回的信息取决于请求的方法，例如：

GET：响应中包含请求资源的实体；

HEAD：响应中包含对应请求资源的实体头部字段，无消息体；

POST：响应中包含描述或包含操作结果的实体；

TRACE：响应中包含由最终服务器接收的请求消息。

10.2.2 201 已创建（Created）

请求已完成，并导致新资源的创建。新创建的资源可以通过响应实体中的URI引用，最具体的URI由Location头字段提供。响应应包含一个实体，列出资源的特性和位置，供用户或用户代理选择最合适的。实体格式由Content-Type头字段指定。源服务器必须在返回201状态码前创建资源。如果无法立即执行操作，服务器应返回202（已接受）响应。

201响应可能包含ETag响应头，指示刚创建的变体的实体标签的当前值（参见第14.19节）。

10.2.3 202 已接受（Accepted）

请求已被接受用于处理，但处理尚未完成。请求可能最终会被执行，也可能因实际处理时被禁止而未执行。没有机制重新发送此类异步操作的状态码。

202响应具有非承诺性质，允许服务器接受请求以进行其他处理（如每天仅运行一次的批处理），而无需保持连接直到处理完成。响应应包含请求的当前状态指示，以及指向状态监控或估计请求完成时间的指针。

10.2.4 203 非权威信息（Non-Authoritative Information）

实体头中的元信息不是来自源服务器的最终集，而是从本地或第三方副本中收集。所提供的集合可能是原始版本的子集或超集。例如，包含本地关于资源的注释信息可能导致超出源服务器已知的元信息。使用此状态码非强制，仅在响应本应为200（OK）时适用。

10.2.5 204 无内容（No Content）

服务器已完成请求，但无需返回实体体，可能希望返回更新的元信息。响应可以包含新的或更新的元信息（实体头），如果存在，应与请求的变体相关联。

如果客户端是用户代理，不应改变其文档视图，以免影响用户当前的显示。此响应主要用于在不改变用户代理活动文档的情况下提供输入，任何新或更新的元信息应应用于当前显示的文档。

204响应不得包含消息体，始终以头部之后的第一个空行结束。

10.2.6 205 重置内容（Reset Content）

服务器已完成请求，用户代理应重置引起请求的文档视图。此响应主要用于通过用户输入进行操作后，清空输入表单，便于用户发起新的输入。响应不得包含实体。

10.2.7 206 部分内容（Partial Content）

服务器已完成资源的部分GET请求。请求必须包含Range头字段（第14.35节）以指示所需范围，也可以包含If-Range头字段（第14.27节）以使请求有条件。

响应必须包含以下头部字段：

- Content-Range（第14.16节）指示此次响应包含的范围，或包含每部分的Content-Range字段的multipart/byteranges内容类型。如果响应中有Content-Length头字段，其值必须与消息体中实际传输的字节数一致。

- Date

- ETag和/或Content-Location（如果在相同请求的200响应中会发送）

- Expires、Cache-Control和/或Vary（如果字段值可能与之前响应中的不同）

如果206响应是由使用强验证器的If-Range请求引起的，则应避免包含其他实体头。如果由使用弱验证器的If-Range请求引起，则不得包含其他实体头，以防缓存的实体体与更新的头部不一致。否则，响应应包含所有在相同请求的200（OK）响应中会返回的实体头。

缓存不得将206部分内容的响应与之前缓存的内容合并，除非ETag或Last-Modified头字段完全匹配，详见13.5.4。

不支持Range和Content-Range头字段的缓存，必须不缓存206（部分内容）响应。

10.3 重定向 3xx

此类状态码表示用户代理需要采取进一步的操作以完成请求。所需的操作只有在第二次请求的方法为GET或HEAD时，用户代理可以在不与用户交互的情况下自动执行。客户端应检测无限重定向循环，因为此类循环会产生网络流量。

注意：本规范的早期版本建议最多允许五次重定向。内容开发者应注意，可能存在实现此类固定限制的客户端。

10.3.1 300 多重选择

请求的资源对应一组不同的表现形式，每个都具有自己的特定位置，并提供代理驱动的协商信息（第12节），以便用户（或用户代理）选择最合适的表现形式并将请求重定向到该位置。

除非是HEAD请求，否则响应应包含一个实体，列出资源的特性和位置，供用户或用户代理选择最合适的。实体格式由Content-Type头字段指定。根据格式和用户代理的能力，可能会自动选择最合适的选项，但本规范未定义此类自动选择的标准。

如果服务器有偏好的表现形式，应在Location字段中包含该表现形式的具体URI；用户代理可以使用Location字段的值进行自动重定向。除非另有指示，否则此响应是可缓存的。

10.3.2 301 永久移动

请求的资源已被分配一个新的永久URI，未来对该资源的引用应使用返回的URI之一。具有链接编辑能力的客户端应自动将对请求URI的引用重新链接到服务器返回的一个或多个新引用（如果可能）。除非另有指示，否则此响应是可缓存的。

新永久URI应由响应中的Location字段提供。除非请求方法为HEAD，否则响应的实体应包含一个简短的超文本说明，带有指向新URI的超链接。

如果对非GET或HEAD请求收到301状态码，用户代理不得自动重定向，除非得到用户确认，因为这可能会改变请求的条件。

注意：在收到301状态码后自动重定向POST请求时，某些现有的HTTP/1.0用户代理会错误地将其变为GET请求。

10.3.3 302 找到

请求的资源暂时位于不同的URI下。由于重定向可能会被更改，客户端应继续使用原始请求URI进行未来请求。除非由Cache-Control或Expires头指示，否则此响应不可缓存。

临时URI应由响应中的Location字段提供。除非请求方法为HEAD，否则响应应包含一个简短的超文本说明，带有指向新URI的超链接。

如果对非GET或HEAD请求收到302状态码，用户代理不得自动重定向，除非得到用户确认，因为这可能会改变请求的条件。

注意：RFC 1945和RFC 2068规定，客户端不得更改重定向请求的方法。然而，大多数现有的用户代理会将302视作303响应，无论原始请求方法如何，都对Location字段值执行GET。为明确指示客户端应采取的反应，已添加303和307状态码。

10.3.4 303 查看其他

响应可以在不同的URI下找到，应使用GET方法检索该资源。此方法主要用于让POST激活的脚本输出重定向用户代理到选定的资源。新URI不是对原始请求资源的替代引用。303响应不得缓存，但对第二次（重定向）请求的响应可能可缓存。

不同的URI应由响应中的Location字段提供。除非请求方法为HEAD，否则响应应包含一个简短的超文本说明，带有指向新URI的超链接。

注意：许多HTTP/1.1之前的用户代理不理解303状态。当需要与此类客户端的互操作性时，可以使用302状态码，因为大多数用户代理会像对待303一样对待302响应。

10.3.5 304 未修改

如果客户端已发出条件GET请求且允许访问，但文档未被修改，服务器应返回此状态码。304响应不得包含消息体，响应由头字段后的第一个空行终止。

响应必须包含以下头字段：

- Date（除非第14.18.1节要求省略）

如果无时钟的源服务器遵守这些规则，代理和客户端在响应中未包含Date时添加自己的Date，缓存将正常工作。

- ETag和/或Content-Location（如果在相同请求的200响应中会发送此头）

- Expires、Cache-Control和/或Vary（如果字段值可能与之前响应中为相同变体所发的值不同）

如果条件GET使用强验证（见13.3.3节），响应不应包含其他实体头。否则（即使用弱验证），响应不得包含其他实体头，以防止缓存的实体体与更新的头信息不一致。

如果304响应指示实体未被缓存，缓存必须忽略此响应，并在不带条件的情况下重发请求。

如果缓存使用收到的304响应更新缓存条目，必须用响应中的新字段值更新条目。

10.3.6 305 使用代理

请求的资源必须通过Location字段指定的代理访问。Location字段提供代理的URI。预期接收方应通过代理重复此单一请求。305响应必须由源服务器生成。

注意：RFC 2068未明确指出305旨在重定向单个请求，也仅由源服务器生成。不遵守这些限制会带来严重的安全后果。

10.3.7 306（未使用）

该状态码在早期版本的规范中使用，但现已不再使用，代码已被保留。

10.3.8 307 临时重定向

请求的资源暂时位于不同的URI下。由于重定向可能会被更改，客户端应继续使用原始请求URI进行未来请求。除非由Cache-Control或Expires头指示，否则此响应不可缓存。

临时URI应由响应中的Location字段提供。除非请求方法为HEAD，否则响应应包含一个简短的超文本说明，带有指向新URI的超链接，因为许多HTTP/1.1之前的用户代理不理解307状态码。因此，说明中应包含用户重复在新URI上发起原始请求所需的信息。

如果对非GET或HEAD请求收到307状态码，用户代理不得自动重定向，除非得到用户确认，因为这可能会改变请求条件。

10.4 客户端错误 4xx

4xx状态码类用于客户端似乎出错的情况。除非响应HEAD请求，服务器应包含一个实体，说明错误情况及其临时或永久性质。这些状态码适用于任何请求方法。用户代理应向用户显示任何包含的实体。

如果客户端正在发送数据，使用TCP的服务器实现应确保在关闭输入连接前，客户端已确认收到包含响应的数据包。如果客户端在连接关闭后继续向服务器发送数据，服务器的TCP堆栈会向客户端发送复位包，可能会在HTTP应用读取和解释之前清除客户端未确认的输入缓冲区。

10.4.1 400 错误请求

请求由于语法错误无法被服务器理解。客户端不应在未修改请求的情况下重复请求。

10.4.2 401 未授权

请求需要用户认证。响应必须包含一个WWW-Authenticate头字段（第14.47节），其中包含适用于请求资源的挑战。客户端可以用合适的Authorization头字段（第14.8节）重复请求。如果请求已包含认证凭据，则401响应表示对这些凭据的授权已被拒绝。如果401响应中的挑战与之前的相同，且用户代理已至少尝试过一次认证，则应向用户显示响应中提供的实体，因为该实体可能包含相关的诊断信息。HTTP访问认证详见“HTTP认证：基本和摘要访问认证”[43]。

10.4.3 402 需要付款

此状态码为将来使用预留。

10.4.4 403 禁止

服务器理解请求，但拒绝执行。授权无助于解决问题，且请求不应重复。如果请求方法不是HEAD，且服务器希望公开说明未完成请求的原因，应在实体中描述拒绝的理由。如果服务器不希望向客户端提供此信息，可以使用404（未找到）状态码。

10.4.5 404 未找到

服务器未找到与请求URI匹配的任何内容。未指明此状态是临时还是永久。若服务器通过某些内部配置机制知道某个旧资源已永久不可用且没有转发地址，应使用410（已删除）状态码。此状态码常用于服务器不愿透露拒绝请求的具体原因，或无其他适用响应时。

10.4.6 405 方法不允许

请求行中指定的方法不被请求URI所允许。响应必须包含Allow头，列出请求资源支持的有效方法。

10.4.7 406 不可接受

请求所识别的资源只能生成内容特性不符合请求中Accept头所允许的响应实体。

除非是HEAD请求，否则响应应包含一个实体，列出可用的实体特性和位置，用户或用户代理可以从中选择最合适的一个。实体的格式由Content-Type头字段中指定的媒体类型定义。根据格式和用户代理的能力，自动选择最合适的选项可能会被自动执行，但本规范并未定义任何关于此类自动选择的标准。

注意：HTTP/1.1服务器可以返回不符合请求中Accept头字段所指定的接受类型的响应。在某些情况下，这甚至比返回406（不接受）状态码更为合适。鼓励用户代理检查收到的响应头，以判断其是否可接受。

如果响应可能不可接受，用户代理应暂时停止接收更多数据，并询问用户是否继续操作。

10.4.8 407 代理认证要求

此状态码类似于401（未授权），但表示客户端必须先向代理进行认证。代理必须返回一个Proxy-Authenticate头字段（第14.33节），其中包含适用于请求资源的挑战。客户端可以用合适的Proxy-Authorization头字段（第14.34节）重复请求。HTTP认证机制详见《HTTP认证：基本和摘要访问认证》[43]。

10.4.9 408 请求超时

客户端未在服务器准备等待的时间内发出请求。客户端可以在任何稍后时间重复请求，且无需修改。

10.4.10 409 冲突

请求无法完成，因为与资源当前状态存在冲突。此状态码仅在用户可能解决冲突并重新提交请求的情况下使用。响应体应包含足够的信息，让用户识别冲突的源头。理想情况下，响应实体应包含足够信息，帮助用户或用户代理修正问题，但这并非强制。

冲突最常发生在处理PUT请求时。例如，若使用版本控制，且PUT的实体包含与之前（第三方）请求冲突的更改，服务器可能用409状态码表示无法完成请求。此时，响应实体可能包含两个版本之间差异的列表，格式由响应的Content-Type定义。

10.4.11 410 已移除

请求的资源在服务器上不再可用，且没有已知的转发地址。此状态被视为永久性。具有链接编辑能力的客户端应在用户确认后删除对请求URI的引用。如果服务器不知道或无法判断此状态是否为永久，应该使用404（未找到）状态码。除非另有指示，此响应可缓存。

410状态码主要用于网站维护，通知接收方资源已被故意移除，服务器希望删除对该资源的所有远程链接。这在限时促销服务或不再由原工作人员管理的资源中较为常见。无需将所有永久不可用的资源都标记为“已移除”或长时间保持此标记，具体由服务器所有者决定。

10.4.12 411 需要内容长度

服务器拒绝接受没有定义Content-Length的请求。客户端可以在请求中添加有效的Content-Length头字段（包含消息体长度）后重试。

10.4.13 412 预条件失败

请求头中的一个或多个预条件在服务器测试时为假。此状态码允许客户端对资源的元信息（头字段）设置预条件，从而避免将请求方法应用于非预期的资源。

10.4.14 413 请求实体过大

请求实体超过服务器愿意或能够处理的大小，服务器可能会关闭连接以阻止客户端继续请求。如果此情况是临时的，服务器应在响应中包含Retry-After头字段，指示临时状态及客户端可再次尝试的时间。

10.4.15 414 请求URI过长

请求被拒绝，因为请求URI超出服务器能理解的长度。此情况极少发生，通常在客户端错误地将POST请求转为带有长查询信息的GET请求，或在URI重定向中出现“黑洞”情况，或服务器受到利用固定长度缓冲区的安全漏洞攻击时发生。

10.4.16 415 不支持的媒体类型

请求被拒绝，因为请求实体的格式不被目标资源支持，或不支持用于该请求方法。

10.4.17 416 请求范围不满足

如果请求包含Range头字段（第14.35节），且该范围的任何部分都不与当前资源范围重叠，且请求未包含If-Range头字段，服务器应返回此状态码（对于字节范围，意味着所有范围的起始字节位置都大于当前资源长度）。当返回此状态码时，响应应包含Content-Range实体头，指明当前资源的长度（见第14.16节），且不得使用multipart/byteranges内容类型。

10.4.18 417 期望未满足

请求中的Expect头字段（第14.20节）所表达的期望未被服务器满足，或者如果服务器是代理，则有明确证据表明下一跳服务器无法满足该请求。

10.5 服务器错误5xx

以“5”开头的状态码表示服务器已意识到自身出错或无法完成请求。除非响应HEAD请求，服务器应包含一个实体，说明错误情况及其临时或永久性质。用户代理应向用户显示该实体内容。这些状态码适用于任何请求方法。

10.5.1 500 内部服务器错误

服务器遇到未预料的情况，阻止其完成请求。

10.5.2 501 未实现

服务器不支持完成请求所需的功能。当服务器不识别请求方法，且无法支持任何资源时，应返回此状态码。

10.5.3 502 错误的网关

作为网关或代理的服务器，从上游服务器收到无效响应，未能完成请求。

10.5.4 503 服务不可用

服务器暂时无法处理请求，可能由于过载或维护。此为临时状态，稍后会恢复。若已知延迟时间，可在Retry-After头中指明。若未提供，客户端应按处理500状态码的方式处理。

注意：存在503状态码并不意味着服务器必须在过载时使用它，某些服务器可能会选择直接拒绝连接。

10.5.5 504 网关超时

作为网关或代理的服务器未能及时从上游服务器（如HTTP、FTP、LDAP）或其他辅助服务器（如DNS）获得响应，导致请求未完成。

注意：一些已部署的代理在DNS超时时会返回400或500。

10.5.6 505 不支持的HTTP版本

服务器不支持或拒绝支持请求中使用的HTTP协议版本。表示服务器无法或不愿意用与客户端相同的主版本完成请求（详见第3.1节），除非返回此错误。响应应包含说明为何不支持该版本及支持的其他协议的实体。

11 访问认证

HTTP提供多种可选的挑战-响应认证机制，供服务器向客户端发起认证挑战，以及客户端提供认证信息。访问认证的基本框架，以及“基本”和“摘要”认证的规范，详见《HTTP认证：基本和摘要访问认证》[43]。本规范采用该文档中的“挑战”和“凭据”定义。

12 内容协商

大多数HTTP响应都包含一个实体，供人类用户理解。理想情况下，应提供“最佳可用”实体以满足请求。不幸的是，不是所有用户对“最佳”有相同偏好，也不是所有用户代理都能平等渲染所有实体类型。因此，HTTP定义了多种“内容协商”机制——在存在多种表示时，选择最优表示的过程。

注意：这里不称为“格式协商”，因为备选表示可能具有相同的媒体类型，但使用不同的功能、不同的语言等。

任何包含实体主体的响应都可能进行协商，包括错误响应。

HTTP中有两种内容协商方式：服务器驱动和代理驱动。这两者是正交的，可以单独使用，也可以结合使用。一种结合方式称为透明协商，即缓存利用由源服务器提供的代理驱动信息，为后续请求提供服务器驱动的协商。

12.1 服务器驱动协商

如果响应的最佳表示由服务器端的算法决定，则称为服务器驱动协商。选择依据响应的不同表示（如语言、内容编码等）以及请求中的特定头字段或其他相关信息（如客户端的网络地址）进行。

服务器驱动协商的优势在于：当从多种表示中选择的算法难以向用户代理描述，或服务器希望在首次响应中就向客户端提供“最佳猜测”以避免后续请求的往返延迟时。为了优化服务器的猜测，用户代理可以在请求中加入描述偏好的请求头（Accept、Accept-Language、Accept-Encoding等）。

服务器驱动协商也存在一些缺点：

1. 服务器无法准确判断对任何特定用户来说“最佳”的内容，因为这需要完全了解用户代理的能力以及响应的预期用途（例如，用户是希望在屏幕上查看还是打印在纸上？）。

2. 在每个请求中让用户代理描述其能力，既可能非常低效（因为只有少部分响应具有多种表现形式），又可能侵犯用户隐私。

3. 这会增加源服务器的实现复杂性，以及生成响应算法的复杂度。

4. 这可能限制公共缓存使用相同响应满足多个用户请求的能力。

HTTP/1.1包括以下请求头字段，用于通过描述用户代理能力和用户偏好实现由服务器驱动的协商：Accept（第14.1节）、Accept-Charset（第14.2节）、Accept-Encoding（第14.3节）、Accept-Language（第14.4节）以及User-Agent（第14.43节）。然而，源服务器并不局限于这些维度，可以根据请求的任何方面调整响应，包括请求头字段之外的信息或未在本规范中定义的扩展头字段。

Vary头字段可以用来表达服务器用以选择表现形式的参数，这些表现形式受服务器驱动的协商影响。关于缓存如何使用Vary头字段，请参见第13.6节；关于服务器如何使用Vary头字段，请参见第14.44节。

12.2 代理驱动的协商

在代理驱动的协商中，响应的最佳表现形式由用户代理在收到源服务器的初始响应后进行选择。选择依据是初始响应中包含的多个表现形式的列表，每个表现形式由其自身的URI标识。用户代理可以自动选择（如果具备此能力）或由用户通过生成的（可能是超文本的）菜单手动选择。

当响应在常用维度（如类型、语言或编码）上会变化，且源服务器无法通过检查请求确定用户代理的能力，或者在使用公共缓存分担服务器负载、减少网络使用时，代理驱动的协商具有优势。

代理驱动的协商的缺点是需要发出第二个请求以获得最佳的备用表现形式。只有在使用缓存时，这个第二个请求才是高效的。此外，本规范未定义支持自动选择的机制，但也不阻止开发者将此类机制作为扩展在HTTP/1.1中使用。

HTTP/1.1定义了状态码300（多重选择）和406（不可接受），以在服务器不愿或无法通过服务器驱动的协商提供变化的响应时启用代理驱动的协商。

12.3 透明协商

透明协商结合了服务器驱动和代理驱动的协商方式。当缓存获得了响应的表现形式列表（如在代理驱动协商中）且缓存完全理解变化的维度时，缓存可以代表源服务器为后续请求执行服务器驱动的协商。

透明协商的优点在于分担了本应由源服务器完成的协商工作，并在缓存能正确猜测出合适响应时，避免了代理驱动协商中第二次请求的延迟。

本规范未定义任何透明协商的机制，但也不阻止开发者将此类机制作为扩展在HTTP/1.1中实现。

13. HTTP中的缓存

HTTP通常用于分布式信息系统，通过使用响应缓存可以提升性能。HTTP/1.1协议包含多种元素，旨在使缓存工作达到最佳效果。由于这些元素与协议的其他方面密不可分、相互作用，单独描述HTTP的基本缓存设计比详细介绍方法、头字段、响应码等更为有用。

如果缓存不能显著提升性能，缓存的作用将变得毫无意义。HTTP/1.1中缓存的目标是：在许多情况下避免发出请求，在其他许多情况下避免传输完整响应。前者减少了网络往返次数（通过“过期”机制实现，见第13.2节）；后者减少了网络带宽的需求（通过“验证”机制实现，见第13.3节）。

性能、可用性和离线操作的需求使我们必须在必要时放宽语义透明性的目标。HTTP/1.1协议允许源服务器、缓存和客户端在必要时明确降低透明性。然而，由于非透明操作可能会让非专家用户困惑，也可能与某些服务器应用（如订单处理）不兼容，协议规定：

- 只有在客户端或源服务器明确请求的情况下，才能在协议层面放宽透明性；
- 只有在缓存或客户端明确警告的情况下，才能在放宽时通知最终用户。

因此，HTTP/1.1提供了以下重要机制：

1. 在所有参与方都要求的情况下，提供完全语义透明的协议特性。

2. 允许源服务器或用户代理明确请求和控制非透明操作的协议特性。

3. 允许缓存对不完全保持语义透明性要求的响应附加警告。

基本原则是，客户端必须能够检测到任何潜在的语义透明性放宽。

注意：服务器、缓存或客户端的实现者可能会面临本规范未明确讨论的设计决策。如果某个决策可能影响语义透明性，除非经过仔细且完整的分析显示打破透明性带来显著好处，否则实现者应倾向于保持透明性。

13.1.1 缓存正确性

正确的缓存必须对请求作出响应，使用缓存中最适合该请求的最新响应（参见第13.2.5、13.2.6和13.12节），且满足以下条件之一：

1. 通过与源服务器重新验证响应，确认其与源服务器返回的内容等价（第13.3节）；

2. 该响应“足够新鲜”（第13.2节）。在默认情况下，这意味着它满足客户端、源服务器和缓存中最不严格的“新鲜度”要求（第14.9节）；如果源服务器特别说明，则仅满足源服务器的“新鲜度”要求。

如果存储的响应不符合客户端和源服务器中最严格的“新鲜度”要求，在经过慎重考虑的情况下，缓存仍可在符合条件时返回该响应，并附加适当的Warning头（见第13.1.5节和14.46节），除非此类响应被禁止（例如，由“no-store”缓存指令或“no-cache”请求指令禁止，见第14.9节）。

3. 响应是合适的304（未修改）、305（代理重定向）或4xx/5xx错误响应。

如果缓存无法与源服务器通信，正确的缓存应在响应可以从缓存正确提供的情况下，按上述方式响应；否则，应返回错误或警告，指示通信失败。

当缓存收到一个响应（完整响应或304响应）且该响应原本会转发给请求的客户端，但此响应已不再新鲜时，缓存应将其转发给请求客户端（不附加新Warning，但保留已有Warning头）。缓存不应仅因响应在传输中变得陈旧就重新验证该响应，以免陷入无限循环。用户代理收到无Warning的陈旧响应时，可以向用户显示警告。

13.1.2 警告

当缓存返回的响应既非第一手（直接来自源）也不“足够新鲜”（符合第13.1.1节条件2）时，必须在响应中附加警告，使用Warning通用头。Warning头及现有的警告定义详见第14.46节。警告允许客户端采取适当措施。

警告还可以用于其他目的，无论是缓存相关还是其他。使用警告而非错误状态码，可以将这些响应与真正的失败区分开。

警告由三位数字的warn-code组成。第一位数字表示在成功重新验证后，是否必须删除该警告：

- 1xx：描述响应的新鲜度或重新验证状态，成功重新验证后必须删除。1xx warn-code仅在验证缓存条目时生成，客户端不得生成。

- 2xx：描述实体主体或实体头的某些方面（如有损压缩），在成功重新验证后不得删除。

具体代码定义请参见第14.46节。

HTTP/1.0缓存会缓存所有警告，但不会删除第一类警告。传递给HTTP/1.0缓存的响应中的警告会带有额外的警告日期字段，以防止未来的HTTP/1.1接收者误信缓存中的错误警告。

警告还包含警告文本，可以用任何适当的自然语言（可能基于客户端的Accept头）描述，并可选择指明所用字符集。

响应中可以附加多个警告（由源服务器或缓存），包括相同代码的多个警告。例如，服务器可能用英语和巴斯克语提供相同的警告文本。

当响应附加多个警告时，可能不实际或不合理将所有警告都显示给用户。此版本的HTTP未规定严格的优先级规则，也未规定应按何种顺序显示警告，但提供一些启发式建议。

13.1.3 缓存控制机制

HTTP/1.1中的基本缓存机制（由服务器指定的过期时间和验证器）是隐式指令，传达给缓存。在某些情况下，服务器或客户端可能需要提供明确的指令给HTTP缓存。为此，我们使用Cache-Control头。

Cache-Control头允许请求或响应中传递多种指令。这些指令通常会覆盖默认的缓存算法。一般而言，如果头字段值之间存在明显冲突，应采用最严格的解释（即最能保持语义透明性的那一项）。但在某些情况下，缓存控制指令会明确表示削弱语义透明性的近似（例如，“max-stale”或“public”）。

详细的缓存控制指令定义请参见第14.9节。

13.1.4 明确的用户代理警告

许多用户代理允许用户覆盖基本的缓存机制。例如，用户代理可能允许用户指定永不验证已缓存实体（即使它们已过期）。或者，用户代理可能习惯性地在每个请求中添加“Cache-Control: max-stale=3600”。用户代理不应默认采用非透明行为或导致缓存效率异常低下，但可以通过用户的明确操作进行配置。

如果用户覆盖了基本的缓存机制，用户代理应在每次出现可能不符合服务器透明性要求（尤其是当显示的实体被知晓为过时）信息时，明确向用户提示。由于协议通常允许用户代理判断响应是否过时，这种提示只需在实际发生时显示即可。提示方式不必是对话框，也可以是图标（例如一张腐烂的鱼的图片）或其他指示器。

如果用户以异常方式覆盖了缓存机制，导致缓存的效果明显降低，用户代理应持续向用户显示此状态（例如显示一张火焰中的货币图片），以防用户无意中消耗过多资源或遭遇过高延迟。

13.1.5 规则例外与警告

在某些情况下，缓存的操作员可以选择配置缓存，即使客户端未请求，也返回过期的响应。此决定不应轻率作出，但出于可用性或性能的考虑，尤其是在缓存与源服务器连接不良时，可能是必要的。每当缓存返回过期响应时，必须标记为过期（使用Warning头），以便客户端软件提醒用户可能存在的问题。

这也允许用户代理采取措施获取第一手或最新的响应。因此，除非出于技术或策略原因无法遵守，否则缓存不应在客户端明确请求第一手或新鲜响应时返回过期响应。

13.1.6 客户端控制的行为

虽然源服务器（以及在一定程度上，中间缓存，通过它们对响应年龄的贡献）是主要的过期信息来源，但在某些情况下，客户端可能需要控制缓存是否返回未验证的缓存响应。客户端通过Cache-Control头的多个指令实现这一点。

客户端请求可以指定其愿意接受的未验证响应的最大年龄；设置为零则强制缓存重新验证所有响应。客户端还可以指定响应到期前的最小剩余时间。这两种选项都增加了对缓存行为的限制，因此不能进一步放宽缓存对语义透明性的近似。

客户端还可以指定接受过期响应，最多允许一定的过期时间。这放宽了缓存的限制，可能违反源服务器关于语义透明性的要求，但在断开连接或连接不良时支持高可用性可能是必要的。

13.2 过期模型

13.2.1 由服务器指定的过期时间

HTTP缓存的最佳状态是缓存能完全避免向源服务器发起请求。避免请求的主要机制是由源服务器提供一个明确的未来过期时间，表明响应可以用来满足后续请求。换句话说，缓存可以在不联系服务器的情况下返回新鲜的响应。

我们预期服务器会为响应分配未来的明确过期时间，认为在此时间之前实体不会发生语义上显著的变化。这通常能保持语义透明，只要服务器的过期时间被谨慎选择。

此过期机制仅适用于从缓存中获取的响应，而不适用于立即转发给请求客户端的第一手响应。

如果源服务器希望强制要求语义透明的缓存每次都验证请求，可以将过期时间设置为过去的某个时间点。这意味着响应始终是过期的，缓存应在使用前验证它。详见第14.9.4节的更严格的强制重验证方法。

如果源服务器希望强制任何HTTP/1.1缓存都验证每个请求，应使用“must-revalidate”缓存控制指令（见第14.9节）。

源服务器通过Expires头或Cache-Control头的max-age指令指定明确的过期时间。

过期时间不能用来强制用户代理刷新显示或重新加载资源；其语义仅适用于缓存机制，且只有在发起新请求时，缓存机制才需检查资源的过期状态。详见第13.13节关于缓存与历史机制的区别。

13.2.2 启发式过期

由于源服务器不总是提供明确的过期时间，HTTP缓存通常会采用启发式算法，利用其他头字段（如Last-Modified）估算合理的过期时间。HTTP/1.1规范没有规定具体算法，但对其结果设有限制。由于启发式过期可能影响语义透明性，应谨慎使用，鼓励源服务器尽可能提供明确的过期时间。

13.2.3 过期时间的计算

为了判断缓存条目是否新鲜，需比较其“新鲜期”与“年龄”。第13.2.4节将介绍如何计算“新鲜期”；本节描述如何计算响应或缓存条目的“年龄”。

在此讨论中，使用“now”表示“执行计算的主机当前的时钟值”。使用HTTP的主机（尤其是源服务器和缓存）应通过NTP或类似协议同步其时钟到全球标准时间。

HTTP/1.1要求源服务器尽可能在每个响应中包含Date头，指示响应生成的时间（见第14.18节）。用“date_value”表示Date头的值，适合进行算术运算。

HTTP/1.1用Age响应头表示从缓存中获取响应的估算年龄。Age字段值是缓存估算的自响应生成或重新验证以来经过的时间。

本质上，Age值是响应在从源服务器到各个缓存的路径上驻留的时间总和，加上沿网络路径传输的时间。

用“age_value”表示Age头的值，适合算术运算。

响应的年龄可以通过两种完全独立的方法计算：

1. 现在时间减去date_value（前提是本地时钟与源服务器的时钟同步良好）。若结果为负，则置为零。

2. age_value（所有沿路径的缓存都实现了HTTP/1.1）。

结合这两种方法，可以得出：

    corrected_received_age = max(现在时间 - date_value, age_value)

只要时钟几乎同步或路径上所有缓存都支持HTTP/1.1，就能得到可靠（保守的）结果。

由于网络延迟，响应生成到被下一缓存或客户端接收之间可能会有显著的时间差。如果不校正，这可能导致年龄估算偏低。

因为引发Age值的请求在Age值生成之前已发出，所以可以通过记录请求发出的时间来校正网络延迟。收到Age值时，必须以请求发出时间为基准，而非响应到达时间。

此算法确保在任何延迟情况下都表现出保守行为。具体计算如下：

    corrected_initial_age = corrected_received_age + (现在时间 - 请求发出时间)

其中，“请求发出时间”是根据本地时钟记录的，指引发此响应的请求发出的时间。

当缓存收到响应时，年龄计算的总结：

``` 
/* 
 * age_value
 *      是缓存从响应中收到的Age头的值
 * date_value
 *      是源服务器的Date头的值
 * request_time
 *      是缓存发出引发此响应的请求的本地时间
 * response_time
 *      是缓存收到响应的本地时间
 * now
 *      是当前本地时间
 */

apparent_age = max(0, response_time - date_value);
corrected_received_age = max(apparent_age, age_value);
response_delay = response_time - request_time;
corrected_initial_age = corrected_received_age + response_delay;
resident_time = now - response_time;
current_age = corrected_initial_age + resident_time;
```

缓存条目的当前年龄是将自上次由源服务器验证以来的时间（秒）加到corrected_initial_age上。当响应由缓存生成时，必须在响应中包含一个Age头，其值等于该缓存条目的当前年龄。

响应中存在Age头意味着响应不是第一手的，但反之不成立。因为响应中没有Age头，并不意味着响应一定是第一手的，除非请求路径上的所有缓存都符合HTTP/1.1（即旧的HTTP缓存未实现Age头）。

13.2.4 过期时间的计算

为了判断响应是否新鲜或过期，需要将其“新鲜期”与“年龄”进行比较。年龄的计算在第13.2.3节已述，此节介绍如何计算“新鲜期”以及判断响应是否已过期。以下讨论中，相关值可以采用任何适合算术运算的形式。

用“expires_value”表示Expires头的值，用“max_age_value”表示响应中Cache-Control头的max-age指令的秒数值（见第14.9.3节）。

max-age指令优先于Expires，因此如果响应中有max-age，则新鲜期为：

    freshness_lifetime = max_age_value

否则，如果响应中有Expires头，则新鲜期为：

    freshness_lifetime = expires_value - date_value

这两个计算都不受时钟偏差影响，因为所有信息都来自源服务器。

如果响应中既没有Expires，也没有Cache-Control的max-age或s-maxage（见第14.9.3节），且响应没有其他缓存限制，则缓存可以采用启发式方法估算新鲜期。若响应年龄超过24小时，缓存必须附加Warning 113。

此外，如果响应有Last-Modified时间，启发式过期值应不超过自该时间起的某个比例（如10%）。此比例的典型值为10%。

判断响应是否过期的计算非常简单：

    response_is_fresh = (freshness_lifetime > current_age)

以上即为缓存响应是否仍然新鲜的判定依据。

如果一个客户端在执行检索时，收到一个非第一手的响应，而该请求在其自身缓存中已经是最新的，并且其现有缓存条目中的Date头比新响应中的Date头更新，那么客户端可以忽略该响应。如果选择忽略，它可以用“Cache-Control: max-age=0”指令（参见第14.9节）重新尝试请求，以强制与源服务器进行核查。

如果缓存中存在两个针对同一表示的响应，且这两个响应具有不同的验证器，但都为新鲜状态，则必须使用具有较新Date头的那个响应。这种情况可能发生在缓存从其他缓存中汇总响应，或因为客户端请求重新加载或重新验证一个表面上新鲜的缓存条目。

13.2.6 消除多重响应的歧义

由于客户端可能通过多条路径接收响应，某些响应经过一组缓存，而其他响应经过另一组缓存，因此客户端可能会以不同于源服务器发送的顺序接收响应。我们希望客户端使用最新生成的响应，即使较旧的响应仍然看似新鲜。

实体标签（ETag）和过期时间（Expires）都不能用来对响应进行排序，因为可能存在后续响应故意携带早于之前响应的过期时间的情况。Date值的排序精度为一秒。

当客户端尝试重新验证缓存条目时，如果收到的响应中的Date头比现有条目的Date头更早，则客户端应无条件重复请求，并加入以下指令：

- `Cache-Control: max-age=0`，以强制中间缓存直接与源服务器验证其副本；
- 或 `Cache-Control: no-cache`，以强制中间缓存从源服务器获取新副本。

如果Date值相等，客户端可以选择使用任意响应（或者如果非常谨慎，也可以请求一个新的响应）。服务器不得依赖客户端在同一秒内生成的响应中能够确定性地选择。

13.3 验证模型

当缓存中有过期的条目，且希望用作响应客户端请求时，必须先与源服务器（或可能是具有新鲜响应的中间缓存）核查，以确认缓存条目是否仍可用。我们称之为“验证”缓存条目。为了避免在缓存条目有效时重新传输完整响应的开销，也避免在无效时多出一次往返，HTTP/1.1协议支持条件请求。

支持条件请求的关键特性是“缓存验证器”。当源服务器生成完整响应时，会附加某种验证器（如实体标签或Last-Modified时间），并与缓存条目一同保存。当客户端（用户代理或代理缓存）对已缓存的资源发起条件请求时，会在请求中包含相关验证器。

服务器随后会用该验证器与当前实体的验证器进行比对，如果匹配（见13.3.3节），则返回状态码304（未修改）且无实体主体；否则返回完整响应（包括实体主体）。这样可以避免在验证成功时传输完整响应，验证失败时避免多余的往返。

在HTTP/1.1中，条件请求与普通请求相同，唯一不同的是它携带一个特殊的头部（包含验证器），隐式将请求方法（通常为GET）变为条件请求。

协议支持正向和负向的缓存验证条件。也就是说，可以请求在验证器匹配时执行某个操作，或者在验证器不匹配时执行。

注意：没有验证器的响应仍然可以被缓存，并在到期前从缓存中提供，除非被明确的缓存控制指令禁止。然而，如果没有验证器，缓存就无法进行条件检索，也就无法在到期后进行刷新。

13.3.1 Last-Modified日期

Last-Modified实体头字段常用作缓存验证器。简单来说，如果实体自Last-Modified值以来未被修改，则缓存条目被视为有效。

13.3.2 实体标签（ETag）缓存验证器

ETag响应头字段（实体标签）提供了一种“模糊”的缓存验证器。在不便存储修改日期、HTTP日期值的秒级分辨率不足，或源服务器希望避免由修改日期引发的某些悖论的情况下，这可能更可靠。实体标签在第3.11节中描述，相关头部在第14.19、14.24、14.26和14.44节中说明。

13.3.3 弱验证器与强验证器

由于源服务器和缓存会比较两个验证器以判断是否代表同一实体，通常期望实体（实体主体或任何实体头）发生任何变化时，验证器也会变化。如果是这样，则称之为“强验证器”。

但也存在某些情况下，服务器倾向于只在语义上重要的变化时才更改验证器，而在无关紧要的实体变化时保持不变。这种不总是变化的验证器称为“弱验证器”。

实体标签通常是“强验证器”，但协议提供机制将实体标签标记为“弱”。可以理解为：强验证器在实体内容每次变化时都会变化，而弱验证器在实体语义变化时才会变化。或者，强验证器是特定实体的标识符的一部分，弱验证器则是语义等价实体集合的标识符。

示例：每次实体在稳定存储中更改时递增的整数，可以作为强验证器。

实体的修改时间（以秒为单位）也可以作为弱验证器，因为在一秒内实体可能被修改多次。

支持弱验证器是可选的，但它允许更高效地缓存等价对象。例如，一个网站的访问计数器每隔几天或几周更新一次，期间的任何值都“足够好”作为验证器。

验证器的“使用”包括：客户端在请求中包含验证器（生成验证请求），或服务器比较两个验证器。

强验证器在任何场景下都可用。弱验证器只在不依赖实体内容完全相等的场景中使用。例如，完整实体的条件GET可以使用任何验证器，但子范围检索（partial content）只应使用强验证器，以避免客户端获得内部不一致的实体。

客户端可以在非子范围的GET请求中使用弱或强验证器，但不得在其他请求中使用弱验证器。

HTTP/1.1协议唯一定义的验证器操作是比较。比较函数有两种，取决于是否允许使用弱验证器：

- 强比较：两个验证器必须在所有方面完全相同，且都不能是弱验证器，才能视为相等；
- 弱比较：两个验证器必须在所有方面完全相同，但可以标记为“弱”，不影响结果。

实体标签默认是强验证器，除非明确标记为弱。第3.11节给出了实体标签的语法。

当用作验证器的Last-Modified时间（请求中）除非可以推断为强验证器，否则默认为弱验证器，遵循以下规则：

- 由源服务器与实体的当前验证器比较；
- 源服务器可靠地知道在验证器所覆盖的时间段内，实体未被修改两次；
- 或客户端在If-Modified-Since或If-Unmodified-Since头中使用，且缓存条目中的Date值表示源服务器发送原始响应的时间，且Last-Modified时间至少比Date值早60秒；
- 或中间缓存与其存储的验证器比较，且缓存条目中的Date值表示源服务器发送原始响应的时间，且Last-Modified时间至少比Date值早60秒。

此方法基于：如果源服务器在同一秒内发送了两个不同响应，但它们的Last-Modified时间相同，则至少有一个响应的Date值等于其Last-Modified时间。60秒的限制用以防止Date和Last-Modified值由不同的时钟或不同时间点生成。实现可以使用大于60秒的值。

如果客户端希望对只有Last-Modified时间且没有模糊验证器的值进行子范围检索，必须确保Last-Modified时间在此定义下是强验证器。

接收条件请求（非完整GET请求）的缓存或源服务器，必须使用强比较函数来评估条件。

这些规则确保HTTP/1.1的缓存和客户端可以安全地对从HTTP/1.0服务器获得的值执行子范围检索。

13.3.4 使用实体标签和Last-Modified日期的规则

我们制定了一套规则和建议，指导源服务器、客户端和缓存在何时应使用各种验证器类型及其用途。

HTTP/1.1源服务器：

- 应该发送实体标签验证器，除非无法生成；
- 如果性能考虑支持弱实体标签，或无法发送强实体标签，可以发送弱实体标签；
- 如果可行，应发送Last-Modified值，除非使用该日期在If-Modified-Since头中可能引发严重的语义透明性问题。

换句话说，HTTP/1.1源服务器的首选行为是同时发送强实体标签和Last-Modified值。

为了合法，强实体标签在实体值任何变化时必须变化。弱实体标签应在实体发生语义上重要的变化时变化。

注意：为了提供语义透明的缓存，源服务器必须避免为两个不同的实体重复使用特定的强实体标签值，或为两个语义不同的实体重复使用特定的弱实体标签值。缓存条目可能会无限期存在，无论其过期时间如何，因此可能不适合期望缓存永远不会再次尝试使用其在过去某个时间点获得的验证器来验证条目。

HTTP/1.1 客户端：

- 如果源服务器提供了实体标签，必须在任何缓存条件请求中使用该实体标签（使用 If-Match 或 If-None-Match）。

- 如果源服务器只提供了 Last-Modified 值，建议在非子范围的缓存条件请求中使用该值（使用 If-Modified-Since）。

- 如果 HTTP/1.0 源服务器只提供了 Last-Modified 值，可能在子范围的缓存条件请求中使用该值（使用 If-Unmodified-Since）。用户代理应提供禁用此功能的方法，以防出现困难。

- 如果源服务器同时提供了实体标签和 Last-Modified 值，建议在缓存条件请求中同时使用这两个验证器。这允许 HTTP/1.0 和 HTTP/1.1 缓存正确响应。

当 HTTP/1.1 源服务器收到包含 Last-Modified 日期（如在 If-Modified-Since 或 If-Unmodified-Since 头字段中）以及一个或多个实体标签（如在 If-Match、If-None-Match 或 If-Range 头字段中）作为缓存验证器的条件请求时，除非所有条件头字段都一致，否则不得返回状态码 304（未修改）。

当 HTTP/1.1 缓存代理收到包含 Last-Modified 日期和一个或多个实体标签作为缓存验证器的条件请求时，除非所有条件头字段都一致，否则不得返回本地缓存的响应。

注意：这些规则背后的基本原则是，HTTP/1.1 服务器和客户端应尽可能传输其响应和请求中所有可用的非冗余信息。接收此信息的 HTTP/1.1 系统将对所接收的验证器做出最保守的假设。

HTTP/1.0 客户端和缓存将忽略实体标签。通常，这些系统接收或使用的 Last-Modified 值将支持透明且高效的缓存，因此 HTTP/1.1 源服务器应提供 Last-Modified 值。在极少数情况下，使用 Last-Modified 作为验证器可能会导致严重问题，此时 HTTP/1.1 源服务器不应提供。

13.3.5 非验证条件

实体标签的原则是，只有服务作者自己充分了解资源语义，才能选择合适的缓存验证机制。任何比字节相等更复杂的验证器比较函数的定义都可能引发问题。因此，除了为了兼容 HTTP/1.0 而使用 Last-Modified 之外，其他任何头字段的比较（用于验证缓存条目）都不被采用。

13.4 响应的缓存性

除非由缓存控制（第14.9节）指令明确限制，否则缓存系统可以始终将成功响应（参见第13.8节）存储为缓存条目，如果响应是新鲜的，可以直接返回而无需验证，或者在验证成功后返回。如果响应没有缓存验证器或明确的过期时间，我们不期望它被缓存，但某些缓存可能会违反这一预期（例如，在网络连接几乎不可用时）。客户端通常可以通过比较 Date 头字段与当前时间，检测响应是否来自缓存。

注意：一些 HTTP/1.0 缓存已知会在未提供任何 Warning 的情况下违反此预期。

然而，在某些情况下，缓存保留实体或在后续请求中返回实体可能不合适。这可能是因为服务作者认为必须绝对语义透明，或出于安全或隐私考虑。因此，提供某些缓存控制指令，让服务器可以指示某些资源实体或其部分不应被缓存，无论其他考虑因素如何。

注意：第14.8节通常阻止共享缓存保存并返回包含授权头的先前请求的响应。

状态码为 200、203、206、300、301 或 410 的响应可以被缓存并用于后续请求，前提是未被缓存控制指令禁止缓存，且符合过期机制。然而，不支持 Range 和 Content-Range 头的缓存不得缓存 206（部分内容）响应。

任何其他状态码（如 302 和 307）返回的响应，除非有明确的缓存控制指令或其他头字段允许，否则不得在后续请求中返回。例如，以下情况允许缓存：存在 Expires 头（第14.21节）；存在 "max-age"、"s-maxage"、"must-revalidate"、"proxy-revalidate"、"public" 或 "private" 的缓存控制指令（第14.9节）。

13.5 从缓存构造响应

HTTP 缓存的目的是存储响应中接收的信息，以便在未来的请求中使用。在许多情况下，缓存会直接返回响应的相关部分给请求者。然而，如果缓存基于之前的响应存储了缓存条目，可能需要将新响应的部分内容与缓存中的内容结合。

13.5.1 端到端和跳跃头字段

为了定义缓存和非缓存代理的行为，我们将 HTTP 头字段分为两类：

- 端到端头字段，传递给请求或响应的最终接收者。响应中的端到端头字段必须作为缓存条目的一部分存储，并在由缓存条目形成的任何响应中传输。

- 跳跃头字段，仅在单一传输层连接中有意义，不由缓存存储，也不由代理转发。

以下是 HTTP/1.1 中的跳跃头字段：

- Connection
- Keep-Alive
- Proxy-Authenticate
- Proxy-Authorization
- TE
- Trailers
- Transfer-Encoding
- Upgrade

其他由 HTTP/1.1 定义的头字段均为端到端头字段。

所有未列出的头字段，除非在连接头（第14.10节）中列出，否则为端到端头字段。

其他跳跃头字段必须在连接头中列出，以引入到 HTTP/1.1（或更高版本）。

13.5.2 不可修改的头字段

某些 HTTP/1.1 特性（如摘要认证）依赖于特定的端到端头字段值。透明代理不应修改这些端到端头字段，除非定义或特别允许。

透明代理不得修改请求或响应中的以下字段，也不得添加这些字段（除非已存在）：

- Content-Location
- Content-MD5
- ETag
- Last-Modified

在响应中，不得修改以下字段：

- Expires

但可以添加这些字段（如果未存在），如果添加了 Expires 头，其值必须与响应中的 Date 头相同。

对于包含 no-transform 缓存控制指令的消息，代理不得修改或添加以下字段：

- Content-Encoding
- Content-Range
- Content-Type

非透明代理可以修改或添加这些字段（不含 no-transform），但如果这样做，必须添加 Warning 214（已应用转换）头（见第14.46节）。

警告：不必要地修改端到端头字段可能会导致认证失败，尤其是在后续版本的 HTTP 引入更强的认证机制时。这些机制可能依赖未列出的头字段值。

请求或响应的 Content-Length 字段由第4.4节规则添加或删除。透明代理必须保持实体主体的实体长度（第7.2.2节），但可以更改传输长度（第4.4节）。

13.5.3 组合头字段

当缓存向服务器发出验证请求，且服务器返回 304（未修改）或 206（部分内容）响应时，缓存会构造响应以返回给请求的客户端。

如果状态码为 304，缓存使用存储在缓存条目中的实体主体作为响应的实体主体。如果状态码为 206 且 ETag 或 Last-Modified 头字段完全匹配，缓存可以将存储在缓存中的内容与新响应中的内容结合，作为响应的实体主体（见13.5.4节）。

存储在缓存中的端到端头字段用于构造的响应，但：

- 任何 warn-code 为 1xx 的 Warning 头必须从缓存条目和转发的响应中删除。

- 任何 warn-code 为 2xx 的 Warning 头必须保留在缓存条目和转发的响应中。

- 由 304 或 206 响应提供的端到端头字段必须替换缓存条目中的对应头字段。

除非缓存决定删除缓存条目，否则还必须用收到的响应中的对应端到端头字段替换存储在缓存中的端到端头字段（除了上述 Warning 头之外）。如果收到的响应中某个头字段名在缓存条目中出现多次，所有旧的头都必须被替换。

换句话说，收到的响应中的端到端头字段集会覆盖存储在缓存条目中的所有对应端到端头字段（除了 warn-code 为 1xx 的 Warning 头会被删除，即使未被覆盖）。

注意：此规则允许源服务器使用 304（未修改）或 206（部分内容）响应，更新与同一实体或其子范围相关的任何头字段，尽管这样做可能并不总是有意义或正确。此规则不允许源服务器用 304 或 206 响应完全删除之前响应中提供的某个头字段。

13.5.4 组合字节范围

响应可能只传输实体主体的某个子范围，原因包括请求中包含 Range 规格，或连接提前中断。经过多次此类传输后，缓存可能已接收同一实体的多个范围。

如果缓存中存有非空的子范围集合，且新响应传输了另一个子范围，且满足以下条件，则可以将新子范围与已有集合结合：

- 两者都具有缓存验证器。

- 两个验证器通过强比较函数匹配（见13.3.3节）。

如果不满足任一条件，缓存必须只使用最新的部分响应（基于每个响应中传输的 Date 值，若相等或缺失则使用新响应），并丢弃其他部分信息。

13.6 缓存协商响应

使用服务器驱动的内容协商（第12.1节），由响应中的 Vary 头字段指示，会改变缓存使用响应进行后续请求的条件和流程。关于服务器如何使用 Vary 头字段，详见第14.44节。

一台服务器应使用 Vary 头字段来通知缓存哪些请求头字段被用来在多种可缓存响应的表示之间进行选择，这些响应受服务器驱动的协商控制。由 Vary 字段值所命名的请求头字段集合被称为“选择性”请求头。

当缓存收到一个后续请求，其 Request-URI 指定了包含 Vary 头字段的一个或多个缓存条目时，除非新请求中的所有选择性请求头都与原始请求中存储的对应请求头匹配，否则缓存不得使用该缓存条目来构建响应。

如果两个请求的选择性请求头定义为匹配，条件是第一个请求中的选择性请求头可以通过添加或删除允许的线性空白（LWS）或合并多个具有相同字段名的消息头字段（遵循第4.2节关于消息头的规则）来转换为第二个请求中的选择性请求头。

对于值为“*”的 Vary 头字段，总是无法匹配，且对该资源的后续请求只能由原始服务器正确解释。

如果缓存中的请求头字段与新请求的请求头字段不匹配，除非缓存首先将新请求作为条件请求转发到源服务器，并且服务器以 304（未修改）响应（包括指示要使用的实体标签或内容位置的实体标签或 Content-Location），否则缓存不得使用该缓存条目满足请求。

如果为缓存表示分配了实体标签，转发的请求应为条件请求，并在所有缓存条目中包含对应资源的实体标签在 If-None-Match 头字段中。这向服务器传达了缓存当前持有的实体集合，以便如果其中任何一个实体与请求的实体匹配，服务器可以在其 304（未修改）响应中使用 ETag 头字段告诉缓存哪个条目是合适的。如果新响应的实体标签与现有条目的实体标签匹配，则应使用新响应更新现有条目的头字段，且结果必须返回给客户端。

如果任何现有缓存条目只包含部分内容的实体，其实体标签不应包含在 If-None-Match 头字段中，除非请求范围完全由该条目满足。

当缓存收到一个成功响应，其 Content-Location 字段与现有缓存条目（请求 URI 相同）匹配，但实体标签不同且日期更近时，现有条目不应在未来请求中返回，应从缓存中删除。

13.7 共享与非共享缓存

出于安全和隐私考虑，有必要区分“共享”与“非共享”缓存。非共享缓存仅对单一用户可访问，应通过适当的安全机制加以保障。所有其他缓存都视为“共享”。本规范的其他部分对共享缓存的操作提出了某些限制，以防止隐私泄露或访问控制失效。

13.8 错误或不完整响应的缓存行为

接收不完整响应（例如，内容长度少于 Content-Length 头指定的字节数）的缓存可以存储该响应，但必须视为部分响应。部分响应可以按照第13.5.4节的描述进行合并，结果可能是完整响应，也可能仍是部分响应。缓存不得在未明确标记为部分响应（使用 206（部分内容）状态码）的情况下返回部分响应，也不得使用 200（OK）状态码返回部分响应。

当缓存在尝试重新验证条目时收到 5xx 响应时，可以选择将此响应转发给请求客户端，或视为服务器未响应。在后者情况下，可以返回之前接收的响应，除非缓存条目包含“must-revalidate”缓存控制指令（见第14.9节）。

13.9 GET 和 HEAD 方法的副作用

除非源服务器明确禁止缓存其响应，否则对任何资源应用 GET 和 HEAD 方法不应产生会导致缓存中响应被误用的副作用。它们可能仍有副作用，但缓存无需在缓存决策中考虑这些副作用。缓存应始终遵守源服务器关于缓存的明确限制。

有一个例外：由于一些应用传统上使用带查询字符串（在 rel_path 部分包含“?”）的 GET 和 HEAD 来执行具有显著副作用的操作，缓存不得将此类 URI 的响应视为新鲜，除非服务器提供明确的过期时间。这意味着，来自 HTTP/1.0 服务器的此类 URI 的响应不应从缓存中取出（详见第9.1.1节）。

13.10 更新或删除后的失效

在源服务器上对资源执行某些方法可能导致一个或多个现有缓存条目变得非透明失效。也就是说，虽然它们可能仍被标记为“新鲜”，但它们不能准确反映源服务器对该资源新请求的返回内容。

HTTP 协议无法保证所有此类缓存条目都被标记为失效。例如，导致源服务器变更的请求可能未经过存有缓存条目的代理。然而，若干规则有助于减少错误行为的可能性。

“使实体失效”在此处意味着缓存要么删除所有该实体的实例，要么将其标记为“无效”，并在后续请求中强制重新验证。

某些 HTTP 方法必须导致缓存使实体失效，包括：

- PUT
- DELETE
- POST

为了防止拒绝服务攻击，基于 Location 或 Content-Location 头中的 URI 进行的失效操作，必须仅在主机部分与请求 URI 相同时才执行。

对于不理解的方法请求，缓存应使请求 URI 所指的任何实体失效。

13.11 强制写入

所有可能引起源服务器资源修改的方法，必须在传递到源服务器后再作出响应（即“写穿”）。目前包括除 GET 和 HEAD 之外的所有方法。缓存不得在将请求传送到源服务器并收到响应之前，向客户端回复此类请求。此规则不阻止代理在源服务器发出最终响应前，先发出 100（继续）响应。

“写回”或“复制回”缓存（即“写回”策略）在 HTTP/1.1 中不允许，因为难以保证一致性，且在写回前的服务器、缓存或网络故障可能导致数据不一致。

13.12 缓存替换

当从资源接收新的可缓存响应（参见第14.9.2、13.2.5、13.2.6和13.8节）时，如果同一资源已有缓存响应，缓存应使用新响应来应答当前请求。它可以将新响应存入缓存，并在满足所有其他条件的情况下，用它响应未来可能会返回旧响应的请求。若将新响应存入缓存，须遵守第13.5.3节的规则。

注意：新响应的日期头值若比已有缓存响应的日期更旧，则不可缓存。

13.13 历史列表

用户代理通常具有历史机制，如“后退”按钮和历史列表，用于重新显示会话中早期检索的实体。

历史机制与缓存不同。特别是，历史机制不应试图显示资源当前状态的语义透明视图，而应准确反映用户在检索时所见。

默认情况下，历史机制不应用过期时间。只要实体仍存储在缓存中，历史机制应显示它，即使实体已过期，除非用户特别配置代理以刷新过期的历史文档。

这不意味着历史机制不能告诉用户视图可能已过时。

注意：如果历史列表机制不必要地阻止用户查看过时资源，可能会迫使服务提供者避免使用 HTTP 的过期控制和缓存控制，从而影响缓存策略。服务提供者可能认为，用户在使用导航控件（如“后退”）查看已获取的资源时，不应出现错误或警告信息。虽然某些资源本应不缓存或应快速过期，但用户界面考虑可能迫使服务提供者采用其他手段（如“一次性”URL）以避免历史机制的缺陷。

注意：使用“q”参数名来区分媒体类型参数与Accept扩展参数是出于历史习惯。虽然这会阻止任何名为“q”的媒体类型参数与媒体范围一起使用，但鉴于IANA媒体类型注册表中没有“q”参数，也很少在Accept中使用任何媒体类型参数，因此这种情况被认为不太可能发生。未来注册的媒体类型不鼓励使用名为“q”的参数。

字段定义等内容请参见第100页。

RFC 2616  HTTP/1.1 1999年6月

示例

Accept: audio/*; q=0.2, audio/basic

应理解为“我偏好audio/basic，但如果在80%的质量折扣后没有更好的音频类型，也可以接受任何音频类型。”

如果没有提供Accept头字段，则假定客户端接受所有媒体类型。如果存在Accept头字段，且服务器无法提供符合该Accept字段值的响应，则服务器应返回406（不接受）状态码。

更详细的示例：

Accept: text/plain; q=0.5, text/html,
        text/x-dvi; q=0.8, text/x-c

口头理解为：“text/html和text/x-c是首选媒体类型，但如果不存在，则发送text/x-dvi实体；如果也不存在，则发送text/plain实体。”

媒体范围可以被更具体的媒体范围或具体的媒体类型覆盖。如果一个类型符合多个媒体范围，则优先级最高的最具体的引用具有优先权。例如：

Accept: text/*, text/html, text/html;level=1, */*

其优先级如下：

1) text/html;level=1
2) text/html
3) text/*
4) */*

与某一类型相关联的媒体类型质量因子由匹配该类型的最高优先级的媒体范围的质量值决定。例如：

Accept: text/*;q=0.3, text/html;q=0.7, text/html;level=1,
        text/html;level=2;q=0.4, */*;q=0.5

会对应以下值：

text/html;level=1 = 1
text/html = 0.7
text/plain = 0.3
image/jpeg = 0.5
text/html;level=2 = 0.4
text/html;level=3 = 0.7

注意：用户代理可能会为某些媒体范围提供默认的质量值集，但除非用户代理是一个无法与其他渲染代理交互的封闭系统，否则此默认集应由用户配置。

14.2 Accept-Charset

Accept-Charset请求头字段用于指示响应中可接受的字符集。该字段允许能够理解更全面或特殊用途字符集的客户端向支持这些字符集的服务器发出能力信号。

Accept-Charset = "Accept-Charset" ":" 1#( ( charset | "*" )[ ";" "q" "=" qvalue ] )

字符集值在第3.4节中描述。每个字符集可以附带一个质量值，表示用户对该字符集的偏好。默认值为q=1。例如：

Accept-Charset: iso-8859-5, unicode-1-1;q=0.8

如果Accept-Charset字段中存在特殊值“*”，则匹配所有未在该字段中明确提及的字符集（包括ISO-8859-1）。如果没有“*”，则未明确提及的字符集的质量值为0，除了ISO-8859-1（如果未明确提及，则其质量值为1）。

如果没有Accept-Charset头字段，则默认任何字符集都是可接受的。如果存在该字段，且服务器无法提供符合Accept-Charset的响应，则应返回406（不接受）状态码，尽管也允许返回不符合的响应。

14.3 Accept-Encoding

Accept-Encoding请求头字段类似于Accept，但限制响应中可接受的内容编码（第3.5节）。

Accept-Encoding = "Accept-Encoding" ":"
1#( codings [ ";" "q" "=" qvalue ] )
codings = ( content-coding | "*" )

示例用法：

Accept-Encoding: compress, gzip
Accept-Encoding:
Accept-Encoding: *
Accept-Encoding: compress;q=0.5, gzip;q=1.0
Accept-Encoding: gzip;q=1.0, identity; q=0.5, *;q=0

服务器根据Accept-Encoding字段的规则判断内容编码是否可接受：

1. 如果内容编码在Accept-Encoding列出的内容编码中，且其q值不为0，则接受；如果q值为0，则不接受。
2. Accept-Encoding中的“*”符号匹配所有未在字段中明确列出的内容编码。
3. 如果多个内容编码都可接受，则优先选择q值最高（非零）的内容编码。
4. “identity”内容编码始终可接受，除非明确拒绝（如字段中包括“identity;q=0”或“*;q=0”且未明确包括“identity”）。如果Accept-Encoding为空，则只接受“identity”。

如果请求中存在Accept-Encoding字段，且服务器无法提供符合该字段的响应，则应返回406状态码。

如果请求中没有Accept-Encoding字段，服务器可以假设客户端接受任何内容编码。在这种情况下，如果“identity”可用，服务器应优先使用“identity”，除非有其他信息表明使用不同的内容编码更有意义。

注意：如果请求不包含Accept-Encoding字段，且“identity”不可用，则优先使用HTTP/1.0客户端常识理解的内容编码（如“gzip”和“compress”）；某些旧客户端可能会错误显示其他内容编码的消息。服务器也可能根据用户代理或客户端的具体信息做出此决策。

14.4 Accept-Language

Accept-Language请求头类似于Accept，但限制响应中偏好的自然语言集合。语言标签定义在第3.10节。

Accept-Language = "Accept-Language" ":" 1#( language-range [ ";" "q" "=" qvalue ] )
language-range = ( ( 1*8ALPHA *( "-" 1*8ALPHA ) ) | "*" )

每个language-range可以附带一个质量值，表示用户对该范围内语言的偏好估计，默认q=1。例如：

Accept-Language: da, en-gb;q=0.8, en;q=0.7

意思是：“我偏好丹麦语，但也接受英式英语和其他英语变体。”一个language-range与一个语言标签匹配，如果它完全等于该标签，或如果它是该标签的前缀，且后续字符为“-”。如果Accept-Language中存在“*”，则匹配所有未被其他范围匹配的标签。

注意：前缀匹配规则不意味着语言标签被赋予某种语言的方式总是符合“理解某个标签的用户也一定理解所有以该标签为前缀的语言”。前缀规则只是允许在符合条件时使用前缀标签。

由Accept-Language字段分配给某个语言标签的质量因子，是该标签与字段中最长匹配范围的质量值。如果没有匹配范围，则质量值为0。若请求中没有Accept-Language头，则应假设所有语言都同样可接受。若存在Accept-Language头，且某些语言的质量值大于0，则这些语言被视为可接受。

向用户发送完整的语言偏好信息可能会侵犯隐私。详见第15.1.4节。鉴于理解能力高度依赖个人用户，建议客户端应用程序提供用户选择语言偏好的功能。如果未提供此功能，则请求中不得包含Accept-Language字段。

注意：在向用户提供语言偏好选择时，应提醒用户他们可能不熟悉上述的语言匹配细节，应提供相应指导。例如，用户可能会认为选择“en-gb”后，若没有英国英语文档，也会得到任何英语文档。用户代理可以建议添加“en”以获得更佳匹配。

14.5 Accept-Ranges

Accept-Ranges响应头允许服务器指示其是否接受范围请求：

Accept-Ranges = "Accept-Ranges" ":" acceptable-ranges
acceptable-ranges = 1#range-unit | "none"

支持字节范围请求的源服务器可以返回：

Accept-Ranges: bytes

但不是必须的。客户端可以在未收到此头的情况下发起字节范围请求。范围单位定义在第3.12节。

不支持任何范围请求的服务器可以返回：

Accept-Ranges: none

以告知客户端不要尝试范围请求。

14.6 Age

Age响应头字段传达发件人对响应（或其重新验证）在源服务器生成后经过时间的估算。缓存的响应如果其年龄不超过其新鲜度期限，则为“新鲜”。年龄值按第13.2.3节的规定计算。

Age = "Age" ":" age-value
age-value = delta-seconds

年龄值为非负十进制整数，表示秒数。

如果缓存收到的年龄值超过其能表示的最大正整数，或任何年龄计算溢出，则必须发送值为2147483648（2^31）的Age头字段。包含缓存的HTTP/1.1服务器必须在每个由其缓存生成的响应中包含Age字段。缓存应使用至少31位范围的算术类型。

14.7 Allow

Allow实体头列出由请求URI标识的资源支持的方法集。此字段的目的是通知接收者资源支持的有效方法。对于405（方法不允许）响应，必须包含Allow头。

Allow = "Allow" ":" #Method

示例：

Allow: GET, HEAD, PUT

此字段不能阻止客户端尝试其他方法，但应遵循Allow字段值所示的指示。实际允许的方法由源服务器在每次请求时定义。

在发出PUT请求时，Allow头也可以用来建议支持的方法。服务器不必支持这些方法，但应在响应中包含实际支持的方法。

代理服务器不得修改Allow头，即使它不理解所有列出的方法，因为用户代理可能有其他与源服务器通信的方式。

14.8 Authorization

希望进行身份验证的用户代理——通常在收到401响应后——通过在请求中包含Authorization请求头字段实现。Authorization字段的值由包含用户代理在请求资源的领域中的认证信息的凭据组成。

授权 = "Authorization" ":" credentials

HTTP访问认证在《HTTP认证：基本和摘要访问认证》[43]中有所描述。如果请求已通过认证且指定了realm，则在该realm内的所有其他请求应使用相同的凭据（前提是认证方案本身没有其他要求，例如凭据会根据挑战值变化或使用同步时钟）。

当共享缓存（参见第13.7节）收到包含Authorization字段的请求时，除非满足以下某一特定例外情况，否则不得将对应的响应作为对其他请求的回复：

1. 如果响应中包含"s-maxage"缓存控制指令，缓存可以在回复后续请求时使用该响应。但（如果指定的最大年龄已过）代理缓存必须先用新请求的请求头对其进行重新验证，以便源服务器验证新请求的身份（这是s-maxage的定义行为）。如果响应中包含"s-maxage=0"，代理必须在再次使用前始终重新验证。

2. 如果响应中包含"must-revalidate"缓存控制指令，缓存可以在回复后续请求时使用该响应。但如果响应已过期，所有缓存都必须先用新请求的请求头与源服务器重新验证，以便源服务器验证新请求。

3. 如果响应中包含"public"缓存控制指令，则可以在回复任何后续请求时返回。

---

字段定义，摘自RFC 2616第14.9节：缓存控制（Cache-Control）

缓存控制的通用头字段用于指定所有沿请求/响应链的缓存机制必须遵守的指令。这些指令旨在防止缓存对请求或响应产生不利干扰，通常会覆盖默认的缓存算法。缓存指令是单向的，即请求中出现某指令并不意味着响应中也必须包含相同指令。

注意：HTTP/1.0的缓存可能不支持Cache-Control，只支持Pragma: no-cache（见第14.32节）。

代理或网关应用必须传递所有缓存控制指令，无论其对应用的重要性如何，因为这些指令可能适用于请求/响应链上的所有接收者。不能为特定缓存指定缓存控制指令。

定义格式：
Cache-Control = "Cache-Control" ":" 1#cache-directive

cache-directive可以是：
- cache-request-directive（请求端的缓存指令）
- cache-response-directive（响应端的缓存指令）

请求端缓存指令包括：
- "no-cache"（第14.9.1节）
- "no-store"（第14.9.2节）
- "max-age"=delta-seconds（第14.9.3、14.9.4节）
- "max-stale"[ "=" delta-seconds ]（第14.9.3节）
- "min-fresh"=delta-seconds（第14.9.3节）
- "no-transform"（第14.9.5节）
- "only-if-cached"（第14.9.4节）
- cache-extension（第14.9.6节）

响应端缓存指令包括：
- "public"（第14.9.1节）
- "private"[ "=" <"> 1#field-name <"> ]（第14.9.1节）
- "no-cache"[ "=" <"> 1#field-name <"> ]（第14.9.1节）
- "no-store"（第14.9.2节）
- "no-transform"（第14.9.5节）
- "must-revalidate"（第14.9.4节）
- "proxy-revalidate"（第14.9.4节）
- "max-age"=delta-seconds（第14.9.3节）
- "s-maxage"=delta-seconds（第14.9.3节）
- cache-extension（第14.9.6节）

cache-extension = token [ "=" ( token | quoted-string ) ]

当指令没有任何1#field-name参数时，适用于整个请求或响应；如果带有参数，则只适用于指定的字段，不影响其他部分。这种机制支持扩展，未来版本的HTTP协议可能会将这些指令应用于未在HTTP/1.1中定义的头字段。

缓存控制指令可以归为以下几类：
- 关于可缓存内容的限制（由源服务器单独规定）
- 关于缓存存储内容的限制（由源服务器或用户代理规定）
- 对基本过期机制的修改（由源服务器或用户代理规定）
- 缓存重验证和重新加载的控制（仅由用户代理规定）
- 对实体转换的控制
- 缓存系统的扩展

14.9.1 什么内容是可缓存的

默认情况下，如果请求方法、请求头字段和响应状态符合条件，则响应是可缓存的。第13.4节总结了这些默认的可缓存性。以下的响应缓存控制指令允许源服务器覆盖默认的缓存策略：

- public：表示响应可以被任何缓存缓存，即使它通常是不可缓存或只在非共享缓存中缓存。（详见第14.8节的Authorization）

- private：表示响应的全部或部分内容仅供单一用户使用，不能被共享缓存缓存。这允许源服务器声明某些部分仅供特定用户使用，不适合其他用户请求。一个非共享缓存可以缓存此响应。

  注意：此处的“private”仅控制缓存位置，不能保证消息内容的隐私。

- no-cache：如果未指定字段名，则缓存不得在未成功与源服务器重新验证的情况下，用此响应满足后续请求。这允许源服务器阻止缓存，即使缓存已配置为返回陈旧响应。

  如果指定了字段名，则缓存可以用此响应满足后续请求，但在没有成功验证的情况下，不应在后续请求中发送这些字段名。这样源服务器可以阻止某些头字段被缓存或重用。

  注意：大多数HTTP/1.0缓存不识别或遵守此指令。

14.9.2 缓存可以存储的内容

- no-store：旨在防止敏感信息的意外泄露或存储（如备份带）。此指令适用于整个消息，可以在响应或请求中发送。请求中发送时，缓存不得存储请求或响应的任何部分；响应中发送时，缓存不得存储响应或引发该响应的请求的任何部分。此指令适用于非共享和共享缓存。“MUST NOT store”意味着缓存不得有意将信息存入非易失存储，也应尽快从易失存储中删除。

  即使在响应中使用此指令，用户仍可手动保存（如“另存为”对话框）。历史缓冲区也可能存储此类响应。

  该指令旨在满足某些用户和服务作者对意外泄露敏感信息的担忧。虽然使用此指令在某些情况下可以增强隐私，但不能作为确保隐私的可靠或充分机制。恶意或被攻破的缓存可能不遵守此指令，通信网络也可能被窃听。

14.9.3 基本过期机制的修改

实体的过期时间可以由源服务器通过Expires头（第14.21节）指定，也可以通过响应中的max-age指令指定。当缓存响应中存在max-age指令时，如果实体的当前年龄超过该值（秒），则视为陈旧。max-age指令意味着响应是可缓存的（即“public”），除非存在其他更严格的缓存指令。

如果响应同时包含Expires头和max-age指令，max-age优先于Expires头，即使Expires更严格。这允许源服务器为某个响应提供比HTTP/1.0缓存更长的过期时间，特别是在某些HTTP/1.0缓存因时钟不同步而错误计算年龄或过期时间时。

许多HTTP/1.0缓存会将Expires值小于等于响应日期视为“no-cache”。如果HTTP/1.1缓存收到此类响应，且未包含Cache-Control头，应视为不可缓存，以保持与HTTP/1.0的兼容。

  注意：源服务器可能希望在网络中使用较新的HTTP缓存控制特性（如“private”），即使某些旧缓存不理解该特性。此时应结合Expires字段（值小于等于日期）使用，以防旧缓存错误缓存。

s-maxage：如果响应中包含s-maxage指令，则在共享缓存（非私有缓存）中，此指令指定的最大年龄优先于max-age和Expires头。s-maxage还意味着必须在实体变陈旧后重新验证（proxy-revalidate，见第14.9.4节），即共享缓存在实体变陈旧后，不能直接用其响应后续请求，必须先验证。私有缓存会忽略s-maxage。

注意：许多旧缓存不支持任何缓存控制指令，源服务器若希望限制但不阻止缓存，可以利用max-age覆盖Expires的规则，因旧缓存不遵守max-age。

其他指令允许用户代理修改基本的过期机制，这些指令可以在请求中指定：

- max-age：表示客户端愿意接受的响应最大年龄（秒），除非同时包含max-stale，否则不接受陈旧响应。

- min-fresh：表示客户端愿意接受的响应的最小新鲜时间（秒），即响应在当前年龄基础上还要保持新鲜的时间。

- max-stale：表示客户端愿意接受超出过期时间的响应。如果赋值，则表示允许超出过期时间不超过指定秒数的响应；如果未赋值，则接受任何陈旧响应。

以上内容为翻译，旨在帮助理解HTTP缓存控制相关的技术细节。

如果缓存返回了过时的响应，无论是因为请求中包含了 max-stale 指令，还是因为缓存被配置为覆盖响应的过期时间，缓存都必须在过时的响应中附加一个 Warning 头，使用 Warning 110（响应已过期）。

字段定义，等同于 RFC 2616 中的内容：
缓存可以被配置为在不进行验证的情况下返回过时的响应，但前提是这不与任何“必须”级别的缓存验证要求（例如“must-revalidate”缓存控制指令）相冲突。

如果新请求和缓存中的条目都包含“max-age”指令，则使用两个值中较小的那个来确定该缓存条目的新鲜度。

14.9.4 缓存重验证与重新加载控制

有时，用户代理可能希望或需要强制缓存与源服务器重新验证其缓存条目（而不仅仅是与路径上的下一个缓存验证），或从源服务器重新加载缓存条目。如果缓存或源服务器高估了缓存响应的过期时间，端到端的重验证可能是必要的。如果缓存条目因某种原因已被破坏，可能也需要端到端的重新加载。

端到端的重验证可以在以下两种情况下请求：
- 客户端没有自己的本地缓存副本，此时称为“未指定的端到端重验证”；
- 客户端有本地缓存副本，此时称为“特定的端到端重验证”。

客户端可以通过请求中的 Cache-Control 指令指定这三种操作：

**端到端重新加载**  
请求中包含“no-cache”缓存控制指令，或为了兼容 HTTP/1.0 客户端，包含“Pragma: no-cache”。请求中不得包含 no-cache 指令的字段名。服务器在响应时不得使用缓存副本。

**特定的端到端重验证**  
请求中包含“max-age=0”缓存控制指令，强制沿路径的每个缓存（如果有）与下一个缓存或服务器重新验证其条目。初始请求还应包含一个带有客户端当前验证器的缓存验证条件。

**未指定的端到端重验证**  
请求中包含“max-age=0”指令，强制沿路径的每个缓存（如果有）与下一个缓存或服务器重新验证其条目。初始请求不包含缓存验证条件；沿路径的第一个缓存（如果有）会包含一个带有其当前验证器的缓存验证条件。

**max-age**  
当中间缓存被“max-age=0”指令强制重新验证其缓存条目，且客户端在请求中提供了验证器时，可能会出现验证器不同的情况。在这种情况下，缓存可以使用任意一个验证器发起请求，而不影响语义的透明性。

不过，验证器的选择可能影响性能。最优做法是中间缓存在请求时使用其自己的验证器。如果服务器返回304（未修改），缓存可以用已验证的副本以200（成功）响应返回给客户端；如果服务器返回新实体和验证器，中间缓存可以用强比较函数将返回的验证器与请求中的验证器进行比较。如果两者相等，则返回304（未修改）；否则，返回新实体和200（成功）。

如果请求中包含 no-cache 指令，则不应包含 min-fresh、max-stale 或 max-age。

**only-if-cached**  
在某些情况下，比如网络连接极差时，客户端可能只希望缓存返回其已有的响应，而不重新验证或从源服务器加载。此时，客户端可以在请求中加入 only-if-cached 指令。如果收到此指令，缓存应返回一个符合请求其他约束的缓存副本，或返回504（网关超时）状态码。但如果多个缓存作为一个系统协同工作，且内部连接良好，也可以将此请求转发到该缓存组。

**must-revalidate**  
由于缓存可能被配置为忽略服务器的过期时间，且客户端请求可能包含“max-stale”指令（具有类似效果），协议还引入了源服务器要求在每次使用缓存条目前进行重验证的机制。当响应中包含 must-revalidate 指令时，缓存在响应变为过期后，必须在再次使用前重新验证，否则不得使用该条目。

must-revalidate 指令对于支持某些协议特性（如可靠操作）是必要的。在任何情况下，HTTP/1.1 缓存都必须遵守 must-revalidate；特别是在无法联系到源服务器时，必须返回 504（网关超时）。

服务器应在必要时（如未能重新验证可能导致操作错误）发送 must-revalidate 指令。接收方不得采取任何违反此指令的自动操作，也不得在验证失败时自动提供未验证的实体副本。

虽然不推荐，但在网络连接极差的情况下，用户代理可以违反此指令，但必须明确警告用户，已提供未验证的响应。每次未验证访问都必须显示警告，并建议用户确认。

**proxy-revalidate**  
proxy-revalidate 指令与 must-revalidate 相同，但不适用于非共享的用户代理缓存。它可以用于对已认证请求的响应，允许用户的缓存存储并在后续请求中返回响应，无需重新验证（因为已由用户验证过一次），但仍要求代理在每次服务多用户时重新验证，以确保每个用户都已验证。注意，这类已认证的响应还需要公共缓存控制指令，才能被缓存。

14.9.5 No-Transform 指令

**no-transform**  
中间缓存（代理）的实现者发现，将某些实体体的媒体类型转换很有用。例如，为节省缓存空间或减少慢速链路上的流量，非透明代理可能会在不同图像格式之间转换。

然而，当这些转换应用于为特定应用设计的实体体时，会引发严重的操作问题。例如，医疗成像、科学数据分析以及使用端到端认证的应用，都依赖于接收与原始实体体位比完全相同的实体体。

因此，如果消息中包含 no-transform 指令，中间缓存或代理不得更改第13.5.2节中列出的受 no-transform 指令限制的头部。这意味着，缓存或代理不得更改由这些头部指定的实体体的任何方面，包括实体体的值。

14.9.6 缓存控制扩展

Cache-Control 头字段可以通过添加一个或多个缓存扩展（cache-extension）令牌（每个可带可选值）进行扩展。信息性扩展（不改变缓存行为的扩展）可以在不改变其他指令语义的情况下添加。行为扩展旨在作为现有缓存指令的修饰符，既可以同时提供新指令和标准指令，未理解新指令的应用会遵循标准指令的行为，理解新指令的应用会将其视为对标准指令要求的修正。这样，缓存控制指令的扩展可以在不修改基础协议的情况下实现。

此扩展机制依赖于 HTTP 缓存遵守其本身 HTTP 版本定义的所有缓存控制指令，遵守某些扩展，并忽略不理解的指令。

例如，假设定义一个名为 community 的新响应指令，作为 private 指令的修饰符。该指令意味着，除了非共享缓存外，任何由其值中指定的社区成员共享的缓存都可以缓存该响应。源服务器如果希望允许 UCI 社区在其共享缓存中使用本应私有的响应，可以在响应中加入：

    Cache-Control: private, community="UCI"

看到此头字段的缓存，即使不理解 community 扩展，也会正确处理，因为它会理解并遵循 private 指令，从而保持安全。

未识别的缓存指令必须被忽略；假设任何可能被 HTTP/1.1 缓存未识别的指令都将与标准指令（或响应的默认缓存性）结合使用，以确保即使不理解扩展，缓存行为仍能保持基本正确。

14.10 连接（Connection）

Connection 头字段允许发送方指定特定连接的选项，且这些选项不得由代理在后续连接中传递。

Connection 头的语法如下：

    Connection = "Connection" ":" 1#(connection-token)  
    connection-token = token

HTTP/1.1 代理在转发消息前必须解析 Connection 头字段，对于每个 connection-token，删除消息中与之同名的头字段。连接选项由 Connection 头中的 connection-token 表示，而不是由任何附加的头字段，因为如果没有参数，可能不会发送额外的头字段。

在 Connection 头中列出的头字段不得包含端到端的头（如 Cache-Control）。

HTTP/1.1 定义了“close”连接选项，用于通知对方在响应完成后关闭连接。例如：

    Connection: close

在请求或响应头中，表示在当前请求/响应完成后，连接不应被视为“持久的”（第8.1节）。

不支持持久连接的 HTTP/1.1 应用必须在每个消息中包含“close”连接选项。

接收包含 Connection 头的 HTTP/1.0（或更低版本）消息的系统，必须对每个 connection-token，删除并忽略消息中与之同名的头字段，以防止误转发非 HTTP/1.1 代理的头字段。详见第19.6.2节。

14.11 内容编码（Content-Encoding）

Content-Encoding 实体头字段用作媒体类型的修饰符。当存在时，其值指示已对实体体应用了哪些内容编码，因此必须应用哪些解码机制以获得 Content-Type 头字段所引用的媒体类型。Content-Encoding 主要用于在不丢失底层媒体类型标识的情况下，对文档进行压缩。

其语法定义为：

    Content-Encoding = "Content-Encoding" ":" 1#content-coding

内容编码在第3.5节中定义。示例用法：

    Content-Encoding: gzip

内容编码是请求URI所标识实体的一个特性。通常，实体主体会以该编码存储，只有在渲染或类似用途之前才会进行解码。然而，非透明代理可以修改内容编码，只要新的编码被接收方接受，除非消息中包含“no-transform”缓存控制指令。

如果实体的内容编码不是“identity”，那么响应必须包含一个内容编码（Content-Encoding）实体头（第14.11节），列出所使用的非身份内容编码。

如果请求消息中的实体内容编码不被源服务器接受，服务器应返回状态码415（不支持的媒体类型）。

如果对实体应用多种编码，内容编码必须按应用顺序列出。关于编码参数的其他信息可以由本规范未定义的其他实体头字段提供。

14.12 内容语言

内容语言（Content-Language）实体头字段描述所包含实体的自然语言或语言集合。注意，这可能与实体主体中使用的所有语言不完全相同。

语言标签定义在第3.10节。内容语言的主要目的是让用户根据自己的偏好识别和区分实体。例如，如果内容仅面向丹麦语读者，合适的字段是：

    Content-Language: da

如果未指定内容语言，默认认为内容面向所有语言受众。这可能意味着发送者不认为内容特定于任何自然语言，或不知道内容的目标语言。

可以为多种受众列出多种语言。例如，一份同时提供毛利语和英语版本的《怀唐伊条约》应使用：

    Content-Language: mi, en

然而，实体中存在多种语言并不意味着它面向多个语言群体。例如，一本初学者拉丁语教材（如《拉丁语第一课》）显然是面向英语读者的，此时内容语言应仅为“en”。

内容语言可以应用于任何媒体类型，不限于文本。

14.13 内容长度

内容长度（Content-Length）实体头字段指示实体主体的大小（以十进制字节数），即发送给接收方的字节数，或在HEAD请求中，表示如果是GET请求时会发送的实体主体的大小。

示例：

    Content-Length: 3495

应用程序应使用此字段指示消息体的传输长度，除非第4.4节的规则禁止。

任何大于或等于零的内容长度都是有效值。第4.4节描述了在未提供内容长度时如何确定消息体的长度。

请注意，此字段的含义与MIME中的定义有显著不同。在MIME中，它是“message/external-body”内容类型中的可选字段。在HTTP中，应在可以在传输前确定消息长度时发送，除非第4.4节的规则禁止。

14.14 内容位置

内容位置（Content-Location）实体头字段可用于提供实体的资源位置，特别是当该实体可以从不同于请求资源URI的位置访问时。服务器应为响应实体的变体提供内容位置，尤其是在一个资源对应多个实体且这些实体有各自的访问位置时，应提供对应的内容位置。

    Content-Location: <绝对URI或相对URI>

内容位置的值也定义了实体的基础URI。

内容位置不是原始请求URI的替代，只是说明在请求时该实体对应资源的当前位置。未来的请求可以将内容位置URI作为请求URI，以标识该实体的来源。

缓存不能假设具有不同内容位置的实体可以用来响应后续对该内容位置URI的请求，但内容位置可以用来区分从单一请求资源中检索的多个实体（见13.6节）。

如果内容位置是相对URI，则相对URI相对于请求URI进行解释。

PUT或POST请求中的内容位置头的含义未定义，服务器可以在这些情况下忽略它。

14.15 内容MD5

内容MD5（Content-MD5）实体头字段由RFC 1864定义，是实体主体的MD5摘要，用于提供端到端的消息完整性检查（MIC）。注意：MIC主要用于检测传输中的意外修改，但不能防止恶意攻击。

格式如下：

    Content-MD5: <base64编码的128位MD5摘要>

其中，md5-digest是按照RFC 1864定义的MD5摘要的Base64编码。

内容MD5头字段可以由源服务器或客户端生成，用于验证实体主体的完整性。只有源服务器或客户端可以生成此字段，代理和网关不得生成，以确保端到端的完整性。任何接收实体主体的实体（包括网关和代理）都可以检查此摘要是否匹配。

MD5摘要基于实体主体的内容（包括已应用的内容编码），但不包括任何传输编码。如果消息带有传输编码，必须在验证前去除。

因此，摘要是在实体主体的字节上计算的，顺序和内容都与实际传输时一致。

HTTP扩展了RFC 1864，允许对MIME复合媒体类型（如multipart/*和message/rfc822）计算摘要，但这不改变前述的计算方式。

这有几个后果：复合类型的实体主体可能包含多个部分，每个部分有自己的MIME和HTTP头（包括Content-MD5、Content-Transfer-Encoding和Content-Encoding）。如果某个部分有Content-Transfer-Encoding或Content-Encoding头，假设其内容已被相应编码，内容MD5会对该部分的编码后内容进行计算，即编码应用后再计算。传输编码头在部分中不允许。

在计算或验证摘要前，不应将所有换行符转换为CRLF：应保持实际传输文本中的换行符不变。

注意：虽然HTTP中的Content-MD5定义与RFC 1864中MIME实体主体的定义完全相同，但在应用到HTTP实体主体时存在差异。HTTP不像MIME那样使用Content-Transfer-Encoding，而是使用Transfer-Encoding和Content-Encoding。HTTP更频繁使用二进制内容类型，因此在此类情况下，计算摘要所用的字节顺序为传输定义的字节顺序。最后，HTTP允许以多种换行符样式传输文本类型，而不仅仅是CRLF。

14.16 内容范围

内容范围（Content-Range）实体头字段用于部分实体的响应中，指示部分内容应在完整实体中的位置。范围单位在第3.12节定义。

    Content-Range: <内容范围描述>

内容范围描述（content-range-spec）格式如下：

    content-range-spec = byte-content-range-spec
    byte-content-range-spec = bytes-unit SP byte-range-resp-spec "/" (实例长度 | "*")
    byte-range-resp-spec = (第一个字节位置 "-" 最后一个字节位置) | "*"
    实例长度 = 1*DIGIT

该头应指示完整实体的总长度，除非长度未知或难以确定。星号“*”表示在响应生成时，实例长度未知。

不同于第14.35.1节的字节范围说明符（byte-ranges-specifier），byte-range-resp-spec必须只指定一个范围，且范围的起止字节位置必须是绝对的。

如果byte-range-resp-spec中的最后字节位置小于起始字节位置，或实例长度小于等于最后字节位置，则该字节内容范围描述无效。接收方应忽略无效的描述及随之传输的内容。

返回状态码416（请求的范围无法满足）时，服务器应包含一个内容范围字段，范围为“*”。实例长度指示所请求资源的当前长度。

状态码206（部分内容）响应不得包含范围为“*”的内容范围描述。

示例（假设实体总共1234字节）：

- 前500字节：bytes 0-499/1234
- 后500字节：bytes 734-1233/1234
- 除前500字节外的所有内容：bytes 500-1233/1234
- 最后500字节：bytes 734-1233/1234

当HTTP消息包含单个范围内容（如对单个范围的响应，或多个重叠范围无空隙的请求响应）时，内容以Content-Range头传输，内容长度用Content-Length指示实际传输的字节数。例如：

    HTTP/1.1 206 Partial Content
    Date: Wed, 15 Nov 1995 06:25:24 GMT
    Last-Modified: Wed, 15 Nov 1995 04:58:08 GMT
    Content-Range: bytes 21010-47021/47022
    Content-Length: 26012
    Content-Type: image/gif

当响应包含多个范围（如对多个不重叠范围的请求）时，内容以多部分消息（multipart/byteranges）传输，具体定义在附录19.2。详见附录19.6.3的兼容性说明。

对单个范围的请求响应不得使用multipart/byteranges类型。对多个范围的请求，如果结果为单一范围，也可以用multipart/byteranges类型，只包含一个部分。客户端若不能解码多部分消息，不应请求多个字节范围。

当客户端在请求中同时请求多个字节范围时，服务器应按请求中范围出现的顺序返回。

如果服务器因语法错误忽略某个字节范围描述，应将请求视为不存在该范围头，通常返回完整实体（状态码200）。

如果服务器收到的范围请求（除非包含If-Range头）中所有范围的第一个字节位置都大于资源当前长度，应返回状态码416（请求的范围无法满足）。

14.17 内容类型（Content-Type）

内容类型实体头字段指示发送给接收方的实体主体的媒体类型，或者在HEAD方法的情况下，指示如果请求是GET时会发送的媒体类型。

       Content-Type = "Content-Type" ":" media-type

媒体类型在第3.7节中定义。该字段的示例为：

       Content-Type: text/html; charset=ISO-8859-4

关于识别实体媒体类型的方法的进一步讨论请参见第7.2.1节。

14.18 日期（Date）

通用头字段“Date”表示消息的产生日期和时间，其语义与RFC 822中的orig-date相同。字段值为HTTP日期格式，如第3.3.1节所述；必须采用RFC 1123 [8]中的日期格式。

       Date = "Date" ":" HTTP-date

示例：

       Date: Tue, 15 Nov 1994 08:12:31 GMT

源服务器必须在所有响应中包含Date头字段，除非满足以下情况：

1. 如果响应状态码为100（继续）或101（切换协议），响应可以由服务器选择性地包含Date头字段。

2. 如果响应状态码表示服务器错误，例如500（内部服务器错误）或503（服务不可用），且生成有效Date字段不方便或不可能。

3. 如果服务器没有能够提供合理当前时间的时钟，其响应不得包含Date头字段。在这种情况下，必须遵循第14.18.1节中的规则。

如果接收的消息没有Date头字段，接收方必须为其赋值，尤其是在消息会被缓存或通过需要Date的协议转发时。没有时钟的HTTP实现不得缓存未重新验证的响应。HTTP缓存（尤其是共享缓存）应使用如NTP [28]的机制同步其时钟。

客户端应仅在消息包含实体主体（如PUT和POST请求）时发送Date头字段，即使如此也为可选。没有时钟的客户端不得在请求中发送Date头字段。

在Date头中发送的HTTP日期不应表示消息生成之后的日期和时间。它应尽可能接近消息生成的时间，除非实现无法生成较为准确的日期和时间。从理论上讲，日期应代表实体生成前的瞬间，但实际上，日期可以在消息产生的任何时间生成，而不影响其语义。

14.18.1 无时钟源的源服务器操作

某些源服务器实现可能没有可用的时钟。没有时钟的源服务器不得为响应分配Expires或Last-Modified值，除非这些值由具有可靠时钟的系统或用户与资源相关联。它可以在服务器配置时或之前分配一个已知的、在过去的Expires值（允许“预过期”响应，而无需为每个资源存储单独的Expires值）。

14.19 实体标签（ETag）

实体标签响应头字段提供请求变体的当前实体标签值。与实体标签相关的头字段在第14.24、14.26和14.44节中描述。实体标签可用于与同一资源的其他实体进行比较（参见第13.3.3节）。

      ETag = "ETag" ":" entity-tag

示例：

      ETag: "xyzzy"
      ETag: W/"xyzzy"
      ETag: ""

14.20 期望（Expect）

请求头字段“Expect”用于指示客户端要求的特定服务器行为。

      Expect = "Expect" ":" 1#expectation

      expectation = "100-continue" | expectation-extension
      expectation-extension = token [ "=" ( token | quoted-string )
                               *expect-params ]
      expect-params = ";" token [ "=" ( token | quoted-string ) ]

不理解或无法满足请求中“Expect”字段中任何期望值的服务器，必须以适当的错误状态响应。如果任何期望无法满足，服务器必须返回状态码417（Expectation Failed）；如果请求存在其他问题，也应返回其他4xx状态。

该头字段采用可扩展语法，以支持未来扩展。如果服务器收到包含不支持的expectation-extension的Expect字段的请求，必须返回状态码417（Expectation Failed）。

对于未加引号的标记（包括“100-continue”标记），期望值的比较不区分大小写；对于引号括起的期望扩展，比较则区分大小写。

“Expect”机制是逐跳的：即，HTTP/1.1代理必须在收到无法满足的期望请求时返回417（Expectation Failed）。但“Expect”请求头本身是端到端的；如果请求被转发，必须转发该头字段。

许多旧的HTTP/1.0和HTTP/1.1应用程序不理解“Expect”头。

有关使用“100（继续）”状态的详细信息，请参见第8.2.3节。

14.21 过期时间（Expires）

实体头字段“Expires”指示响应被视为过期的日期/时间。除非先与源服务器（或具有最新实体副本的中间缓存）验证，否则过期缓存条目（代理缓存或用户代理缓存）通常不会返回。关于过期模型的详细讨论请参见第13.2节。

“Expires”字段的存在不意味着原始资源会在该时间点之前或之后发生变化或不存在。

格式为HTTP日期格式（第3.3.1节定义的绝对日期时间），必须采用RFC 1123日期格式：

      Expires = "Expires" ":" HTTP-date

示例：

      Expires: Thu, 01 Dec 1994 16:00:00 GMT

注意：如果响应中包含带有max-age指令（见第14.9.3节）的Cache-Control字段，则该指令优先于“Expires”字段。

HTTP/1.1客户端和缓存必须将其他无效日期格式（尤其是“0”）视为已过期（即“已过期”）。

为了将响应标记为“已过期”，源服务器应发送等于Date头字段值的Expires日期（参见第13.2.4节中的过期计算规则）。

为了标记响应为“永不过期”，源服务器应发送大约在响应发出时间一年前的Expires日期。HTTP/1.1服务器不应发送超过一年后到期的Expires日期。

在响应中存在未来某个时间点的Expires头字段，且该响应默认不可缓存，表示该响应可被缓存，除非由Cache-Control头字段（第14.9节）另行指示。

14.22 来源（From）

“From”请求头字段（如果提供）应包含控制请求用户代理的人类用户的电子邮件地址。该地址应为机器可用，定义见RFC 822 [9]中的“mailbox”，并由RFC 1123 [8]更新：

       From = "From" ":" mailbox

示例：

       From: webmaster@w3.org

该字段可用于日志记录和识别无效或不需要的请求来源。不得用作不安全的访问控制手段。该字段的解释是，代表给定的人员执行请求，该人员对所执行的方法负责。特别是，机器人代理应包含此头，以便在出现问题时能联系到负责运行机器人的人员。

该字段中的电子邮件地址可以与发出请求的互联网主机不同。例如，经过代理传递请求时，应使用原始发起者的地址。

客户端不应在未获得用户许可的情况下发送“From”头字段，以免侵犯用户隐私或违反安全策略。强烈建议用户可以在发出请求前随时禁用、启用或修改此字段的值。

14.23 主机（Host）

“Host”请求头字段指定请求资源的互联网主机和端口号，信息来源于用户提供的原始URI或引用资源（通常为HTTP URL，详见第3.2.2节）。“Host”字段的值必须代表原始URL中指定的源服务器或网关的命名权威。这允许源服务器或网关区分内部可能模糊的URL，例如多个主机名共用一个IP地址的服务器的根“/”URL。

       Host = "Host" ":" host [ ":" port ] ; 第3.2.2节

没有端口信息的“host”默认表示请求的服务端口（例如HTTP URL的“80”）。例如，向源服务器请求：

       GET /pub/WWW/ HTTP/1.1
       Host: www.w3.org

客户端必须在所有HTTP/1.1请求中包含“Host”头字段。如果请求的URI未包含服务的互联网主机名，则“Host”字段必须为空值。HTTP/1.1代理必须确保转发的请求中包含正确的“Host”字段，标识请求的服务。所有基于互联网的HTTP/1.1服务器必须对缺少“Host”字段的请求返回400（错误请求）状态码。

有关“Host”的其他要求，请参见第5.2节和第19.6.1.1节。

14.24 If-Match

“If-Match”请求头字段与方法结合使用，使请求具有条件性。客户端可以在“If-Match”头中包含之前从资源获取的一个或多个实体标签，以验证其中之一是否为最新。实体标签定义见第3.11节。此功能旨在以最小的事务开销高效更新缓存信息，也用于在更新请求中防止误修改资源的错误版本。特殊情况下，值“*”匹配资源的任何当前实体。

      If-Match = "If-Match" ":" ( "*" | 1#entity-tag )

如果任何实体标签与响应类似GET请求（未包含If-Match头）返回的实体标签匹配，或如果提供了“*”且资源存在任何当前实体，服务器可以像没有“ If-Match”头一样执行请求的方法。

服务器必须使用强比较（见第13.3.3节）来比较实体标签。

如果没有任何实体标签匹配，或如果提供了“*”且没有当前实体，服务器不得执行请求的方法，必须返回412（前提条件失败）状态。这在客户端希望防止PUT等更新方法修改自上次获取后已更改的资源时特别有用。

如果请求在没有“If-Match”头的情况下会导致非2xx或412状态码，则必须忽略“ If-Match”头。

“如果匹配：*”的含义是：如果由源服务器（或缓存，可能使用Vary机制，见第14.44节）选择的表示存在，则应执行该方法；如果表示不存在，则不得执行该方法。

旨在更新资源的请求（例如PUT）可以包含一个If-Match头字段，以表明如果与该头字段值（单个实体标签）对应的实体不再是该资源的表示，则该请求方法不得应用。这允许用户指示在资源被未经其知情的情况下更改时，不希望请求成功。示例：

    If-Match: "xyzzy"
    If-Match: "xyzzy", "r2d2xxxx", "c3piozzzz"
    If-Match: *

具有If-Match头字段的请求与包含If-None-Match或If-Modified-Since头字段的请求的结果在本规范中未定义。

14.25 如果修改时间（If-Modified-Since）

If-Modified-Since请求头字段与方法一起使用，用于使请求具有条件性：如果请求的变体自该字段指定的时间以来未被修改，则不会从服务器返回实体；相反，将返回状态码304（未修改），且没有消息体。

字段格式：

    If-Modified-Since: HTTP-date

示例：

    If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT

带有If-Modified-Since头且没有Range头的GET请求，要求仅在实体自该日期之后被修改时才传输该实体。判断的算法包括以下情况：

a) 如果请求通常会导致除200（OK）以外的状态，或传递的If-Modified-Since日期无效，则响应与普通GET相同。晚于服务器当前时间的日期无效。

b) 如果变体自If-Modified-Since日期以来已被修改，响应与普通GET相同。

c) 如果变体自该有效的If-Modified-Since日期未被修改，服务器应返回304（未修改）响应。

此功能的目的是以最少的事务开销高效更新缓存信息。

注意：Range请求头会修改If-Modified-Since的含义；详见第14.35节。

注意：服务器对If-Modified-Since时间的解释可能与客户端不同步。

注意：处理If-Modified-Since头时，一些服务器会使用精确日期比较函数，而非小于函数，以决定是否返回304响应。建议客户端在进行缓存验证时，尽可能使用之前从Last-Modified头获得的精确日期字符串。

注意：如果客户端在If-Modified-Since头中使用了任意日期，而非从Last-Modified头中取的日期，客户端应意识到该日期在服务器的时间理解中被解释。应考虑时钟不同步和时间编码差异带来的舍入问题，包括请求和响应之间的时间差异可能引发的竞态条件，以及基于客户端时钟的If-Modified-Since日期未校正到服务器时钟可能引发的问题。由于网络延迟，客户端和服务器之间的不同时间基准的校正也只是近似。

具有If-Modified-Since头和If-Match或If-Unmodified-Since头的请求，其结果在本规范中未定义。

14.26 如果匹配（If-None-Match）

If-None-Match请求头用于使请求具有条件性。客户端可以在之前从资源获取的一个或多个实体中验证它们是否都不是最新的，通过在If-None-Match头中包含它们的实体标签列表。此功能旨在以最少的事务开销高效更新缓存信息，也用于防止客户端误用PUT等方法意外修改已存在的资源。

特殊情况：值“*”匹配资源的任何当前实体。

字段格式：

    If-None-Match: "If-None-Match" ":" ( "*" | 1#entity-tag )

如果任何实体标签与响应类似GET请求（未带If-None-Match）返回的实体标签匹配，或如果给出“*”且资源存在任何实体，则服务器不得执行请求的方法，除非因为请求中的If-Modified-Since头所提供的修改时间不匹配而必须如此。对于GET或HEAD请求，服务器应返回304（未修改）响应，并包含匹配实体的缓存相关头（特别是ETag）。对于其他请求方法，服务器必须返回状态码412（前提条件失败）。

关于如何判断两个实体标签是否匹配的规则，请参见第13.3.3节。弱比较只能用于GET或HEAD请求。

如果没有任何实体标签匹配，服务器可以像没有If-None-Match头一样，执行请求的操作，但必须忽略请求中的任何If-Modified-Since头。也就是说，如果没有实体标签匹配，服务器不得返回304（未修改）响应。

如果没有实体标签匹配，且请求在没有If-None-Match头的情况下会导致非2xx或非304状态码，则必须忽略If-None-Match头（详见第13.3.4节，关于同时出现If-Modified-Since和If-None-Match的服务器行为讨论）。

“如果匹配：*”的含义是：如果由源服务器（或缓存，可能使用Vary机制，见第14.44节）选择的表示存在，则该方法不得执行；如果不存在，则应执行。此特性旨在防止PUT操作之间的竞态条件。

示例：

    If-None-Match: "xyzzy"
    If-None-Match: W/"xyzzy"
    If-None-Match: "xyzzy", "r2d2xxxx", "c3piozzzz"
    If-None-Match: W/"xyzzy", W/"r2d2xxxx", W/"c3piozzzz"
    If-None-Match: *

具有If-None-Match头和If-Match或If-Unmodified-Since头的请求，其结果在本规范中未定义。

14.27 如果范围（If-Range）

如果客户端在缓存中有部分实体副本，且希望获得完整实体的最新版本，可以使用Range请求头结合条件GET（使用If-Unmodified-Since或If-Match，或两者）。但如果条件失败（即实体已被修改），客户端将不得不发出第二个请求以获取完整的实体。

If-Range头允许客户端“短路”第二次请求。其含义大致为：“如果实体未变，发送我缺失的部分；否则，发送整个新实体”。

字段格式：

    If-Range: "If-Range" ":" ( entity-tag | HTTP-date )

如果客户端没有实体标签，但有Last-Modified日期，也可以在If-Range头中使用该日期（服务器通过检查前两个字符区分有效的HTTP-date和实体标签）。建议只在有Range头时使用If-Range，并且如果请求没有Range头或服务器不支持子范围操作，则应忽略。

如果If-Range头中的实体标签与当前实体标签匹配，服务器应返回指定的子范围（206 Partial Content）；否则，应返回整个实体（200 OK）。

14.28 如果未修改（If-Unmodified-Since）

If-Unmodified-Since请求头用于使请求具有条件性：如果请求的资源自该时间以来未被修改，服务器应像没有该头一样执行请求。

如果资源自该时间以来已被修改，服务器不得执行请求操作，必须返回412（前提条件失败）。

字段格式：

    If-Unmodified-Since: HTTP-date

示例：

    If-Unmodified-Since: Sat, 29 Oct 1994 19:43:31 GMT

如果请求在没有该头的情况下会导致非2xx或412状态码，则应忽略该头。

无效的日期应被忽略。

具有If-Unmodified-Since头和If-None-Match或If-Modified-Since头的请求，其结果在本规范中未定义。

14.29 最后修改时间（Last-Modified）

Last-Modified实体头字段指示源服务器认为该变体最后被修改的日期和时间。

字段格式：

    Last-Modified: HTTP-date

示例：

    Last-Modified: Tue, 15 Nov 1994 12:45:26 GMT

其具体含义依赖于源服务器的实现和资源的性质。对于文件，可能只是文件系统的最后修改时间；对于包含动态部分的实体，可能是其组成部分的最新修改时间；对于数据库网关，可能是记录的最后更新时间戳；对于虚拟对象，可能是内部状态最后变化的时间。

源服务器不得发送晚于消息发起时间的Last-Modified日期。在此类情况下（资源的最后修改时间在未来），必须用消息发起时间替代。

源服务器应尽可能在生成响应的Date头时，获取实体的Last-Modified值，以便接收方能准确判断实体的修改时间，尤其是在实体在响应生成时间附近发生变化时。

HTTP/1.1服务器应尽可能发送Last-Modified。

14.30 位置（Location）

Location响应头字段用于将接收方重定向到除请求URI之外的其他位置，以完成请求或标识新资源。对于201（已创建）响应，Location指示由请求创建的新资源位置；对于3xx响应，Location应指示服务器首选的URI，用于自动重定向到资源。该字段值为单一的绝对URI。

示例：

    Location: http://www.w3.org/pub/WWW/People.html

注意：Content-Location头（第14.14节）与Location不同，Content-Location标识请求中包含实体的原始位置。因此，响应中可能同时包含Location和Content-Location头。详见第13.10节关于某些方法的缓存要求。

14.31 最大转发数（Max-Forwards）

Max-Forwards请求头提供一种机制，结合TRACE（第9.8节）和OPTIONS（第9.2节）方法，用于限制请求在转发到下一个入站服务器之前经过的代理或网关的数量。当客户端试图追踪请求链（可能出现失败或环路）时，这非常有用。

字段格式：

    Max-Forwards: 1*DIGIT

最大转发次数（Max-Forwards）值是一个十进制整数，表示该请求消息剩余可以被转发的次数。

每个代理或网关在接收到包含Max-Forwards头字段的TRACE或OPTIONS请求时，必须在转发请求之前检查并更新其值。如果接收到的值为零（0），则该接收方不得转发请求，而应作为最终接收者作出响应。如果接收到的Max-Forwards值大于零，则转发的消息必须包含一个更新后的Max-Forwards字段，其值减一（1）。

对于本规范定义的其他所有方法以及未在该方法定义中明确提及的扩展方法，Max-Forwards头字段可以被忽略。

14.32 Pragma

Pragma通用头字段用于包含可能适用于请求/响应链中任何接收者的特定实现指令。所有Pragma指令从协议的角度来看都是可选的行为；然而，某些系统可能要求行为与指令保持一致。

Pragma的语法如下：
```
Pragma = "Pragma" ":" 1#pragma-directive
pragma-directive = "no-cache" | extension-pragma
extension-pragma = token [ "=" ( token | quoted-string ) ]
```

当请求消息中包含no-cache指令时，应用程序应当即使有缓存副本，也将请求转发到源服务器。此Pragma指令的语义与no-cache缓存指令（见第14.9节）相同，为了向后兼容HTTP/1.0而定义。客户端在向不明确为HTTP/1.1兼容的服务器发送no-cache请求时，应同时包含两个头字段。

代理或网关应用必须传递Pragma指令，无论其对该应用的重要性如何，因为这些指令可能适用于请求/响应链中的所有接收者。不能为特定接收者指定Pragma，但任何与该接收者无关的Pragma指令应被忽略。

HTTP/1.1的缓存机制应将“Pragma: no-cache”视为客户端已发送“Cache-Control: no-cache”。HTTP中不会定义新的Pragma指令。

注意：由于“Pragma: no-cache”作为响应头字段的具体含义未被明确规定，因此它不能可靠地替代“Cache-Control: no-cache”在响应中的作用。

14.33 代理验证（Proxy-Authenticate）

Proxy-Authenticate响应头字段必须作为407（需要代理身份验证）响应的一部分。其值包含一个挑战，指示适用于该请求URI的代理的身份验证方案和参数。

```
Proxy-Authenticate = "Proxy-Authenticate" ":" 1#challenge
```

HTTP访问认证过程详见“HTTP认证：基本和摘要访问认证”[43]。不同于WWW-Authenticate，Proxy-Authenticate头字段仅适用于当前连接，不应传递给下游客户端。然而，中间代理可能需要向下游客户端请求其凭据，以获取自己的认证信息，在某些情况下，这看起来就像代理在转发Proxy-Authenticate头字段。

14.34 代理授权（Proxy-Authorization）

Proxy-Authorization请求头字段允许客户端向需要认证的代理标识自己（或其用户）。其值包含用户代理的认证信息，用于代理和/或请求资源的域。

```
Proxy-Authorization = "Proxy-Authorization" ":" credentials
```

HTTP访问认证过程详见“HTTP认证：基本和摘要访问认证”[43]。与Authorization不同，Proxy-Authorization头字段仅适用于下一个要求认证的出站代理（使用Proxy-Authenticate字段的代理）。在代理链中，Proxy-Authorization由第一个期望接收凭据的出站代理消耗。如果多个代理链中，代理可以将客户端请求中的凭据转发给下一个代理，以实现协作认证。

14.35 范围（Range）

14.35.1 字节范围（Byte Ranges）

由于所有HTTP实体在HTTP消息中都以字节序列表示，字节范围的概念对任何HTTP实体都具有意义（但并非所有客户端和服务器都支持字节范围操作）。

HTTP中的字节范围指定适用于实体体（不一定是消息体）的字节序列。

字节范围操作可以指定单一范围或多个范围。

语法如下：
```
ranges-specifier = byte-ranges-specifier
byte-ranges-specifier = bytes-unit "=" byte-range-set
byte-range-set  = 1#( byte-range-spec | suffix-byte-range-spec )
byte-range-spec = first-byte-pos "-" [last-byte-pos]
first-byte-pos  = 1*DIGIT
last-byte-pos   = 1*DIGIT
```

在byte-range-spec中，first-byte-pos表示范围内第一个字节的偏移量（从0开始），last-byte-pos表示范围内最后一个字节的偏移量（包含在内）。如果last-byte-pos存在，则必须大于或等于first-byte-pos，否则语法无效。包含一个或多个语法无效的字节范围规范的byte-range-set，接收方应忽略包含该set的头字段。

如果没有提供last-byte-pos，或其值大于等于实体体的当前长度，则last-byte-pos视为实体体长度减一（以字节为单位）。

通过选择last-byte-pos，客户端可以在不知道实体体大小的情况下限制检索的字节数。

示例（假设实体体长度为10000）：
- 前500字节（偏移0-499）：bytes=0-499
- 后500字节（偏移9500-9999）：bytes=9500-9999
- 最后500字节（偏移9500-9999）：bytes=-500
- 仅第一个和最后一个字节：bytes=0-0,-1
- 其他合法但非规范的写法：
  - bytes=500-600,601-999
  - bytes=500-700,601-999

14.35.2 范围请求（Range Retrieval Requests）

使用条件或无条件GET方法的HTTP请求可以请求实体的一个或多个子范围，而不是整个实体，方法是使用Range请求头。

```
Range = "Range" ":" ranges-specifier
```

服务器可能会忽略Range头，但HTTP/1.1的源服务器和中间缓存应支持字节范围，以便高效恢复部分失败的传输和高效部分检索大实体。

如果服务器支持Range头且请求的范围适合实体：

- 无条件GET中出现Range头会改变返回内容，响应状态码为206（部分内容）而非200（成功）。
- 条件GET（使用If-Modified-Since、If-None-Match等）中出现Range头，在条件成立时也会返回206，否则返回304（未修改）。

在某些情况下，结合使用If-Range头（见第14.27节）可能更合适。

支持范围的代理收到Range请求后，应将请求转发到后端服务器，并只返回请求的范围部分。如果符合其缓存策略，也应存储完整响应。

14.36 引用（Referer）

Referer请求头字段允许客户端为服务器提供请求URI的来源地址（URI），即“引荐源”。虽然拼写有误，但该字段用于生成资源的反向链接列表、日志、优化缓存等，也便于追踪过时或错误的链接。若请求URI来自没有URI的源（如用户键盘输入），则不得发送Referer字段。

语法：
```
Referer = "Referer" ":" ( absoluteURI | relativeURI )
```

示例：
```
Referer: http://www.w3.org/hypertext/DataSources/Overview.html
```

如果值为相对URI，应相对于请求URI进行解释。URI不得包含片段（fragment）。安全考虑详见第15.1.3节。

14.37 重试（Retry-After）

Retry-After响应头字段用于在503（服务不可用）响应中指示服务预计何时恢复。它也可用于任何3xx（重定向）响应，指示用户代理在发起重定向请求前应等待的最短时间。该字段的值可以是HTTP日期或以秒为单位的整数（十进制），表示从响应时间起的等待时间。

语法：
```
Retry-After = "Retry-After" ":" ( HTTP-date | delta-seconds )
```

示例：
- Retry-After: Fri, 31 Dec 1999 23:59:59 GMT
- Retry-After: 120

第二个示例表示等待2分钟。

14.38 服务器信息（Server）

Server响应头字段包含关于源服务器处理请求所用软件的信息。可以包含多个产品标记（第3.8节）和描述服务器及其重要子产品的注释。产品标记按其识别应用的重要性排序。

语法：
```
Server = "Server" ":" 1*( product | comment )
```

示例：
```
Server: CERN/3.0 libwww/2.17
```

如果响应通过代理转发，代理应用不得修改Server头字段，而应包含Via字段（见第14.45节）。

注意：披露服务器的具体软件版本可能使服务器更易受到已知安全漏洞的攻击。建议服务器实现者将此字段设为可配置选项。

14.39 传输编码（TE）

TE请求头字段指示客户端愿意接受的扩展传输编码，以及是否愿意接受分块传输中的尾部字段。其值可以包括关键词“trailers”和/或用逗号分隔的扩展传输编码名称及可选的接受参数（详见第3.6节）。

语法：
```
TE = "TE" ":" #( t-codings )
t-codings = "trailers" | ( transfer-extension [ accept-params ] )
```

“trailers”关键词表示客户端愿意接受分块传输中的尾部字段（定义在第3.6.1节），该关键词专用于传输编码值，尽管它本身不代表一种传输编码。

示例：
- TE: deflate
- TE:
- TE: trailers, deflate;q=0.5

TE头字段仅适用于直接连接。因此，当HTTP/1.1消息中存在TE字段时，必须在连接头字段（第14.10节）中提供关键字。

服务器根据以下规则测试传输编码是否可接受：

1. “chunked”传输编码始终是可接受的。如果列出了“trailers”关键字，客户端表示愿意接受在分块响应中的尾部字段（trailers），代表自己和任何下游客户端都愿意接受尾部字段。意味着如果提供了“trailers”，客户端声明所有下游客户端都愿意接受转发响应中的尾部字段，或者它会尝试代表下游接收者缓冲响应。

   注意：HTTP/1.1没有定义任何限制分块响应大小的方法，以确保客户端可以缓冲整个响应。

2. 如果被测试的传输编码是TE字段中列出的某个传输编码，除非伴随q值为0，否则它是可接受的。（如第3.9节定义，q值为0表示“不接受”。）

3. 如果多个传输编码都可接受，则优先选择具有最高非零q值的传输编码。 “chunked”传输编码的q值始终为1。

如果TE字段值为空或没有TE字段，唯一的传输编码是“chunked”。没有传输编码的消息始终是可接受的。

14.40 尾部（Trailer）

尾部字段值表示在使用分块传输编码的消息的尾部中存在一组特定的头字段。

   Trailer = "Trailer" ":" 1#field-name

HTTP/1.1消息应在使用分块传输编码且尾部非空的消息中包含Trailer头字段。这样可以让接收方知道尾部中应期待哪些头字段。

如果没有Trailer头字段，尾部不应包含任何头字段。关于在“chunked”传输编码中使用尾部字段的限制，请参见第3.6.1节。

在尾部头字段中列出的消息头字段不得包括：

- Transfer-Encoding
- Content-Length
- Trailer

14.41 传输编码（Transfer-Encoding）

传输编码头字段指示为安全传输消息体而应用的（如果有的话）变换类型。这与内容编码不同，内容编码是实体的属性，而传输编码是消息的属性。

Transfer-Encoding = "Transfer-Encoding" ":" 1#transfer-coding

传输编码在第3.6节中定义。例如：

Transfer-Encoding: chunked

如果对实体应用多个编码，必须按应用顺序列出传输编码。关于编码参数的其他信息可以由本规范未定义的实体头字段提供。

许多旧的HTTP/1.0应用程序不理解Transfer-Encoding头。

14.42 升级（Upgrade）

升级头允许客户端指定支持的其他通信协议，并在服务器认为合适时切换协议。服务器必须在101（切换协议）响应中使用Upgrade头字段，指示正在切换的协议。

Upgrade = "Upgrade" ":" 1#product

例如：

Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11

Upgrade头旨在提供从HTTP/1.1过渡到其他不兼容协议的简便机制。它允许客户端在当前请求使用HTTP/1.1的同时，广告其希望使用更“优越”协议（由服务器根据请求的方法和资源的性质决定）。这简化了不兼容协议之间的过渡。

Upgrade头字段仅适用于在现有传输层连接上切换应用层协议。不能用来强制协议变更；服务器是否接受由其决定。协议变更后应用层通信的能力和性质完全取决于新协议，但变更后第一步必须是对包含Upgrade头的初始HTTP请求的响应。

Upgrade头字段仅适用于立即连接。因此，若存在Upgrade，必须在连接头（第14.10节）中提供关键字。

Upgrade头不能用于指示切换到不同连接的协议。此类情况应使用301、302、303或305重定向响应。

本规范仅定义“HTTP”协议名，用于HTTP系列协议（第3.1节定义的版本规则及未来更新）。任何标记都可以作为协议名，但只有双方都将其与相同协议关联时才有意义。

14.43 用户代理（User-Agent）

用户代理请求头字段包含发起请求的用户代理信息，用于统计、协议违规追踪，以及自动识别用户代理以优化响应。用户代理应在请求中包含此字段。该字段可以包含多个产品标记（第3.8节）和评论，标识代理及其子产品。通常，产品标记按其识别应用的重要性排序。

User-Agent = "User-Agent" ":" 1*( product | comment )

示例：

User-Agent: CERN-LineMode/2.15 libwww/2.17b3

14.44 变体（Vary）

Vary字段值指示在响应保持新鲜时，哪些请求头字段能完全决定缓存是否允许使用该响应来响应后续请求，无需重新验证。对于不可缓存或陈旧的响应，Vary字段告诉用户代理用以选择表示的标准。Vary字段值为“*”表示缓存无法根据请求头判断此响应是否为合适的表示。关于缓存中Vary头的使用，请参见第13.6节。

Vary = "Vary" ":" ( "*" | 1#field-name )

HTTP/1.1服务器应在任何可缓存且受服务器驱动协商影响的响应中包含Vary头。这样可以帮助缓存正确解释未来对该资源的请求，并通知用户代理存在协商。对于受服务器驱动协商影响的不可缓存响应，也可以包含Vary头，以提供有关响应变化范围的有用信息。

由字段名组成的列表表示响应所选表示基于只考虑列出的请求头字段值的选择算法。缓存可以假设未来请求中只要这些字段值相同，仍会做出相同的选择，前提是响应仍然新鲜。

字段名不限于本规范定义的标准请求头字段。字段名不区分大小写。

“*”值表示未指定参数（不限于请求头）在响应表示选择中的作用（例如，客户端的网络地址）。代理服务器不得生成“*”；只能由源服务器生成。

14.45 通过（Via）

Via头字段由网关和代理使用，用于指示用户代理与服务器之间、以及源服务器与客户端之间的中间协议和接收者。它类似于RFC 822的“Received”字段，用于追踪消息转发、避免请求循环，以及识别链路中所有发件方的协议能力。

Via = "Via" ":" 1#( received-protocol received-by [ comment ] )

received-protocol = [ protocol-name "/" ] protocol-version

protocol-name = token

protocol-version = token

received-by = ( host [ ":" port ] ) | pseudonym

pseudonym = token

received-protocol指示请求/响应链中每段由服务器或客户端接收的消息的协议版本。转发消息时，协议版本会附加到Via字段中，以确保上游应用的协议能力信息对所有接收者可见。

protocol-name是可选的，前提是它是“HTTP”。received-by字段通常是接收方服务器或客户端的主机名和可选端口号。如果认为真实主机名敏感，可以用假名代替。若未提供端口，则假定为接收协议的默认端口。

多个Via字段值代表每个转发该消息的代理或网关。每个接收者必须附加其信息，确保最终顺序反映转发链的顺序。

可以在Via头中加入评论，用于标识接收代理或网关的软件，类似User-Agent和Server头字段。但所有评论都是可选的，任何接收者在转发前都可以删除。

例如，一条请求可能由HTTP/1.0用户代理发出，经过名为“fred”的内部代理（使用HTTP/1.1）转发到名为“nowhere.com”的公共代理，最后由www.ics.uci.edu的源服务器完成请求。此时，www.ics.uci.edu收到的请求的Via头可能如下：

Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)

作为网络防火墙门户的代理和网关，默认不应转发防火墙区域内主机的名称和端口，除非明确启用。未启用时，应用适当的假名替代。

对于有强隐私保护需求、希望隐藏内部结构的组织，代理可以将具有相同received-protocol值的Via头条目合并为一个。例如：

Via: 1.0 ricky, 1.1 ethel, 1.1 fred, 1.0 lucy

可以合并为：

Via: 1.0 ricky, 1.1 mertz, 1.0 lucy

除非这些条目都由同一组织控制且已用假名替换，否则应用不应合并多个条目。不同的received-protocol值的条目也不应合并。

14.46 警告（Warning）

Warning头字段用于携带关于消息状态或变换的附加信息，这些信息可能未在消息中反映。通常用于警告缓存操作或变换对实体体的影响可能导致语义不透明。

Warning头字段格式为：

Warning = "Warning" ":" 1#warning-value

warning-value = warn-code SP warn-agent SP warn-text [SP warn-date]

警告代码  = 3位数字  
警告代理  = （主机 [“:”端口]）|假名  
               ; 添加警告头的服务器的名称或假名，用于调试  
警告文本  = 引号字符串  
警告日期  = <"> HTTP日期 <">  

响应可能携带多个警告头。

警告文本应使用最有可能被接收响应的人工用户理解的自然语言和字符集。这个决定可以基于任何可用的知识，例如缓存或用户的位置，请求中的Accept-Language字段，响应中的Content-Language字段等。默认语言为英语，默认字符集为ISO-8859-1。

如果使用的字符集不是ISO-8859-1，必须按照RFC 2047 [14]中描述的方法对警告文本进行编码。

一般而言，警告头可以应用于任何消息，但某些特定的警告代码仅适用于缓存，且只能应用于响应消息。新添加的警告头应放在任何现有的警告头之后。缓存不得删除它收到的任何警告头。然而，如果缓存成功验证了缓存条目，应删除之前附加在该条目上的任何警告头，除非针对特定警告代码另有说明。验证成功后，缓存还应添加在验证响应中收到的任何警告头。换句话说，警告头是那些会附加到最新相关响应上的。

当响应中附加多个警告头时，用户代理应尽可能按照它们在响应中出现的顺序通知用户。如果无法通知用户所有的警告，用户代理应遵循以下启发式规则：

- 出现在响应早期的警告优先于后续的警告。
- 用户偏好的字符集中的警告优先于其他字符集中的相同警告代码和警告代理。

生成多个警告头的系统应考虑这些用户代理行为进行排序。

关于缓存对警告的行为要求详见第13.1.2节。

以下是当前定义的警告代码列表，每个都附有英文建议警告文本及其含义说明。

110  响应已过期  
    必须在返回的响应过期时包含。

111  重新验证失败  
    如果缓存因无法联系到服务器而返回过期响应时必须包含。

112  断开操作  
    如果缓存故意在一段时间内与网络其他部分断开，应包含。

113  启发式过期  
    如果缓存启发式地选择的新鲜度时间超过24小时，且响应的年龄也超过24小时，必须包含。

199  其他警告  
    警告文本可以包含任何信息，供人类用户查看或记录。接收此警告的系统不得采取任何自动行动，除非是向用户展示。

214  已应用变换  
    如果中间缓存或代理对响应的内容编码（Content-Encoding）或媒体类型（Content-Type）或实体主体进行了变换（除非该警告代码已在响应中出现），则必须添加。

299  其他持久性警告  
    警告文本可以包含任何信息，供人类用户查看或记录。接收此警告的系统不得采取任何自动行动。

如果实现发送的消息中包含版本为HTTP/1.0或更低的一个或多个警告头，则必须在每个警告值中包含一个与响应日期相匹配的warn-date。

如果接收的消息中包含带有warn-date的警告值，并且该warn-date与响应中的Date值不同，则在存储、转发或使用之前，必须删除该警告值中的warn-date（以防止天真缓存Warning头字段带来的不良后果）。如果因此删除了所有警告值，也必须删除Warning头。

14.47 WWW-Authenticate

WWW-Authenticate响应头字段必须在401（未授权）响应消息中包含。该字段值至少包含一个挑战，指示适用于请求URI的认证方案及参数。

       WWW-Authenticate  = "WWW-Authenticate" ":" 1#challenge

HTTP访问认证过程详见“HTTP认证：基本和摘要访问认证”[43]。建议用户代理在解析WWW-Authenticate字段值时格外小心，因为它可能包含多个挑战，或者如果提供多个WWW-Authenticate头字段，挑战本身的内容也可能包含用逗号分隔的认证参数列表。

15 安全注意事项

本节旨在告知应用开发者、信息提供者和用户关于HTTP/1.1中存在的安全限制。本讨论不提供问题的最终解决方案，但提出一些减少安全风险的建议。

15.1 个人信息

HTTP客户端通常掌握大量个人信息（如用户姓名、位置、邮箱、密码、加密密钥等），应非常谨慎地防止这些信息通过HTTP协议无意中泄露给其他来源。强烈建议提供便捷的界面让用户控制此类信息的传播，设计者和实现者在此方面应特别小心。历史经验表明，这方面的错误常会引发严重的安全和隐私问题，并给实现者公司带来负面影响。

15.1.1 滥用服务器日志信息

服务器可能保存关于用户请求的个人数据，这些数据可能识别用户的阅读习惯或兴趣主题。这些信息本质上是机密的，其处理在某些国家可能受到法律限制。使用HTTP协议提供数据的用户有责任确保未经允许不得将此类信息传播给任何可识别的个人。

15.1.2 敏感信息的传输

像任何通用数据传输协议一样，HTTP无法控制传输内容的敏感程度，也没有事先方法判断请求中某一信息的敏感性。因此，应用应尽可能让信息提供者对这些信息拥有控制权。在此背景下，特别值得提及的头字段有：Server、Via、Referer和From。

- 公开服务器软件版本可能使服务器更易受到已知安全漏洞的攻击。实现者应将Server头字段设为可配置。

- 作为网络防火墙门户的代理应特别注意传输识别后端主机的头信息，尤其是应删除或用已清理的版本替换任何由防火墙后端生成的Via字段。

- Referer头允许分析用户的浏览模式和反向链接，虽然非常有用，但如果不将用户信息与Referer中的内容分离，可能被滥用。即使已去除个人信息，Referer也可能指示某个私有文档的URI，其公开可能不合适。

- From字段中发送的信息可能与用户隐私或站点安全策略冲突，因此不应在用户未能禁用、启用或修改该字段内容的情况下传输。用户必须能在偏好设置或应用默认配置中设置此字段。

- 建议（非强制）提供便捷的切换界面，让用户选择是否发送From和Referer信息。

- User-Agent（第14.43节）或Server（第14.38节）头字段有时可用来识别存在特定安全漏洞的客户端或服务器，但这些信息也常被用作其他用途，HTTP目前没有更好的机制。

15.1.3 URI中敏感信息的编码

由于链接的来源可能是私人信息或可能泄露其他私人信息源，强烈建议用户能选择是否发送Referer字段。例如，浏览器可以提供“匿名浏览”或“公开浏览”的切换，分别启用或禁用Referer和From信息的发送。

如果引用页面通过安全协议传输，客户端不应在非安全HTTP请求中包含Referer头。

使用HTTP协议的服务提供者不应使用GET表单提交敏感数据，因为这会将数据编码在请求URI中，许多现有服务器、代理和用户代理会在某些位置记录请求URI，可能被第三方看到。建议改用POST表单提交。

15.1.4 与Accept头相关的隐私问题

Accept请求头可能泄露用户信息，尤其是Accept-Language头，可能暴露用户的民族或语言偏好。建议用户代理在每次请求中配置Accept-Language头时，加入提示信息，让用户意识到隐私风险。

一种减少隐私泄露的方法是，用户代理默认不发送Accept-Language头，只有在检测到服务器返回的Vary响应头表明可能改善服务质量时，才询问用户是否开始发送。

用户自定义的Accept头（尤其带有质量值）可能被服务器用作相对可靠且持久的用户标识符，用于点击轨迹追踪或跨服务器匹配。对于没有代理的用户，主机的网络地址也可作为长效用户标识符。在使用代理以增强隐私的环境中，用户代理应谨慎提供Accept头配置选项。极端情况下，代理可以过滤中继请求中的Accept头。提供高度可配置的用户代理应警告用户可能的隐私损失。

15.2 基于文件名和路径名的攻击

HTTP源服务器的实现应当谨慎限制通过HTTP请求返回的文档内容，仅限于由服务器管理员预期提供的内容。如果HTTP服务器将HTTP URI直接转换为文件系统调用，则必须特别注意不要提供未被授权传递给HTTP客户端的文件。例如，UNIX、Microsoft Windows及其他操作系统使用“..”作为路径组件，表示上一级目录。在此类系统中，HTTP服务器必须禁止在请求URI中使用此类构造，以免访问超出HTTP服务器预期范围的资源。同样，旨在仅供服务器内部参考的文件（如访问控制文件、配置文件和脚本代码）也必须受到保护，避免被不当检索，因为它们可能包含敏感信息。经验表明，这类HTTP服务器实现中的微小漏洞可能演变成安全风险。

15.3 DNS欺骗

使用HTTP的客户端高度依赖域名服务（DNS），因此容易受到基于故意错误关联IP地址和DNS名称的安全攻击。客户端应谨慎对待IP地址与DNS名称的持续有效性。

特别是，HTTP客户端应依赖其名称解析器确认IP地址与DNS名称的关联，而非缓存之前的主机名查询结果。许多平台已能在适当情况下本地缓存主机名查询结果，应配置为如此。只有当名称服务器报告的TTL（存活时间）信息表明缓存信息仍然可能有效时，缓存才是合理的。

如果HTTP客户端为了提升性能而缓存主机名查询结果，必须遵守DNS报告的TTL信息。

如果不遵守此规则，当已访问的服务器IP地址发生变化时，客户端可能会被欺骗。随着网络重新编号变得日益普遍[24]，此类攻击的可能性也会增加。因此，遵守此要求有助于降低潜在的安全漏洞。

此外，这一要求还能改善使用相同DNS名称的复制服务器的负载均衡行为，减少用户访问使用该策略站点时失败的可能性。

15.4 Location头字段与欺骗

如果单一服务器支持多个彼此不信任的组织，则必须检查响应中的Location和Content-Location头字段，确保它们不试图使其无权管理的资源失效。

15.5 Content-Disposition问题

RFC 1806 [35]定义的Content-Disposition（见第19.5.1节）头字段在实际中被广泛实现，但存在许多严重的安全考虑。Content-Disposition并非HTTP标准的一部分，但鉴于其广泛应用，本文记录其使用风险。详情请参阅RFC 2183 [49]（对RFC 1806的更新）。

15.6 认证凭据与空闲客户端

现有的HTTP客户端和用户代理通常会无限期保留认证信息。HTTP/1.1未提供机制让服务器指示客户端丢弃这些缓存的凭据。这是一个重大缺陷，需在HTTP中引入扩展。凭据缓存可能干扰应用的安全模型，具体情况包括但不限于：

- 客户端长时间空闲后，服务器可能希望促使客户端重新提示用户输入凭据。
- 应用中包含会话终止指示（如页面上的“注销”或“提交”按钮），之后服务器“知道”客户端无需再保留凭据。

此问题目前正进行单独研究。已有一些解决方案，我们鼓励在屏幕保护程序、空闲超时等方法中使用密码保护，以减轻此问题的安全隐患。特别是，缓存凭据的用户代理应提供便捷的机制，让用户可以自行清除缓存凭据。

15.7 代理与缓存

由于其本质，HTTP代理是“中间人”，存在中间人攻击的风险。代理系统被攻破可能导致严重的安全和隐私问题。代理可以访问安全相关信息、个人信息、组织信息以及内容提供者的专有信息。被攻破或未考虑安全和隐私的代理可能被用于多种攻击。

代理运营者应像保护任何含敏感信息的系统一样保护代理系统。特别是，代理收集的日志信息通常包含高度敏感的个人或组织信息，应严格保管，并制定相应的使用指南（见第15.1.1节）。

缓存代理还存在额外的潜在漏洞，因为缓存内容是攻击的潜在目标。缓存内容在HTTP请求完成后仍然存在，攻击者可以在用户认为信息已被删除后仍能访问到这些信息。因此，缓存内容应视为敏感信息加以保护。

代理实现者应考虑其设计、编码和配置选项对隐私和安全的影响（尤其是默认配置）。用户应意识到，他们对代理的信任程度不高，HTTP本身无法解决此问题。

在适当情况下，合理使用加密技术可能足以防范多种安全和隐私攻击，但这超出了HTTP/1.1规范的范围。

15.7.1 拒绝服务攻击（DoS）对代理的影响

此类攻击存在，且难以防御。研究仍在进行中。请保持警惕。

16 致谢

本规范大量借鉴了David H. Crocker为RFC 822 [9]定义的增强BNF和通用结构。同样，许多定义借鉴了Nathaniel Borenstein和Ned Freed为MIME [7]提供的内容。希望这些内容的加入能帮助减少过去关于HTTP与互联网邮件消息格式关系的混淆。

HTTP协议多年来不断发展，得益于庞大而活跃的开发者社区——即参与www-talk邮件列表的众多人士——正是这个社区推动了HTTP和万维网的成功。特别感谢Marc Andreessen、Robert Cailliau、Daniel W. Connolly、Bob Denny、John Franks、Jean-Francois Groff、Phillip M. Hallam-Baker、Hakon W. Lie、Ari Luotonen、Rob McCool、Lou Montulli、Dave Raggett、Tony Sanders和Marc VanHeyningen，他们在定义协议早期阶段做出了重要贡献。

本文件还得益于所有参与HTTP工作组成员的宝贵意见。除前述人士外，以下个人也为本规范的完善做出了贡献：

（名单略）

缓存设计的内容和表现形式在很大程度上得益于Shel Kaphan、Paul Leach、Koen Holtman、David Morris和Larry Masinter等人的建议和评论。

范围的多数定义基于Ari Luotonen和John Franks的早期工作，并得到Steve Zilles的补充。

感谢帕洛阿尔托的“穴居人”。你们知道自己是谁。

我（Jim Gettys，本文当前编辑）特别感谢Roy Fielding（前任编辑）、John Klensin、Jeff Mogul、Paul Leach、Dave Kristol、Koen Holtman、John Franks、Josh Cohen、Alex Hopmann、Scott Lawrence和Larry Masinter的帮助。特别感谢Jeff Mogul和Scott Lawrence对“必须/可以/应当”规则的审查。

17 参考文献

（略，内容为各种RFC编号和相关文献，详见原文）

[24] Carpenter, B. 和 Y. Rekhter，“重新编号的需求需要改进”，RFC 1900，1996年2月。

[25] Deutsch, P.，“GZIP文件格式规范版本4.3”，RFC 1952，1996年5月。

Fielding 等人            标准轨道                   [第159页]

RFC 2616                        HTTP/1.1                       1999年6月

[26] Venkata N. Padmanabhan 和 Jeffrey C. Mogul。“改善HTTP延迟”，计算机网络与ISDN系统，第28卷，第25-35页，1995年12月。该论文在“第二届国际万维网会议’94：Mosaic与Web”中的论文略有修订，1994年10月，相关资料可在 http://www.ncsa.uiuc.edu/SDG/IT94/Proceedings/DDay/mogul/HTTPLatency.html 获取。

[27] Joe Touch、John Heidemann 和 Katia Obraczka。“HTTP性能分析”，<URL: http://www.isi.edu/touch/pubs/http-perf96/>，ISI研究报告ISI/RR-98-463（原始报告日期为1996年8月），美国南加州大学信息科学研究所，1998年8月。

[28] Mills, D.，“网络时间协议（版本3）规范、实现与分析”，RFC 1305，1992年3月。

[29] Deutsch, P.，“DEFLATE压缩数据格式规范版本1.3”，RFC 1951，1996年5月。

[30] S. Spero，“HTTP性能问题分析”，http://sunsite.unc.edu/mdma-release/http-prob.html。

[31] Deutsch, P. 和 J. Gailly，“ZLIB压缩数据格式规范版本3.3”，RFC 1950，1996年5月。

[32] Franks, J.、Hallam-Baker, P.、Hostetler, J.、Leach, P.、Luotonen, A.、Sink, E. 和 L. Stewart，“对HTTP的扩展：摘要访问认证”，RFC 2069，1997年1月。

[33] Fielding, R.、Gettys, J.、Mogul, J.、Frystyk, H. 和 T. Berners-Lee，“超文本传输协议——HTTP/1.1”，RFC 2068，1997年1月。

[34] Bradner, S.，“在RFC中使用的关键词以指示需求级别”，BCP 14，RFC 2119，1997年3月。

[35] Troost, R. 和 Dorner, S.，“在互联网消息中传达展示信息：Content-Disposition头”，RFC 1806，1995年6月。

[36] Mogul, J.、Fielding, R.、Gettys, J. 和 H. Frystyk，“HTTP版本号的使用与解释”，RFC 2145，1997年5月。[jg639]

[37] Palme, J.，“通用互联网消息头”，RFC 2076，1997年2月。[jg640]

Fielding 等人            标准轨道                   [第160页]

RFC 2616                        HTTP/1.1                       1999年6月

[38] Yergeau, F.，“UTF-8：Unicode和ISO-10646的转换格式”，RFC 2279，1998年1月。[jg641]

[39] Nielsen, H.F.、Gettys, J.、Baird-Smith, A.、Prud'hommeaux, E.、Lie, H. 和 C. Lilley。“HTTP/1.1、CSS1和PNG对网络性能的影响”，在ACM SIGCOMM ’97会议论文集，法国康城，1997年9月。[jg642]

[40] Freed, N. 和 N. Borenstein，“多用途互联网邮件扩展（MIME）第二部分：媒体类型”，RFC 2046，1996年11月。[jg643]

[41] Alvestrand, H.，“IETF字符集和语言政策”，BCP 18，RFC 2277，1998年1月。[jg644]

[42] Berners-Lee, T.、Fielding, R. 和 L. Masinter，“统一资源标识符（URI）：通用语法和语义”，RFC 2396，1998年8月。[jg645]

[43] Franks, J.、Hallam-Baker, P.、Hostetler, J.、Lawrence, S.、Leach, P.、Luotonen, A.、Sink, E. 和 L. Stewart，“HTTP认证：基本和摘要访问认证”，RFC 2617，1999年6月。[jg646]

[44] Luotonen, A.，“通过Web代理服务器隧道传输基于TCP的协议”，工作中稿。[jg647]

[45] Palme, J. 和 A. Hopmann，“MIME电子邮件封装聚合文档（如HTML的MHTML）”，RFC 2110，1997年3月。

[46] Bradner, S.，“互联网标准流程——修订版3”，BCP 9，RFC 2026，1996年10月。

[47] Masinter, L.，“超文本咖啡壶控制协议（HTCPCP/1.0）”，RFC 2324，1998年4月1日。

[48] Freed, N. 和 N. Borenstein，“多用途互联网邮件扩展（MIME）第五部分：符合性标准和示例”，RFC 2049，1996年11月。

[49] Troost, R.、Dorner, S. 和 K. Moore，“在互联网消息中传达展示信息：Content-Disposition头字段”，RFC 2183，1997年8月。

---

作者联系方式

Roy T. Fielding  
加州大学欧文分校  
信息与计算机科学系  
地址：美国加利福尼亚州欧文市，邮编92697-3425  
传真：+1 (949) 824-1715  
电子邮箱：fielding@ics.uci.edu

James Gettys  
万维网联盟（W3C）  
麻省理工学院计算机科学实验室  
地址：麻省剑桥市，科技广场545号，邮编02139  
传真：+1 (617) 258 8682  
电子邮箱：jg@w3.org

Jeffrey C. Mogul  
惠普公司西部研究实验室  
地址：美国加州帕洛阿尔托，大学大道250号，邮编94305  
电子邮箱：mogul@wrl.dec.com

Henrik Frystyk Nielsen  
万维网联盟（W3C）  
麻省理工学院计算机科学实验室  
地址：麻省剑桥市，科技广场545号，邮编02139  
传真：+1 (617) 258 8682  
电子邮箱：frystyk@w3.org

Larry Masinter  
施乐公司  
地址：美国加州帕洛阿尔托，Coyote Hill Road 3333号，邮编94034  
电子邮箱：masinter@parc.xerox.com

Paul J. Leach  
微软公司  
地址：美国华盛顿州雷德蒙德，微软大道1号  
电子邮箱：paulle@microsoft.com

Tim Berners-Lee  
万维网联盟（W3C）主任  
麻省理工学院计算机科学实验室  
地址：麻省剑桥市，科技广场545号，邮编02139  
传真：+1 (617) 258 8682  
电子邮箱：timbl@w3.org

---

[第163页]完

19 附录

19.1 互联网媒体类型 message/http 和 application/http

除了定义HTTP/1.1协议外，本文件还作为“message/http”和“application/http”两种互联网媒体类型的规范。message/http类型可以用来封装单个HTTP请求或响应消息，前提是其符合所有“message”类型关于行长度和编码的MIME限制。application/http类型可以用来封装一串（一个或多个）HTTP请求或响应消息（不可混用）。以下内容需向IANA注册[17]。

- 媒体类型名称：message  
- 子类型名称：http  
- 必需参数：无  
- 可选参数：version（版本）、msgtype（消息类型）  
  - version：封装消息的HTTP版本号（如“1.1”）。若未提供，可从消息的第一行推断。  
  - msgtype：消息类型——“request”或“response”。若未提供，可从第一行推断。  
- 编码考虑：仅允许“7bit”、“8bit”或“binary”。  
- 安全考虑：无

- 媒体类型名称：application  
- 子类型名称：http  
- 必需参数：无  
- 可选参数：version（版本）、msgtype（消息类型）  
  - version：封装消息的HTTP版本号（如“1.1”）。若未提供，可从第一行推断。  
  - msgtype：消息类型——“request”或“response”。若未提供，可从第一行推断。  
- 编码考虑：由此类型封装的HTTP消息为“二进制”格式；通过电子邮件传输时，需使用适当的Content-Transfer-Encoding。  
- 安全考虑：无

19.2 互联网媒体类型 multipart/byteranges

当HTTP 206（部分内容）响应消息包含多个范围的内容（对多个不重叠范围的请求的响应）时，这些内容作为多部分消息体传输。此类媒体类型称为“multipart/byteranges”。

该多部分/byteranges媒体类型包含两个或多个部分，每个部分有自己的Content-Type和Content-Range字段。必需参数boundary指定用以分隔各个消息体部分的边界字符串。

- 媒体类型名称：multipart  
- 子类型名称：byteranges  
- 必需参数：boundary  
- 可选参数：无  
- 编码考虑：仅允许“7bit”、“8bit”或“binary”  
- 安全考虑：无

示例：

```
HTTP/1.1 206 Partial Content
Date: Wed, 15 Nov 1995 06:25:24 GMT
Last-Modified: Wed, 15 Nov 1995 04:58:08 GMT
Content-type: multipart/byteranges; boundary=THIS_STRING_SEPARATES

--THIS_STRING_SEPARATES
Content-type: application/pdf
Content-range: bytes 500-999/8000

...第一个范围内容...
--THIS_STRING_SEPARATES
Content-type: application/pdf
Content-range: bytes 7000-7999/8000

...第二个范围内容...
--THIS_STRING_SEPARATES--
```

注意事项：

1) 在实体的第一个边界字符串之前，可能会有额外的CRLF。

2) 虽然RFC 2046 [40]允许用引号括起边界字符串，但某些现有实现会错误处理带引号的边界字符串。

3) 一些浏览器和服务器早期实现使用了multipart/x-byteranges媒体类型（基于早期草案），与HTTP/1.1中记录的版本几乎兼容，但不完全一致。

19.3 宽容性应用

虽然本文规定了生成HTTP/1.1消息的要求，但并非所有应用都能完全符合。建议操作性应用在偏差可以被无歧义解释的情况下，应表现出宽容。

客户端在解析状态行时应宽容，服务器在解析请求行时也应宽容。特别是，字段之间允许有任意数量的空格（SP）或水平制表符（HT），即使只要求一个空格。

消息头字段的行终止符为CRLF序列，但建议在解析此类头时，将单个LF视为行终止符，并忽略前导的CR。

实体主体的字符集应标记为该主体中所用字符码的最低公分母，但不标记时优先于用US-ASCII或ISO-8859-1标记。详见第3.7.1节和3.4.1节。

关于日期的解析和编码的额外规则，包括：

- HTTP/1.1客户端和缓存应假设出现超过50年未来的RFC-850日期实际上是过去的（有助于解决“千年虫”问题）。

- HTTP/1.1实现可以在内部将解析的Expires日期表示为早于实际值，但不得表示为晚于实际值。

- 所有到期相关的计算必须在GMT中进行。本地时区不得影响年龄或到期时间的计算或比较。

- 如果HTTP头部错误地携带非GMT时区的日期值，必须使用最保守的转换将其转换为GMT。

19.4 HTTP实体与RFC 2045实体的差异

HTTP/1.1借用了许多定义于互联网邮件（RFC 822 [9]）和多用途互联网邮件扩展（MIME [7]）的结构，以支持多样的表示和可扩展机制。然而，RFC 2045主要讨论邮件，而HTTP在某些方面与RFC 2045不同。这些差异经过精心选择，旨在优化二进制连接的性能、允许更大自由度使用新媒体类型、简化日期比较，以及考虑一些早期HTTP服务器和客户端的实践。

本附录描述HTTP与RFC 2045的具体差异。代理和网关在严格MIME环境中应注意这些差异，并在必要时进行相应转换。反之，从MIME环境到HTTP的代理和网关也需了解这些差异，以便进行必要的转换。

19.4.1 MIME-Version

HTTP不是一个严格的MIME协议，但HTTP/1.1消息可以包含单个MIME-Version头字段，以指示所用的MIME版本。使用MIME-Version头字段表示消息完全符合RFC 2045定义的MIME协议。代理/网关在将HTTP消息导出到严格MIME环境时，应确保尽可能符合。

MIME-Version = "MIME-Version" ":" 1*DIGIT "." 1*DIGIT

HTTP/1.1默认使用MIME版本“1.0”。但本文件定义了HTTP/1.1的消息解析和语义，而非依赖MIME规范。

19.4.2 转换为规范形式

RFC 2045 [7]要求在传输前将互联网邮件实体转换为规范形式（详见RFC 2049 [48]第4节）。本文件第3.7.1节描述了在HTTP中传输“text”媒体类型子类型时允许的形式。RFC 2046要求“text”类型的内容将换行符表示为CRLF，禁止在行结束序列之外使用CR或LF。HTTP允许在传输文本内容时使用CRLF、裸CR或裸LF作为换行符。

在可能的情况下，从HTTP到严格MIME环境的代理或网关应将文本媒体类型中的所有换行符转换为RFC 2049的规范形式CRLF。注意，这可能因内容编码的存在以及HTTP允许使用不使用13和10字节（CR和LF）的字符集（如某些多字节字符集）而变得复杂。

实现者应注意，除非原始内容已处于规范化形式，否则转换过程会破坏应用于原始内容的任何加密校验和。因此，建议在HTTP中使用此类校验和的内容采用规范化形式。

19.4.3 日期格式的转换

HTTP/1.1使用一组受限的日期格式（第3.3.1节）以简化日期比较过程。来自其他协议的代理和网关应确保消息中的任何Date头字段符合HTTP/1.1的格式之一，并在必要时重写日期。

19.4.4 引入内容编码

RFC 2045没有包含等同于HTTP/1.1中Content-Encoding头字段的概念。由于它作为媒体类型的修饰符，HTTP到MIME兼容协议的代理和网关必须在转发消息前更改Content-Type头字段的值或解码实体主体。（一些互联网邮件中Content-Type的试验性应用使用了“;conversions=<content-coding>”的媒体类型参数来执行与Content-Encoding等效的功能，但该参数不属于RFC 2045。）

19.4.5 无内容传输编码

HTTP不使用RFC 2045中的Content-Transfer-Encoding（CTE）字段。从MIME兼容协议到HTTP的代理和网关必须在将响应消息交付给HTTP客户端之前，移除任何非标识的CTE（如“quoted-printable”或“base64”）编码。

从HTTP到MIME兼容协议的代理和网关负责确保消息采用正确的格式和编码，以便在该协议上安全传输，其中“安全传输”由所使用协议的限制定义。如果这样做能提高在目标协议上的安全传输可能性，代理或网关应使用适当的Content-Transfer-Encoding对数据进行标记。

19.4.6 引入传输编码

HTTP/1.1引入了Transfer-Encoding头字段（第14.41节）。代理/网关在通过MIME兼容协议转发消息前，必须移除任何传输编码。

“chunked”传输编码（第3.6节）的解码伪代码示例如下：

```
length := 0
读取块大小、块扩展（如果有）和CRLF
while (块大小 > 0) {
    读取块数据和CRLF
    将块数据附加到实体主体
    length := length + 块大小
    读取下一个块大小和CRLF
}
读取实体头
while (实体头不为空) {
    将实体头附加到现有头字段
    读取实体头
}
Content-Length := length
移除“chunked”从Transfer-Encoding
```

19.4.7 MHTML与行长度限制

与MHTML [45]实现共享代码的HTTP实现需要注意MIME的行长度限制。由于HTTP本身没有此限制，因此不会折叠长行。通过HTTP传输的MHTML消息遵循所有MHTML的惯例，包括行长度限制、折叠、规范化等，因为HTTP将所有消息体作为有效载荷（见第3.7.2节）传输，并不解析内容或其中可能包含的任何MIME头行。

19.5 附加特性

RFC 1945和RFC 2068描述了某些现有HTTP实现中使用的协议元素，但在大多数HTTP/1.1应用中并不一致或正确。建议实现者了解这些特性，但不能依赖它们的存在或与其他HTTP/1.1应用的互操作性。其中一些描述了拟议的实验性特性，另一些则是实验部署中发现不足之处，现已在基础HTTP/1.1规范中得到解决。

此外，还常见一些其他头字段，如Content-Disposition和Title，源自SMTP和MIME（参见RFC 2076 [37]）。

19.5.1 Content-Disposition

Content-Disposition响应头字段被提出作为一种方式，让源服务器在用户请求将内容保存为文件时，建议默认文件名。此用法源自RFC 1806 [35]中对Content-Disposition的定义。

示例：

```
Content-Disposition: attachment; filename="fname.ext"
```

接收端用户代理不应尊重任何在filename参数中存在的目录路径信息（目前认为唯一适用于HTTP的参数），应将文件名视为终端组件。

如果在响应中使用此头且内容类型为application/octet-stream，暗示用户代理不应显示响应，而应直接弹出“另存为...”对话框。

有关Content-Disposition的安全性问题，请参见第15.5节。

19.6 与以前版本的兼容性

协议规范超出范围，不会强制要求遵守早期版本。然而，HTTP/1.1的设计故意使支持早期版本变得容易。值得注意的是，在撰写本规范（1996年）时，预期商业HTTP/1.1服务器应：

- 识别HTTP/0.9、1.0和1.1请求的Request-Line格式；
- 理解任何符合HTTP/0.9、1.0或1.1格式的有效请求；
- 以客户端使用的主要版本的消息作出适当响应。

同时，预期HTTP/1.1客户端应：

- 识别HTTP/1.0和1.1响应的Status-Line格式；
- 理解任何符合HTTP/0.9、1.0或1.1格式的有效响应。

对于大多数HTTP/1.0实现，连接在请求前由客户端建立，响应后由服务器关闭。一些实现支持RFC 2068第19.7.1节描述的持久连接（Keep-Alive）版本。

19.6.1 与HTTP/1.0的变化

本节总结HTTP/1.0与HTTP/1.1的主要差异。

19.6.1.1 简化多宿主Web服务器和节省IP地址的变更

支持Host请求头、在HTTP/1.1请求中缺少Host请求头时报告错误，以及接受绝对URI的要求，是本规范定义的最重要变更之一。

早期HTTP/1.0客户端假设IP地址与服务器一一对应；没有其他机制区分请求的目标服务器。上述变更将支持在未来不再普遍使用旧HTTP客户端的情况下，从单一IP地址支持多个网站，大大简化大型Web服务器的运维，解决多个IP地址分配带来的问题。还可以回收为特殊域名在根级HTTP URL中使用而分配的IP地址。鉴于Web的增长速度和已部署的服务器数量，所有HTTP实现（包括对现有HTTP/1.0应用的更新）都必须正确实现这些要求：

- 客户端和服务器必须支持Host请求头；
- 发送HTTP/1.1请求的客户端必须包含Host头；
- 如果HTTP/1.1请求未包含Host头，服务器必须返回400（错误请求）；
- 服务器必须接受绝对URI。

19.6.2 与HTTP/1.0持久连接的兼容性

一些客户端和服务器可能希望兼容HTTP/1.0中某些持久连接的早期实现。HTTP/1.0中的持久连接是通过显式协商实现的，因为它们不是默认行为。HTTP/1.0的实验性持久连接实现存在缺陷，HTTP/1.1中的新机制旨在修正这些问题。问题在于某些旧的HTTP/1.0客户端可能会向不理解Connection头的代理发送Keep-Alive，代理会错误地将其转发到下游服务器，后者建立连接后导致HTTP/1.0代理等待响应关闭，从而造成挂起。为此，必须阻止HTTP/1.0客户端在与代理通信时使用Keep-Alive。

然而，与代理通信是持久连接最重要的用途，因此完全禁止是不合理的。应采用其他机制指示希望使用持久连接，即使与忽略Connection的旧代理通信也安全。HTTP/1.1默认使用持久连接，新增了“Connection: close”关键词（第14.10节）以声明非持久连接。

HTTP/1.0中持久连接的原始形式（Connection: Keep-Alive和Keep-Alive头）详见RFC 2068 [33]。

19.6.3 与RFC 2068的变更

本规范经过仔细审查，修正并澄清了关键词的用法；RFC 2068在遵循RFC 2119 [34]的约定方面存在许多问题。

明确了服务器失败（如DNS失败）应使用的错误码（第10.5.5节）。

创建资源时需要发送Etag的竞态条件已修正（第10.2.2节）。

删除了Content-Base，因为未被广泛实现，且没有简单、安全的扩展机制引入。此外，它在MHTML [45]中以类似但不完全相同的方式使用。

传输编码和消息长度的交互关系在使用分块编码时需要特别修正，以正确计算消息长度（第3.6、4.4、7.2.2、13.5.2、14.13、14.16节）。

引入“identity”内容编码，以解决缓存中发现的问题（第3.5节）。

零质量值（q=0）应表示“我不想要某内容”，以允许客户端拒绝某个表示（第3.9节）。

通过RFC 2145澄清了HTTP版本号的使用和解释。要求代理升级请求到其支持的最高协议版本，以解决HTTP/1.0实现中发现的问题（第3.1节）。

引入字符集通配符，避免accept头中字符集名称爆炸（第14.2节）。

在HTTP/1.1的Cache-Control模型中遗漏了s-maxage，现引入以补充（第13.4、14.8、14.9、14.9.3节）。

对响应中的Cache-Control: max-age指令定义不当的问题已修正（第14.9.3节）。

在某些情况下，服务器（尤其是代理）可能不知道完整响应长度，但能处理字节范围请求。为此，需引入机制允许在内容范围未指示完整消息长度的情况下使用字节范围（第14.16节）。

如果所有元数据都返回，范围请求响应会变得非常冗长；通过允许服务器在206响应中只发送必要的头部，可以避免此问题（第10.2.7、13.5.3、14.27节）。

修正范围请求不满足的情况，包括语法问题和范围不存在于文档中的情况。引入状态码416以明确指示超出内容范围的字节范围请求错误（第10.4.17、14.16节）。

重写消息传输要求，使实现者更难出错，避免错误对互联网产生重大影响，并解决以下问题：

1. 将“HTTP/1.1或更高版本”改为“HTTP/1.1”，以避免错误地对未来版本的实现施加要求；
2. 明确用户代理应重试请求，而非“客户端”；
3. 将客户端忽略意外的100（Continue）响应的要求，以及代理转发100响应的要求，统一为对所有1xx响应的要求；
4. 修改部分TCP相关措辞，更清楚地表明非TCP传输也是可能的；
5. 要求源服务器在发送100（Continue）响应前不得等待请求体。

6. 允许服务器在已经看到部分请求体的情况下，选择省略100（继续）响应，而不是强制要求。

7. 允许服务器采取措施防御拒绝服务攻击和损坏的客户端。

此变更引入了Expect头字段和417状态码。消息传输要求的修正内容见第8.2节、第10.4.18节、第8.1.2.2节、第13.11节和第14.20节。

代理服务器应在适当情况下能够添加Content-Length头字段。（第13.5.2节）

澄清403和404响应之间的混淆问题。（第10.4.4节、第10.4.5节和第10.4.11节）

警告信息可能被错误缓存，或未能适当更新。（第13.1.2节、第13.2.4节、第13.5.2节、第13.5.3节、第14.9.3节和第14.46节）此外，警告头还应作为通用头字段，因为PUT或其他方法在请求中可能需要使用。

Fielding 等人            标准轨迹                   [第174页]

RFC 2616                        HTTP/1.1                       1999年6月

传输编码存在重大问题，尤其是在与分块编码的交互中。解决方案是将传输编码发展为与内容编码同等重要。这包括为传输编码（与内容编码分开）新增IANA注册表、引入新的头字段（TE）以及未来支持Trailer头。传输编码带来显著的性能提升，因此值得修正[39]。TE还解决了由认证Trailer、分块编码和HTTP/1.0客户端之间的交互可能引发的另一个晦涩的向下兼容性问题。（第3.6节、第3.6.1节和第14.39节）

PATCH、LINK、UNLINK方法已被定义，但在之前的版本中并不常见。详见RFC 2068 [33]。

Alternates、Content-Version、Derived-From、Link、URI、Public和Content-Base等头字段在之前的版本中已被定义，但未被广泛实现。详见RFC 2068 [33]。

20 索引

请参阅本RFC的PostScript版本以获取索引。

Fielding 等人            标准轨迹                   [第175页]

RFC 2616                        HTTP/1.1                       1999年6月

21. 完整版权声明

版权所有 (C) 互联网协会（1999年）。保留所有权利。

本文件及其翻译版本可以被复制、提供给他人，且可以对其进行评论、解释或协助实现的衍生作品，全部或部分复制、出版和分发，且不受任何限制，前提是所有此类副本和衍生作品都必须包含上述版权声明和本段内容。然而，本文件本身不得以任何方式修改，例如删除版权声明或提及互联网协会或其他互联网组织，除非为制定互联网标准的目的所需，且必须遵循互联网标准流程中的版权程序，或为将其翻译成非英语语言所必需。

上述授予的有限权限是永久性的，不会被互联网协会或其继任者或受让人撤销。

本文件及其中包含的信息是“按原样”提供的，互联网协会和互联网工程任务组（IETF）不对其作任何明示或暗示的保证，包括但不限于不保证其不会侵犯任何权利，或对其适销性或特定用途的适用性作出任何保证。

致谢

RFC编辑工作由互联网协会目前提供资金支持。