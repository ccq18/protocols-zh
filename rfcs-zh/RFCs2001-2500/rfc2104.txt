# RFC 2104 中文翻译 (stub)
# 原文文件: ../../rfcs/RFCs2001-2500/rfc2104.txt

网络工作组                                       H. Krawczyk
评论请求：2104                                              IBM
类别：信息性                                              M. Bellare
                                                               UCSD
                                                         R. Canetti
                                                                IBM
                                                      1997年2月

             HMAC：用于消息认证的密钥哈希机制

本备忘录的状态

   本备忘录旨在向互联网社区提供信息。 本备忘录
   并不规定任何类型的互联网标准。 本备忘录的分发
   不受限制。

摘要

   本文介绍了HMAC，一种利用密码学哈希函数进行消息认证的机制。HMAC可以与任何
   迭代密码学哈希函数（例如MD5、SHA-1）结合使用，配合一个共享的秘密密钥。HMAC的
   密码学强度取决于底层哈希函数的特性。

1. 引言

   在开放计算和通信的世界中，提供一种验证传输或存储信息完整性的方法是
   一项基本需求。基于秘密密钥的完整性验证机制通常被称为“消息认证码”（MAC）。
   通常，消息认证码在两个共享秘密密钥的方之间使用，用于验证这些方之间传输的信息。
   本文介绍的这种基于密码学哈希函数的MAC机制，称为HMAC。该机制基于作者们的工作
   [BCK1]，其中介绍了其构造和密码学分析。关于HMAC的原理、安全性分析以及与其他
   密钥哈希方法的比较，详见该工作。

Krawczyk 等人            信息性                     [第1页]

RFC 2104                          HMAC                     1997年2月

   HMAC可以与任何迭代密码学哈希函数结合使用。MD5和SHA-1是此类哈希函数的例子。HMAC
   还使用秘密密钥来计算和验证消息认证值。该构造的主要目标包括：

   * 在不修改的情况下使用现有的哈希函数。
     特别是那些在软件中表现良好、代码免费且广泛可用的哈希函数。

   * 保持哈希函数的原始性能，而不造成显著的性能下降。

   * 简单地使用和处理密钥。

   * 具有对基于合理假设的底层哈希函数的安全性进行良好理解的密码学分析。

为了方便在发现或需要更快或更安全的哈希函数时，能够轻松替换底层的哈希函数。

本文件规定了使用通用密码学哈希函数（用H表示）实现的HMAC。具体的HMAC实例需要定义特定的哈希函数。目前候选的哈希函数包括SHA-1 [SHA]、MD5 [MD5]、RIPEMD-128/160 [RIPEMD]等。这些不同实现的HMAC将被标记为HMAC-SHA1、HMAC-MD5、HMAC-RIPEMD等。

注意：在本文撰写之时，MD5和SHA-1是最广泛使用的密码学哈希函数。最近的研究表明，MD5已被证明存在碰撞搜索攻击的漏洞 [Dobb]。虽然这种攻击以及MD5的其他已知弱点目前尚未影响在本文件中规定的HMAC中使用MD5（参见 [Dobb]），但SHA-1似乎是更强的密码学函数。到目前为止，MD5仍可在对性能要求较高的应用中考虑用于HMAC，但用户和实现者应当注意任何关于这些哈希函数的密码分析新进展，以及最终可能需要更换底层哈希函数的情况。（关于HMAC安全性的更多信息，请参见第6节。）

Krawczyk 等人，信息性文档 [第2页]

RFC 2104  HMAC  1997年2月

2. HMAC的定义

HMAC的定义需要一个密码学哈希函数（用H表示）和一个秘密密钥K。我们假设H是一个密码学哈希函数，它通过对数据块反复应用基本压缩函数来进行哈希处理。设B为这些数据块的字节长度（上述所有哈希函数的B均为64字节），L为哈希输出的字节长度（MD5为16字节，SHA-1为20字节）。密钥K可以是任何长度，不超过B字节。对于使用超过B字节长的密钥的应用，首先用H对密钥进行哈希，然后将得到的L字节串作为HMAC的实际密钥。无论如何，建议的K的最小长度为L字节（即哈希输出的长度）。关于密钥的更多信息，请参见第3节。

我们定义两个固定且不同的字符串ipad和opad，定义如下（字母‘i’和‘o’代表内部和外部）：

                   ipad = 字节0x36重复B次
                  opad = 字节0x5C重复B次

为了计算数据“text”的HMAC，我们执行以下操作：

                    H(K XOR opad, H(K XOR ipad, text))

也就是说，

以下是英文内容的中文翻译：

```
(1) 在K的末尾补充零字节，直到总长度达到B字节
    （例如，如果K的长度为20字节，B=64，则在K后面补充44个零字节0x00）
(2) 将步骤（1）中计算得到的B字节串与ipad进行按位异或（XOR）
(3) 将数据流'text'附加到步骤（2）中得到的B字节串后面
(4) 对步骤（3）生成的流应用哈希函数H
(5) 将步骤（1）中计算得到的B字节串与opad进行按位异或（XOR）
(6) 将步骤（4）中的H结果附加到步骤（5）中得到的B字节串后面
(7) 对步骤（6）生成的流应用哈希函数H，并输出结果

为了说明，附录中提供了基于MD5的示例代码。

Krawczyk 等人            信息性文档                      [第3页]

RFC 2104                          HMAC                     1997年2月

3. 密钥

   HMAC的密钥可以是任何长度（长度超过B字节的密钥会先用H进行哈希）。然而，长度少于L字节的密钥强烈不建议使用，因为这会降低函数的安全强度。长度超过L字节的密钥是可以接受的，但额外的长度不会显著增强函数的安全性。（如果密钥的随机性较弱，建议使用更长的密钥。）

   密钥需要随机选择（或使用带有随机种子的密码学强的伪随机生成器），并且应定期更新。（目前的攻击没有指明具体的密钥更换频率，因为这些攻击在实际中几乎不可行。然而，定期更换密钥是一项基本的安全措施，有助于防范潜在的函数和密钥弱点，并限制密钥泄露带来的损害。）

4. 实现注意事项

   HMAC的定义方式使得底层的哈希函数H可以无需修改其代码即可使用。特别是，它使用带有预定义初始值IV（由每个迭代哈希函数指定的用于初始化其压缩函数的固定值）的哈希函数H。然而，如果需要，可以通过（可能）修改H的代码以支持可变的IV，从而实现性能提升。
```

这个想法是，在生成密钥K时，或者在首次使用之前，可以预先计算出压缩函数在两个B字节块（即(K XOR ipad)和(K XOR opad)）上的中间结果。这些中间结果会被存储起来，然后在每次需要验证消息时，用于初始化H的初始化向量（IV）。这种方法可以节省每次验证消息时对H的压缩函数进行两次B字节块（即(K XOR ipad)和(K XOR opad)）的运算。当验证短数据流时，这种节省可能非常显著。我们强调，存储的中间值需要像秘密密钥一样进行处理和保护。

选择以上述方式实现HMAC，是由本地实现决定的，不会影响互操作性。

Krawczyk 等人，信息性文档 [第4页]

RFC 2104  HMAC  1997年2月

5. 截断输出

在消息认证码（MAC）中，一个常见的做法是截断MAC的输出，只输出部分比特（例如，[MM, ANSI]）。Preneel 和 van Oorschot [PV] 展示了截断基于哈希的MAC函数输出的某些分析优势。这方面的结果并非绝对，因为截断在整体安全性方面既有优势（减少攻击者可获得的哈希结果信息），也有劣势（攻击者预测的比特更少）。HMAC的应用可以选择截断其输出，即输出HMAC计算的前t个比特（参数t），即按照第2节中定义的正常方式进行计算，但最终结果被截断到t比特。我们建议输出长度t不应少于哈希输出长度的一半（以匹配生日攻击的界限），也不应少于80比特（这是攻击者需要预测的比特数的合理下限）。我们建议用HMAC-H-t来表示使用输出为t比特的哈希函数H的HMAC实现。例如，HMAC-SHA1-80表示使用SHA-1函数计算的HMAC，并将输出截断到80比特。（如果未指定参数t，例如HMAC-MD5，则假设输出所有哈希比特。）

6. 安全性

这里所介绍的消息认证机制的安全性依赖于哈希函数H的密码学性质：包括对碰撞发现的抗性（这一点在初始值是秘密且随机的情况下成立，且攻击者无法明确获得函数的输出），以及在应用到单个块时压缩函数的消息认证特性（在HMAC中，这些块对攻击者来说部分未知，因为它们包含内部H计算的结果，尤其是不能被攻击者完全选择）。

这些性质，实际上还包括更强的性质，通常被假设为用于HMAC的哈希函数所具备的特性。特别是，如果某个哈希函数不满足上述性质，那么它将不适合用于大多数（可能全部）密码学应用，包括基于此类函数的替代消息认证方案。（关于HMAC函数的完整分析和原理，读者可参考文献[BCK1]。）

鉴于目前对候选哈希函数的密码强度的信心有限，重要的是要注意HMAC结构及其在消息认证中的安全使用的以下两个性质：

1. 该结构与所使用的具体哈希函数H的细节无关，因此可以用任何其他安全（迭代式）密码学哈希函数替换H。

2. 消息认证不同于加密，它具有“短暂”的效果。若某个消息认证方案被破解，虽然该方案会被替换，但对过去已认证的信息不会产生敌对影响。这与加密形成鲜明对比——如果今天加密的信息被破解，未来可能会导致信息暴露。

目前已知对HMAC的最强攻击是基于哈希函数H的碰撞频率（“生日攻击”）[PV,BCK2]，但对于合理的哈希函数来说，这种攻击完全不切实际。

例如，考虑像MD5这样的哈希函数，其输出长度为L=16字节（128位），攻击者需要在大约2^64个已知明文上获得正确的消息认证标签（使用相同的秘密密钥K！）。这将需要在H函数下处理至少2^64个块，在任何现实场景中都是不可能完成的任务（对于一个64字节的块长度，这在连续的1Gbps链路上也需要250,000年，而且在此期间不更换密钥K）。除非发现该函数H在碰撞行为方面存在严重缺陷（例如，在2^30条消息后找到碰撞），否则这种攻击不可能变得现实。若发现此类缺陷，将立即替换H函数（此类失败的影响对于H在数字签名、公钥证书等传统用途中的安全性将更加严重）。

注意：这种攻击必须与对密码哈希函数的常规碰撞攻击区分开来，后者不涉及秘密密钥，只需大约2^64次离线并行操作即可找到碰撞。后者的可行性正逐步逼近[VW]的水平，而对HMAC的生日攻击则完全不切实际。（在上述例子中，如果使用输出为160位的哈希函数，则应将2^64替换为2^80。）

正确实现上述结构、选择随机（或密码学伪随机）密钥、采用安全的密钥交换机制、频繁更换密钥以及良好的密钥保密措施，都是确保HMAC提供的完整性验证机制安全的关键要素。

附录——示例代码

为了说明，我们提供以下HMAC-MD5的示例代码以及一些对应的测试向量（该代码基于[MD5]中描述的MD5代码）。

以下是该英文内容的中文翻译：

```
{
        MD5_CTX context;
        unsigned char k_ipad[65];    /* 内部填充 -
                                          * 密钥与 ipad 异或
                                          */
        unsigned char k_opad[65];    /* 外部填充 -
                                          * 密钥与 opad 异或
                                          */
        unsigned char tk[16];
        int i;
        /* 如果密钥长度超过 64 字节，则将其重置为 MD5(密钥) */
        if (key_len > 64) {

                MD5_CTX      tctx;

                MD5Init(&tctx);
                MD5Update(&tctx, key, key_len);
                MD5Final(tk, &tctx);

                key = tk;
                key_len = 16;
        }

        /*
         * HMAC_MD5 转换的结构如下：
         *
         * MD5(K XOR opad, MD5(K XOR ipad, 文本))
         *
         * 其中 K 是一个 n 字节的密钥
         * ipad 是重复 0x36 字节 64 次
         * opad 是重复 0x5c 字节 64 次
         * 文本是需要保护的数据
         */

        /* 首先将密钥存入填充区 */
        bzero(k_ipad, sizeof k_ipad);
        bzero(k_opad, sizeof k_opad);
        bcopy(key, k_ipad, key_len);
        bcopy(key, k_opad, key_len);

        /* 将密钥与 ipad 和 opad 进行异或 */
        for (i = 0; i < 64; i++) {
                k_ipad[i] ^= 0x36;
                k_opad[i] ^= 0x5c;
        }
        /*
         * 执行内部 MD5
         */
        MD5Init(&context);                   /* 初始化第一个
                                              * 计算的上下文 */
        MD5Update(&context, k_ipad, 64);      /* 从内部填充开始 */
        MD5Update(&context, text, text_len);  /* 然后是数据文本 */
        MD5Final(digest, &context);           /* 完成第一次计算 */
        /*
         * 执行外部 MD5
         */
        MD5Init(&context);                   /* 初始化第二个
                                              * 计算的上下文 */
        MD5Update(&context, k_opad, 64);     /* 从外部填充开始 */
        MD5Update(&context, digest, 16);     /* 然后是第一次哈希的结果 */
        MD5Final(digest, &context);          /* 完成第二次计算 */
}

测试向量（字符字符串的尾随 '\0' 不包含在测试中）：

  密钥 = 0x0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b
  密钥长度 = 16 字节
  数据 = "Hi There"
  数据长度 = 8 字节
  摘要 = 0x9294727a3638bb1c13f48ef8158bfc9d

  密钥 = "Jefe"
  数据 = "what do ya want for nothing?"
  数据长度 = 28 字节
  摘要 = 0x750c783e6ab0b503eaa86e310a5db738

  密钥 = 0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA



Krawczyk 等人            信息性文档                      [第 9 页]


RFC 2104                          HMAC                     1997 年 2 月
```

密钥长度       16字节
数据 =        0xDDDDDDDDDDDDDDDDDDDD...
             ..DDDDDDDDDDDDDDDDDDDD...
             ..DDDDDDDDDDDDDDDDDDDD...
             ..DDDDDDDDDDDDDDDDDDDD...
             ..DDDDDDDDDDDDDDDDDDDD
数据长度 =    50字节
摘要 =        0x56be34521d144c88dbb8c733f0e8b3f6

致谢

   Pau-Chen Cheng、Jeff Kraemer 和 Michael Oehler 在早期草稿中提供了有益的意见，并进行了本规范的首次互操作性测试。Jeff 和 Pau-Chen 还慷慨地提供了附录中的示例代码和测试向量。 Burt Kaliski、Bart Preneel、Matt Robshaw、Adi Shamir 和 Paul van Oorschot 在研究 HMAC 构造过程中提供了宝贵的意见和建议。

参考文献

   [ANSI]  ANSI X9.9，《金融机构消息认证的美国国家标准（批量）》，美国银行家协会，1981年。修订版1986年。

   [Atk]   Atkinson, R.，《IP认证头》，RFC 1826，1995年8月。

   [BCK1]  M. Bellare、R. Canetti 和 H. Krawczyk，《带密钥的哈希函数与消息认证》，发表于Crypto'96会议论文集，LNCS 1109，第1-15页。
           (http://www.research.ibm.com/security/keyed-md5.html)

   [BCK2]  M. Bellare、R. Canetti 和 H. Krawczyk，《伪随机函数再探：级联构造》，发表于FOCS'96会议。

   [Dobb]  H. Dobbertin，《MD5在近期攻击之后的状态》，RSA Labs的CryptoBytes，第2卷第2期，1996年夏季。
           http://www.rsa.com/rsalabs/pubs/cryptobytes.html

   [PV]    B. Preneel 和 P. van Oorschot，《用哈希函数构建快速MAC》，发表于《密码学进展——CRYPTO'95会议论文集》，Springer-Verlag，第963卷，1995年，第1-14页。

   [MD5]   Rivest, R.，《MD5消息摘要算法》，RFC 1321，1992年4月。

Krawczyk 等人            信息性文档                     [第10页]

RFC 2104                          HMAC                     1997年2月

   [MM]    Meyer, S. 和 Matyas, S.M.，《密码学》，纽约 Wiley，1982年。

   [RIPEMD] H. Dobbertin、A. Bosselaers 和 B. Preneel，《RIPEMD-160：RIPEMD的增强版本》，快速软件加密，LNCS 第1039卷，第71-82页。
            ftp://ftp.esat.kuleuven.ac.be/pub/COSIC/bosselae/ripemd/。

   [SHA]   NIST，《FIPS PUB 180-1：安全哈希标准》，1995年4月。

   [Tsu]   G. Tsudik，《用单向哈希函数进行消息认证》，发表于Infocom'92会议论文集，1992年5月。
           （也收录于《网络中的访问控制与策略执行》，南加州大学计算机科学系博士论文，1991年4月。）

[VW] P. van Oorschot 和 M. Wiener，"并行碰撞搜索及其在哈希函数和离散对数中的应用"，载于第二届ACM计算机与通信安全会议论文集，地点：弗吉尼亚州费尔法克斯，1994年11月。

作者联系方式

Hugo Krawczyk  
IBM T.J. Watson研究中心  
邮政信箱704  
约克镇高地，纽约州10598  
电子邮箱：hugo@watson.ibm.com

Mihir Bellare  
加州大学圣地亚哥分校计算机科学与工程系  
邮政编码：0114  
邮箱：mihir@cs.ucsd.edu

Ran Canetti  
IBM T.J. Watson研究中心  
邮政信箱704  
约克镇高地，纽约州10598  
电子邮箱：canetti@watson.ibm.com

Krawczyk 等人，信息性文献，第11页