# RFC 1122 中文翻译 (stub)
# 原文文件: ../../rfcs/RFCs1001-1500/rfc1122.txt

网络工作组                    互联网工程任务组
评论请求编号：1122                            R. Braden，编辑
                                                          1989年10月


        互联网主机的需求——通信层


本备忘录的状态

   本RFC是互联网社区的官方规范。它通过引用、修订、纠正和补充，整合了与主机相关的主要协议标准文件。本文档的分发不受限制。

摘要

   这是关于定义和讨论互联网主机软件需求的两份RFC之一。本文涵盖了通信协议层：链路层、IP层和传输层；其配套的RFC-1123则涉及应用层和支持协议。





目录



1. 引言 ...............................................    5
   1.1 互联网架构 ......................................    6
      1.1.1 互联网主机 ..................................    6
      1.1.2 架构假设 ....................................    7
      1.1.3 互联网协议套件 ..............................    8
      1.1.4 嵌入式网关代码 ..............................   10
   1.2 一般考虑 ........................................   12
      1.2.1 互联网的持续演进 ............................   12
      1.2.2 鲁棒性原则 ..................................   12
      1.2.3 错误日志 ....................................   13
      1.2.4 配置 ........................................   14
   1.3 阅读本文件 ........................................   15
      1.3.1 组织结构 ....................................   15
      1.3.2 需求 ........................................   16
      1.3.3 术语 ........................................   17
   1.4 致谢 ............................................   20

2. 链路层 ...............................................   21
   2.1 引言 ............................................   21



互联网工程任务组                                 [第1页]





RFC1122                       引言                  1989年10月

2.2 协议流程介绍 ........................................... 21  
2.3 具体问题 ................................................. 21  
 2.3.1  拖车协议协商 ...................................... 21  
 2.3.2  地址解析协议（ARP） .............................. 22  
  2.3.2.1  ARP缓存验证 .................................. 22  
  2.3.2.2  ARP数据包队列 ................................ 24  
 2.3.3 以太网和IEEE 802封装 ............................... 24  
2.4 链路/互联网层接口 ...................................... 25  
2.5 链路层需求总结 .......................................... 26

3. 互联网层协议 .................................... 27  
   3.1 引言 ............................................ 27  
   3.2 协议流程介绍 .................................... 29  
      3.2.1 互联网协议——IP ............................ 29  
         3.2.1.1  版本号 .................................. 29  
         3.2.1.2  校验和 .................................. 29  
         3.2.1.3  地址 .................................... 29  
         3.2.1.4  分片与重组 .............................. 32  
         3.2.1.5  标识符 .................................. 32  
         3.2.1.6  服务类型 ................................ 33  
         3.2.1.7  生存时间 ................................ 34  
         3.2.1.8  选项 .................................... 35  
      3.2.2 互联网控制消息协议——ICMP .................. 38  
         3.2.2.1  目的地不可达 ............................ 39  
         3.2.2.2  重定向 .................................. 40  
         3.2.2.3  源抑制 .................................. 41  
         3.2.2.4  时间超时 ................................ 41  
         3.2.2.5  参数问题 ................................ 42  
         3.2.2.6  回显请求/应答 ............................ 42  
         3.2.2.7  信息请求/应答 ............................ 43  
         3.2.2.8  时间戳与时间戳应答 ...................... 43  
         3.2.2.9  地址掩码请求/应答 ....................... 45  
      3.2.3 互联网组管理协议——IGMP .................... 47  
   3.3  特定问题 ........................................ 47  
      3.3.1  出站数据报的路由 ................................ 47  
         3.3.1.1  本地/远程决策 ............................ 47  
         3.3.1.2  网关选择 ................................ 48  
         3.3.1.3  路由缓存 ................................ 49  
         3.3.1.4  死亡网关检测 ............................ 51  
         3.3.1.5  新网关选择 ................................ 55  
         3.3.1.6  初始化 .................................... 56  
      3.3.2  重组 ............................................ 56  
      3.3.3  分片 ............................................ 58  
      3.3.4  本地多宿 ........................................ 60  
         3.3.4.1  引言 ...................................... 60  
         3.3.4.2  多宿需求 .................................. 61  
         3.3.4.3  选择源地址 ................................ 64  
      3.3.5  源路由转发 .................................... 65  

互联网工程任务组                                 [第2页]  

RFC1122                       引言                  1989年10月

3.3.6 广播 ........................................... 66  
3.3.7 IP多播 ........................................... 67  
3.3.8 错误报告 ......................................... 69  
3.4 互联网/传输层接口 .................................. 69  
3.5 互联网层需求总结 .................................. 72

4. 传输协议 ......................................... 77
   4.1 用户数据报协议（UDP） ............................ 77
      4.1.1 介绍 ........................................... 77
      4.1.2 协议概述 ....................................... 77
      4.1.3 具体问题 ....................................... 77
         4.1.3.1 端口 ....................................... 77
         4.1.3.2 IP 选项 .................................... 77
         4.1.3.3 ICMP 消息 .................................. 78
         4.1.3.4 UDP 校验和 ................................ 78
         4.1.3.5 UDP 多宿主 ................................ 79
         4.1.3.6 无效地址 .................................. 79
      4.1.4 UDP/应用层接口 ................................ 79
      4.1.5 UDP 需求总结 ................................... 80
   4.2 传输控制协议（TCP） ............................... 82
      4.2.1 介绍 ........................................... 82
      4.2.2 协议概述 ....................................... 82
         4.2.2.1 常用端口 .................................. 82
         4.2.2.2 Push 使用 ................................ 82
         4.2.2.3 窗口大小 .................................. 83
         4.2.2.4 紧急指针 .................................. 84
         4.2.2.5 TCP 选项 .................................. 85
         4.2.2.6 最大段大小（MSS）选项 .................... 85
         4.2.2.7 TCP 校验和 ................................ 86
         4.2.2.8 TCP 连接状态图 ............................ 86
         4.2.2.9 初始序列号的选择 .......................... 87
         4.2.2.10 同时开启尝试 .............................. 87
         4.2.2.11 旧重复 SYN 的恢复 ........................ 87
         4.2.2.12 RST 段 .................................... 87
         4.2.2.13 关闭连接 .................................. 87
         4.2.2.14 数据通信 .................................. 89
         4.2.2.15 重传超时 .................................. 90
         4.2.2.16 窗口管理 .................................. 91
         4.2.2.17 探测零窗口 ................................ 92
         4.2.2.18 被动打开调用 ................................ 92
         4.2.2.19 生存时间（TTL） ............................ 93
         4.2.2.20 事件处理 .................................. 93
         4.2.2.21 确认排队段 ................................ 94
      4.2.3 具体问题 ....................................... 95
         4.2.3.1 重传超时的计算 .............................. 95
         4.2.3.2 何时发送确认段 .............................. 96
         4.2.3.3 何时发送窗口更新 ............................ 97

4.2.3.4 何时发送数据 ................................... 98

互联网工程任务组                                 [第3页]





RFC1122                       引言                     1989年10月


            4.2.3.5  TCP连接失败 ......................  100
            4.2.3.6  TCP保持连接 ........................  101
            4.2.3.7  TCP多宿主 ............................  103
            4.2.3.8  IP选项 ................................  103
            4.2.3.9  ICMP消息 ..............................  103
            4.2.3.10 远程地址验证 .........................  104
            4.2.3.11 TCP流量模式 ..........................  104
            4.2.3.12 效率 ..................................  105
         4.2.4  TCP/应用层接口 ............................  106
            4.2.4.1  异步报告 ..............................  106
            4.2.4.2  服务类型 ..............................  107
            4.2.4.3  刷新调用 ..............................  107
            4.2.4.4  多宿主 ................................  108
         4.2.5  TCP需求总结 ...............................  108

   5.  参考文献 ..............................................  112



































互联网工程任务组                                 [第4页]





RFC1122                       引言                     1989年10月


1.  引言

   本文件是描述和讨论互联网协议族主机系统实现要求的两份文件之一。 本RFC涵盖通信协议层：链路层、IP层和传输层。 其配套的RFC——《互联网主机的需求——应用层和支持》 [INTRO:1]，则涉及应用层协议。 本文件还应结合《互联网网关的需求》 [INTRO:2] 一起阅读。

   这些文件旨在为互联网通信软件的供应商、实现者和用户提供指导。 它们代表了大量技术经验和智慧的共识，这些经验和智慧由互联网研究和供应商社区的成员共同贡献。

   本RFC列出了连接到互联网的主机必须使用的标准协议，并通过引用包含了描述这些协议当前规范的RFC和其他文档。 它还纠正了被引用文档中的错误，并为实现者提供了额外的讨论和指导。

对于每个协议，本文件还包含一套明确的要求、建议和选项。读者必须理解，本文件中的要求清单本身是不完整的；关于互联网主机的完整要求主要由标准协议规范文件定义，而本RFC中包含的修正、修正案和补充内容也是其中的一部分。

经过仔细阅读RFC，并与互联网技术社区进行一定互动后，基于良好的通信软件工程实践，合理实现这些协议的善意实现，通常只会在某些细节上与本文件的要求存在细微差异。因此，在许多情况下，本RFC中的“要求”已经在标准协议文件中有所陈述或暗示，因此在这里重复显得有些多余。然而，之所以将它们包括在内，是因为过去某些实现做出了错误的选择，导致了互操作性、性能和/或鲁棒性方面的问题。

本文件还包括对许多要求和建议的讨论与说明。仅列出要求的清单可能会带来风险，因为：

- 一些必需的功能比其他功能更为重要，而某些功能是可选的。
- 可能存在合理的理由，某些为特定限制环境设计的厂商产品可能会选择使用不同的规范。

然而，为了实现互联网系统中各种主机之间的广泛互操作性，必须遵循本文件中的规范。尽管目前大多数实现未能在多方面满足这些要求（有些是次要的，有些是重大的），但本规范代表了我们应当努力追求的理想目标。

这些要求基于当前的互联网架构水平。本文件将根据需要进行更新，以提供更多的澄清或包含尚在演变中的规范领域的额外信息。

本引言部分首先简要介绍了与主机相关的互联网架构，然后为主机软件供应商提供一些一般性建议。最后，还提供了关于阅读本文件其余部分的指导以及一些术语说明。

1.1 互联网架构

关于互联网架构及其支持协议套件的总体背景和讨论，可以在《DDN协议手册》[INTRO:3]中找到；有关背景信息，参见例如[INTRO:9]、[INTRO:10]和[INTRO:11]。参考文献[INTRO:5]描述了获取互联网协议文档的程序，而[INTRO:6]则列出了在互联网协议中分配的编号列表。

1.1.1 互联网主机

主机（Host）是通信服务的最终用户。主机通常代表用户执行应用程序，利用网络和/或互联网通信服务来支持这一功能。互联网主机对应于OSI协议套件中所用的“终端系统”概念[INTRO:13]。

互联网通信系统由互联的分组网络组成，支持主机之间通过互联网协议进行通信。这些网络通过被互联网社区称为“网关”或“IP路由器”的分组交换计算机互连，OSI世界中则称为“中间系统”[INTRO:13]。RFC《互联网网关的需求》[INTRO:2]包含了互联网网关的官方规范。该RFC与本文件及其伴随文件[INTRO:1]共同定义了当前互联网架构实现的规则。

互联网主机的规模、速度和功能差异很大。从小型微处理器、工作站到大型机和超级计算机不等。在功能方面，它们从单一用途的主机（如终端服务器）到支持多种在线网络服务的全功能主机，通常包括远程登录、文件传输和电子邮件。

如果一台主机拥有多个接口连接到相同或不同的网络，通常称其为多宿主（multihomed）。关于“术语”的详细内容，请参见第1.1.3节。

1.1.2 架构假设

当前的互联网架构基于一系列关于通信系统的假设。其中对主机最相关的假设如下：

(a) 互联网是一个网络的网络。

每台主机都直接连接到某个特定的网络；它与互联网的连接仅是概念上的。处于同一网络的两个主机使用相同的协议集进行通信，就像它们与远程网络上的主机通信一样。

(b) 网关不保存连接状态信息。

为了提高通信系统的鲁棒性，网关被设计为无状态的，即每个IP数据报都独立转发，不依赖其他数据报。因此，可以利用冗余路径在中间网关和网络发生故障时仍提供可靠的服务。

所有端到端流量控制和可靠性所需的状态信息都由主机在传输层或应用程序中实现。所有连接控制信息都与通信的端点共同存在，因此只有在端点发生故障时才会丢失。

(c) 路由的复杂性应由网关承担。

路由是一个复杂且困难的问题，应该由网关来处理，而不是由主机来完成。一个重要的目标是使主机软件免受互联网路由架构不可避免的演变带来的影响。

(d) 系统必须能够容忍广泛的网络变化。

互联网设计的基本目标之一是能够容忍各种网络特性差异——例如带宽、延迟、数据包丢失、数据包乱序以及最大数据包大小。另一个目标是具备对单个网络、网关和主机故障的鲁棒性，利用仍可用的带宽。最后，目标是实现完全的“开放系统互联”：一个互联网主机必须能够与任何其他互联网主机进行稳健且高效的互操作，跨越多样的互联网路径。

有时，主机实现者会为较低的目标设计。例如，局域网（LAN）环境通常比整个互联网更为安全；局域网的包丢失和延迟较低，也不会发生包的乱序。一些厂商提供的主机实现适用于简单的局域网环境，但在一般互操作中表现不佳。这些厂商将此类产品辩解为在有限的局域网市场中经济实惠。然而，孤立的局域网很少能长时间保持孤立；它们很快就会通过网关连接到彼此、组织范围的互联网，最终连接到全球互联网系统。归根结底，客户和厂商都无法从不完整或低标准的互联网主机软件中获益。

本文件中所列的要求旨在为一台具有完整功能的互联网主机设计，确保其能够在任意互联网路径上实现全面互操作。

1.1.3 互联网协议族

为了使用互联网系统进行通信，主机必须实现由多层协议组成的互联网协议族。通常，主机至少需要实现每一层中的一种协议。

互联网架构中使用的协议层如下[引言：4]：

- 应用层

互联网工程任务组（IETF）[第8页]

RFC1122  引言  1989年10月

应用层是互联网协议族的顶层。互联网协议族没有对应用层进行进一步细分，尽管一些互联网应用层协议内部确实包含一些子层。互联网协议族的应用层基本上结合了OSI参考模型中的前两层——表现层和应用层的功能。

我们将应用层协议分为两类：一类是直接向用户提供服务的用户协议，另一类是提供公共系统功能的支持协议。用户协议和支持协议的具体要求可参见配套的RFC [引言：1]。

最常用的互联网用户协议包括：

- Telnet（远程登录）
- FTP（文件传输）
- SMTP（电子邮件传递）

此外，还有一些其他标准化的用户协议[引言：4]以及许多私有用户协议。

支持协议主要用于主机名映射、引导启动和管理，包括SNMP、BOOTP、RARP以及域名系统（DNS）协议。

- 传输层

传输层为应用程序提供端到端的通信服务。目前主要有两种传输层协议：

- 传输控制协议（TCP）
- 用户数据报协议（UDP）

TCP是一种可靠的面向连接的传输服务，提供端到端的可靠性、数据重排和流量控制。UDP是一种无连接的（“数据报”）传输服务。

研究界还开发了其他传输协议，未来官方的互联网传输协议集可能会扩展。

传输层协议的详细内容将在第4章中讨论。

互联网工程任务组                                 [第9页]





RFC1122                       引言                     1989年10月


         o  互联网层

              所有互联网传输协议都使用互联网协议（IP）将数据从源主机传送到目标主机。
              IP是一种无连接或数据报式的网络服务，不提供端到端的传递保证。因此，IP数据报可能会在到达目标主机时损坏、重复、乱序，或者根本未到达。 
              IP之上的层负责在需要时提供可靠的传递服务。IP协议包括地址分配、服务类型说明、分片与重组以及安全信息的相关功能。

              IP协议的无连接或数据报性质是互联网架构的基本和特征性特征。互联网IP曾是OSI无连接网络协议模型的范例[引言:12]。

              ICMP是一种控制协议，被认为是IP的一个组成部分，尽管它在架构上是建立在IP之上的，即它使用IP来端到端传输其数据，就像TCP或UDP这样的传输协议一样。ICMP提供错误报告、拥塞报告和第一跳网关重定向等功能。

              IGMP是一种互联网层协议，用于建立IP多播的动态主机组。

              互联网层协议IP、ICMP和IGMP将在第3章中进行讨论。


         o  链路层

              为了在其直接连接的网络上进行通信，主机必须实现用于与该网络接口的通信协议。我们称之为链路层或介质访问层协议。

              链路层协议种类繁多，适应不同类型的网络。详见第2章。


      1.1.4  嵌入式网关代码

         一些互联网主机软件包含嵌入式网关功能，使这些主机能够像网关一样转发数据包，同时仍执行主机的应用层功能。

         这类双重用途的系统在其网关功能方面必须遵循网关需求RFC [引言:2]，在其主机功能方面必须遵循本文件的规定。在所有重叠的情况下，这两个规范应保持一致。

关于嵌入式网关功能，互联网社区中存在不同的观点。主要的论点如下：

- 支持观点：在本地网络环境中，网络较为非正式，或在孤立的互联网中，使用现有的主机系统作为网关可能既方便又经济。还有一个架构上的理由支持嵌入式网关功能：多宿主（multihoming）比最初预料的更为普遍，而多宿主会迫使主机像网关一样做出路由决策。如果多宿主主机内置了嵌入式网关，它将拥有完整的路由知识，因此能够做出更优化的路由决策。

- 反对观点：网关算法和协议仍在不断变化，随着互联网系统的不断扩大，这些变化也会持续发生。在主机的IP层中尝试集成通用的网关功能，将迫使主机系统维护者跟踪这些（更频繁的）变化。此外，更多的网关实现将使得协调这些变化变得更加困难。最后，网关IP层的复杂性比普通主机要高一些，这会使得实现和操作变得更加复杂。

此外，某些主机的操作方式可能不适合提供稳定且强大的网关服务。

这两种观点都具有一定的合理性。可以得出一个结论：主机管理员必须对某个主机是否充当网关拥有有意识的控制权。关于详细的要求，请参见第3.1节。

---

互联网工程任务组（IETF）[第11页]

RFC1122 介绍 1989年10月

1.2 一般考虑因素

有两点重要的经验教训，互联网主机软件的供应商已经学到，并且新供应商应当认真考虑。

1.2.1 互联网的持续演进

互联网的巨大增长暴露出在一个基于数据报的分组通信系统中管理和扩展的问题。这些问题正在被解决，因此本文档中描述的规范将会不断演进。这些变化将经过精心的规划和控制，因为参与规划的厂商和负责网络运营的组织都在积极参与。

发展、演变和修订是当今计算机网络协议的特征，这一状况将持续数年。开发用于互联网协议套件（或任何其他协议套件！）的计算机通信软件的供应商，如果未能维护和更新其软件以适应不断变化的规范，就会留下大量不满的客户。互联网是一个庞大的通信网络，用户通过它保持持续联系。经验表明，供应商软件中的缺陷信息会迅速在互联网技术社区中传播。

1.2.2  鲁棒性原则

在协议的每一层，都有一条通用规则，其应用可以带来极大的鲁棒性和互操作性[IP:1]：

“对接受的内容要宽容，对发送的内容要保守。”

软件应设计成能够应对各种可能的错误，无论这些错误多么不太可能；迟早会有数据包带有特定的错误组合和属性，如果软件没有做好准备，可能会引发混乱。一般而言，最好假设网络中充满了恶意实体，它们会发送设计用以产生最坏效果的数据包。这一假设将促使采取相应的保护性设计，尽管互联网中最严重的问题往往源于未预料到的机制被低概率事件触发；而单纯的人类恶意行为绝不会走如此阴险的路线！

所有层级的互联网主机软件都必须具备适应变化的能力。举个简单的例子，考虑一个协议规范中包含某个头字段的值的枚举——例如，类型字段、端口号或错误代码；这个枚举必须假设是不完整的。因此，如果协议定义了四个可能的错误代码，当出现第五个代码时，软件不应崩溃。未定义的代码可能会被记录（见下文），但绝不能导致程序失败。

原则的第二部分几乎同样重要：
其他主机上的软件可能存在缺陷，使得利用合法但晦涩的协议特性变得不明智。偏离明显和简单的做法是不明智的，以免在其他地方引发不良后果。这一原则的推论是“警惕行为异常的主机”；主机软件应当做好准备，不仅要能应对其他行为异常的主机，还要协作限制这些主机可能对共享通信设施造成的干扰。

1.2.3 错误日志

互联网包含各种各样的主机和网关系统，每个系统实现了许多协议和协议层，其中一些在其互联网协议软件中存在漏洞和不良特性。由于复杂性、多样性和功能的分布，诊断互联网问题常常非常困难。

如果主机实现中包含一个经过精心设计的错误或“奇怪”协议事件的日志记录功能，将有助于问题的诊断。在记录错误时，尽可能包含详细的诊断信息尤为重要。特别是，记录引发错误的数据包的头部信息通常非常有用。然而，必须注意确保错误日志记录不会消耗过多资源或以其他方式干扰主机的正常运行。

异常但无害的协议事件可能会导致错误日志文件溢出；这可以通过使用“循环”日志或仅在诊断已知故障时启用日志记录来避免。过滤和统计连续重复的消息也可能很有用。一种行之有效的策略是：(1) 始终统计异常情况，并通过管理协议（参见[INTRO:1]）使这些统计数据可访问；(2) 允许选择性启用各种事件的日志记录。例如，可能希望能够“记录所有内容”或“为主机X记录所有内容”。

请注意，不同的管理策略可能对主机中通常启用的错误日志记录量有不同的偏好。有些管理者会说：“如果不影响我，我就不想知道”，而另一些则希望采取更警惕和积极的态度，检测并消除协议异常。

1.2.4 配置

如果互联网协议套件的主机实现能够完全自我配置，那将是理想的。这将允许整个协议套件被实现为只读存储器（ROM）或集成到芯片中，简化无磁盘工作站的设计，也将极大地帮助繁忙的局域网（LAN）管理员和系统供应商。我们尚未达到这一理想；实际上，甚至离这个目标还很遥远。

在本文的许多部分，你会发现需要将某个参数设为可配置选项。这种需求背后有几种不同的原因。在少数情况下，目前对最佳值存在不确定性或分歧，未来可能需要更新推荐值。在其他情况下，参数的值实际上取决于外部因素——例如，主机的规模和通信负载的分布，或附近网络的速度和拓扑结构——而自调算法不可用或可能不足以应对这些变化。在某些情况下，配置的可调性是出于管理上的需要。

最后，一些配置选项之所以必须存在，是为了与那些过时或错误的协议实现进行通信，这些实现没有源代码，且在互联网的许多部分仍然存在。为了让正确的系统与这些有缺陷的系统共存，管理员常常不得不“误配置”正确的系统。随着有缺陷的系统逐步退役，这个问题会逐渐自行解决，但供应商不能忽视这个问题。

当我们说某个参数必须是可配置的，并不意味着要求每次启动时都必须从配置文件中明确读取其值。我们建议实现者为每个参数设置一个默认值，这样只有在特定安装中默认值不合适时，才需要通过配置文件进行覆盖。因此，可配置性要求的意义在于确保在必要时，即使是二进制或ROM基础的产品，也能有可能覆盖默认值。

本文档在某些情况下对默认值要求特定的设置。默认值的选择是一个敏感问题，尤其当配置项控制着对现有故障系统的适应时。如果互联网要成功实现完全的互操作性，内置于实现中的默认值必须遵循官方协议，而不能为了适应存在缺陷的实现而设置“误配置”的默认值。尽管一些厂商出于市场营销的考虑选择了误配置的默认值，但我们强烈建议厂商选择符合标准的默认值。

最后，我们指出，厂商需要提供充分的文档，说明所有配置参数、它们的限制以及影响。

1.3 阅读本文档

1.3.1 结构

协议分层，作为实现网络软件的组织原则，通常被用作组织本文档的依据。在描述规则时，我们假设实现严格反映协议的分层结构。因此，以下三个主要部分分别规定了链路层、互联网层和传输层的要求。配套的RFC [INTRO:1] 涉及应用层软件。这种分层组织方式是为了简化和清晰。

然而，严格的分层模型并不完美，无论是对于协议套件还是推荐的实现方法。不同层的协议之间会以复杂且有时微妙的方式相互作用，某些功能常常涉及多个层。在实现中存在许多设计选择，其中许多涉及对严格分层的创造性“突破”。每个实现者都被敦促阅读参考文献 [INTRO:7] 和 [INTRO:8]。

本文档使用功能（“过程调用”）的符号表示层之间的概念服务接口，类似于TCP规范 [TCP:1] 中的描述。主机实现必须支持这些调用所暗示的逻辑信息流，但不必字面实现这些调用。例如，许多实现通过共享访问公共数据结构来反映传输层与IP层之间的耦合关系。这些数据结构，而非显式的过程调用，成为传递大部分所需信息的媒介。

一般而言，本文件的每个主要部分都组织成以下子部分：

（1）引言

（2）协议逐步讲解——逐节考虑协议规范文件，纠正错误，说明可能模糊或定义不清的要求，并提供进一步的澄清或解释。

（3）具体问题——讨论在逐步讲解中未涉及的协议设计和实现问题。

（4）接口——讨论与下一层的服务接口。

（5）总结——包含本节要求的摘要。

在本文件的许多主题下，都会有括号中的“讨论”或“实现”材料。这些内容旨在对前述要求文本进行澄清和解释，还包括一些关于未来可能方向或发展的建议。实现材料中包含一些建议的方法，供实现者考虑。

总结部分旨在作为指南和索引，但必然简洁且不完整。总结不应单独使用或引用，必须结合完整的RFC一同参考。

1.3.2 需求

在本文件中，用大写字母表示用以定义每个特定需求的重要性的词语。

这些词语包括：

* “MUST”（必须）

  这个词或形容词“REQUIRED”意味着该项是规范的绝对要求。

* “SHOULD”（应当）

  这个词或形容词“RECOMMENDED”意味着在特定情况下可能存在合理的理由忽略此项，但应充分理解其全部影响，并在选择不同方案前慎重权衡。

* “MAY”（可以）

  这个词或形容词“OPTIONAL”意味着该项是真正可选的。一个供应商可能会选择包含此项，因为某个市场需要它或它能增强产品；另一个供应商则可能省略同样的项目。

如果实现未能满足其所实现协议的一个或多个“必须”要求，则该实现不符合规范。满足其协议所有“必须”和“应当”要求的实现被称为“无条件符合”；只满足所有“必须”要求但未满足所有“应当”要求的实现则被称为“有条件符合”。

1.3.3 术语

本文件使用以下技术术语：

段（Segment）
指TCP协议中端到端传输的基本单位。一个段由TCP头部和应用数据组成。段通过封装在IP数据报中进行传输。

消息（Message）
在本低层协议描述中，消息是传输层协议中的传输单位。特别地，TCP段即为一种消息。消息由传输协议头部和应用协议数据组成。为了在互联网中端到端传输，消息必须被封装在数据报中。

IP数据报（IP Datagram）
在IP协议中，IP数据报是端到端传输的基本单位。一个IP数据报由IP头部和传输层数据（即消息）组成。

在第3节关于互联网层的描述中，未加限定的“数据报”一词应理解为指IP数据报。

数据包（Packet）
在互联网层与链路层之间传递的数据单位。包括一个IP头部和数据。一个数据包可以是完整的IP数据报，也可以是IP数据报的片段。

帧（Frame）
链路层协议中的传输单位，由链路层头部和数据（通常为一个数据包）组成。

连接网络（Connected Network）
与主机相连的网络通常被称为“局域网”或“子网”，相对于该主机而言。然而，这些术语可能引起混淆，因此本文使用“连接网络”一词。

多宿（Multihomed）
如果一台主机拥有多个IP地址，则称其为多宿主。关于多宿的讨论请参见下面的第3.3.4节。

物理网络接口
这是连接到网络的物理接口，具有一个（可能是唯一的）链路层地址。在一台主机上，多个物理网络接口可以共享相同的链路层地址，但在同一物理网络上的不同主机，其地址必须是唯一的。

逻辑[网络]接口
我们将逻辑[网络]接口定义为一条逻辑路径，通过唯一的IP地址连接到网络。详见第3.3.4节。

特定目的地地址
这是数据报的实际目的地地址，即使它是广播或多播；详见第3.2.1.3节。

路径
在某一特定时刻，从某一源主机到某一目标主机的所有IP数据报通常会经过相同的网关序列。我们用“路径”一词来指代这个序列。请注意，路径是单向的；在一对主机之间，两个方向的路径可能不同。

MTU
最大传输单元，即可以传输的最大数据包的大小。

以下示意图说明了帧、数据包、数据报、消息和段的概念：

A. 在连接网络上的传输：
```
_______________________________________________
| LL hdr | IP hdr |         (data)              |
|________|________|_____________________________|

<---------- 帧 ------------------------------>
             <---------- 数据包 -------------->
```

B. 在IP分片前或IP重组后：
```
____________________________________
| IP hdr | 传输层 hdr | 应用数据 |
|________|___________|__________|

<-------- 数据报 ------------------>
         <-------- 消息 ----------->
或者，对于TCP：
____________________________________
| IP hdr |  TCP hdr | 应用数据 |
|________|__________|__________|

<-------- 数据报 ------------------>
         <-------- 段 ----------->
```

本文件汇集了大量互联网协议专家的贡献和意见，包括来自大学和研究实验室、供应商以及政府机构的代表。该文件主要由互联网工程任务组（IETF）的主机需求工作组（Host Requirements Working Group）整理完成。

编辑特别感谢以下人员的不懈努力，他们在过去的18个月中参加了多次漫长的会议，并通过电子邮件交流产生了300万字节的内容，以推动本文件的完成：Philip Almquist、Dave Borman（Cray Research）、Noel Chiappa、Dave Crocker（DEC）、Steve Deering（斯坦福大学）、Mike Karels（加州大学伯克利分校）、Phil Karn（贝尔实验室）、John Lekashman（NASA）、Charles Lynn（BBN）、Keith McCloghrie（TWG）、Paul Mockapetris（ISI）、Thomas Narten（普渡大学）、Craig Partridge（BBN）、Drew Perkins（卡内基梅隆大学）、James Van Bokkelen（FTP Software）。

此外，以下人员也为本工作做出了重要贡献：Bill Barns（Mitre）、Steve Bellovin（AT&T）、Mike Brescia（BBN）、Ed Cain（DCA）、Annette DeSchon（ISI）、Martin Gross（DCA）、Phill Gross（NRI）、Charles Hedrick（罗格斯大学）、Van Jacobson（LBL）、John Klensin（MIT）、Mark Lottor（SRI）、Milo Medin（NASA）、Bill Melohn（Sun Microsystems）、Greg Minshall（Kinetics）、Jeff Mogul（DEC）、John Mullen（CMC）、Jon Postel（ISI）、John Romkey（Epilogue Technology）、Mike StJohns（DCA）。以下人员在特定领域也做出了重要贡献：Eric Allman（伯克利）、Rob Austein（MIT）、Art Berggreen（ACC）、Keith Bostic（伯克利）、Vint Cerf（NRI）、Wayne Hathaway（NASA）、Matt Korn（IBM）、Erik Naggum（挪威Naggum Software）、Robert Ullmann（Prime Computer）、David Waitzman（BBN）、Frank Wancho（美国）、Arun Welch（俄亥俄州立大学）、Bill Westfield（思科）、Rayan Zachariassen（多伦多）。

我们对所有人表示感谢，包括那些可能在无意中被遗漏的贡献者。

---

互联网工程任务组 [第20页]

RFC1122  链路层  1989年10月

2. 链路层

2.1  引言

所有互联网系统，无论是主机还是网关，对链路层协议的需求都是相同的。这些需求在《互联网网关需求》[INTRO:2]的第3章中已有说明，并在本节中补充了相关内容。

2.2  协议概述

无。

2.3  具体问题

2.3.1   trailer协议协商

trailers协议[链接：1]可以用于链路层封装，但前提是必须已验证参与链路层通信的两个系统（主机或网关）都实现了 trailers。 如果系统没有在每个目标地址基础上动态协商使用 trailers 协议，则必须在默认配置中禁用该协议。

讨论：
 trailers协议是一种链路层封装技术，它会重新排列在物理网络上传输的数据包的内容。在某些情况下， trailers可以通过减少操作系统内部的数据复制量来提高高层协议的吞吐量。 高层协议并不知晓 trailers 的使用，但如果使用该协议，发送端和接收端都必须理解。

不当使用 trailers 可能会导致非常混乱的现象。 只有具有特定大小属性的数据包才会使用 trailers 进行封装，而且通常只有一小部分交换的数据包具有这些属性。 因此，如果使用 trailers 的系统与不使用 trailers 的系统交换数据包，一些数据包可能会“消失”在黑洞中，而另一些则能成功传递。

实现方式：
在以太网中，使用 trailers 封装的数据包会使用一种不同的以太网类型[链接：1]，而 trailers 的协商是在使用 ARP 发现目标系统的链路层地址时进行的。

具体来说，ARP 交换以通常的方式完成，使用正常的 IP 协议类型，但希望使用 trailers 的主机会额外发送一份“ trailers ARP应答”包，即一份指定 trailers 封装协议类型的 ARP应答，但其余格式与普通 ARP应答相同。 如果配置为使用 trailers 的主机收到远程主机发来的 trailers ARP应答消息，它可以将该主机加入理解 trailers 的设备列表，例如通过在 ARP 缓存中标记对应条目。

希望接收 trailer 封装的主机在完成普通 IP ARP 消息交换后，会发送 trailer ARP 回复。因此，收到针对其 IP 协议地址的 ARP 请求的主机，除了正常的 IP ARP 回复外，还会发送 trailer ARP 回复；而发送 IP ARP 请求的主机，在收到相应的 IP ARP 回复后，也会发送 trailer ARP 回复。通过这种方式，任何一方——请求方或应答方——在进行 IP ARP 交换时，都可以请求接收 trailer 封装。

这种方案采用额外的 trailer ARP 回复包，而不是为 trailer 协议类型发送 ARP 请求，旨在避免与行为异常的主机持续交换 ARP 包的问题。该主机违反任何规范或常识，错误地用另一个 ARP 回复 IP 来响应 trailer 的 ARP 回复。通过仅在 IP ARP 回复对应未完成的请求时，才对 IP ARP 回复作出 trailer ARP 回复，从而避免此问题；当收到 IP ARP 回复时，如果主机的硬件地址仍未知，则会这样做。无论何时， trailer ARP 回复都可以与响应 IP ARP 请求的 IP ARP 回复一同发送。

2.3.2 地址解析协议——ARP

2.3.2.1 ARP 缓存验证

实现地址解析协议（ARP）[LINK:2]的系统必须提供机制，以清除过期的缓存条目。如果该机制涉及超时，应允许配置超时时间。

还必须包含防止 ARP 泛洪（即以高频率重复发送针对同一 IP 地址的 ARP 请求）的机制。建议的最大速率为每个目的地每秒1个包。

讨论：
ARP规范[LINK:2]建议但并未要求在主机更改以太网地址时设置超时机制以使缓存条目失效。代理ARP的普及（参见[INTRO:2]第2.4节）显著增加了主机中缓存条目变得无效的可能性，因此现在需要某种ARP缓存失效机制。即使在没有代理ARP的情况下，较长时间的缓存超时也有助于自动纠正可能被缓存的不良ARP数据。

实现：
已经采用了四种机制，有时结合使用，以清除过期的缓存条目。

（1）超时——定期对缓存条目设置超时，即使它们正在使用中也如此。注意，当缓存条目被“刷新”时（通过观察系统发出的ARP广播中的源字段，无论目标地址如何），应重新启动此超时。对于代理ARP的情况，超时时间应大约为一分钟。

（2）单播轮询——主动向远程主机发送点对点的ARP请求，定期轮询，如果连续N次未收到ARP应答，则删除该条目。同样，超时时间应大约为一分钟，通常N取2。

（3）链路层建议——如果链路层驱动检测到传输问题，则清除相应的ARP缓存条目。

（4）高层建议——由互联网层向链路层发出调用，指示传输问题。此调用的效果是使相应的缓存条目失效。此调用类似于传输层向互联网层发出的“ADVISE_DELIVPROB()”调用（参见第3.4节），实际上，ADVISE_DELIVPROB例程可能会调用链路层建议例程以使ARP缓存条目失效。

方法（1）和（2）涉及ARP缓存超时时间大约为一分钟或更短。在没有代理ARP的情况下，这么短的超时时间可能会在非常大的以太网中产生明显的额外流量。因此，可能需要配置主机以延长ARP缓存的超时时间。

2.3.2.2 ARP数据包队列

链路层应当保存（而不是丢弃）每组目标为同一未解决IP地址的至少一份（最新的）数据包，并在该地址被解析后再进行传输。

讨论：
不遵循此建议会导致每次通信的第一包数据丢失。虽然上层协议通常可以通过重传来应对数据包丢失，但数据包丢失会影响性能。例如，TCP连接请求的丢失会导致初始往返时间估算偏高。基于UDP的应用程序，如域名系统（DNS），受到的影响更为严重。

2.3.3 以太网和IEEE 802封装

以太网的IP封装在RFC-894 [LINK:3]中描述，而IEEE 802网络的IP封装在RFC-1042 [LINK:4]中描述。RFC-1042详细说明并取代了[INTRO:2]第3.4节中的讨论。

每个连接到10Mbps以太网的互联网主机：
- 必须能够使用RFC-894封装发送和接收数据包；
- 应该能够接收混合有RFC-1042和RFC-894封装的数据包；
- 可以选择性地使用RFC-1042封装发送数据包。

实现同时支持RFC-894和RFC-1042封装的互联网主机，必须提供一个配置开关以选择使用哪一种，且该开关的默认设置应为RFC-894。

注意，RFC-1042中的标准IP封装未使用IEEE为IP保留的协议ID值（K1=6）；相反，它使用了一个值（K1=170），该值暗示一种扩展（“SNAP”），可用于携带Ether-Type字段。互联网系统不得使用K1=6发送802封装的数据包。

在以太网和IEEE 802网络上，将互联网地址转换为链路层地址必须由地址解析协议（ARP）管理。

以太网的最大传输单元（MTU）为1500字节，802.3的MTU为1492字节。

讨论：
IEEE 802.3规范规定了在10Mbps以太网电缆上的操作，此时以太网帧和IEEE 802.3帧可以在物理层上混合传输。接收端可以通过802.3长度字段的值来区分以太网帧和802.3帧；该两字节字段在头部中与以太网帧的Ether-Type字段位置相同。特别地，802.3长度字段的值必须小于或等于1500，而所有有效的Ether-Type值都大于1500。

另一个兼容性问题出现在链路层广播方面。使用一种帧格式发送的广播不会被只能接收另一种帧格式的主机看到。

本节的规定旨在最大限度地实现支持894协议和1042协议的系统在同一电缆上的直接互操作。其设计目的是支持目前以894协议系统为主的局面，同时也为未来可能普及的1042协议系统提供便捷的过渡方案。

请注意，只有894协议的系统不能直接与仅支持1042协议的系统互通。如果将这两种系统在同一根电缆上设置为两个不同的逻辑网络，它们只能通过IP网关进行通信。此外，由于链路层广播的问题，双格式主机自动检测应使用哪种格式进行发送既不实用，也不可能实现。

2.4 链路/互联网层接口

IP层与链路层之间的包接收接口必须包含一个标志，用以指示接收的包是否是发往链路层广播地址的。

讨论：
虽然IP层通常不知道链路层地址（因为不同的网络介质通常具有不同的地址格式），但在支持广播的介质上，广播地址是一个重要的特殊情况。详见第3.2.2节，特别是关于广播风暴的讨论。

IP层与链路层之间的包发送接口必须包含5位的TOS字段（参见第3.2.1.6节）。

链路层不得仅因为没有目标地址的ARP缓存条目而向IP报告“目标不可达”错误。

2.5 链路层需求总结

以下是英文内容的中文翻译：

```
                                                  |       | | | |S| |
                                                  |       | | | |H| |F
                                                  |       | | | |O|M|o
                                                  |       | |S| |U|U|o
                                                  |       | |H| |L|S|t
                                                  |       |M|O| |D|T|n
                                                  |       |U|U|M| | |o
                                                  |       |S|L|A|N|N|t
                                                  |       |T|D|Y|O|O|t
功能                                              |章节   | | | |T|T|e
--------------------------------------------------|-------|-|-|-|-|-|--
                                                  |       | | | | | |
封装视频预告                                    |2.3.1  | | |x| | |
默认情况下发送预告，无需协商                     |2.3.1  | | | | |x|
ARP（地址解析协议）                                |2.3.2  | | | | | |
  清除过期的ARP缓存条目                            |2.3.2.1|x| | | | |
  防止ARP泛洪                                    |2.3.2.1|x| | | | |
  缓存超时时间可配置                              |2.3.2.1| |x| | | |
  至少保存一个（最新的）未解决的数据包             |2.3.2.2| |x| | | |
以太网和IEEE 802封装                              |2.3.3  | | | | | |
  主机能够执行：                                   |2.3.3  | | | | | |
    发送和接收RFC-894封装                         |2.3.3  |x| | | | |
    接收RFC-1042封装                                |2.3.3  | |x| | | |
    发送RFC-1042封装                                |2.3.3  | | |x| | |
      然后配置交换机以选择，RFC-894为默认             |2.3.3  |x| | | | |
  发送K1=6封装                                    |2.3.3  | | | | |x|
  在以太网和IEEE 802网络上使用ARP                     |2.3.3  |x| | | | |
链路层报告广播到IP层                              |2.4    |x| | | | |
IP层将TOS传递给链路层                              |2.4    |x| | | | |
没有ARP缓存条目被视为目的地不可达                     |2.4    | | | | |x|





互联网工程任务组                                              [第26页]





RFC1122                      互联网层                     1989年10月


3. 互联网层协议

   3.1 引言

      鲁棒性原则：“在你接受的内容上要宽容，在你发送的内容上要保守”，在互联网层尤为重要，因为一个行为不端的主机可能会拒绝为许多其他主机提供互联网服务。

      互联网层使用的协议标准包括：

      o    RFC-791 [IP:1] 定义了IP协议，并介绍了互联网的架构。
```

RFC-792 [IP:2] 定义了 ICMP（互联网控制消息协议），它为 IP 提供路由、诊断和错误处理功能。虽然 ICMP 消息被封装在 IP 数据报中，但 ICMP 的处理被认为（并且通常实现为）属于 IP 层。详见第3.2.2节。

RFC-950 [IP:3] 定义了对寻址架构的强制子网扩展。

RFC-1112 [IP:4] 定义了互联网组管理协议（IGMP），作为对主机及其与网关接口的推荐扩展，以支持在 IP 层进行互联网范围的多播。详见第3.2.3节。

IP 多播的目标可以是任意一组互联网主机。IP 多播被设计为某些网络链路层多播功能的自然扩展，并提供一种标准方式，用于本地访问此类链路层多播功能。

其他重要参考资料列在本文档第5节中。

主机软件的互联网层必须实现 IP 和 ICMP。关于支持 IGMP 的要求，详见第3.3.7节。

主机的 IP 层有两个基本功能：(1) 选择出站 IP 数据报的“下一跳”网关或主机；(2) 重新组装传入的 IP 数据报。IP 层还可以（3）实现有意的出站数据报分段。最后，IP 层必须（4）提供诊断和错误功能。我们预期，随着互联网控制和管理设施的进一步发展，IP 层的功能可能会有所增加。

对于普通数据报，处理过程相对简单。对于传入的数据报，IP 层：

(1) 验证数据报格式是否正确；

(2) 验证其是否为本地主机的目的地；

(3) 处理选项；

(4) 必要时重新组装数据报；

(5) 将封装的消息传递给相应的传输层协议模块。

对于传出的数据报，IP 层：

(1) 设置传输层未设置的字段；

(2) 选择连接网络上的正确第一跳（此过程称为“路由”）；

(3) 如果需要且实现了有意的分段，则对数据报进行分段（参见第3.3.3节）；

(4) 将数据包传递给相应的链路层驱动程序。

主机如果拥有多个IP地址，则被称为多宿（多重连接）主机。多宿引入了相当大的混乱和复杂性，给协议族带来了严重的不足之处，尤其是在解决所有相关问题方面。多宿主要涉及两个不同的问题领域：

（1）本地多宿——主机本身具有多个IP地址；或者

（2）远程多宿——本地主机需要与远程多宿主机通信。

目前，远程多宿必须在应用层处理，详见配套的RFC [INTRO:1]。而主机支持本地多宿（即本地多IP地址配置），则由本文讨论，特别是在第3.3.4节中。

任何转发由另一台主机生成的数据报的主机，都是网关，必须符合网关要求RFC [INTRO:2]中的规范。包含嵌入式网关代码的互联网主机，必须具有一个配置开关，用于禁用网关功能，并且该开关的默认设置必须为非网关模式。在此模式下，无论主机是单宿还是多宿，通过某一接口到达的数据报都不会被转发到另一台主机或网关（除非采用源路由），除非数据报是源路由的。主机软件不得在主机拥有多个接口时自动切换到网关模式，因为机器的操作员可能既不希望提供此服务，也可能没有能力这样做。

在以下情况下，某些操作被规定为“静默丢弃”接收的数据报。这意味着数据报将被直接丢弃，不会进行进一步处理，也不会因此向源主机发送任何ICMP错误消息（详见第3.2.2节）。然而，为了诊断问题，主机应提供记录错误的能力（见第1.2.3节），包括被静默丢弃的数据报内容，并应在统计计数器中记录此事件。

讨论：
静默丢弃错误数据报通常是为了防止“广播风暴”。

3.2 协议流程简介

3.2.1 互联网协议——IP

3.2.1.1 版本号：RFC-791第3.1节

版本号不是4的IP数据报必须被静默丢弃。

3.2.1.2 校验和：RFC-791第3.1节

主机必须在每次接收数据报时验证IP头部的校验和，校验和错误的数据报应被静默丢弃。

3.2.1.3 地址：RFC-791第3.2节

现在有五类IP地址：A类到E类。D类地址用于IP多播[IP:4]，而E类地址则保留用于实验性用途。

多播（D类）地址是一个28位的逻辑地址，代表一组主机，可以是永久的也可以是临时的。永久多播地址由互联网号码分配局（Internet Assigned Number Authority）[INTRO:6]分配，而临时地址则可以动态分配给临时组。组成员资格是通过IGMP [IP:4]动态确定的。

我们现在总结A、B、C类IP地址的重要特殊情况，使用以下符号表示IP地址：

    { <网络号>, <主机号> }

或
    { <网络号>, <子网号>, <主机号> }

以及用“-1”表示包含全部1比特的字段。这种符号并不意味着地址掩码中的1比特必须连续。

(a)  { 0, 0 }

这是该网络上的本地主机。除非作为初始化过程中的源地址，用于主机学习其自身IP地址，否则不得发送。

另请参见第3.3.6节，关于{0,0}的非标准用法。

(b)  { 0, <主机号> }

指定网络上的某一主机。除非作为初始化过程中的源地址，用于主机学习其完整的IP地址，否则不得发送。

(c)  { -1, -1 }

广播地址。不得用作源地址。

带有此目的地址的数据报会被连接的物理网络上的每个主机接收，但不会被转发到网络之外。

(d)  { <网络号>, -1 }

指向指定网络的定向广播地址。不得用作源地址。

(e)  { <网络号>, <子网号>, -1 }

指向指定子网的定向广播地址。不得用作源地址。

(f)  { <网络号>, -1, -1 }

指向所有子网的定向广播地址，属于指定子网的网络。不得用作源地址。

(g)  { 127, <任意> }

内部主机回环地址。此类地址的形式绝对不能出现在主机之外。

网络号码（<Network-number>）由管理机构分配，确保其在全球范围内唯一。

IP地址的<Host-number>、<Network-number>或<Subnet-number>字段不得为0或-1（除非符合上述特殊情况）。这意味着这些字段的长度至少为两位。

关于广播地址的详细讨论，请参见第3.3.6节。

主机必须支持IP的子网扩展[IP:3]。因此，每个主机的本地IP地址都将关联一个地址掩码，形式为：{-1, -1, 0}；详见第3.2.2.9节和第3.3.1.1节。

当主机发送任何数据报时，IP源地址必须是其自身的IP地址（但不能是广播地址或多播地址）。

主机必须静默丢弃所有非本机目的地的数据报。判断数据报是否为本机目的地的方法是：数据报的目的地址字段是以下之一：

1. 主机的一个IP地址；或

2. 连接网络上的有效IP广播地址；或

3. 该主机在接收的物理接口上属于的多播组地址。

在大多数情况下，发往广播或多播目的地的数据报会被处理为发往主机的某个IP地址；我们用“特定目的地地址”来指代主机的本地IP地址。特定目的地地址定义为IP头中的目的地址，除非该地址是广播或多播地址；在这种情况下，特定目的地地址是分配给接收数据报的物理接口的IP地址。

主机必须静默丢弃包含无效IP源地址（符合本节规则）的入站数据报。这种验证可以在IP层完成，也可以由传输层的每个协议自行完成。

讨论：
错误的地址可能由链路层广播单播数据报引起，或者由网关或主机的配置错误或混乱造成。

互联网主机的一个架构目标是使IP地址成为无特征的32位数字，避免使用需要了解IP地址格式的算法。否则，未来任何关于IP地址格式或解释的变更都将需要主机软件的修改。然而，对广播地址和多播地址的验证违反了这一目标；本文档中还描述了其他一些违反情况。

实现者应当注意，依赖全子网定向广播地址（f）的应用可能在某些网络上无法使用。目前，所有子网广播在供应商的网关中尚未广泛实现，即使已实现，某些网络管理员也可能在网关配置中禁用它。

3.2.1.4  分段与重组：RFC-791第3.2节

互联网模型要求每台主机都支持重组。关于分段和重组的具体要求，请参见第3.3.2和第3.3.3节。

3.2.1.5  标识符：RFC-791第3.2节

当发送一份早期数据报的相同副本时，主机可以选择性地在副本中保留相同的标识字段。

讨论：
一些互联网协议专家认为，当主机发送一份早期数据报的相同副本时，新的副本应包含与原始数据报相同的标识值。有两个建议的优点：（1）如果数据报被分段且部分分段丢失，接收方可能能够从原始分段和副本中重建完整的数据报；（2）在网络拥堵的网关中，IP的标识字段（以及分段偏移）可以用来丢弃队列中的重复数据报。

然而，互联网中观察到的数据报丢失模式并不支持重传分段填补重组空隙的概率，而其他机制（例如，TCP在重传时重新打包）则倾向于防止重传相同的数据报 [IP:9]。因此，我们认为重复传输相同的标识字段（Identification）并没有多大用处。此外，像UDP这样的无连接传输协议需要应用程序的配合，以在相同的数据报中保持相同的标识值。

3.2.1.6 服务类型（Type-of-Service）：RFC-791第3.2节

IP头中的“服务类型”字节被划分为两个部分：优先级字段（高位3位）和通常称为“服务类型”或“TOS”的字段（低位5位）。在本文中，所有提及“TOS”或“TOS字段”的内容仅指低位的5位。

优先级字段旨在用于国防部的互联网协议应用。该字段中使用非零值的情况超出了本文和IP标准规范的范围。供应商应咨询国防通信局（DCA），以获取关于IP优先级字段及其对其他协议层影响的指导。然而，供应商应注意，使用优先级很可能需要像传递TOS字段一样，在协议层之间传递其值。

IP层必须提供一种机制，使传输层能够设置每个发送的数据报的TOS字段；默认值为全部零位。IP层应将接收到的TOS值传递给传输层。

RFC-795中关于TOS的特定链路层映射不应被实现。

讨论：
虽然TOS字段过去使用较少，但预计在不久的将来其作用将逐渐增强。TOS字段预计将用于控制网关操作的两个方面：路由和排队算法。关于应用程序指定TOS值的要求，请参见[INTRO:1]第2节。

TOS字段也可以映射到链路层服务选择器。这已被应用于实现不同类别的TCP流量在串行线路上的有效共享，例如。然而，RFC-795中建议的网络映射（这些网络在1981年已被纳入互联网）现已过时。

3.2.1.7  生存时间（Time-to-Live，TTL）：RFC-791第3.2节

主机不得发送TTL值为零的数据报。

主机不得仅因为收到的TTL值小于2而丢弃数据报。

IP层必须提供一种机制，允许传输层设置每个发送数据报的TTL字段。当使用固定TTL值时，必须可以进行配置。当前建议的值将在“已分配号码”RFC中公布。

讨论：
TTL字段有两个功能：限制TCP段的生存时间（参见RFC-793 [TCP:1]，第28页），以及终止互联网路由环路。虽然TTL是以秒为单位的时间，但它也具有跳数的某些属性，因为每个网关都必须将TTL字段至少减一。

其意图是TTL到期会导致网关丢弃数据报，但不会由目的主机丢弃；然而，作为网关转发数据报的主机必须遵循网关关于TTL的规则。

上层协议可能希望设置TTL，以实现对某些互联网资源的“扩展范围”搜索。这在一些诊断工具中使用，预计在利用IP多播定位某一类别的“最近”服务器时也会很有用。例如，某些传输协议可能还希望指定其最大数据报生存时间的TTL限制。

固定值应至少足够覆盖互联网的“直径”，即最长可能路径。一个合理的值大约是直径的两倍，以适应互联网的持续增长。

3.2.1.8  选项：RFC-791第3.2节

必须有一种机制，允许传输层指定要包含在传输的IP数据报中的IP选项（参见第3.4节）。

所有在数据报中接收的IP选项（除NOP或END-OF-LIST之外）必须传递给传输层（或者在数据报为ICMP消息时传递给ICMP处理）。IP层和传输层必须各自解释它们理解的IP选项，而对其他选项则应默默忽略。

本文件的后续章节将讨论ICMP、TCP和UDP各自所需支持的具体IP选项。

讨论：
将所有接收的IP选项传递给传输层是一种有意的“违反严格层次结构”的做法，旨在简化未来引入新的与传输相关的IP选项的过程。每一层都必须提取出与自身处理相关的选项，忽略其余部分。为此，除了NOP和END-OF-LIST之外的每个IP选项都应包含其自身长度的说明。

本文件未定义接收方在处理同一IP头中的多个选项时应遵循的顺序。发送多个选项的主机应意识到，这可能会在与源路由选项结合使用时引入某些选项含义的歧义。

实现方面：
IP层不得因选项长度超出可能范围而崩溃。例如，已观察到错误的选项长度可能导致某些IP实现进入无限循环。

以下是对特定IP选项的要求：

(a) 安全选项
某些环境要求每个数据报都包含安全选项；此类要求超出本文件和IP标准规范的范围。然而，值得注意的是，RFC-791和RFC-1038中描述的安全选项已被废弃。对于国防部的应用，供应商应参考[IP:8]以获取指导。

(b) 流标识符选项
此选项已废弃；不应发送，且如果接收，应默默忽略。

(c) 源路由选项
主机必须支持发起源路由，并且必须能够作为源路由的最终目的地。

如果主机收到一个包含完整源路由的IP数据报（即指针指向最后一个字段之后），则该数据报已到达其最终目的地；接收到的选项（即记录的路由）必须传递到传输层（或ICMP消息处理）。这个记录的路由将被反转，用于形成回复数据报的返回源路由（参见第4节中关于IP选项的讨论）。当构建返回源路由时，即使记录的路由中包含源主机，也必须正确地形成（参见下面讨论中的情况（B））。

包含多个源路由选项的IP头部不得发送；多个源路由选项对路由的影响是由实现决定的。

第3.3.5节介绍了作为源路由中间跳的主机的规则，即转发源路由数据报的规则。

讨论：
如果源路由数据报被分段，每个分段都将包含源路由的副本。由于IP选项（包括源路由）的处理必须在重组之前进行，因此原始数据报在到达最终目的地之前不会被重组。

假设一个源路由数据报需要通过网关G1、G2、… Gn从主机S路由到主机D。在规范中存在一个歧义，即数据报中由S发出的源路由选项应为（A）还是（B）：

（A）：{>>G2, G3, ... Gn, D}  <--- 正确

（B）：{S, >>G2, G3, ... Gn, D}  <--- 错误

（其中“>>”表示指针）。如果发送的是（A），那么在D接收到的数据报中将包含选项：{G1, G2, ... Gn >>}，IP源地址和目的地址分别为S和D。如果发送的是（B），那么在D接收到的数据报中仍然会包含S和D作为IP源和目的地址，但选项将是：{S, G1, ... Gn >>}；也就是说，发起主机将是路由中的第一个跳点。

起源和处理记录路由选项的实现是可选的。

（e）时间戳选项

起源和处理时间戳选项的实现是可选的。如果实现了，必须遵守以下规则：

- 起源主机必须在时间戳选项中记录时间戳，该选项的互联网地址字段未预先指定，或其第一个预先指定的地址是主机的接口地址。

- 目的主机必须（如果可能的话）在将时间戳选项传递给传输层或ICMP进行处理之前，添加当前的时间戳。

- 时间戳值必须遵循第3.2.2.8节中关于ICMP时间戳消息的规则。

3.2.2 互联网控制消息协议——ICMP

ICMP消息分为两类。

* ICMP错误消息：
  - 不可达目的地（见第3.2.2.1节）
  - 重定向（见第3.2.2.2节）
  - 源抑制（见第3.2.2.3节）
  - 超时（见第3.2.2.4节）
  - 参数问题（见第3.2.2.5节）

* ICMP查询消息：
  - 回显（见第3.2.2.6节）
  - 信息（见第3.2.2.7节）
  - 时间戳（见第3.2.2.8节）
  - 地址掩码（见第3.2.2.9节）

如果收到未知类型的ICMP消息，必须将其静默丢弃。

每个ICMP错误消息都包含引发错误的 datagram 的互联网头部和至少前8个数据八位字节；可以发送超过8个八位字节；这些头部和数据必须与接收的datagram保持一致。

在需要将ICMP错误消息传递给传输层的情况下，必须从原始头部中提取IP协议号，并用它来选择相应的传输协议实体以处理错误。

ICMP错误消息应以正常（即，零）TOS位发送。

不得因接收以下情况而发送ICMP错误消息：
- 一个ICMP错误消息本身，或

*  一个目标为IP广播或IP多播地址的数据报，或者

*  作为链路层广播发送的数据报，或者

*  非初始片段，或者

*  源地址不指向单一主机的数据报——例如，零地址、回环地址、广播地址、多播地址或E类地址。

注意：这些限制优先于本文档中其他任何关于发送ICMP错误消息的要求。

讨论：
这些规则将防止因主机对广播数据报返回ICMP错误消息而引发的“广播风暴”。例如，向不存在端口的广播UDP段可能会引发大量的ICMP目的地不可达数据报，来自所有没有该目标端口客户端的机器。在大型以太网中，产生的碰撞可能导致网络在一秒或更长时间内变得无法使用。

在连接的网络上广播的每个数据报都应具有有效的IP广播地址作为其IP目的地址（参见第3.3.6节）。然而，某些主机会违反此规则。因此，为了确保检测到广播数据报，主机需要同时检查链路层广播和IP层广播地址。

实现：
这要求链路层在接收到链路层广播数据报时通知IP层；详见第2.4节。

3.2.2.1 目的地不可达：RFC-792

以下附加代码已被定义：

6 = 目的网络未知

7 = 目的主机未知

8 = 源主机隔离

9 = 与目的网络的通信被管理禁止

10 = 与目的主机的通信被管理禁止

11 = 由于服务类型，网络不可达

12 = 由于服务类型，主机不可达

主机应使用以下代码生成目的地不可达消息：

2（协议不可达），当指定的传输协议不支持时；或者

3（端口不可达），当指定的传输协议（例如UDP）无法对数据报进行多路复用，但没有协议机制通知发送方。

接收到的不可达目的地消息必须报告给传输层。传输层应当合理利用这些信息；例如，参见下面的第4.1.3.3、4.2.3.9和4.2.4节。具有自己通知发送方端口不可达机制的传输协议（例如，TCP会发送RST段）仍然必须接受用于相同目的的ICMP端口不可达消息。

当接收到代码为0（网络）、1（主机）或5（错误的源路由）的不可达目的地消息时，可能是由路由瞬时变化引起的，因此必须将其仅作为提示，而非证明，表明指定的目的地不可达[IP:11]。例如，不得将其用作网关已死的证明（参见第3.3.1节）。

3.2.2.2 重定向：RFC-792

主机不应发送ICMP重定向消息；重定向应仅由网关发送。

接收重定向消息的主机必须相应地更新其路由信息。每个主机都必须准备好接受主机重定向和网络重定向，并按照下面第3.3.1.2节的描述进行处理。

如果重定向消息中指定的新网关地址不在与重定向到达的相同连接（子）网内，或者重定向的源不是为指定目的地的当前第一跳网关，则应静默丢弃该重定向消息[INTRO:2，附录A]。

3.2.2.3 源抑制：RFC-792

当主机接近或达到因重组缓冲区或其他资源短缺而被迫丢弃传入数据报的临界点时，可以发送源抑制消息。关于何时发送源抑制的建议，请参见[INTRO:2]的第2.2.3节。

如果收到源抑制消息，IP层必须将其报告给传输层（或ICMP处理）。一般而言，传输层或应用层应实现机制，以响应任何能向同一目的地连续发送数据报且能合理维护足够状态信息的协议的源抑制。关于TCP和UDP对源抑制的处理，请参见第4节。

讨论：
源抑制（Source Quench）可能由目标主机或数据报路径中的某个网关生成。接收源抑制的主机应在一段时间内减缓自身的传输速率，然后逐步恢复传输速度。对源抑制的响应机制可以在传输层（如面向连接的协议TCP）中实现，也可以在应用层（如建立在UDP之上的协议）中实现。

已有一种机制被提出[IP:14]，可以让IP层直接响应源抑制，通过控制数据报的发送速率，但该方案目前仍处于试验阶段，目前不推荐使用。

3.2.2.4 超时（Time Exceeded）：RFC-792

收到的超时消息必须传递给传输层。

讨论：
当网关因TTL字段过期而丢弃数据报时，会发送一个超时代码0（在途）消息。这表明可能存在路由环路或初始TTL值过小的问题。

主机可能会收到来自目的主机的超时代码1（重组超时）消息，表示已超时并丢弃了未完成的数据报；详见下文第3.3.2节。未来，接收此类消息可能成为“MTU发现”过程的一部分，用于探测在不分片的情况下可以在路径上传输的最大数据报大小。

3.2.2.5 参数问题（Parameter Problem）：RFC-792

主机应生成参数问题消息。接收的参数问题消息必须传递给传输层，也可以向用户报告。

讨论：
ICMP参数问题消息用于报告任何未被其他ICMP消息覆盖的问题。收到参数问题消息通常表示存在某些本地或远程实现错误。

现定义参数问题消息的一个新变体：
代码1 = 缺少必需的选项。

讨论：
该变体目前在军事社区中用于报告缺失的安全选项。

3.2.2.6 回显请求/应答（Echo Request/Reply）：RFC-792

每个主机必须实现一个ICMP回显服务器功能，能够接收回显请求并发送相应的回显应答。主机还应实现一个应用层接口，用于发送回显请求和接收回显应答，以便进行诊断。

目的地为IP广播地址或IP多播地址的ICMP回显请求可能会被静默丢弃。

讨论：
这一中立的规定源于一场激烈的辩论，一方认为向广播地址发送ICMP回显提供了有价值的诊断能力，另一方则担心滥用此功能可能会轻易引发数据包风暴。

在ICMP回显应答中的IP源地址必须与对应的ICMP回显请求消息中的特定目标地址（定义在第3.2.1.3节）相同。

在ICMP回显请求中接收的数据必须完整包含在生成的回显应答中。然而，如果发送回显应答需要有意进行分段（且未实现分段），则数据报必须被截断至最大传输尺寸（参见第3.3.3节）后再发送。

除非对应的回显请求起源于IP层，否则回显应答消息必须传递给ICMP用户接口。

如果在ICMP回显请求中接收到记录路径（Record Route）和/或时间戳（Time Stamp）选项，应将这些选项（这些选项）更新为包含当前主机信息，并在回显应答的IP头中加入，而不进行“截断”。这样，记录的路径将涵盖整个往返过程。

如果在ICMP回显请求中接收到源路由（Source Route）选项，返回路径必须反转，并作为回显应答的源路由选项使用。

3.2.2.7 信息请求/应答：RFC-792

主机不应实现这些消息。

讨论：
信息请求/应答对旨在支持无盘工作站等自配置系统，使其在启动时能够发现自己的IP网络编号。然而，RARP和BOOTP协议提供了更好的机制，让主机能够自行发现其IP地址。

3.2.2.8 时间戳和时间戳应答：RFC-792

主机可以实现时间戳和时间戳应答。如果实现了，必须遵循以下规则。

互联网工程任务组                                [第43页]

RFC1122                      互联网层                 1989年10月

o    ICMP时间戳服务器功能会对每个接收到的时间戳消息返回一个时间戳应答。如果实现了此功能，应该设计成延迟变化最小（例如，在内核中实现以避免调度用户进程时的延迟）。

以下关于时间戳的情况应按照ICMP回显的相应规则处理：

o    发送到IP广播或IP多播地址的ICMP时间戳请求消息可能会被静默丢弃。

o    ICMP时间戳应答中的IP源地址必须与对应时间戳请求消息的特定目标地址相同。

o    如果在ICMP回显请求中收到源路由选项，则返回路径必须反转，并作为时间戳应答消息的源路由选项使用。

o    如果在时间戳请求中收到记录路由和/或时间戳选项，则应更新这些选项以包含当前主机，并在时间戳应答消息的IP头中包含它们。

o    传入的时间戳应答消息必须传递给ICMP用户界面。

时间戳值的首选形式（“标准值”）是自世界协调时午夜起的毫秒数。然而，提供具有毫秒级分辨率的值可能较困难。例如，许多系统使用每秒仅更新50或60次的时钟。因此，在“标准值”中允许一定的弹性：

(a)  “标准值”必须每秒至少更新15次（即，值的最低六位可能未定义）。

(b)  “标准值”的精确度必须接近操作员设置的CPU时钟，即误差在几分钟之内。

互联网工程任务组                                [第44页]

RFC1122                      互联网层                 1989年10月

3.2.2.9  地址掩码请求/应答：RFC-950

一台主机必须支持以下方法中的第一种，并可以实现全部三种方法，用于确定其IP地址对应的地址掩码：

(1)  静态配置资料；

（2）在系统初始化过程中，动态获取地址掩码（作为副作用）（参见[INTRO:1]）；以及

（3）发送ICMP地址掩码请求（Address Mask Request）并接收ICMP地址掩码应答（Address Mask Reply）。

在特定主机中必须可配置所使用的方法。

当启用方法（3）——即使用地址掩码消息时，则：

(a) 当主机初始化时，必须在与其IP地址对应的连接网络上广播一条地址掩码请求消息。如果未能立即收到地址掩码应答，则应多次重传该消息。

(b) 在收到地址掩码应答之前，主机应假设该IP地址所属的地址类别对应的掩码，即假设连接的网络没有子网划分。

(c) 首次收到的地址掩码应答消息必须用来设置对应该本地IP地址的地址掩码。即使该应答是“非 solicited”（非主动请求的），也应如此，因为它可能是广播的，并且可能在主机停止重传地址掩码请求后到达。一旦通过地址掩码应答设置了掩码，之后收到的任何地址掩码应答都必须（静默地）忽略。

相反，如果禁用地址掩码消息，则不会发送任何ICMP地址掩码请求，且任何为该本地IP地址收到的ICMP地址掩码应答都必须（静默地）忽略。

主机应对其安装的任何地址掩码进行合理性检查；详见下文的实现部分。

除非是权威的地址掩码代理，否则系统不得发送地址掩码应答。权威代理可以是主机或网关，但必须明确配置为地址掩码代理。接收地址掩码应答并不赋予接收方任何权限，也不得作为发出地址掩码应答的依据。

对于静态配置的地址掩码，应有额外的配置标志，决定主机是否作为该掩码的权威代理，即是否会用此掩码响应地址掩码请求消息。

如果配置为代理，则主机在初始化时必须在相应接口上广播一条地址掩码应答（Address Mask Reply）以响应掩码请求。

有关地址掩码请求/应答（Address Mask Request/Reply）消息的更多信息，请参见[INTRO:1]中的“系统初始化”。

讨论
    随意发送带有无效地址掩码的地址掩码应答的主机，常常会造成严重的干扰。为了防止这种情况，应当仅由经过明确管理操作选定的权威代理（authoritative agents）发送地址掩码应答。

    当权威代理收到地址掩码请求（Address Mask Request）消息时，它会向源IP地址发送一条单播的地址掩码应答（Address Mask Reply）。如果该地址的网络部分为零（见3.2.1.3中的(a)和(b)），则应答将以广播方式发送。

    如果主机未收到对其地址掩码请求的应答，它将假设没有代理存在，并使用未子网划分的掩码，但代理可能只是暂时无法到达。代理在初始化时会广播一条未请求的地址掩码应答，以更新所有在此期间已初始化的主机的掩码。

实现建议：
    对地址掩码进行合理性检查：掩码不应全为1位，并且应满足以下条件之一：
    - 掩码不全为1
    - 或者掩码的最高8位为1

3.2.3 互联网组管理协议（IGMP）

IGMP [IP:4] 是一种在单一网络中，主机与网关之间用以建立主机对特定多播组成员身份的协议。网关利用这些信息，结合多播路由协议，支持互联网中的IP多播。

目前，IGMP的实现是可选的；更多信息请参见第3.3.7节。没有IGMP，主机仍然可以参与其连接网络内的多播。

3.3 具体问题

3.3.1 传出数据报的路由

IP层会为每个发出的数据报选择正确的下一跳。如果目的地在连接的网络上，数据报会直接发送到目标主机；否则，必须将其路由到连接网络上的网关。

3.3.1.1 本地/远程决策

为了判断目的地是否在连接的网络上，必须使用以下算法[参见IP:3]：

(a) 地址掩码（针对多宿主主机的本地IP地址的特定掩码）是一个32位掩码，用于选择对应IP地址的网络号和子网号字段。

(b) 如果通过地址掩码提取的目标IP地址位与通过相同掩码提取的源IP地址位相匹配，则说明目标位于对应的已连接网络上，数据报将直接传输到目标主机。

(c) 如果不匹配，则说明目标只能通过网关访问。网关的选择在下面的（3.3.1.2）部分进行描述。

对于特殊情况的目标地址，处理方式如下：

* 对于有限广播或多播地址，直接将数据报交给链路层的相应接口处理。

* 对于（网络或子网）定向广播，数据报可以使用标准的路由算法进行转发。

主机的IP层必须在最小的网络环境中正常工作，特别是在没有网关的情况下。例如，如果某个主机的IP层在初始化时坚持必须找到至少一个网关，那么该主机将无法在单一的隔离广播网络上正常运行。

3.3.1.2 网关选择

为了高效地将一系列数据报路由到同一目的地，源主机必须维护一个“路由缓存”，存储到下一跳网关的映射关系。主机使用以下基本算法在此缓存上进行数据报的路由；该算法旨在将主要的路由负担转移到网关上[IP:11]。

(a) 如果路由缓存中没有关于某个特定目的地的信息，主机将选择一个“默认”网关并将数据报发送给它，同时建立相应的路由缓存条目。

(b) 如果该网关不是到目的地的最佳下一跳，网关会将数据报转发到更优的下一跳网关，并向源主机返回一个ICMP重定向消息。

(c) 当主机收到重定向消息后，会更新相应路由缓存条目中的下一跳网关信息，以便后续发往相同目的地的数据报可以直接送达最佳网关。

由于通常无法知道与目标地址对应的子网掩码，因此应将网络重定向（Network Redirect）消息与主机重定向（Host Redirect）消息一视同仁；即，只有目标主机的缓存条目会被更新（如果不存在该条目，则会创建一个新条目）以指向新的网关。

讨论：
这一建议旨在防止网关错误地为子网划分的网络发送网络重定向，违反了网关的相关要求 [INTRO:2]。

当没有目标主机地址的路由缓存条目（且目标不在直接连接的网络上）时，IP层必须从其“默认”网关列表中选择一个网关。IP层必须支持多个默认网关。

作为额外功能，主机的IP层可以实现一张“静态路由”表。每个静态路由可以包含一个标志，指示是否可以被ICMP重定向覆盖。

讨论：
通常，主机至少需要知道一个默认网关以便开始通信。这些信息可以通过配置文件获得，或者在主机启动序列中获取，例如通过BOOTP协议（参见 [INTRO:1]）。

有人建议，主机可以通过记录它所学到的任何新网关来扩展其默认网关列表。例如，它可以记录每个被重定向的网关。虽然在某些情况下此类功能可能有用，但在其他情况下可能会引发问题（例如，不同网关的优劣不同），因此不推荐这样做。

静态路由通常是将目标主机或网络映射到特定下一跳网关的预设配置；它也可能依赖于服务类型（见下一节）。系统管理员会设置静态路由，以覆盖正常的自动路由机制，以应对特殊情况。然而，任何静态路由信息都可能成为配置变更或设备故障时的潜在故障源。

3.3.1.3 路由缓存

每个路由缓存条目需要包括以下字段：

(1) 本地主机的IP地址（适用于多宿主机）

(2) 目标IP地址

（3） 服务类型

（4） 下一跳网关的IP地址

字段（2）可以是目标的完整IP地址，也可以仅是目标网络号。字段（3），即服务类型（TOS），应包含在内。

请参阅第3.3.4.2节，了解多宿（multihoming）对该缓存中查找过程的影响。

讨论：
在路由缓存中包含服务类型字段，并在主机路由算法中加以考虑，将为未来互联网中普遍使用服务类型路由提供必要的机制。详见第3.2.1.6节。

每个路由缓存条目定义了一个互联网路径的端点。虽然连接路径可能会以任意方式动态变化，但路径的传输特性倾向于在比单一典型主机到主机传输连接更长的时间内保持大致不变。因此，路由缓存条目是缓存路径属性的自然位置。这些属性的示例可能包括最大未分段数据报大小（见第3.3.3节）或由传输协议测量的平均往返延迟。这些数据通常由更高层的协议（如TCP）或使用UDP的应用程序收集和使用。目前正在进行关于以此方式缓存路径属性的实验。

关于路由缓存是否应仅以目标主机地址作为键，还是允许同时使用主机和网络地址，尚无统一共识。支持仅使用主机地址的观点包括：
（1） 根据第3.3.1.2节的要求，重定向（Redirect）消息通常会导致以目标主机地址为键的条目；最简单且最通用的方案是始终使用主机地址。
（2） 在复杂的子网环境中，IP层可能无法总是知道网络地址的掩码。
（3） 仅使用主机地址允许将目标地址作为纯粹的32位数字，这可能使未来互联网架构的扩展变得更容易，而无需...

互联网工程任务组                                [第50页]





RFC1122                      互联网层                 1989年10月


对主机的任何更改。

反对的观点认为，在路由缓存中允许目的主机和网络混合存在：

(1) 节省内存空间。

(2) 导致数据结构更为简洁，便于将缓存与默认路由和静态路由表结合（见下文）。

(3) 提供一个更有用的地方来缓存路径属性，正如前面讨论的那样。


实现方式：
路由缓存需要足够大，以包含在某一时刻可能使用的最大目的主机数的条目。

一个路由缓存条目还可以包括用于选择替换条目的控制信息。例如，可以是“最近使用”位、使用计数或最后使用时间戳。建议还应包括条目的最后修改时间，以便进行诊断。

实现时可能希望减少每个数据报传输时扫描路由缓存的开销。这可以通过使用哈希表加快查找速度，或者为面向连接的传输协议提供“提示”或临时句柄，指向适当的缓存条目，并在每个后续数据报中传递给IP层。

虽然我们已描述了路由缓存、默认网关列表和静态路由表在概念上是不同的，但在实际中，它们可以合并为一个“路由表”数据结构。

3.3.1.4 死亡网关检测

IP层必须能够检测其路由缓存中列出的“下一跳”网关的失效，并选择备用网关（见第3.3.1.5节）。

关于死亡网关检测的详细内容在RFC-816 [IP:11]中有所介绍。迄今为止的经验尚未提出完全令人满意的算法，但已识别出几条禁止路径和一些有前景的技术。

* 在没有积极迹象表明某个网关正常工作的情况下，不应无限期使用该网关。

以下是英文内容的中文翻译：

```
            *    主动探测方法，例如“pinging”（即使用ICMP回显请求/应答交换）成本较高，且扩展性差。特别是，主机绝不能通过持续ping网关的方式主动检查第一个跳跃网关的状态。

            *    即使ping是验证网关状态的唯一有效方法，也必须仅在向网关发送流量且没有其他积极指示表明网关正常工作的情况下使用。

            *    为了避免ping，网络层以上和/或以下的层应能够在有正面（网关正常）或负面（网关失效）信息可用时，提供关于路由缓存条目状态的“建议”。

            讨论：
                 如果实现没有包括检测死网关和重新路由的充分机制，网关故障可能导致数据报似乎“消失”在“黑洞”中。这种故障可能会让用户感到非常困惑，也给网络维护人员带来调试上的困难。

                 死网关检测机制不得对主机、连接的网络或第一个跳跃网关造成不可接受的负载。关于死网关检测的及时性和可接受负载的具体限制，可能会根据主机的任务性质有所不同，但一般来说，主机需要足够快地检测到失败的第一个跳跃网关，以确保在选择备用网关之前，传输层连接不会中断。

                 从协议栈的其他层传递建议虽然会使层之间的接口变得复杂，但这是检测死网关的首选方法。建议可以来自IP/TCP架构的几乎任何部分，但主要应来自传输层和链路层。以下是一些可能提供网关建议的来源：

                 o    TCP或任何面向连接的传输协议应能够提供负面建议，例如，由于过多的重传而触发的建议。
```

- TCP 在确认（新）数据时可能会提供积极的建议。即使路由可能是非对称的，对新数据的确认（ACK）也证明已确认的数据一定已成功传输。

- 来自特定网关的 ICMP 重定向消息应被用作关于该网关的积极建议。

- 可靠检测并报告主机故障的链路层信息（例如，ARPANET 目的地失效消息）应被用作消极建议。

- 不能进行 ARP 或未能重新验证 ARP 映射可能被用作对应 IP 地址的消极建议。

- 来自特定链路层地址的包到达是该地址上的系统存活的证据。然而，将此信息转化为关于网关的建议需要将链路层地址映射到 IP 地址，然后检查该 IP 地址是否在路由缓存指向的网关中。这可能是极其低效的。

请注意，为每个接收的数据报提供积极建议可能会导致实现中的不可接受的开销。

虽然建议可以通过在所有接口中使用必需参数传递给 IP 层，但一些传输层和应用层协议无法推断出正确的建议。因此，这些接口必须允许一个中立的建议值，因为始终为正或始终为负的建议都会导致不正确的行为。

还有一种用于检测死网关的技术，虽然曾被广泛使用，但不推荐使用。

这种技术依赖于主机被动接收（“窃听”）网关之间广播的内部网关协议（IGP）数据报。这种方法的缺点是主机需要识别所有网关可能使用的内部网关协议（参见 [INTRO:2]）。此外，它仅在广播网络上有效。

目前，使用ICMP回显消息（即ping）作为网关探测的机制仅在绝对必要时采用。成功的ping可以保证被探测的接口及其关联的机器是在线的，但不能保证该机器是网关而非主机。通常的推断是，如果收到重定向消息或其他证据表明某台机器是网关，那么成功的ping会表明该机器仍然在线，因此仍然是网关。然而，由于主机会静默丢弃网关会转发或重定向的包，这一假设有时可能会失效。为了解决这个问题，正在开发一种新的ICMP消息，将询问“你是网关吗？”

实现方案：
建议采用以下具体算法：

- 为路由缓存中指向的每个网关关联一个“重定向定时器”。将该定时器初始化为一个值Tr，Tr必须足够小，以便在传输连接超时之前检测到死掉的网关。

- 积极的建议会将重定向定时器重置为Tr。消极的建议则会减少或归零该定时器。

- 每当IP层使用某个特定网关路由数据包时，它会检查对应的重定向定时器。如果定时器已到期（归零），IP层会向该网关发送一次ping，紧接着发送数据包。

- 如果有必要，ping（ICMP回显）会被重复发送最多N次。如果在N次尝试中都未收到ping应答，则假设该网关已失效，并为所有指向该失效网关的缓存条目选择新的第一跳网关。

注意，Tr的大小与可用建议的多少成反比。Tr应足够大，以确保：

* 任何ping操作都处于较低的包发送比例（例如，所有发往网关的包中，ping包占比少于10%），

* 以及ping的频率较低（例如，每3分钟一次）。

由于推荐的算法关注的是由路由缓存条目指向的网关，而不是缓存条本身，因此在实现路由缓存时，可能需要采用一种双层数据结构（或许与ARP或类似的缓存协同工作）会更为理想。

3.3.1.5 新网关的选择

如果失败的网关不是当前的默认网关，IP层可以立即切换到另一个默认网关。如果是当前的默认网关失败，IP层必须选择一个不同的默认网关（假设已知多个默认网关）来处理失败的路由以及建立新的路由。

讨论：
当一个网关失效时，连接网络上的其他网关会通过某种网关间的路由协议得知这一失效。然而，这并不是瞬时发生的，因为网关路由协议通常有30到60秒的收敛时间。如果主机在网关达成一致之前切换到备用网关，新的目标网关可能会将数据报转发到已失效的网关，并向主机发送重定向消息，指向已失效的网关（！）。这可能导致在网关收敛期间，主机的路由缓存内容迅速振荡。有人建议在死网关逻辑中加入一些滞后机制，以防止这种振荡，但经验表明，这种振荡并无害，因为在网关的路由信息稳定之前，服务无法恢复到主机。

实现：
一种选择新默认网关的实现方法是，简单地在主机的默认网关列表中轮询（轮换）。另一种方法是根据优先级对网关进行排序，当当前的默认网关不是优先级最高的时，逐个“ping”优先级更高的网关，以检测它们何时恢复服务。这种ping操作可以非常低频，例如每秒0.005次。

3.3.1.6 初始化

以下信息必须可配置：

（1）IP地址。

（2）地址掩码。

（3）默认网关列表，包含优先级。

必须提供一种手动输入此配置信息的方法。此外，还可以使用多种方法动态获取此信息；详见[INTRO:1]中的“主机初始化”部分。

讨论：
一些主机实现通过在广播网络上“窃听”网关协议，以了解存在的网关。用于默认网关发现的标准方法正在开发中。

3.3.2 重组

IP层必须实现IP数据报的重组。

我们将能被重组的最大数据报尺寸定义为EMTU_R（“接收的有效MTU”）；有时也称为“重组缓冲区大小”。EMTU_R必须大于或等于576，最好是可配置的或无限的，并且应大于或等于连接网络的MTU。

讨论：
不应在代码中硬编码固定的EMTU_R限制，因为某些应用层协议需要比576更大的EMTU_R值。

实现：
实现可以为每个数据报使用连续的重组缓冲区，或者使用更复杂的数据结构，不对重组数据报的大小设定明确限制；在后一种情况下，EMTU_R被称为“无限”。

逻辑上，重组通过将每个片段复制到包缓冲区的正确偏移位置来完成。注意，如果连续的重传使用不同的分段方式但具有相同的重组ID，片段可能会重叠。

重组的难点在于管理账目，以确定何时所有字节都已被重组。我们建议采用Clark算法[IP:10]，该算法不需要额外的空间来进行账目管理。然而，需注意，与[IP:10]相反，首个片段的头部信息需要保存，以便包含在可能的ICMP“超时重组”消息中。

必须有一种机制，使传输层能够了解MMS_R，即在IP数据报中可以接收和重组的最大消息尺寸（参见第3.4节中的GET_MAXSIZES调用）。如果EMTU_R不是无限的，则MMS_R的值由以下公式给出：

MMS_R = EMTU_R - 20

因为20是IP头部的最小尺寸。

必须设置重组超时。重组超时的值应为固定值，而不应根据剩余的TTL来设定。建议该值介于60秒到120秒之间。如果该超时到期，部分重组的IP数据报必须被丢弃，并向源主机发送一个ICMP“时间超时”消息（前提是已收到第零片）。

讨论：
IP规范指出，重组超时应为IP头中的剩余TTL，但实际上这种做法效果不佳，因为网关通常将TTL视为简单的跳数计数，而非经过的时间。如果重组超时设置得过短，数据报会被不必要地丢弃，可能导致通信失败。重组超时应至少等于互联网中典型的最大延迟。一个合理的最低值建议为60秒。

有人建议可以缓存传输协议对不同目的地测得的往返时间（RTT），并利用这些值动态确定合理的重组超时值。这一方法需要进一步研究。

如果重组超时设置得过长，接收主机的缓冲资源将被占用过久，最大段寿命（MSL）[TCP:1]也会变得比必要的更大。MSL控制使用不同的16位标识字段值时，碎片化数据报的最大传输速率；MSL越大，最大速率越低。TCP规范[TCP:1]随意设定MSL为2分钟，这为合理的重组超时值设定了上限。

3.3.3  分片

IP层可以选择性地实现一种机制，用于有意对传出的数据报进行分片。

我们用 EMTU_S（“有效发送MTU”）来表示在特定的IP源和目的地址组合（可能还包括TOS）下，允许发送的最大IP数据报尺寸。

主机必须实现一种机制，使传输层能够了解 MMS_S，即在给定的{源地址、目的地址、TOS}三元组下，允许发送的最大传输层消息大小（详见第3.4节中的GET_MAXSIZES调用）。如果没有进行本地分片，MMS_S的值将为：

   MMS_S = EMTU_S - <IP头部大小>

并且 EMTU_S 必须小于或等于对应数据报源地址的网络接口的 MTU。
请注意，公式中的 <IP 头部大小> 默认为 20，除非 IP 为了插入 IP 选项（用于自身目的）而预留空间，且除了传输层插入的选项之外。

未实现本地分片的主机必须确保传输层（对于 TCP）或应用层（对于 UDP）从 IP 层获取 MMS_S，并且不发送超过 MMS_S 大小的数据报。

通常应避免本地分片，并选择足够低的 EMTU_S，以避免路径中任何网关发生分片。在不知道路径上最小 MTU 的情况下，IP 层应在目标地址不在连接网络时使用 EMTU_S <= 576，否则应使用连接网络的 MTU。

每个物理接口的 MTU 必须可配置。

主机的 IP 层实现可以设置一个配置标志“所有子网的 MTU（All-Subnets-MTU）”，指示应使用连接网络的 MTU 来为同一网络内不同子网的目的地选择 MTU，但不适用于其他网络。因此，该标志会导致使用网络类别掩码（而非子网掩码）来选择 EMTU_S。对于多宿主（多网卡）主机，每个网络接口都需要设置“所有子网的 MTU”标志。

讨论：
选择合适的数据报大小以发送数据是一个复杂的话题 [IP:9]。

(a) 一般而言，没有主机被要求接受超过 576 字节（包括头部和数据）的 IP 数据报，因此，主机不得在没有明确了解或事先与目的地主机达成协议的情况下，发送更大的数据报。因此，MMS_S 只是传输协议可以发送的数据报最大尺寸的上限；即使 MMS_S 超过 556，在没有关于目的地主机的其他信息时，传输层也必须将其消息限制在 556 字节以内。

(b) 一些传输协议（如 TCP）提供一种机制，明确通知发送方对端可以接收和重组的最大数据报大小 [IP:7]。而在 IP 层没有对应的机制。

一种假设其EMTU_R大于576（见第3.3.2节）的传输协议，可以向实现相同协议的另一台主机发送更大尺寸的数据报。

(c) 主机理想情况下应将其针对特定目的地的EMTU_S限制在路径上所有网络的最小MTU，以避免任何分段。虽然IP分段在形式上是正确的，但可能会引发严重的传输协议性能问题，因为丢失单个分段意味着必须重传该段中的所有分段[IP:9]。

由于目前几乎所有互联网网络都支持576或更大的MTU，我们强烈建议对发送到非本地网络的数据报采用576的MTU。

有人建议，主机可以通过发送一个偏移为零的数据报分段，并等待接收方超时重组（无法完成！）并返回一个ICMP“超时”消息，来确定路径上的MTU。该消息的正文中会包含最大剩余分段的头部信息。更直接的机制正在试验中，但尚未被采用（参见例如RFC-1063）。

3.3.4 本地多宿（Multihoming）

3.3.4.1 引言

多宿主（multihomed）主机拥有多个IP地址，我们可以将其视为“逻辑接口”。这些逻辑接口可能与一个或多个物理接口相关联，而这些物理接口可能连接到相同或不同的网络。

以下是一些多宿主的重要情况：

(a) 多个逻辑网络

互联网架构师设想每个物理网络应拥有唯一的IP网络（或子网）编号。然而，局域网管理员有时发现违反这一假设是有用的，即在一个物理连接的网络上运行多个逻辑网络。

如果连接到这样一个物理网络的主机被配置为处理N个不同逻辑网络的流量，那么该主机将拥有N个逻辑接口。这些接口可以共享一个物理接口，或者使用N个物理接口连接到同一网络。

(b) 多个逻辑主机

当一个主机拥有多个IP地址，并且这些地址的<网络号>部分（以及（如果有的话）<子网号>部分）都相同时，这些逻辑接口被称为“逻辑主机”。这些逻辑接口可能共享一个物理接口，也可能使用不同的物理接口连接到同一物理网络。

(c) 简单多宿（Multihoming）

在这种情况下，每个逻辑接口映射到一个单独的物理接口，并且每个物理接口连接到不同的物理网络。“多宿”这个术语最初仅用于这种情况，但现在已被更广泛地应用。

具有嵌入式网关功能的主机通常属于简单多宿的情况。然而，需要注意的是，主机可以是纯粹的多宿（即拥有多个IP地址）而没有嵌入式网关，也就是说，它没有将数据报从一个连接的网络转发到另一个网络。

这种情况带来了最复杂的路由问题。接口的选择（即选择第一个跳跃的网络）可能会显著影响性能，甚至影响到远程互联网部分的可达性。

最后，我们还要指出一种非多宿的可能性：一个逻辑接口可以绑定到多个物理接口上，以通过提供备用的物理路径，增加直接连接的机器之间的可靠性或吞吐量。例如，两个系统可能通过多条点对点链路相连。我们称之为“链路层多路复用”。通过链路层多路复用，上层协议（即链路层之上的协议）并不知道存在多个物理接口；链路层设备驱动程序负责在物理接口之间进行多路复用和数据包路由。

在互联网协议架构中，一个传输协议实例（“实体”）没有自己的地址，而是使用单一的互联网协议（IP）地址。这对IP层、传输层和应用层，以及它们之间的接口产生了影响。特别是，应用软件可能需要知道多宿主机的多个IP地址；在其他情况下，地址的选择可以由网络软件来决定。

以下关于为多宿主主机选择IP源地址的通用规则适用：

（1）如果数据报是对接收到的数据报的响应，则应将响应的源地址设为请求的特定目标地址。有关更具体的高层要求，请参见第4.1.3.5节、第4.2.3.7节以及[INTRO:1]中的“常规问题”部分。

否则，必须选择一个源地址。

（2）应用程序必须能够明确指定用于发起连接或请求的源地址。

（3）在没有此类明确指定的情况下，网络软件必须选择一个源地址。关于此选择的规则将在下文描述。

与多宿主相关的两个关键需求问题是：

（A）主机可以默默丢弃目的地址与接收该数据报的物理接口不对应的入站数据报。

（B）主机可以限制自己仅通过与数据报的IP源地址对应的物理接口发送（非源路由的）IP数据报。

讨论：
互联网主机的实现者在多宿主模型方面采用了两种不同的概念模型，简要总结如下。本文件不对哪种模型更优作出立场表态；每种模型似乎都有其适用之处。这种模糊性也体现在（A）和（B）两个问题是可选的。

o 强ES模型

强ES（端系统，即主机）模型强调主机/网关（ES/IS）之间的区别，因此在上述（A）和（B）问题中应将“可能”替换为“必须”。该模型倾向于将多宿主主机建模为同一物理主机内的一组逻辑主机。

关于（A），支持强ES模型的观点指出，自动的互联网路由机制无法将数据报路由到与目的地址不对应的物理接口。

在强ES模型下，出站数据报的路由计算是如下映射关系：

   route（源IP地址，目的IP地址，TOS） -> 网关

这里将源地址作为参数包含在内，目的是选择一个在相应物理接口上可以直接到达的网关。注意，该模型在逻辑上要求每个IP源地址通常至少有一个默认网关，最好有多个默认网关。

- 弱ES模型

该视图淡化了ES/IS的区别，因此在（A）和（B）问题中应使用“绝不允许（MUST NOT）”而非“可能（MAY）”。这种模型对于监听网关路由协议的主机可能更自然，也对于具有嵌入式网关功能的主机是必要的。

弱ES模型可能导致重定向机制失效。如果数据报通过一个与目的地址不对应的物理接口发出，第一跳网关将无法意识到需要发送重定向。另一方面，如果主机具有嵌入式网关功能，则它拥有路由信息，无需监听重定向。

在弱ES模型中，出站数据报的路由计算是如下映射关系：

   route（目的IP地址，TOS） -> 网关，接口

(a) 如果远程互联网地址位于主机直接连接的某个（子）网内，可以选择相应的源地址，除非已知对应的接口已关闭。

(b) 可以查阅路由缓存，查看是否存在通向指定目标网络的活动路由，通过任何网络接口；如果存在，可以选择与该接口对应的本地IP地址。

(c) 也可以查阅静态路由表（参见第3.3.1.2节），进行类似的查询。

(d) 可以咨询默认网关。如果这些网关被分配到不同的接口，则可以选择与优先级最高的网关对应的接口。

将来，可能会制定一种方式，使多宿主主机能够向所有连接网络的网关请求建议，以确定用于特定目的地的最佳网络。

实现说明：
需要注意的是，这一过程本质上与数据报路由（见第3.3.1节）相同，因此主机可能能够结合实现这两项功能。

3.3.5 源路由转发

在满足以下限制的前提下，主机可以作为源路由中的中间跳点，将源路由数据报转发到下一个指定的跳点。

然而，在执行此类网关般的功能时，主机必须遵守所有关于源路由数据报转发的相关规则[引言：2]。这些规则包括以下具体条款，优先于本文前面给出的主机相关规定：

(A) TTL（参见第3.2.1.7节）

TTL字段必须递减，并且如[引言：2]中所述，可能会因此丢弃数据报。

(B) ICMP目的地不可达（参见第3.2.2.1节）

主机必须能够生成带有以下代码的目的地不可达消息：

4（需要分片但DF（不要分片）位已设置）——当源路由数据报无法分片以适应目标网络时。

当源路由数据报无法转发时（例如由于路由问题或严格源路由的下一跳不在连接网络上），会产生“源路由失败” (Source Route Failed) 的错误代码 5。

（C）IP源地址（参见第3.2.1.3节）

被转发的源路由数据报可能（通常也会）具有一个不属于转发主机的IP地址作为源地址。

（D）记录路由选项（参见第3.2.1.8d节）

转发包含记录路由选项的源路由数据报的主机，必须（如果有空间的话）更新该选项。

（E）时间戳选项（参见第3.2.1.8e节）

转发包含时间戳选项的源路由数据报的主机，必须根据该选项的规则，将当前时间戳添加到该选项中。

为了定义限制主机转发源路由数据报的规则，我们使用“本地源路由”一词，指下一跳通过与数据报到达时相同的物理接口；否则，称为“非本地源路由”。

- 主机被允许无限制地执行本地源路由。

- 支持非本地源路由的主机，必须配备一个可配置的开关以禁用转发，并且该开关的默认状态必须为禁用。

- 主机必须满足所有网关的政策过滤器（参考引言第2节）要求，以限制非本地转发。

如果主机收到一个源路由不完整的数据报，但由于某种原因未进行转发，除非该数据报本身是一个ICMP错误消息，否则主机应返回一个ICMP目的地不可达（代码5，源路由失败）消息。

3.3.6 广播

第3.2.1.3节定义了四种标准的IP广播地址形式：

- 有限广播：{-1, -1}

- 定向广播：{<网络号>, -1}

- 子网定向广播：{<网络号>, <子网号>, -1}

- 所有子网定向广播：{<网络号>, -1, -1}

主机必须识别任何这些形式的目标地址。

还有一类主机*，使用非标准的广播地址形式，用0代替-1。所有主机都应遵循此规定。

_________________________
*4.2BSD Unix及其派生版本，但不包括4.3BSD。

互联网工程任务组                                [第66页]





RFC1122                      互联网层                 1989年10月


         识别并接受任何这些非标准的广播地址作为传入数据报的目标地址。
         主机可以选择为每个物理接口配置一个选项，以选择
         0或-1形式的广播地址，但此选项应默认为标准的（-1）形式。

         当主机向链路层广播地址发送数据报时，
         IP目标地址必须是合法的IP广播地址或IP多播地址。

         主机应静默丢弃通过链路层广播（参见第2.4节）接收的
         但未指定IP多播或广播目标地址的数据报。

         主机应使用有限广播地址在连接的网络上进行广播。


         讨论：
              使用有限广播地址而非定向广播地址可能会提高系统的鲁棒性。
              问题通常由不理解大量广播地址（参见第3.2.1.3节）或
              对哪些广播地址在使用中有不同理解的机器引起。 
              后者的典型例子是那些不理解子网划分但连接到子网的机器。
              向连接的网络发送子网广播会使这些机器感到困惑，
              它们会将其视为发给其他主机的消息。

              关于是否应从多宿主机的所有接口发送指向有限广播地址的数据报，
              这一问题曾有讨论。本规范对此不作规定。

      3.3.7  IP多播

         主机应支持所有连接网络上的本地IP多播，只要已为
         类DIP地址到链路层地址的映射进行了规定（见下文）。
         支持本地IP多播包括发送多播数据报、加入多播组、
         接收多播数据报以及离开多播组。这意味着支持
         [IP:4]中的所有功能，除了IGMP协议本身（该协议为可选）。

讨论：
IGMP（Internet组管理协议）提供了能够进行多播路由的网关，这些网关具备支持跨多个网络进行IP多播所需的信息。目前，多播路由网关仍处于试验阶段，尚未广泛普及。对于那些未连接到具有多播路由网关的网络，或不需要接收来自其他网络的多播数据报的主机，IGMP没有任何作用，因此暂时是可选的。然而，[IP:4]的其他部分目前建议用于提供IP层对本地网络多播地址的访问，作为本地广播地址的优选替代方案。预计在未来某个时间点，当多播路由网关变得更加普及时，IGMP将被推荐使用。

如果未实现IGMP，主机仍应在IP层初始化时加入“所有主机”组（224.0.0.1），并在IP层活动期间保持其成员身份。

讨论：
加入“所有主机”组将支持多播的严格本地用途，例如网关发现协议，即使未实现IGMP。

IP类别D地址映射到本地地址的规则目前适用于以下类型的网络：

- 以太网/IEEE 802.3，如[IP:4]中定义的。
- 支持广播但不支持多播的任何网络：所有IP类别D地址都映射到本地广播地址。
- 任何点对点链路（例如SLIP或HDLC链路）：无需映射，所有IP多播数据报直接以原样在本地帧中发送。

其他类型网络的映射规则将在未来制定。

主机应提供一种机制，使更高层协议或应用程序能够确定其连接的网络是否支持IP多播地址。

互联网工程任务组（IETF）第1122号请求评论（RFC）文件，标题为“互联网层”，于1989年10月发布。

3.3.8 错误报告
在实际操作中，主机必须在检测到错误时返回ICMP错误数据报，除非在某些特定情况下明确禁止返回ICMP错误消息。

讨论：
在数据报网络中，一个常见现象是“黑洞病”：数据报被发送出去，但没有任何反馈返回。没有错误数据报的情况下，用户很难判断问题所在。

3.4 互联网/传输层接口

传输层与IP层之间的接口必须提供对IP层所有机制的完全访问，包括选项、服务类型（Type-of-Service）和生存时间（Time-to-Live）。传输层必须具备设置这些接口参数的机制，或者提供一种从应用程序传递参数的路径，或两者兼备。

讨论：
鼓励应用程序在适用的情况下使用这些机制，即使这些机制在当前互联网中尚未生效（例如，TOS）。这样，当这些机制变得有效时，它们可以立即发挥作用，而无需对主机软件进行大量的改造。

我们现在描述传输层与IP层之间的概念性接口，作为一组过程调用。这是对RFC-791第3.3节中信息的扩展[IP:1]。

* 发送数据报

  SEND(src, dst, prot, TOS, TTL, BufPTR, len, Id, DF, opt => result)

  其中参数定义见RFC-791。传递Id参数是可选的；详见第3.2.1.5节。

* 接收数据报

  RECV(BufPTR, prot => result, src, dst, SpecDest, TOS, len, opt)

所有参数均在RFC-791中定义，除了：

SpecDest = 数据报的特定目的地址（定义在第3.2.1.3节）

结果参数dst包含数据报的目的地址。由于这可能是广播或多播地址，必须传递SpecDest参数（在RFC-791中未显示）。参数opt包含在数据报中接收到的所有IP选项，这些也必须传递给传输层。

* 选择源地址

  GET_SRCADDR(remote, TOS) -> local

  remote = 远程IP地址
  TOS = 服务类型
  local = 本地IP地址

  详见第3.3.4.3节。

* 查找最大数据报尺寸

  GET_MAXSIZES(local, remote, TOS) -> MMS_R, MMS_S

  MMS_R = 最大接收传输消息尺寸
  MMS_S = 最大发送传输消息尺寸
  （local、remote、TOS定义如上）

  详见第3.3.2节和第3.3.3节。

* 关于传递成功的建议

  ADVISE_DELIVPROB(sense, local, remote, TOS)

这里，参数 sense 是一个1位的标志，用于指示是提供正面建议还是负面建议；详见第3.3.1.4节的讨论。其他参数在前文已定义。

* 发送ICMP消息

  SEND_ICMP(src, dst, TOS, TTL, BufPTR, len, Id, DF, opt)
  -> 结果

（参数定义见RFC-791）

传递一个Id参数是可选的；详见第3.2.1.5节。传输层必须能够发送某些ICMP消息：端口不可达或任何查询类型的消息。当然，这个功能可以被视为SEND()调用的一个特殊情况；为了清晰起见，我们单独描述它。

* 接收ICMP消息

  RECV_ICMP(BufPTR) -> 结果、源地址、目标地址、长度、选项

（参数定义见RFC-791）

IP层必须将某些ICMP消息传递给相应的传输层例程。当然，这个功能可以被视为RECV()调用的一个特殊情况；为了清晰起见，我们单独描述它。

对于ICMP错误消息，传递上来的数据必须包括原始的Internet头部以及ICMP消息中包含的所有原始消息的八位字节。这些数据将被传输层用来定位连接状态信息（如果有的话）。

特别是，以下ICMP消息应被传递上去：

- 目的地不可达
- 源抑制
- 回显应答（对ICMP用户界面，除非回显请求起源于IP层）
- 时间戳应答（对ICMP用户界面）
- 超时

讨论：
未来，可能会在此接口中添加传递路径数据（参见第3.3.1.3节）以在IP层和传输层之间进行通信。

---

互联网工程任务组（Internet Engineering Task Force） [第71页]

RFC1122 互联网层 1989年10月

3.5 互联网层需求总结

以下是英文内容的中文翻译：

```
                                                 |        | | | |S| |
                                                 |        | | | |H| |F
                                                 |        | | | |O|M|o
                                                 |        | |S| |U|U|o
                                                 |        | |H| |L|S|t
                                                 |        |M|O| |D|T|n
                                                 |        |U|U|M| | |o
                                                 |        |S|L|A|N|N|t
                                                 |        |T|D|Y|O|O|t
功能                                              |章节    | | | |T|T|e
-------------------------------------------------|--------|-|-|-|-|-|--
                                                 |        | | | | | |
实现IP和ICMP                                    |3.1     |x| | | | |
在应用层处理远程多宿主                        |3.1     |x| | | | |
支持本地多宿主                                |3.1     | | |x| | |
满足网关规范（转发数据报）                     |3.1     |x| | | | |
嵌入式网关的配置开关                          |3.1     |x| | | | |1
   配置开关默认非网关                          |3.1     |x| | | | |1
   根据接口数量自动配置                        |3.1     | | | | |x|1
能够记录丢弃的数据报                          |3.1     | |x| | | |
   以计数器记录                                |3.1     | |x| | | |
                                                 |        | | | | | |
静默丢弃版本不等于4的IP数据报                  |3.2.1.1 |x| | | | |
验证IP校验和，静默丢弃错误的数据报            |3.2.1.2 |x| | | | |
地址相关：                                      |        | | | | | |
  子网地址（RFC-950）                            |3.2.1.3 |x| | | | |
  源地址必须是主机的IP地址                      |3.2.1.3 |x| | | | |
  静默丢弃目的地址错误的数据报                  |3.2.1.3 |x| | | | |
  静默丢弃源地址错误的数据报                      |3.2.1.3 |x| | | | |
支持数据报重组                                |3.2.1.4 |x| | | | |
在相同数据报中保持相同的ID字段                  |3.2.1.5 | | |x| | |
                                                 |        | | | | | |
服务类型（TOS）：                                |        | | | | | |
  允许传输层设置TOS                              |3.2.1.6 |x| | | | |
  将接收到的TOS传递给传输层                      |3.2.1.6 | |x| | | |
  使用RFC-795定义的链路层映射TOS                  |3.2.1.6 | | | |x| |
生存时间（TTL）：                                |        | | | | | |
  发送TTL为0的包                                |3.2.1.7 | | | | |x|
  丢弃TTL小于2的接收包                          |3.2.1.7 | | | | |x|
  允许传输层设置TTL                              |3.2.1.7 |x| | | | |
  固定TTL可配置                                  |3.2.1.7 |x| | | | |
                                                 |        | | | | | |
IP选项：                                         |        | | | | | |
```

允许传输层发送IP选项       |3.2.1.8 |x| | | | |
将所有接收的IP选项传递给更高层       |3.2.1.8 |x| | | | |

互联网工程任务组                                [第72页]

RFC1122                      互联网层                     1989年10月

IP层静默忽略未知选项       |3.2.1.8 |x| | | | |
安全选项                                |3.2.1.8a| | |x| | |
发送流标识符选项                        |3.2.1.8b| | | |x| |
静默忽略流标识符选项                    |3.2.1.8b|x| | | | |
记录路由选项                            |3.2.1.8d| | |x| | |
时间戳选项                              |3.2.1.8e| | |x| | |
源路由选项：                            |        | | | | | |
  发起和终止源路由选项                    |3.2.1.8c|x| | | | |
 携带完整源路由的数据报传递到传输层      |3.2.1.8c|x| | | | |
 构建正确（非冗余）返回路由              |3.2.1.8c|x| | | | |
 在一个头部中发送多个源路由选项          |3.2.1.8c| | | | |x|
                                                 |        | | | | | |
ICMP：                                       |        | | | | | |
  静默丢弃未知类型的ICMP消息               |3.2.2   |x| | | | |
  包含超过8个八位组的原始数据报             |3.2.2   | | |x| | |
      包含的八位组与接收时相同               |3.2.2   |x| | | | |
  将ICMP错误消息解复用到传输协议            |3.2.2   |x| | | | |
  以TOS=0发送ICMP错误消息                   |3.2.2   | |x| | | |
  发送ICMP错误消息包括：                     |        | | | | | |
   - ICMP错误消息                            |3.2.2   | | | | |x|
   - IP广播或多播                          |3.2.2   | | | | |x|
   - 链路层广播                            |3.2.2   | | | | |x|
   - 非初始片段                            |3.2.2   | | | | |x|
   - 源地址非唯一的数据报                    |3.2.2   | | | | |x|
  返回ICMP错误消息（非禁止时）               |3.3.8   |x| | | | |
                                                 |        | | | | | |
  不可达目的地：                            |        | | | | | |
    生成不可达目的地（代码2/3）               |3.2.2.1 | |x| | | |
    将ICMP不可达目的地传递到上层               |3.2.2.1 |x| | | | |
    上层对不可达目的地的处理                   |3.2.2.1 | |x| | | |
      将不可达目的地仅作为提示解读             |3.2.2.1 |x| | | | |
  重定向：                                   |        | | | | | |
    主机发送重定向                           |3.2.2.2 | | | |x| |
    接收重定向时更新路由缓存                   |3.2.2.2 |x| | | | |
    处理主机和网络重定向                     |3.2.2.2 |x| | | | |
    丢弃非法重定向                           |3.2.2.2 | |x| | | |
  源抑制：                                   |        | | | | | |
    如果缓冲区溢出则发送源抑制消息             |3.2.2.3 | | |x| | |
    将源抑制传递到上层                       |3.2.2.3 |x| | | | |
    上层对源抑制的处理                       |3.2.2.3 | |x| | | |
  超时：传递到上层                          |3.2.2.4 |x| | | | |
  参数问题：                                |        | | | | | |
    发送参数问题消息                         |3.2.2.5 | | | | | |

```
 |x| | | |
    将参数问题传递给上层                     |3.2.2.5 |x| | | | |
    向用户报告参数问题                       |3.2.2.5 | | |x| | |
                                                 |        | | | | | |
  ICMP回显请求或应答：                        |        | | | | | |
    回显服务器和回显客户端                     |3.2.2.6 |x| | | | |
```

互联网工程任务组                                [第73页]

RFC1122                      互联网层                     1989年10月

回显客户端                                  |3.2.2.6 | |x| | | |
丢弃广播地址的回显请求                        |3.2.2.6 | | |x| | |
丢弃多播地址的回显请求                        |3.2.2.6 | | |x| | |
使用特定目的地址作为回显应答的源地址          |3.2.2.6 |x| | | | |
在回显应答中发送相同的数据                      |3.2.2.6 |x| | | | |
将回显应答传递到更高层                        |3.2.2.6 |x| | | | |
反射记录路由、时间戳选项                      |3.2.2.6 | |x| | | |
反转并反射源路由选项                          |3.2.2.6 |x| | | | |
                                                 |        | | | | | |
ICMP信息请求或应答：                            |3.2.2.7 | | | |x| |
ICMP时间戳和时间戳应答：                        |3.2.2.8 | | |x| | |
最小化延迟变化                                |3.2.2.8 | |x| | | |1
静默丢弃广播时间戳                            |3.2.2.8 | | |x| | |1
静默丢弃多播时间戳                            |3.2.2.8 | | |x| | |1
使用特定目的地址作为时间戳应答的源地址        |3.2.2.8 |x| | | | |1
反射记录路由、时间戳选项                      |3.2.2.6 | |x| | | |1
反转并反射源路由选项                          |3.2.2.8 |x| | | | |1
将时间戳应答传递到更高层                      |3.2.2.8 |x| | | | |1
遵守“标准值”的规则                            |3.2.2.8 |x| | | | |1
                                                 |        | | | | | |
ICMP地址掩码请求和应答：                        |        | | | | | |
地址掩码源可配置                                |3.2.2.9 |x| | | | |
支持地址掩码的静态配置                          |3.2.2.9 |x| | | | |
在启动过程中动态获取地址掩码                    |3.2.2.9 | | |x| | |
通过ICMP地址掩码请求/应答获取地址               |3.2.2.9 | | |x| | |
如果无应答，则重传地址掩码请求                  |3.2.2.9 |x| | | | |3
无应答时假设默认掩码                          |3.2.2.9 | |x| | | |3
仅从第一个应答中更新地址掩码                    |3.2.2.9 |x| | | | |3
对地址掩码进行合理性检查                        |3.2.2.9 | |x| | | |
发送未授权的地址掩码应答消息                    |3.2.2.9 | | | | |x|
明确配置为代理的地址掩码应答                     |3.2.2.9 |x| | | | |
静态配置=>地址掩码权威标志                     |3.2.2.9 | |x| | | |
初始化时广播地址掩码应答                        |3.2.2.9 |x| | | | |3
                                                 |        | | | | | |
路由出站数据报：                                |        | | | | | |
使用地址掩码进行本地/远程决策                    |3.3.1.1 |x| | | | |
在没有网关的连接网络上操作                      |3.3.1.1 |x| | | | |
维护“路由缓存”中的下一跳网关                  |3.3.1.2 |x| | | | |
将主机重定向和网络重定向视为相同                |3.3.1.2 | |x| | | |
如果没有缓存条目，则使用默认网关                |3.3.1.2 |x| | | | |
支持多个默认网关                                |3.3.1.2 |x| | | | |
提供静态路由表                                |3.3.1.2 | | |x| | |
  标志：路由可被重定向覆盖

```
  |3.3.1.2 | | |x| | |
  主机上的关键路由缓存，而非网络地址       |3.3.1.3 | | |x| | |
  在路由缓存中包含服务类型（TOS）             |3.3.1.3 | |x| | | |
                                                 |        | | | | | |
  能够检测到下一跳网关的故障                   |3.3.1.4 |x| | | | |
  假设路由永远有效                              |3.3.1.4 | | | |x| |
```

互联网工程任务组                                [第74页]

RFC1122                      互联网层                     1989年10月

持续对网关进行Ping                     |3.3.1.4 | | | | |x|
仅在有流量发送时进行Ping               |3.3.1.4 |x| | | | |
仅在没有正面指示时进行Ping             |3.3.1.4 |x| | | | |
高层和低层提供建议                     |3.3.1.4 | |x| | | |
从失败的默认网关切换到另一个             |3.3.1.5 |x| | | | |
手动输入配置信息的方法                   |3.3.1.6 |x| | | | |
                                             |        | | | | | |
重组与分段：                              |        | | | | | |
能够重组传入的数据报                     |3.3.2   |x| | | | |
  至少576字节的数据报                     |3.3.2   |x| | | | |
  EMTU_R可配置或无限                     |3.3.2   | |x| | | |
传输层能够学习MMS_R                       |3.3.2   |x| | | | |
在重组超时时发送ICMP“时间超出”消息     |3.3.2   |x| | | | |
  固定的重组超时时间                       |3.3.2   | |x| | | |
                                             |        | | | | | |
将MMS_S传递给更高层                        |3.3.3   |x| | | | |
本地对外发包进行分段                       |3.3.3   | | |x| | |
  否则不发送大于MMS_S的数据包             |3.3.3   |x| | | | |
向非网内目的地发送最大576字节的数据     |3.3.3   | |x| | | |
所有子网MTU配置标志                        |3.3.3   | | |x| | |
                                             |        | | | | | |
多宿主：                                   |        | | | | | |
  使用与目标地址相同的地址作为应答地址     |3.3.4.2 | |x| | | |
  允许应用选择本地IP地址                   |3.3.4.2 |x| | | | |
  在“错误”接口静默丢弃数据报               |3.3.4.2 | | |x| | |
  仅通过“正确”接口发送数据报               |3.3.4.2 | | |x| | |4
                                             |        | | | | | |
源路由转发：                               |        | | | | | |
  转发带有源路由选项的数据报                |3.3.5   | | |x| | |1
    遵守相应的网关规则                     |3.3.5   |x| | | | |1
      按网关规则更新TTL                     |3.3.5   |x| | | | |1
      能生成ICMP错误代码4、5                |3.3.5   |x| | | | |1
      IP源地址不是本地主机                   |3.3.5   | | |x| | |1
      更新时间戳、记录路由选项               |3.3.5   |x| | | | |1
  配置开关以支持非本地源路由                |3.3.5   |x| | | | |1
    默认为关闭                              |3.3.5   |x| | | | |1
  满足网关访问规则以支持非本地源路由       |3.3.5   |x| | | | |1
  若不转发，则发送目的地不可达（代码5）     |3.3.5   | |x| | | |2
                                             |        | | | | | |
广播：                                     |        | | | | | |
  使用IP源地址作为广播地址                 |3.2.1.3 | | | | |x|
  接收0或-1广播格式正常                     |3.3.6   | |x| | | |
  可配置选项以发送0或-1广播                |

|3.3.6   | | |x| | |  
默认使用 -1 进行广播                     |3.3.6   | |x| | |  
识别所有广播地址格式                     |3.3.6   |x| | | |  
在链路层广播中使用 IP 广播/多播地址     |3.3.6   |x| | | |  
静默丢弃仅在链路层的广播数据包         |3.3.6   | |x| | |  
对已连接网络使用有限广播地址             |3.3.6   | |x| | |

互联网工程任务组                                [第75页]





RFC1122                      互联网层                 1989年10月


                                                 |        | | | | | |
多播：                                       |        | | | | | |
  支持本地IP多播（RFC-1112）                     |3.3.7   | |x| | | |
  支持IGMP（RFC-1112）                            |3.3.7   | | |x| | |
  启动时加入所有主机组                          |3.3.7   | |x| | | |
  高层协议了解接口多播能力                        |3.3.7   | |x| | | |
                                                 |        | | | | | |
接口：                                           |        | | | | | |
  允许传输层使用所有IP机制                        |3.4     |x| | | | |
  将接口标识传递给传输层                          |3.4     |x| | | | |
  将所有IP选项传递给传输层                        |3.4     |x| | | | |
  传输层可以发送某些ICMP消息                        |3.4     |x| | | | |
  将特定的ICMP消息传递给传输层                      |3.4     |x| | | | |
     包含IP头+原始数据的8个字节或更多               |3.4     |x| | | | |
  能够一跃而上，跨越高楼大厦                        |3.5     | |x| | | |

脚注：

(1)  仅在功能已实现的情况下。

(2)  如果数据报是ICMP错误消息，则此要求被推翻。

(3)  仅在功能已实现且已配置为“开启”的情况下。

(4)  除非具有嵌入式网关功能或是源路由。


























互联网工程任务组                                [第76页]





RFC1122                  传输层——UDP             1989年10月


4. 传输协议

   4.1  用户数据报协议——UDP

      4.1.1  引言

         用户数据报协议UDP [UDP:1]仅提供最基本的传输服务——非保证的数据报传递——并允许应用程序直接访问IP层的数据报服务。UDP被用于那些不需要TCP服务水平或希望使用TCP未提供的通信服务（如多播或广播传递）的应用。

         UDP几乎是一个空协议；它在IP之上的唯一服务是数据校验和和端口号多路复用。因此，运行在UDP之上的应用程序必须直接处理端到端的通信问题——比如，为了可靠传输的重传、数据包的分段与重组、流量控制、拥塞避免等——这些本应由面向连接的协议处理。IP与TCP之间相对复杂的耦合关系，也将在UDP与许多使用UDP的应用之间得到体现。

      4.1.2  协议流程

         UDP的规范中没有已知的错误。

      4.1.3  具体问题

         4.1.3.1  端口

UDP知名端口遵循与TCP知名端口相同的规则；详见下文第4.2.2.1节。

如果一个数据报到达一个没有挂起监听（LISTEN）调用的UDP端口，UDP应当发送一个ICMP端口不可达（Port Unreachable）消息。

4.1.3.2 IP选项

UDP必须透明地将其从IP层接收到的任何IP选项传递给应用层。

应用程序必须能够指定在其UDP数据报中要发送的IP选项，UDP必须将这些选项传递给IP层。

互联网工程任务组（Internet Engineering Task Force）[第77页]

RFC1122 传输层——UDP 1989年10月

讨论：
目前，只有源路由（Source Route）、记录路由（Record Route）和时间戳（Time Stamp）这几种选项需要通过UDP传递。然而，未来可能会定义新的选项，UDP无需也不应对其传递的选项的格式或内容做任何假设；唯一的例外可能是IP层的安全选项。

基于UDP的应用程序需要从请求数据报中获取源路由信息，并在发送相应的应答时提供反向路由。

4.1.3.3 ICMP消息

UDP必须将从IP层接收到的所有ICMP错误消息传递给应用层。至少在概念上，这可以通过调用ERROR_REPORT例程（见第4.2.4.1节）实现。

讨论：
请注意，由发送UDP数据报引发的ICMP错误消息是异步接收的。希望接收ICMP错误消息的基于UDP的应用程序，负责维护必要的状态以在这些消息到达时进行多路复用；例如，应用程序可以为此目的保持一个挂起的接收操作。应用程序还应避免因早前使用相同端口而导致的延迟ICMP错误消息引起的混淆。

4.1.3.4 UDP校验和

主机必须实现生成和验证UDP校验和的功能。应用程序可以选择性地控制是否生成UDP校验和，但默认必须启用校验和功能。

如果接收到的UDP数据报的校验和非零且无效，UDP必须默默地丢弃该数据报。应用程序可以选择控制是否应丢弃没有校验和的UDP数据报，还是将其传递给应用层。

讨论：
一些通常只在局域网中运行的应用程序为了提高效率，选择关闭UDP校验和。因此，出现了许多未被检测到的错误案例。是否应关闭UDP校验和，这个问题具有很大的争议。

实现：
在UDP校验和的实现中存在一个常见错误。与TCP校验和不同，UDP校验和是可选的；在UDP头的校验和字段中传输值零表示没有校验和。如果发射端确实计算出校验和为零，它必须将校验和字段设置为全1（65535）。接收端无需特殊处理，因为在1的补码运算中，零和65535是等价的。

4.1.3.5 UDP多宿（Multihoming）

当接收到一个UDP数据报时，其特定目的地址必须传递给应用层。

应用程序必须能够指定用于发送UDP数据报的IP源地址，或者不指定（此时网络软件将选择一个合适的源地址）。应有一种方式将所选的源地址传递给应用层（例如，以便应用程序之后只从对应的接口接收回复数据报）。

讨论：
使用UDP的请求/响应应用程序应使用与请求的特定目的地址相同的源地址作为响应地址。详见[INTRO:1]中的“常规问题”部分。

4.1.3.6 无效地址

接收到带有无效IP源地址（例如广播地址或多播地址）的UDP数据报时，必须由UDP或IP层（见第3.2.1.3节）将其丢弃。

当主机发送UDP数据报时，源地址必须是该主机的（一个或多个）IP地址。

应用程序界面到UDP必须提供本文件第3.4节所描述的IP/传输接口的全部服务。因此，使用UDP的应用程序需要具备第3.4节中描述的GET_SRCADDR()、GET_MAXSIZES()、ADVISE_DELIVPROB()和RECV_ICMP()调用的功能。例如，GET_MAXSIZES()可以用来了解特定{接口、远程主机、TOS}三元组的有效最大UDP数据报大小。

应用层程序必须能够设置TTL和TOS值，以及用于发送UDP数据报的IP选项，这些值必须透明地传递给IP层。UDP还可以将接收到的TOS值传递给应用层。

4.1.5 UDP的需求总结

以下是英文内容的中文翻译：

```

                                                 |        | | | |S| |
                                                 |        | | | |H| |F
                                                 |        | | | |O|M|o
                                                 |        | |S| |U|U|o
                                                 |        | |H| |L|S|t
                                                 |        |M|O| |D|T|n
                                                 |        |U|U|M| | |o
                                                 |        |S|L|A|N|N|t
                                                 |        |T|D|Y|O|O|t
功能                                              |章节    | | | |T|T|e
-------------------------------------------------|--------|-|-|-|-|-|--
                                                 |        | | | | | |
    UDP                                          |        | | | | | |
-------------------------------------------------|--------|-|-|-|-|-|--
                                                 |        | | | | | |
UDP 发送端口不可达                                |4.1.3.1 | |x| | | |
                                                 |        | | | | | |
IP 选项在UDP中的处理                              |        | | | | | |
 - 将接收的IP选项传递给应用层                      |4.1.3.2 |x| | | | |
 - 应用层可以在发送时指定IP选项                     |4.1.3.2 |x| | | | |
 - UDP将IP选项传递到IP层                          |4.1.3.2 |x| | | | |
                                                 |        | | | | | |
将ICMP消息传递给应用层                            |4.1.3.3 |x| | | | |
                                                 |        | | | | | |
UDP校验和：                                       |        | | | | | |
 - 能够生成和检查校验和                            |4.1.3.4 |x| | | | |
 - 对错误的校验和进行静默丢弃                        |4.1.3.4 |x| | | | |
 - 发送端可选择不生成校验和                        |4.1.3.4 | | |x| | |
   - 默认情况下会进行校验和计算                        |4.1.3.4 |x| | | | |
 - 接收端可选择要求校验和                          |4.1.3.4 | | |x| | |
                                                 |        | | | | | |
UDP多宿主（多网卡）支持                            |        | | | | | |
 - 将指定目的地址传递给应用层                      |4.1.3.5 |x| | | | |



互联网工程任务组                                              [第80页]





RFC1122                  传输层 -- UDP             1989年10月
```

应用层可以指定本地IP地址        |4.1.3.5 |x| | | | |
应用层可以指定模糊的本地IP地址    |4.1.3.5 |x| | | | |
应用层已被通知使用的本地IP地址    |4.1.3.5 | |x| | | |
                                              |        | | | | | |
UDP/IP会默默丢弃源IP地址不正确的数据包 |4.1.3.6 |x| | | | |
只允许发送有效的IP源地址             |4.1.3.6 |x| | | | |
UDP应用接口服务                       |        | | | | | |
应用可以使用完整的IP接口（第3.4节） |4.1.4   |x| | | | |
 - 发送数据报时可以指定TTL、TOS和IP选项 |4.1.4   |x| | | | |
 - 将接收到的TOS信息传递给应用层       |4.1.4   | | |x| | |



互联网工程任务组                                              [第81页]





RFC1122                  传输层——TCP             1989年10月


4.2  传输控制协议——TCP

   4.2.1  引言

      传输控制协议TCP [TCP:1]是互联网套件的主要虚电路传输协议。TCP提供可靠的、按序交付的全双工字节流（8位字节）。需要可靠、面向连接的传输服务的应用（如电子邮件SMTP、文件传输FTP和虚拟终端服务Telnet）会使用TCP；这些应用层协议的需求在[INTRO:1]中有所描述。

   4.2.2  协议概述

      4.2.2.1  常用端口：RFC-793第2.7节

         讨论：
              TCP为“知名端口”保留了0-255范围内的端口号，用于访问在整个互联网中标准化的服务。其余的端口空间可以自由分配给应用程序。当前的“知名端口”定义列在题为“已分配号码”的RFC中[INTRO:6]。定义新的知名端口的前提是有一份详细描述拟议服务的RFC，以便实现新的应用。

              一些系统通过增加TCP端口空间的第三个子区——保留端口，来扩展这一概念。保留端口通常用于操作系统特定的服务。例如，保留端口可能位于256到某个系统相关的上限之间。一些系统还会限制只有特权用户才能打开这些端口的TCP连接，以保护知名端口和保留端口。这在只要主机不假设所有主机都以此方式保护其低编号端口时，是合理的。

4.2.2.2 使用推送（Push）：RFC-793 第2.8节

当应用程序在未设置推送标志（PUSH flag）的情况下连续发出多次发送（SEND）调用时，TCP可能会在内部对数据进行聚合，而不立即发送。同样地，当一系列数据段在没有设置PSH位的情况下被接收时，TCP也可能会在内部将数据排队，而不将其传递给接收应用程序。

互联网工程任务组（IETF）[第82页]

RFC1122 传输层——TCP 1989年10月

PSH位不是记录标记，也与数据段边界无关。发送方在对数据进行分段时，应当合并连续的PSH位，以发送尽可能大的数据段。

TCP可以在发送（SEND）调用中实现推送（PUSH）标志。如果未实现推送标志，则发送端的TCP必须：(1) 不得无限期缓冲数据，以及 (2) 在最后一个缓冲段中设置PSH位（即当没有更多待发送的数据时）。

RFC-793第48、50和74页的讨论错误地暗示接收到的PSH标志必须传递给应用层。现在，传递接收到的PSH标志给应用层是可选的。

应用程序在逻辑上需要在每次调用SEND时设置推送标志（PUSH），以强制将数据传递到对方，避免通信死锁。然而，TCP应尽可能发送最大尺寸的段，以提高性能（参见第4.2.3.4节）。

讨论：
当在SEND调用中未实现推送标志（即应用程序/TCP接口采用纯流式模型）时，负责将微小数据片段聚合成合理大小段的责任部分由应用层承担。

通常，交互式应用协议至少在每个命令或响应序列的最后一次SEND调用中设置推送标志。像FTP这样的批量传输协议应在文件的最后一个数据段或在必要时设置推送标志，以防止缓冲区死锁。

在接收端，PSH（Push）位会强制将缓冲区中的数据立即传递给应用程序（即使只收到少于一个完整缓冲区的数据）。相反，不设置PSH位可以用来避免不必要的唤醒应用程序的调用；这对于大型时间共享主机来说，是一种重要的性能优化。将PSH位传递给接收应用程序，可以在应用层实现类似的优化。

4.2.2.3 窗口大小：RFC-793第3.1节

窗口大小必须被视为无符号数，否则较大的窗口大小会被误认为是负数，从而导致TCP无法正常工作。建议实现中在连接记录中为发送和接收窗口大小保留32位字段，并用32位进行所有窗口计算。

讨论：
众所周知，TCP头中的窗口字段对于高速、长延迟路径来说太小了。已经定义了扩展窗口大小的TCP选项，例如[TCP:11]。为了预期采用此类扩展，TCP实现者应将窗口视为32位。

4.2.2.4 紧急指针：RFC-793第3.1节

第二句话有误：紧急指针指向一段紧急数据中最后一个字节（即最后一个八位字节的序列号），而不是最后一个字节的下一个序列号。第56页的描述（最后一句）是正确的。

TCP必须支持任何长度的紧急数据序列。

TCP必须在收到带有紧急指针的包时，异步通知应用层，特别是在之前没有待处理的紧急数据，或者当紧急指针在数据流中前移时。必须有一种方式让应用程序了解还剩多少紧急数据待读取，或者至少判断是否还有更多的紧急数据需要读取。

讨论：
虽然紧急机制可以用于任何应用，但通常用于向Telnet程序发送“中断”类型的命令（参见[INTRO:1]中的“使用Telnet同步序列”部分）。

异步或“带外”通知将允许应用程序进入“紧急模式”，从TCP连接中读取数据。这使得可以向那些正常输入缓冲区已满、未处理数据的应用程序发送控制命令。

实现方式：
在第4.2.4.1节中描述的通用错误报告（ERROR-REPORT()）回调是一种可能的机制，用于通知应用程序紧急数据的到达。

互联网工程任务组（IETF）[第84页]

RFC1122 传输层——TCP 1989年10月

4.2.2.5 TCP选项：RFC-793第3.1节

TCP必须能够在任何数据段中接收TCP选项。
TCP必须忽略任何未实现的TCP选项（没有错误），前提是该选项具有长度字段（所有未来定义的TCP选项都将包含长度字段）。
TCP必须能够处理非法的选项长度（例如，零）而不崩溃；建议的做法是重置连接并记录原因。

4.2.2.6 最大段大小（MSS）选项：RFC-793第3.1节

TCP必须实现发送和接收最大段大小（MSS）选项[TCP:4]。

当接收的MSS与默认值536不同，TCP应在每个SYN段中发送MSS（最大段大小）选项，也可以始终发送。

如果在连接建立时未收到MSS选项，TCP必须假设默认的发送MSS为536（576-40）[TCP:4]。

TCP实际发送的段的最大尺寸，即“有效发送MSS”，必须是发送MSS（反映远程主机的重组缓冲区大小）和IP层允许的最大尺寸中的较小者：

Eff.snd.MSS =

  min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize

其中：

* SendMSS是从远程主机接收到的MSS值，若未收到MSS选项，则为默认值536。

* MMS_S是TCP可能发送的一次传输层消息的最大尺寸。

* TCPhdrsize是TCP头的大小；通常为20字节，但如果要发送TCP选项，可能会更大。

* IPoptionsize是TCP在当前消息中传递的任何IP选项的大小。

在MSS选项中应发送的MSS值必须小于或等于：

MMS_R - 20

以下是英文内容的中文翻译：

```
            其中 MMS_R 是可以接收（并重组）的传输层消息的最大尺寸。TCP 从 IP 层获取 MMS_R 和 MMS_S；详见第 3.4 节中的通用调用 GET_MAXSIZES。

            讨论：
                 选择 TCP 段大小对性能有很大影响。较大的段通过将头部大小和每个数据报的处理开销摊销到更多的数据字节上，从而提高吞吐量；然而，如果数据包过大导致 IP 分片，如果任何分片丢失，效率会急剧下降 [IP:9]。

                 一些 TCP 实现仅在目标主机位于非连接网络时才发送 MSS 选项。然而，通常情况下，TCP 层可能没有适当的信息来做出此决定，因此更倾向于让 IP 层负责确定适合互联网路径的 MTU。因此，我们建议 TCP 始终发送该选项（如果不是 536），并由 IP 层根据第 3.3.3 和第 3.4 节的规定确定 MMS_R。一个建议的 IP 层测量 MTU 的机制可以在不改变 TCP 的情况下修改 IP 层。

         4.2.2.7  TCP 校验和：RFC-793 第 3.1 节

            与 UDP 校验和（见第 4.1.3.4 节）不同，TCP 校验和从不为可选。发送方必须生成校验和，接收方必须进行校验。

         4.2.2.8  TCP 连接状态图：RFC-793 第 3.2 节，第 23 页

            该状态图存在几个问题：

            (a)  从 SYN-SENT 到 SYN-RCVD 的箭头应标注为 "snd SYN,ACK"，以与第 68 页的文本和图 8 一致。

            (b)  可以有一条箭头从 SYN-RCVD 状态指向 LISTEN 状态，条件是在被动打开后收到 RST（参见第 70 页的文本）。

            (c)  也可以直接从 FIN-WAIT-1 转到 TIME-WAIT 状态（参见规范第 75 页）。

         4.2.2.9  初始序列号的选择：RFC-793 第 3.3 节，第 27 页

            TCP 必须使用规范中规定的基于时钟的初始序列号选择方法。

         4.2.2.10  同时开启尝试：RFC-793 第 3.4 节，第 32 页

            图 8 中存在错误：第 7 行的包应与第 5 行的包完全相同。

            TCP 必须支持同时开启连接的尝试。
```

讨论：
有时实现者会感到惊讶，如果两个应用程序试图同时相互连接，实际上只会建立一个连接，而不是两个。这是一个有意的设计决策；不要试图“修正”它。

4.2.2.11 从旧的重复 SYN 恢复：RFC-793 第3.4节，第33页

请注意，TCP实现必须跟踪连接是否因为被动打开（passive OPEN）或主动打开（active OPEN）而达到 SYN_RCVD 状态。

4.2.2.12 RST段：RFC-793 第3.4节

TCP应允许接收到的RST段包含数据。

讨论：
有人建议，RST段可以包含ASCII文本，用以编码和解释RST的原因。目前尚未为此类数据制定标准。

4.2.2.13 关闭连接：RFC-793 第3.5节

TCP连接可以通过两种方式终止：（1）使用FIN握手的正常关闭序列；（2）“中止”连接，即发送一个或多个RST段，并立即丢弃连接状态。如果远程站点关闭了TCP连接，必须通知本地应用程序是正常关闭还是被中止。

正常的TCP关闭序列会可靠地传输缓冲区中的数据，双向都如此。由于TCP连接的两个方向是独立关闭的，连接可能会“半关闭”，即只在一个方向关闭，主机仍然可以在开放的方向继续发送数据。

主机可以实现“半双工”TCP关闭序列，这样调用CLOSE的应用程序就不能继续从连接中读取数据。如果在TCP中仍有待处理的数据时发出CLOSE调用，或者在调用CLOSE后收到新数据，其TCP应发送RST以表明数据已丢失。

当主动关闭连接时，必须在TIME-WAIT状态停留一段时间，时间为2倍的MSL（最大报文段寿命）。然而，如果远程TCP发起新的SYN请求，且满足以下条件，也可以直接从TIME-WAIT状态重新建立连接：

（1）为新连接分配的初始序列号大于上一次连接中使用的最大序列号，且

（2）如果 SYN 被确认是旧的重复包，则返回到 TIME-WAIT 状态。

讨论：
TCP 的全双工、数据保持关闭是一项特性，而在类似的 ISO 传输协议 TP4 中并未包含这一特性。

一些系统尚未实现半关闭连接，推测原因是它们的操作系统的 I/O 模型不适合这种方式。在这些系统中，一旦应用程序调用了 CLOSE，就不能再从连接中读取输入数据；这被称为“半双工”TCP关闭序列。

TCP 的优雅关闭算法要求连接状态在（至少）一端保持定义，且在超时时间为 2×MSL（即 4 分钟）期间内保持。期间，定义连接的（远程套接字、本地套接字）对是繁忙的，不能被重用。为了缩短某个端口对被占用的时间，一些 TCP 实现允许在 TIME-WAIT 状态下接受新的 SYN。

4.2.2.14 数据通信：RFC-793 第3.7节，第40页

自从 RFC-793 发布以来，关于 TCP 算法以实现高效数据通信的研究已广泛展开。本文件的后续章节描述了确定何时发送数据（第4.2.3.4节）、何时发送确认（第4.2.3.2节）以及何时更新窗口（第4.2.3.3节）所需和推荐的 TCP 算法。

讨论：
一个重要的性能问题是“愚蠢窗口综合征”或“SWS” [TCP:5]，即一种稳定的小增量窗口移动模式，导致 TCP 性能极差。为避免 SWS，下面将介绍在发送端（第4.2.3.4节）和接收端（第4.2.3.3节）都适用的算法。

简而言之，SWS（小窗口问题）是由接收方在有新的缓冲区空间可用以接收数据时，提前推进右窗口边缘引起的，以及由发送方使用任何增量窗口（无论多小）来发送更多数据所导致的[TCP:5]。其结果可能形成一种稳定的模式，即不断发送微小的数据段，即使连接的总缓冲区空间很大。SWS只会在传输大量数据时发生；如果连接变得静止，这个问题就会消失。它是由窗口管理的典型直接实现方式引起的，但下面给出的发送端和接收端的算法可以避免这种情况。

另一个重要的TCP性能问题是，一些应用程序，尤其是远程登录到逐字符主机的应用，倾向于发送一连串的单字节数据段。为了避免死锁，来自此类应用的每次TCP发送调用都必须被“推送”，要么由应用程序显式推送，要么由TCP隐式推送。其结果可能是形成一串每个都只包含一个数据字节的TCP段，这极大地降低了互联网的使用效率，并加剧了网络拥塞。第4.2.3.4节介绍的纳格尔算法（Nagle Algorithm）为这个问题提供了一个简单而有效的解决方案。它确实会在Telnet连接中将字符合并成块；这最初可能会让习惯单字符回显的用户感到惊讶，但用户接受度并不成问题。

请注意，纳格尔算法和避免SWS的小窗口算法在改善性能方面起着互补的作用。纳格尔算法在待发送数据逐渐增加时，抑制发送微小段；而SWS避免算法则抑制由右窗口边缘以小增量推进而导致的小段。

一个粗心的实现可能会在每个接收到的数据段上发送两个或更多的确认段。例如，假设接收方立即确认每个数据段。当应用程序随后消费数据并再次增加可用的接收缓冲区空间时，接收方可能会发送第二个确认段以更新发送方的窗口。极端的情况发生在使用Telnet协议进行远程登录服务的TCP连接中。一些实现中观察到每个接收的单字符段会生成三个返回段：一是确认段，二是窗口增加一个字节，三是回显的字符。

4.2.2.15 重传超时：RFC-793第3.7节，第41页

RFC-793中建议的重传超时算法现在被认为是不充分的；详见下面的第4.2.3.1节。

最近，Jacobson[TCP:7]关于互联网拥塞和TCP重传稳定性的研究提出了一种结合“慢启动”和“拥塞避免”的传输算法。TCP必须实现该算法。

如果重传的数据包与原始数据包完全相同（这不仅意味着数据边界没有变化，还意味着头部中的窗口和确认字段没有变化），那么可以使用相同的IP识别字段（参见第3.2.1.5节）。

实现建议：
一些TCP实现者选择对数据流进行“分段打包”，即在最初发送段时确定段边界，并将这些段放入“重传队列”，直到它们被确认。另一种设计（可能更简单）是在每次传输或重传数据时延迟分段打包，这样就不会有段重传队列。

在具有段重传队列的实现中，当第一次重传超时时，TCP的性能可能会通过重新打包等待确认的段来提升。也就是说，符合条件的未确认段会被合并成一个最大长度的段，并赋予一个新的IP标识值。然后，TCP会将这个合并后的段保留在重传队列中，直到它被确认。然而，如果重传队列中的前两个段总长度超过一个最大长度的段，TCP将只对第一个段进行重传，使用原有的IP标识字段。

4.2.2.16 管理窗口：RFC-793第3.7节，第41页

TCP接收方不应缩小窗口，即不应将右边界向左移动。然而，发送端的TCP必须对窗口缩小具有鲁棒性，这可能导致“可用窗口”（参见第4.2.3.4节）变为负值。

如果发生这种情况，发送端不应发送新数据，而应正常重传未确认的旧数据，即在SND.UNA到SND.UNA+SND.WND之间的数据。发送端也可以重传超出SND.UNA+SND.WND范围的旧数据，但如果超出右边界的数据未被确认，则不应因此而超时关闭连接。如果窗口缩小到零，TCP必须按照标准方式探测窗口（见下一节）。

讨论：
许多TCP实现会在数据已发送到较大窗口后，窗口从右侧缩小时感到困惑。请注意，TCP有一种启发式方法，即选择最新的窗口更新，尽管可能会发生数据报重排序；因此，如果序列号和确认号都没有增加，它可能会忽略比之前提供的窗口更小的窗口更新。

互联网工程任务组（IETF）[第91页]

RFC1122 传输层——TCP 1989年10月

4.2.2.17 探测零窗口：RFC-793第3.7节，第42页

必须支持对零（提供的）窗口的探测。

TCP可以无限期保持其提供的接收窗口关闭状态。只要接收端TCP继续对探测段发送确认，发送端TCP就必须允许连接保持开启状态。

讨论：
请务必记住，包含无数据的确认（ACK）段并不会被TCP可靠地传输。如果不支持零窗口探测，当一个重新开启窗口的ACK段丢失时，连接可能会无限挂起。

通常，开启零窗口的延迟发生在接收应用程序停止从其TCP读取数据时。例如，考虑一个打印机守护进程应用程序，因为打印机用完纸张而停止工作。

发送方应在零窗口持续存在到重传超时时间（参见第4.2.2.15节）后，首次发送零窗口探测，并应以指数方式增加连续探测之间的间隔。

讨论：
如果零窗口状态是由于包含窗口开启更新的ACK段丢失引起的，这一程序可以最大限度地减少延迟。建议采用指数退避策略，可能还会设定某个最大间隔（此处未具体说明）。此程序类似于重传算法，可能在实现中将两者结合使用。

4.2.2.18 被动打开（Passive OPEN）调用：RFC-793第3.8节

每次被动打开调用，要么创建一个处于LISTEN状态的新连接记录，要么返回错误；不得影响任何已存在的连接记录。

支持多用户同时连接的TCP必须提供一种OPEN调用，使应用程序在本地端口处于LISTEN状态时，仍能在有相同本地端口的连接块处于SYN-SENT或SYN-RECEIVED状态时进行监听。

讨论：
一些应用（如SMTP服务器）可能需要同时处理多个连接尝试。通过提供一种机制，让应用在进行三次握手的同时还能监听新连接，可以降低连接失败的概率。

实现：
允许多次被动打开的实现可以允许多个被动OPEN调用，或者允许从单一的被动OPEN调用“克隆”出多个LISTEN状态的连接。

4.2.2.19 生存时间（Time to Live）：RFC-793第3.9节，第52页

RFC-793 规定，TCP 应请求 IP 层发送 TTL = 60 的 TCP 段。这已过时；用于发送 TCP 段的 TTL 值必须是可配置的。详见第3.2.1.7节的讨论。

4.2.2.20 事件处理：RFC-793 第3.9节

虽然不是严格要求，但 TCP 应该能够对乱序的 TCP 段进行排队。请将第70页第一段最后一句中的“may”改为“should”。

讨论：
一些小型主机实现省略了段排队功能，原因是缓冲区空间有限。这种省略可能会对 TCP 吞吐量产生不利影响，因为丢失一个段会导致后续所有段都表现为“乱序”。

一般而言，收到段的处理必须尽可能地合并 ACK 段。例如，如果 TCP 正在处理一系列排队的段，必须在发送任何 ACK 段之前处理完所有段。

以下是关于 RFC-793“事件处理”部分的详细错误更正和说明。

(a) 关闭调用，CLOSE-WAIT 状态，第61页：应进入 LAST-ACK 状态，而不是 CLOSING。

(b) 监听状态，第65、66页：检查 SYN 位时，如果段的安全/隔离级或优先级错误，应发送复位（RST）。文本中显示的复位格式是错误的，正确应为：

<SEQ=0><ACK=SEG.SEQ+SEG.LEN><CTL=RST,ACK>

(c) SYN-SENT 状态，第68页：检查 SYN 位，当连接进入 ESTABLISHED 状态时，必须设置以下变量：
- SND.WND <- SEG.WND
- SND.WL1 <- SEG.SEQ
- SND.WL2 <- SEG.ACK

(d) 检查安全性和优先级，第71页：“ESTABLISHED 状态”这一标题实际上应列出除 SYN-RECEIVED 之外的所有状态：ESTABLISHED、FIN-WAIT-1、FIN-WAIT-2、CLOSE-WAIT、CLOSING、LAST-ACK 和 TIME-WAIT。

(e) 检查 SYN 位，第71页：在 SYN-RECEIVED 状态，如果连接是被动打开的，则应将连接返回到 LISTEN 状态并返回，否则……。

(f) 检查 ACK 字段，第72页：当连接进入 ESTABLISHED 状态时，必须设置（c）中列出的变量。

（g） 检查确认（ACK）字段，处于已建立（ESTABLISHED）状态，第72页：如果SEG.ACK ≤ SND.UNA（等号被省略了），则ACK是重复的。同样，如果满足 SND.UNA ≤ SEG.ACK ≤ SND.NXT，也应更新窗口。

（h） 用户超时，第77页：

通知应用程序超时情况比让TCP强制关闭连接要更好。然而，也请参见第4.2.3.5节。

4.2.2.21 确认排队段：RFC-793第3.9节

当一个有效的段到达，且在窗口内但不在左边界时，TCP可以发送一个确认（ACK）段，确认RCV.NXT。

互联网工程任务组（IETF）[第94页]

RFC1122 传输层——TCP 1989年10月

讨论：
RFC-793（见第74页）在收到乱序段（即SEG.SEQ不等于RCV.NXT）时是否应发送ACK段，存在歧义。

对乱序段进行确认的一个原因可能是为了支持一种名为“快速重传”的实验性算法。使用该算法，发送方通过“冗余”ACK来推断某个段是否已丢失，而无需等待重传定时器到期。它会统计收到的ACK中SEG.ACK值相同且窗口边界相同的次数。如果收到超过阈值的此类ACK，则假定从SEG.ACK开始的字节段已丢失，并立即重传，无需等待超时。该阈值的设定旨在补偿互联网中可能出现的最大段乱序情况。目前还没有足够的经验来评估快速重传算法的实际效果。

4.2.3 具体问题

4.2.3.1 重传超时（RTO）计算

主机的TCP必须实现Karn算法和Jacobson算法，用于计算重传超时（RTO）。

- Jacobson算法用于计算平滑的往返时间（RTT），并包含一个简单的方差测量[TCP:7]。

- Karn算法确保在选择RTT测量值时，模糊的往返时间不会影响平滑RTT的计算[TCP:6]。

该实现还必须包括“指数退避”机制，用于同一数据段的连续重传超时（RTO）值。重传 SYN 段应采用与数据段相同的算法。

讨论：
在 RFC-793 中规定的 RTO 计算存在两个已知问题。首先，在存在重传的情况下，准确测量往返时间（RTT）非常困难。第二，用于计算平滑往返时间的算法不充分[TCP:7]，因为它错误地假设 RTT 值的方差会很小且保持不变。这些问题分别由 Karn 和 Jacobson 的算法解决。

采用这些改进后，性能提升的程度从明显到显著不等。特别是在低速链路上，Jacobson 的算法通过考虑测得的 RTT 方差，显得尤为重要，因为包大小的自然变化会导致 RTT 的大幅波动。一家供应商发现，在一条 9.6 kb 的链路上，应用 Jacobson 方差算法后，链路利用率从 10% 提升到 90%。

对于新连接，建议使用以下值初始化估算参数：
(a) RTT = 0 秒。
(b) RTO = 3 秒（平滑方差应初始化为能得出此 RTO 的值）。

已知在大型互联网中，建议的 RTO 上下界可能不足。下界应以秒的分数为单位（以适应高速局域网），上界应为 2×MSL，即 240 秒。

讨论：
经验表明，这些初始化值是合理的，而且无论如何，Karn 和 Jacobson 的算法都使得 TCP 行为对初始参数的选择具有较好的鲁棒性。

4.2.3.2 何时发送确认（ACK）段

接收 TCP 数据流的主机可以通过减少每个接收数据段的确认段（ACK）数量，提高在互联网和主机上的效率；这被称为“延迟确认”[TCP:5]。

一个 TCP 应该实现延迟确认（delayed ACK），但确认应避免过度延迟；特别是，延迟时间必须少于0.5秒，并且在一串满尺寸的段中，至少每隔第二个段应有一次确认。

讨论：

延迟确认为应用程序提供了一个机会，可以更新窗口，或许还能立即发送响应。特别是在字符模式远程登录的情况下，延迟确认可以将服务器发送的段数减少三倍（将确认、窗口更新和回显字符合并在一个段中）。

此外，在一些大型多用户主机上，延迟确认还能显著减少协议处理的开销，通过减少需要处理的总数据包数量[TCP:5]。然而，确认的过度延迟可能会干扰往返时间的测量和包“时钟同步”算法[TCP:7]。

4.2.3.3 何时发送窗口更新

一个 TCP 必须在接收端实现避免“短窗口”问题（SWS）的算法[TCP:5]。

实现：
接收端的 SWS 避免算法决定何时可以推进右窗口边界；这通常被称为“更新窗口”。该算法与延迟确认算法（见第4.2.3.2节）结合，用于确定何时会真正向接收端发送包含当前窗口的确认段。我们采用 RFC-793 的符号；详见该文档中的图4和图5。

解决接收端 SWS 问题的方法是避免在小幅度地推进右窗口边界 RCV.NXT+RCV.WND，即使从网络接收到了小段数据。

假设总接收缓冲区空间为 RCV.BUFF。在任何时刻，RCV.USER 字节可能被已接收并确认但用户进程尚未消费的数据占用。当连接处于空闲状态时，RCV.WND 等于 RCV.BUFF，RCV.USER 为0。

保持右窗口边缘在数据到达并被确认时保持固定，意味着接收方必须提供少于其全部缓冲区空间的窗口大小，即接收方必须指定一个 RCV.WND，使得 RCV.NXT+RCV.WND 在 RCV.NXT 增加时保持不变。因此，整个缓冲区空间 RCV.BUFF 通常被划分为三个部分：

|<------- RCV.BUFF -------->|
     1             2            3
----|---------|------------------|------|----
               RCV.NXT               ^
                                   (固定)

1 - RCV.USER = 已接收但尚未消费的数据；
2 - RCV.WND = 通告给发送方的空间；
3 - Reduction = 可用但尚未通告的空间。

接收方建议采用的避免“小窗口”问题的算法是：保持 RCV.NXT+RCV.WND 固定，直到满足以下条件：

```
RCV.BUFF - RCV.USER - RCV.WND >= min( Fr * RCV.BUFF, Eff.snd.MSS )
```

其中，Fr 是一个建议值为1/2的分数，Eff.snd.MSS 是连接的有效发送MSS（参见第4.2.2.6节）。当不等式成立时，设置 RCV.WND 为 RCV.BUFF - RCV.USER。

请注意，该算法的总体效果是以 Eff.snd.MSS 为增量逐步推进 RCV.WND（对于实际的接收缓冲区：Eff.snd.MSS < RCV.BUFF/2）。还应注意，接收方必须使用其自己的 Eff.snd.MSS，假设它与发送方的相同。

4.2.3.4 何时发送数据

TCP 必须在其实现中包含避免“小窗口”问题的算法。

TCP 应该实现 Nagle 算法 [TCP:9] 来合并短段。然而，必须有一种方法让应用程序在单个连接上禁用 Nagle 算法。在所有情况下，发送数据还受到慢启动算法（第4.2.2.15节）所施加的限制。

讨论：
Nagle 算法通常如下：

如果存在未确认的数据（即 SND.NXT > SND.UNA），那么发送端的 TCP 会将所有用户数据缓冲起来。

以下是该英文内容的中文翻译：

```
                      数据（无论PSH位是否设置），直到未确认的数据被确认，或者直到TCP可以发送一个满尺寸的段（Eff.snd.MSS字节；参见第4.2.2.6节）。

                 一些应用（例如实时显示窗口更新）需要关闭纳格尔算法，以便可以以最大速率连续传输小数据段。

            实现：
                 发送方的SWS（小窗口避免）算法比接收方的更复杂，因为发送方无法（直接）知道接收方的总缓冲区空间RCV.BUFF。 一种被证明效果良好的方法是，发送方计算最大已见的发送窗口Max(SND.WND)，即在连接中到目前为止看到的最大发送窗口，并将此值作为RCV.BUFF的估算值。不幸的是，这只能是一个估算值；接收方可能随时减小RCV.BUFF的大小。为了避免由此引发的死锁，有必要设置超时机制，强制传输数据，覆盖SWS避免算法。在实际操作中，这个超时应很少发生。

                 “可用窗口” [TCP:5] 定义为：

                      U = SND.UNA + SND.WND - SND.NXT

                 即，提供的窗口减去已发送但尚未确认的数据量。如果D表示在发送端TCP中排队但尚未发送的数据量，则推荐以下规则。

                 发送数据：

                 (1) 如果可以发送最大尺寸的段，即满足条件：

                           min(D, U) >= Eff.snd.MSS;

                 (2) 或者如果数据被推送且所有排队的数据都可以立即发送，即满足条件：

                          [SND.NXT = SND.UNA 且] PUSHED 且 D <= U

                      （括号内的条件由纳格尔算法强制执行）；

                 (3) 或者如果可以发送最大窗口的某一部分（Fs比例），即满足条件：

                          [SND.NXT = SND.UNA 且]

                                  min(D, U) >= Fs * Max(SND.WND);

                 (4) 或者如果数据被推送且超时覆盖发生。
```

这里，Fs 是一个分数，其推荐值为1/2。覆盖超时时间应在0.1到1.0秒的范围内。将此定时器与用于探测零窗口的定时器（第4.2.2.17节）结合使用可能会更方便。

最后，注意刚刚描述的SWS（发送窗口缩放）避免算法应取代[TCP:5]中包含的发送端算法。

4.2.3.5 TCP连接失败

TCP对同一数据段的过度重传表明远程主机或互联网路径出现了某些故障。此类故障可能持续时间短或长。必须使用以下程序来处理数据段的过度重传[IP:11]：

(a) 有两个阈值R1和R2，用于衡量对同一数据段的重传次数。R1和R2可以用时间单位或重传次数来衡量。

(b) 当对同一数据段的传输次数达到或超过阈值R1时，向IP层传递负面建议（参见第3.3.1.4节），以触发死网关诊断。

(c) 当对同一数据段的传输次数达到比R1更大的阈值R2时，关闭连接。

(d) 应用程序必须能够为特定连接设置R2的值。例如，一个交互式应用程序可以将R2设置为“无限”，让用户控制何时断开连接。

互联网工程任务组（RFC1122）[第100页]

RFC1122：传输层——TCP（1989年10月）

当达到R1且在R2之前，TCP应通知应用程序传输问题（除非应用程序已禁用此类信息；参见第4.2.4.1节）。这将允许远程登录（用户Telnet）应用程序通知用户，例如。

R1的值应至少对应3次重传，基于当前的RTO（重传超时）。R2的值应至少对应100秒。

尝试建立TCP连接可能会因对SYN段的过度重传、收到RST段或ICMP端口不可达消息而失败。SYN段的重传必须按照上述处理数据重传的通用方式进行，包括通知应用层。

然而，SYN段和数据段的R1和R2值可能不同。特别是，SYN段的R2必须设置得足够大，以确保该段至少在3分钟内可以重新传输。当然，应用程序可以更早地关闭连接（即放弃建立尝试）。

讨论：
一些互联网路径具有较长的建立时间，且未来此类路径的数量可能会增加。

4.2.3.6 TCP 保活（Keep-Alives）

实现者可以在其TCP实现中加入“保活”功能，尽管这一做法并未被普遍接受。如果加入保活功能，应用程序必须能够为每个TCP连接开启或关闭该功能，并且默认应为关闭状态。

保活包必须仅在在一定时间内未收到任何数据或确认包的情况下发送。该时间间隔必须可配置，且默认不得少于两小时。

非常重要的一点是，要记住，包含无数据的确认（ACK）段并不能被TCP可靠地传输。因此，如果实现了保活机制，不能将未响应任何特定探测包视为连接已死。

实现应当发送不带数据的保活段；不过，也可以配置为发送包含一个垃圾字节的保活段，以兼容存在错误的TCP实现。

讨论：
“保活”机制是在连接空闲时定期探测对端的状态，即使没有数据要发送。TCP规范中没有包含保活机制，原因包括：(1) 在短暂的互联网故障期间，可能会导致正常连接中断；(2) 会消耗不必要的带宽（“如果没人用连接，谁在乎它是否还好？”）；以及 (3) 互联网路径可能会收费，发送包会产生费用。

一些 TCP 实现包含了保持连接机制。为了确认空闲连接仍然有效，这些实现会发送一个探测段，旨在引发对端 TCP 的响应。这样的段通常包含 SEG.SEQ = SND.NXT - 1，可能还会包含一个垃圾字节的数据。注意，在安静的连接中，SND.NXT = RCV.NXT，因此这个 SEG.SEQ 会在窗口之外。因此，探测段会促使接收方返回一个确认段，确认连接仍然活跃。如果对端由于网络分区或崩溃而断开连接，它会用 RST 而不是确认段来响应。

不幸的是，一些行为不端的 TCP 实现未必会对 SEG.SEQ = SND.NXT - 1 的段作出响应，除非该段包含数据。或者，某些实现可以通过判断对端是否正确响应没有垃圾数据的保持连接包，来确定连接状态。

TCP 保持连接机制应仅在服务器应用中使用，特别是在客户端崩溃或中断连接、网络故障导致可能无限挂起并不必要占用资源的情况下。

---

互联网工程任务组（IETF）[第102页]

RFC1122 传输层——TCP  1989年10月

4.2.3.7 TCP 多宿主（Multihoming）

如果多宿主主机上的应用在主动建立 TCP 连接时未指定本地 IP 地址，则 TCP 必须在发送（第一个） SYN 之前请求 IP 层选择一个本地 IP 地址。参见第3.4节中的函数 GET_SRCADDR()。

在其他任何时候，若在此连接上已发送或接收过段，TCP 必须使用之前使用的相同本地地址。

4.2.3.8 IP 选项

当接收到的选项从 IP 层传递到 TCP 时，TCP 必须忽略它不理解的选项。

TCP 可以支持时间戳（Timestamp）和记录路由（Record Route）选项。

应用程序在主动建立 TCP 连接时，必须能够指定源路由，并且此源路由必须优先于在数据报中接收到的源路由。

当被动地建立一个TCP连接并且收到一个带有完整IP源路由选项（包含返回路由）的数据包时，TCP必须保存该返回路由，并在该连接上发送的所有数据段中使用它。如果在后续的数据段中收到不同的源路由，后者的定义应优先于前者。

4.2.3.9 ICMP消息

TCP必须对从IP层传递上来的ICMP错误消息做出反应，并将其引导到引发错误的连接。ICMP消息中的IP头包含了必要的多路复用信息。

- 源抑制（Source Quench）

  TCP必须对源抑制消息作出反应，减慢该连接上的传输速率。推荐的做法是让TCP触发“慢启动”，就像发生重传超时时一样。

- 不可达目的地（Destination Unreachable）——代码0、1、5

  由于这些不可达消息表示软错误条件，TCP不应中止连接，而应将相关信息提供给应用程序。

  讨论：
  TCP可以直接通过调用ERROR_REPORT例程向应用层报告软错误，也可以仅记录该消息，并在TCP连接超时时才向应用程序报告。

- 不可达目的地（Destination Unreachable）——代码2-4

  这些是硬错误条件，因此TCP应中止连接。

- 超时（Time Exceeded）——代码0、1

  这应与不可达目的地（代码0、1、5）处理方式相同（见上文）。

- 参数问题（Parameter Problem）

  这也应与不可达目的地（代码0、1、5）处理方式相同。

4.2.3.10 远程地址验证

TCP实现必须将对无效远程IP地址（例如广播或多播地址）的本地打开请求视为错误并拒绝。

带有无效源地址的SYN包必须由TCP或IP层忽略。

TCP实现必须静默地丢弃目标为广播或多播地址的入站SYN段。

4.2.3.11 TCP流量模式

实现：
TCP协议规范 [TCP:1] 为实现者在设计控制连接上消息流的算法方面提供了较大的自由度——包括分组、管理窗口、发送确认等。这些设计决策具有一定难度，因为TCP必须适应各种不同的流量模式。经验表明，TCP的实现者需要在两种极端的流量模式下验证其设计：

- 单字符段
即使发送方使用了纳格尔算法，当TCP连接在低延迟局域网中传输远程登录流量时，接收方通常会收到一连串的单字符段。如果启用了远程终端回显模式，接收系统通常会在收到每个字符时立即回显。

- 批量传输
当TCP用于批量传输时，数据流应几乎全部由等于有效最大分段大小（MSS）的段组成。虽然TCP使用字节（八位字节）粒度的序列号空间，但在批量传输模式下，其操作应表现得就像TCP只用段数来计数序列一样。

此外，经验还表明，一个TCP实现能够有效且高效地处理这两种极端情况。

验证新TCP实现的最重要工具是数据包跟踪程序。大量经验表明，跟踪各种流量模式并与其他TCP实现进行比较分析，具有重要意义。

4.2.3.12 效率
实现：
丰富的实践经验提出了以下关于高效实现TCP的建议：

（a）避免复制数据
在批量数据传输中，主要的CPU密集型任务是将数据从一个位置复制到另一个位置以及进行校验和计算。必须尽量减少TCP数据的复制次数。

最终的速度限制可能在于从内存总线获取数据，为了提高效率，结合复制和校验和操作，利用一次内存读取同时完成两者，可能会很有帮助。

(b) 手工编写校验和例程

一个优秀的TCP校验和例程通常比简单直接实现的速度快两到五倍。为了让校验和代码“飞快”，通常需要非常细心的设计和巧妙的编码。详见[TCP:10]。

(c) 针对常见情况的代码优化

TCP协议处理可能很复杂，但对于大多数数据段，只需做出少数几个简单的决策。通过优化主流程，减少在最常见情况下的决策次数，可以大大加快每个数据段的处理速度。

4.2.4 TCP/应用层接口

4.2.4.1 异步报告

必须有一种机制，将软TCP错误条件报告给应用程序。一般来说，这可以通过应用程序提供的ERROR_REPORT例程实现，该例程可以在传输层异步调用[INTRO:7]：

ERROR_REPORT(本地连接名，原因，子原因)

这里没有具体规定原因和子原因参数的编码方式。然而，异步报告给应用程序的条件必须包括：

* ICMP错误消息到达（见4.2.3.9）

* 过多的重传（见4.2.3.5）

* 紧急指针提前（见4.2.2.4）

不过，不希望接收此类ERROR_REPORT调用的应用程序应能够有效地禁用这些调用。

讨论：
这些错误报告通常反映的是一些软错误，许多应用程序可以在不受影响的情况下忽略它们。有建议指出，这些错误报告调用应默认“禁用”，但这并非强制要求。

4.2.4.2 服务类型

应用层必须能够为在连接上传输的段指定服务类型（TOS）。虽然不是强制要求，但应用程序应当能够在连接期间更改TOS。TCP在发送连接上的段时，应将当前的TOS值原封不动地传递给IP层。

TOS将在连接的两个方向上分别指定，以便接收端应用程序能够指定用于确认（ACK）段的TOS。

TCP可以将最近接收到的TOS值传递给应用程序。

讨论：
一些应用程序（例如SMTP）在连接的生命周期内会改变其通信的性质，因此希望能够更改TOS的设置。

还应注意，RFC-793中定义的OPEN调用包含一个参数（“options”），调用者可以在其中指定IP选项，如源路由、记录路由或时间戳。

4.2.4.3 刷新（Flush）调用

一些TCP实现包括一个“刷新”调用，用于清空TCP发送队列中用户已发出但仍在当前发送窗口右侧的所有数据。也就是说，它会尽可能地刷新排队的发送数据，而不会丢失序列号同步。这对于实现Telnet的“中止输出”功能非常有用。

4.2.4.4 多宿（Multihoming）

RFC-793第2.7节和3.8节中概述的用户界面需要扩展以支持多宿。OPEN调用必须增加一个可选参数：

    OPEN( ... [local IP address,] ... )

以允许指定本地IP地址。

讨论：
一些基于TCP的应用程序需要指定用于建立特定连接的本地IP地址；例如FTP。

实现：
带有“本地IP地址”参数的被动OPEN调用将等待来自该地址的传入连接请求。如果未指定该参数，则被动OPEN将等待任何本地IP地址的传入连接请求，然后将连接的本地IP地址绑定到所使用的具体地址。

对于主动打开（OPEN）调用，将使用指定的“本地IP地址”参数来建立连接。如果未指定该参数，网络软件将为连接选择一个合适的本地IP地址（参见第3.3.4.2节）。  

4.2.5 TCP 需求总结

| 特性                                              | 章节     | | | |T|T|e |
|---------------------------------------------------|----------|--|--|--|--|--|--|
| 推送标志（Push flag）                              |          |  |  |  |  |  |  |
|  聚合或排队未推送的数据                            | 4.2.2.2  |  |  | x|  |  |  |
|  发送端合并连续的PSH标志                          | 4.2.2.2  |  | x|  |  |  |  |
|  SEND调用可以指定PUSH                              | 4.2.2.2  |  |  | x|  |  |  |

互联网工程任务组（IETF）                                   [第108页]

RFC1122                  传输层——TCP                     1989年10月

如果无法：无限缓冲发送方数据 |4.2.2.2 | | | | |x|
如果无法：发送最后一个 PSH 段 |4.2.2.2 |x| | | | |
通知接收端 ALP 处理 PSH                     |4.2.2.2 | | |x| | |1
在可能时发送最大尺寸段                     |4.2.2.2 | |x| | | |
                                                 |        | | | | | |
窗口                                             |        | | | | | |
  视为无符号数                                   |4.2.2.3 |x| | | | |
  作为 32 位数处理                                |4.2.2.3 | |x| | | |
  从右侧缩小窗口                                |4.2.2.16| | | |x| |
  对缩小窗口具有鲁棒性                          |4.2.2.16|x| | | | |
  接收端窗口无限期关闭                          |4.2.2.17| | |x| | |
  发送端探测零窗口                              |4.2.2.17|x| | | | |
    第一次探测在 RTO 后                            |4.2.2.17| |x| | | |
    指数退避                                      |4.2.2.17| |x| | | |
  允许窗口无限期保持为零                        |4.2.2.17|x| | | | |
  发送端超时允许零窗口连接                      |4.2.2.17| | | | |x|
                                                 |        | | | | | |
紧急数据                                         |        | | | | | |
  指针指向最后一个八位字节                     |4.2.2.4 |x| | | | |
  任意长度的紧急数据序列                        |4.2.2.4 |x| | | | |
  异步通知 ALP 紧急数据                         |4.2.2.4 |x| | | | |1
  ALP 可以获知紧急数据的数量及方式               |4.2.2.4 |x| | | | |1
                                                 |        | | | | | |
TCP 选项                                         |        | | | | | |
  在任何段中接收 TCP 选项                        |4.2.2.5 |x| | | | |
  忽略不支持的选项                                |4.2.2.5 |x| | | | |
  处理非法的选项长度                              |4.2.2.5 |x| | | | |
  实现发送和接收 MSS 选项                         |4.2.2.6 |x| | | | |
  除非为 536，否则发送 MSS 选项                   |4.2.2.6 | |x| | | |
  始终发送 MSS 选项                              |4.2.2.6 | | |x| | |
  默认发送 MSS 为 536                            |4.2.2.6 |x| | | | |
  计算有效的发送段大小                            |4.2.2.6 |x| | | | |
                                                 |        | | | | | |
TCP 校验和                                       |        | | | | | |
  发送端计算校验和                                |4.2.2.7 |x| | | | |
  接收端校验校验和                                |4.2.2.7 |x| | | | |
                                                 |        | | | | | |
使用时钟驱动的 ISN 选择                           |4.2.2.9 |x| | | | |
                                                 |        | | | | | |
建立连接                                         |        | | | | | |
  支持同时打开连接尝试                            |4.2.2.10|x| | | | |
  SYN-RCVD 记住最后状态                            |4.2.2.11|x| | | | |
  被动打开调用会干扰其他连接                     |4.2.2.   |   |   |   |   |

18| | | | |x|
  功能：同时监听相同端口                     |4.2.2.18|x| | | | |
  如有必要，向IP请求SYN的源地址             |4.2.3.7 |x| | | | |
    否则，使用连接的本地地址                   |4.2.3.7 |x| | | | |
  允许广播/多播IP地址的打开                   |4.2.3.14| | | | |x|
  静默丢弃发往广播/多播地址的段               |4.2.3.14|x| | | | |

互联网工程任务组                               [第109页]

RFC1122                  传输层——TCP             1989年10月

以下是英文内容的中文翻译：

```

                                                 |        | | | | | |
关闭连接                                       |        | | | | | |
  RST可以携带数据                                |4.2.2.12| |x| | | |
  通知应用程序连接中止                            |4.2.2.13|x| | | | |
  半双工关闭连接                                  |4.2.2.13| | |x| | |
    发送RST以指示数据丢失                         |4.2.2.13| |x| | | |
  在TIME-WAIT状态保持2×MSL秒                     |4.2.2.13|x| | | | |
    从TIME-WAIT状态接受SYN                        |4.2.2.13| | |x| | |
                                                 |        | | | | | |
重传机制                                       |        | | | | | |
  Jacobson慢启动算法                              |4.2.2.15|x| | | | |
  Jacobson拥塞避免算法                              |4.2.2.15|x| | | | |
  使用相同IP标识符进行重传                        |4.2.2.15| | |x| | |
  Karn算法                                        |4.2.3.1 |x| | | | |
  Jacobson的RTO估算算法                            |4.2.3.1 |x| | | | |
  指数退避                                        |4.2.3.1 |x| | | | |
  SYN的RTO计算与数据相同                           |4.2.3.1 | |x| | | |
  推荐的初始值和界限                                |4.2.3.1 | |x| | | |
                                                 |        | | | | | |
生成确认（ACK）：                                |        | | | | | |
  队列中乱序段                                    |4.2.2.20| |x| | | |
  在发送ACK前处理所有排队段                        |4.2.2.20|x| | | | |
  对乱序段发送ACK                                |4.2.2.21| | |x| | |
  延迟确认（Delayed ACKs）                        |4.2.3.2 | |x| | | |
    延迟时间<0.5秒                                |4.2.3.2 |x| | | | |
    每第2个全尺寸段确认                          |4.2.3.2 |x| | | | |
接收端SWS（滑动窗口缩减）避免算法                |4.2.3.3 |x| | | | |
                                                 |        | | | | | |
发送数据                                         |        | | | | | |
  可配置的TTL                                    |4.2.2.19|x| | | | |
  发送端SWS避免算法                                |4.2.3.4 |x| | | | |
  Nagle算法                                       |4.2.3.4 | |x| | | |
    应用程序可以禁用Nagle算法                        |4.2.3.4 |x| | | | |
                                                 |        | | | | | |
连接失败：                                      |        | | | | | |
  对R1重传时向IP发出负面建议                      |4.2.3.5 |x| | | | |
  在R2重传时关闭连接                              |4.2.3.5 |x| | | | |
  ALP可以设置R2                                   |4.2.3.5 |x| | | | |1
  通知ALP：R1的重传次数≤R2                          |4.2.3.5 | |x| | | |1
  R1、R2的推荐值                                |4.2.3.5 | |x| | | |
  同样机制适用于SYNs                              |4.2.3.5 |x| | | | |
    R2至少应为SYN的3分钟                          |4.2.3.5 |x| | | | |
                                                 |       
```

| | | | | |
发送保持连接包：                         |4.2.3.6 | | |x| | |
  - 应用程序可以请求                        |4.2.3.6 |x| | | | |
  - 默认状态为“关闭”                        |4.2.3.6 |x| | | | |
  - 仅在空闲一段时间后发送                   |4.2.3.6 |x| | | | |
  - 时间间隔可配置                           |4.2.3.6 |x| | | | |

互联网工程任务组                               [第110页]





RFC1122                  传输层——TCP             1989年10月


- 默认至少保持2小时。                      |4.2.3.6 |x| | | | |
- 容忍ACK丢失。                              |4.2.3.6 |x| | | | |
                                              |        | | | | | |
IP选项                                      |        | | | | | |
  忽略TCP不理解的选项                        |4.2.3.8 |x| | | | |
  时间戳支持                                |4.2.3.8 | | |x| | |
  记录路由支持                              |4.2.3.8 | | |x| | |
  源路由：                                   |        | | | | | |
    ALP可以指定                              |4.2.3.8 |x| | | | |1
      覆盖数据报中的源路由                     |4.2.3.8 |x| | | | |
    从源路由构建返回路由                     |4.2.3.8 |x| | | | |
    后续源路由覆盖                           |4.2.3.8 | |x| | | |
                                              |        | | | | | |
从IP接收ICMP消息                            |4.2.3.9 |x| | | | |
  目的不可达（0,1,5）=>通知ALP               |4.2.3.9 | |x| | | |
  目的不可达（0,1,5）=>中止连接               |4.2.3.9 | | | | |x|
  目的不可达（2-4）=>中止连接                 |4.2.3.9 | |x| | | |
  源抑制（Source Quench）=>减慢启动          |4.2.3.9 | |x| | | |
  时间超出（Time Exceeded）=>通知ALP，不中止  |4.2.3.9 | |x| | | |
  参数问题（Param Problem）=>通知ALP，不中止 |4.2.3.9 | |x| | | |
                                              |        | | | | | |
地址验证                                    |        | | | | | |
  拒绝对无效IP地址的OPEN调用                  |4.2.3.10|x| | | | |
  拒绝来自无效IP地址的SYN                     |4.2.3.10|x| | | | |
  静默丢弃广播/多播地址的SYN                  |4.2.3.10|x| | | | |
                                              |        | | | | | |
TCP/ALP接口服务                              |        | | | | | |
  错误报告机制                                |4.2.4.1 |x| | | | |
  ALP可以禁用错误报告例程                     |4.2.4.1 | |x| | | |
  ALP可以为发送指定TOS                        |4.2.4.2 |x| | | | |
    传递给IP时保持不变                        |4.2.4.2 | |x| | | |
  ALP可以在连接期间更改TOS                     |4.2.4.2 | |x| | | |
  将接收到的TOS传递给ALP                      |4.2.4.2 | | |x| | |
  FLUSH调用                                   |4.2.4.3 | | |x| | |
  可选的本地IP地址参数在OPEN中                  |4.2.4.4 |x| | | | |
-------------------------------------------------|--------|-|-|-|-|-|--
-------------------------------------------------|--------|-|-|-|-|-|--

脚注：

(1)  “ALP”指应用层程序。





互联网工程任务组                               [第111页]





RFC1122                  传输层——TCP             1989年10月


5. 参考文献

入门参考资料

[INTRO:1] 《互联网主机的需求——应用与支持》，
     IETF主机需求工作组，R. Braden主编，RFC-1123，
     1989年10月。

[INTRO:2] 《互联网网关的需求》，R. Braden和J. Postel，RFC-1009，1987年6月。

[INTRO:3] 《DDN协议手册》，NIC-50004、NIC-50005、NIC-50006（共三卷），
     斯坦福国际研究所（SRI International），1985年12月。

[INTRO:4] 《官方互联网协议》，J. Reynolds和J. Postel，RFC-1011，
     1987年5月。

     本文件会定期以新的RFC编号重新发布；必须使用最新版本。

[INTRO:5] 《协议文档顺序信息》，O. Jacobsen和J. Postel，RFC-980，
     1986年3月。

[INTRO:6] 《已分配编号》，J. Reynolds和J. Postel，RFC-1010，
     1987年5月。

     本文件会定期以新的RFC编号重新发布；必须使用最新版本。

[INTRO:7] 《协议实现中的模块化与效率》，D. Clark，RFC-817，1982年7月。

[INTRO:8] 《利用上调用（Upcalls）进行系统结构设计》，D. Clark，第十届ACM SOSP会议，华盛顿奥卡斯岛，1985年12月。

次要参考资料：

[INTRO:9] 《分组网络互通协议》，V. Cerf和R. Kahn，IEEE通信杂志，1974年5月。

[INTRO:10] 《ARPA互联网协议》，J. Postel、C. Sunshine和D. Cohen，计算机网络，第5卷第4期，1981年7月。

[INTRO:11] 《DARPA互联网协议套件》，B. Leiner、J. Postel、R. Cole和D. Mills，IEEE INFOCOM 85会议论文集，华盛顿特区，1985年3月。也刊载于《IEEE通信杂志》，1985年3月。另见：ISI-RS-85-153。

[INTRO:12] 《DIS8473最终文本：提供无连接模式网络服务的协议》，ANSI，作为RFC-994发布，1986年3月。

[INTRO:13] 《端系统到中间系统的路由交换协议》，ANSI X3S3.3，作为RFC-995发布，1986年4月。

链路层参考资料

[LINK:1] 《尾部封装》，S. Leffler和M. Karels，RFC-893，1984年4月。

[LINK:2] 《以太网地址解析协议》，D. Plummer，RFC-826，1982年11月。

[LINK:3] 《在以太网网络上传输IP数据报的标准》，C. Hornig，RFC-894，1984年4月。

[LINK:4] 《在IEEE 802网络上传输IP数据报的标准》，J. Postel和J. Reynolds，RFC-1042，1988年2月。

     本RFC包含大量对计划使用IEEE 802网络的互联网实现者具有重要意义的信息。

IP层参考资料

[IP:1] 《互联网协议（IP）》，J. Postel，RFC-791，1981年9月。

[IP:2] 《互联网控制消息协议（ICMP）》，J. Postel，RFC-792，1981年9月。

[IP:3] “互联网标准子网划分程序”，J. Mogul 和 J. Postel，RFC-950，1985年8月。

[IP:4] “IP多播的主机扩展”，S. Deering，RFC-1112，1989年8月。

[IP:5] “军事标准互联网协议”，MIL-STD-1777，美国国防部，1983年8月。

本规范经RFC-963修订，旨在描述互联网协议，但存在一些严重的遗漏（例如，强制性的子网扩展[IP:3]和可选的多播扩展[IP:4]）。此外，它也已过时。如有冲突，应以RFC-791、RFC-792和RFC-950为准，而本文件在所有方面具有权威性。

[IP:6] “关于军事标准互联网协议规范的一些问题”，D. Sidhu，RFC-963，1985年11月。

[IP:7] “TCP最大段大小及相关主题”，J. Postel，RFC-879，1983年11月。

讨论并澄清了TCP最大段大小选项与IP数据报大小之间的关系。

[IP:8] “互联网协议安全选项”，B. Schofield，RFC-1108，1989年10月。

[IP:9] “碎片化有害论”，C. Kent 和 J. Mogul，ACM SIGCOMM-87，1987年8月。发表在《ACM计算机通信评论》，第17卷，第5期。

这篇有用的论文讨论了互联网碎片化带来的问题，并提出了替代方案。

[IP:10] “IP数据报重组算法”，D. Clark，RFC-815，1982年7月。

这篇论文及以下的论文应由每位实现者阅读。

[IP:11] “故障隔离与恢复”，D. Clark，RFC-816，1982年7月。

次要IP参考文献：

[IP:12] “在子网存在的情况下广播互联网数据报”，J. Mogul，RFC-922，1984年10月。

[IP:13] “名称、地址、端口和路由”，D. Clark，RFC-814，1982年7月。

[IP:14] “主机可以用源抑制做些什么：引入延迟的源抑制（SQUID）”，W. Prue 和 J. Postel，RFC-1016，1987年7月。

该RFC首次描述了定向广播地址，但大部分内容关注网关，而非主机。

UDP参考文献：

[UDP:1] “用户数据报协议”，J. Postel，RFC-768，1980年8月。

TCP参考文献：

[TCP:1] “传输控制协议”，J. Postel，RFC-793，1981年9月。

[TCP:2] “传输控制协议”，MIL-STD-1778，美国国防部，1984年8月。

该规范经RFC-964修订，旨在描述与RFC-793[TCP:1]相同的协议。如有冲突，应以RFC-793为准，而本文件在所有方面具有权威性。

一些关于军事标准传输控制协议规范的问题，D. Sidhu 和 T. Blumer，RFC-964，1985年11月。

关于TCP最大段大小及相关主题，J. Postel，RFC-879，1983年11月。

TCP中的窗口和确认策略，D. Clark，RFC-813，1982年7月。

往返时间估算，P. Karn 和 C. Partridge，ACM SIGCOMM-87，1987年8月。

拥塞避免与控制，V. Jacobson，ACM SIGCOMM-88，1988年8月。

次要TCP参考文献：

协议实现的模块化与效率，D. Clark，RFC-817，1982年7月。

互联网工程任务组（IETF）[第115页]

RFC1122 传输层——TCP，1989年10月

关于IP/TCP中的拥塞控制，J. Nagle，RFC-896，1984年1月。

计算互联网校验和，R. Braden、D. Borman 和 C. Partridge，RFC-1071，1988年9月。

用于长延迟路径的TCP扩展，V. Jacobson 和 R. Braden，RFC-1072，1988年10月。

安全注意事项

主机软件通信层存在许多安全问题，但本RFC不对其进行详细讨论。

互联网架构通常对IP源地址的伪造几乎没有防护，因此任何基于验证数据报源IP地址的安全机制都应持怀疑态度。然而，在受限环境中，某些源地址检查可能是可行的。例如，可能存在一个安全的局域网（LAN），其网关会丢弃任何源地址伪造局域网地址的入站数据报。在这种情况下，局域网中的主机可以利用源地址测试本地与远程源的区别。这个问题因源路由而变得复杂，有人建议出于安全考虑，应禁止主机进行源路由数据报的转发（参见第3.3.5节）。

与安全相关的问题在涉及IP安全选项（第3.2.1.8节）、ICMP参数问题消息（第3.2.2.5节）、UDP数据报中的IP选项（第4.1.3.2节）以及保留的TCP端口（第4.2.2.1节）中有所提及。

作者联系方式

Robert Braden  
USC/信息科学研究所  
4676 Admiralty Way  
Marina del Rey, CA 90292-6695

电话：(213) 822 1511

电子邮箱：Braden@ISI.EDU